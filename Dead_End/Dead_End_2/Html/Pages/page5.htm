<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Cryptage RSA</title>
<style type="text/css">
<!--
.Style2 {
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-size: 11px;
}
.style24 {color: #FFFFFF}
.Style3 {
	font-size: 12px;
	font-family: "Times New Roman", Times, serif;
}
.Style4 {
	font-size: 12px;
	font-family: "Times New Roman", Times, serif;
}
.Style6 {font-size: 12px}
.Style10 {font-family: "Times New Roman", Times, serif}
.Style12 {
	font-size: 13px;
	font-family: "Times New Roman", Times, serif;
}
.Style14 {
	font-family: "Courier New", Courier, mono;
	font-size: 12px;
	color: #666666;
}
.Style15 {color: #FFFFFF}
.Style16 {color: #666666}
.Style17 {font-family: Verdana, Arial, Helvetica, sans-serif}
-->
</style>
<link href="style.css" rel="stylesheet" type="text/css">
<style type="text/css">
<!--
.style25 {color: #F8F8F8}
.style26 {font-size: 13px}
.style27 {font-size: 11px}
.style29 {
	font-size: 13px;
	font-weight: bold;
}
.style30 {
	font-size: 16px;
	font-weight: bold;
}
.style31 {font-size: 16px; font-weight: bold; font-family: Verdana, Arial, Helvetica, sans-serif; }
.style32 {
	font-size: 17px;
	font-family: "Lucida Console";
	font-style: italic;
}
.style33 {font-size: 9px}
-->
</style></head>

<body>
<hr>
<p align="center" class="Style2"><img src="Images/rsa.jpg" width="469" height="60"></p>
<hr>
<p class="Style2"><em><a href="page5.htm" target="_blank">AFFICHER CET ARTICLE EN MODE PAGE ENTIERE</a></em></p>
<p align="center" class="Style2"><font size="4"><strong><u>Sommaire<br>
</u></strong></font></p>
<p class="Style4"><a href="#1">1) Rappels arithm&eacute;tique </a><br>
    <span class="style24">__</span><a href="#1.1">1.1) Nombres premiers </a><br>
    <span class="style24">__</span><a href="#1.2">1.2) Congruence</a><br>
    <span class="style24">__</span><a href="#1.3">1.3) Algorithme d'Euclide </a></p>
<p class="Style6"><a href="#2">2) Introduction</a></p>
<p class="Style4"><a href="#3">3) Un peu d'histoire</a></p>
<p class="Style4"><a href="#4">4) Le principe abstrait</a><br>
  <span class="style24">__</span><a href="#4.1">4.1) Choix des cl&eacute;s</a><br>
  <span class="style24">__</span><a href="#4.2">4.2) Cryptage</a><br>
  <span class="style24">__</span><a href="#4.3">4.3) D&eacute;cryptage</a></p>
<p class="Style4"><a href="#5">5) Exemple concret</a> <br>
  <span class="style24">__</span><a href="#5.1">5.1) Choix des cl&eacute;s</a><br>
  <span class="style24">__</span><a href="#5.2">5.2) Cryptage</a><br>
  <span class="style24">__</span><a href="#5.3">5.3) D&eacute;cryptage</a></p>
<p class="Style4"><a href="#6">6) Cracker RSA </a></p>
<p class="Style4"><a href="#7">7) Avantages et inconv&eacute;nients </a></p>
<p class="Style4"><a href="#8">8) Conclusion</a> </p>
<p class="Style4">&nbsp;</p>
<hr>
<p class="Style2">&nbsp;</p>
<p class="Style4">
<p class="Style4"><span class="Style2"><FONT size=2><STRONG><U><A name=1 id="1"></A></U></STRONG></FONT><STRONG><U><span class="style26">1) Rappels arithm&eacute;tiques </span></U></STRONG></span>
<blockquote>
  <em><u><a name="1.1" id="1.1"></a><span class="Style17 Style6">1.1 Nombres premiers </span></u></em></p>
</blockquote>
<p class="Style6"> <span class="style30">U</span>n nombre premier est un nombre qui n'est divisible que par 1 ou par lui - m&ecirc;me ( une liste des 10 000 premiers nombres premiers est &agrave; <a href="http://pagesperso.laposte.net/skyrunner/rsa/10000_nb_1e.txt" target="_blank">ce lien</a>). <br>
  Dire qu'un un nombre est premier avec un autre signifie que le PGCD de ces deux nombres est 1. </p>
<p>
<blockquote>
  <em> <u><a name="1.2" id="1.2"></a><span class="Style17 Style6">1.2 Congruence</span> </u></em></p>
</blockquote>
<p><span class="Style6">a et b appartiennent &agrave; l'ensemble Z.<br>
  a et b sont congrues modulo n ssi a et b ont le m&ecirc;me reste dans la division euclidienne par n, ou bien plus simplement si (a-b) est divisible par n. <br>
  a et b congrue modulo n s'&eacute;crit : <span class="Style15">.</span>a <img src="Images/congru.gif" width="12" height="12"> b (mod n)<br>
  <span class="Style15">__________________________</span><span class="style25">-</span>a <img src="Images/congru.gif" width="12" height="12"> b [n] </span>
<blockquote>
  <em> <u><a name="1.3" id="1.3"></a><span class="Style17 Style6">1.3 Algorithme d'Euclide</span></u></em></p>
</blockquote>
<p class="Style6">a et b apartiennnent &agrave; N* (les entiers naturels priv&eacute;s de 0), on suppose b &lt; a<br>
  On utilise l'algorithme d'Euclide c'est &agrave; dire on remplace le couple (a ; b) par des couples de nombre de plus en plus petit qui ont le m&ecirc;me ensemble de diviseur compris.<br>
</p>
<table width="649" height="252" border="1" align="center" bordercolor="#F8F8F8">
  <tr bordercolor="#000000" class="Style6">
    <td width="228" height="29"><div align="center"><strong>Operations</strong></div></td>
    <td width="57"><div align="center"><strong>Reste</strong></div></td>
    <td width="350"><div align="center"><strong>Commentaire</strong></div></td>
  </tr>
  <tr bordercolor="#000000" class="Style6">
    <td><div align="center">on divise a par b </div></td>
    <td><div align="center">r0</div></td>
    <td><div align="center">0 &le; ro &lt; b et PGCD (a , b) = PGCD (b , r0) </div></td>
  </tr>
  <tr bordercolor="#000000" class="Style6">
    <td><div align="center">si r0 &ne; 0 on divise b par r0 </div></td>
    <td><div align="center">r1</div></td>
    <td><div align="center">0 &le; r1&lt; r0 et PGCD (b , r0) = PGCD (r0 , r1) </div></td>
  </tr>
  <tr bordercolor="#000000" class="Style6">
    <td><div align="center">si r1&ne; 0 on divise r0 par r1</div></td>
    <td><div align="center">r2</div></td>
    <td><div align="center">0 &le; r2&lt; r1 et PGCD (r0 , r1) = PGCD (r1 , r2) </div></td>
  </tr>
  <tr bordercolor="#000000" class="Style6">
    <td><div align="center">.....</div></td>
    <td><div align="center">....</div></td>
    <td><div align="center">....</div></td>
  </tr>
  <tr bordercolor="#000000" class="Style6">
    <td><div align="center">....</div></td>
    <td><div align="center">....</div></td>
    <td><div align="center">....</div></td>
  </tr>
  <tr bordercolor="#000000" class="Style6">
    <td><div align="center">....</div></td>
    <td><div align="center">r(n)</div></td>
    <td><div align="center">....</div></td>
  </tr>
  <tr bordercolor="#000000" class="Style6">
    <td><div align="center">si r(n)&ne; 0 on divise r(n-1) par r(n)</div></td>
    <td><div align="center">....</div></td>
    <td><div align="center">PGCD ( r(n-2) , r(n-1) ) = r(n) </div></td>
  </tr>
</table>
<p class="Style6"><br>
  <span class="style30">A</span>pr&egrave;s un nombre finie d'op&eacute;ration, on trouve un reste non nul, car les restes sont des nombres positifs et strictement d&eacute;croissant.<br>
  On note r(n) le dernier reste non nul.<br>
  PGCD (a , b) = PGCD (b , r0)<br>
  <span class="Style15">___________</span>= PGCD (r0 , r1)<br>
  <span class="Style15">___________</span>= ....<br>
  <span class="Style15">___________</span>= PGCD ( r(n-1) , r(n) )<br>
  <span class="Style15">___________</span>= r(n)<br>
  <br>
  <span class="style30">L</span>orsque b ne divise pas a, le PGCD des entiers naturels non nuls a et b est &eacute;gal au dernier reste non nul obtenu par l'algorithme d'Euclide;<br>
  <br>
  Ex : PGCD (1636 , 1128)<br>
  1636 = 1128 * 1 + 208<br>
  1128 = 508 * 2 + 112<br>
  508 = 112 * 4 + 60<br>
  112 = 60 * 1 + 52<br>
  60 = 52 * 1 + 8<br>
  52 = 8 * 6 + 4<br>
  8 = 4 * 2<br>
  <br>
  PGCD (1636 , 1128) = 4.</p>
<p class="Style2">&nbsp;</p>
<p class="Style2"><FONT size=2><STRONG><U><A name=2 id="2"></A><span class="Style10 Style17">2</span><span class="Style12 Style17">) Introduction </span></U></STRONG></FONT><BR>
  <br>
  <span class="style30">C</span><span class="Style3 Style17">et article a pour but de vous expliquer le fonctionnement de la tr&egrave;s c&eacute;l&egrave;bre methode de cryptage RSA (du nom de ses cr&eacute;ateurs Ronald Rivest, Adi Shamir et L&eacute;onard Adleman.). </span></p>
<p align="center" class="Style2"><img src="Images/rsa1.jpg" width="500" height="363"></p>
<p class="Style2">&nbsp;</p>
<p class="Style2">&nbsp;</p>
<p class="Style2"><FONT size=2><STRONG><U><A name=3 id="3"></A><span class="Style10 Style17">3</span><span class="Style12 Style17">) Un peu d'histoire</span></U></STRONG></FONT><BR>
  <br>
  <span class="style30">D</span><span class="Style3 Style17">&eacute;velopp&eacute; au MIT (Massachussets Institute of Technology) en 1977 par Ronald Rivest, Adi Shamir et Leonard Adleman, le syst&egrave;me RSA est un syst&egrave;me &agrave; clef publique tr&egrave;s s&ucirc;r. Il est int&eacute;ressant de noter que son invention est fortuite : au d&eacute;part, Rivest, Shamir et Adleman voulaient prouver que tout syst&egrave;me &agrave; cl&eacute; publique poss&egrave;de une faille.</span></p>
<p class="Style4 Style17"><span class="style30">L</span>a puissance de chiffrement du RSA repose sur le fait que tous les syst&egrave;mes peuvent &ecirc;tre en d&eacute;finitive forc&eacute;s, mais que l'on peut parvenir &agrave; une s&eacute;curit&eacute; suffisante en rendant totalement irr&eacute;aliste la quantit&eacute; de travail qu'il faudrait fournir pour le forcer.</p>
<p class="Style4 Style17"><span class="style30">I</span>l est fond&eacute;, sur le fait qu'il est tr&egrave;s difficile de d&eacute;composer en produit de facteurs premier un grand nombre (voir impossible quand le chiffre depasse 150 chiffres), en effet les ordinateurs actuels les plus puissants ne peuvent decomposer en produit de facteur premier un nombre premier comportant plus de 130 chiffres. Personne ne peut le d&eacute;composer si ce n'est l'auteur ( pour information d'apr&egrave;s Ron Rivest, la d&eacute;composition d'un nombre de 200 chiffres n&eacute;cessite 4 milliards d'ann&eacute;es de calculs sur ordinateurs, celle d'un nombre de 500 chiffres plus de 1025 milliards d'ann&eacute;es).</p>
<p class="Style4 Style17"><span class="style30">E</span>n revanche si quelqu'un trouve comment factoriser rapidement de tels nombres, le RSA devient obsol&egrave;te. </p>
<p class="Style2">&nbsp;</p>
<p class="Style2"><FONT size=2><STRONG><U><A name=4 id="4"></A></U></STRONG></FONT><STRONG><U><span class="Style12 Style17">4) Le principe abstrait </span></U></STRONG><FONT size=2><STRONG><U></U></STRONG></FONT><FONT size=2><STRONG><U><br> 
  </U></STRONG></FONT><BR>
  <span class="style30">T</span><span class="Style4 Style17">oute cette m&eacute;thode repose principalement sur les nombres premiers.<br>
  Le d&eacute;veloppement du principe s'accompagne de d&eacute;monstrations : elles n&eacute;cessitent quelques bases en arithm&eacute;tique. <br>
Note : les signes <img src="Images/congru.gif" width="12" height="12">, &phi; et ^ designe bien evidemment respectivement la congruence, phi (variable) et la puissance.</span></p>
<blockquote>
  <p>&nbsp;</p>
  <p><em><u><a name="4.1" id="4.1"></a><span class="Style17 Style6">4.1 Choix des cl&eacute;s</span></u></em>
  </p>
    </p>
</blockquote>
<span class="style30">O</span><span class="Style6">n choisi 2 nombres premiers p et q (bien s&ucirc;r plus p et q sont grand plus le cassage du code est difficile car il est difficile de d&eacute;composer un tr&egrave;s grand nombre en facteurs premiers).<br>
On calcule n = pq et &phi;(n) = (p - 1) (q - 1).<br>
On choisit ensuite d tel que d premier avec &phi;(n).<br>
On calcule ensuite e tel que ed <img src="./congru.gif" width="13" height="12"> 1 (mod &phi;(n)) avec e &lt; &phi;(n).</span>
<p class="Style4 Style17">n et e sont publics.<br>
  p, q, &phi;(n) et d sont priv&eacute;s.
</p>
<p class="Style4"><table width="590" height="133" border="1" align="center" bordercolor="#000000">
  <tr>
    <td valign="top" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10 Style14">cle cleCryptage(void)<br>
      {<br>
cle c;<br>
unsigned long int i;<br>
FILE *premier;
      <p class="Style14"> premier = fopen(&quot;nb_premier_phi.txt&quot;,&quot;a&quot;); /* On cr&eacute;e un fichier pour stocker les <span class="Style15">___________________________________________<span class="Style16">/*</span></span> nombres premier avec phi */<br>
  if (premier == NULL)<br>
  {<br>
  <span class="Style15">__</span>printf(&quot;\n\nErreur cr&eacute;ation du fichier nb_premier_phi.txt&quot;);<br>
  <span class="Style15">__</span>exit(42);<br>
  }</p>
      <p class="Style14"> printf (&quot;\n\nEntrez le nombre a crypter : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.nb);<br>
  printf(&quot;Entrez le nombre premier p : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.p);<br>
  printf(&quot;Entrez le nombre premier q : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.q);<br>
  printf(&quot;\nCALCUL DE LA CLE N EN COURS...&quot;);<br>
  c.n = c.p*c.q;<br>
  printf(&quot;\nLa cle n = %lu\n&quot;,c.n);<br>
  printf(&quot;\nCALCUL DE LA CLE PHI EN COURS...&quot;);<br>
  c.phi = (c.p-1)*(c.q-1);<br>
  printf(&quot;\nLa cle phi = %lu\n&quot;,c.phi);</p>
      <p class="Style14"> for (i = 2; i&lt; c.phi/2; i++) /* On incrit dans le fichier tous les nombres */<br>
        <span class="Style15">___</span>if ( c.phi % i != 0) <span class="Style15">_____</span>/* premiers avec phi jusqu'&agrave; phi/2 */<br>
  <span class="Style15">______</span>fprintf(premier,&quot;%lu\n&quot;,i);<br>
  <br>
  fclose(premier);</p>
      <p class="Style14"> printf(&quot;\nUne liste des cles possibles d est disponible dans le fichier&quot; <span class="Style15">_______</span>&quot;nb_premier_phi.txt&quot;);<br>
  printf(&quot;\nEntrez la cle d (premier avec phi) : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.d);<br>
  printf(&quot;\nCALCUL DE LA CLE E EN COURS...&quot;);</p>
      <p class="Style14"> for (c.e=1; c.e &lt; (c.phi*c.phi); c.e++)/*  On recherche une chiffre tel que e*d-1*/ <br>
        <span class="Style15">___</span>if (((c.e*c.d) % c.phi) == 1)<span class="Style15">_______</span>/* soit divisible par phi */<br>
        <span class="Style15">______</span>break;</p>
      <p class="Style14"> printf(&quot;\ne = %lu\n&quot;,c.e);<br>
  return c;</p>
    <p class="Style14">}</p></td>
  </tr>
</table> </p>
<blockquote>
  <p>&nbsp;</p>
  <p><em><u><a name="4.2" id="4.2"></a><span class="Style17 Style6">4.2 Cryptage</span></u></em>
  </p>
    </p>
</blockquote>
<p class="Style6"><span class="style30">P</span>our crypter un message M avec M &lt; n il suffit de calculer C = M^e (mod n ) : </p>
<p class="Style6"><table width="762" border="1" align="center" bordercolor="#000000">
  <tr>
    <td width="752" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style14">unsigned long int cryptage(unsigned long int nb, unsigned long int puiss, unsigned long int mod)<br>
      {<br>
unsigned long int res = 1, nvar, nvar2;<br>
unsigned long int resultat[100000];<br>
int i, j, k,l; // compteurs<br>
int nnb, compt, var, caze;<br>
int tab[100000], tab2[100000];<br>
int puissa = puiss;
    </span>
      <p class="Style14"> printf(&quot;\nCRYPTAGE EN COURS...\n&quot;);<br>
        for (i=0; i&lt;100000; i++) // on remplit le tableau avec des 5<br>
        <span class="Style15">___</span>tab[i]=5;</p>
      <p class="Style14"> for (i=0, compt = -1; puiss &gt; 0; i++, compt++ ) // on convertit la puissance en binaire<br>
  {<br>
  if (puiss % 2 &gt; 0)<br>
  nnb = 1;<br>
  if (puiss % 2 == 0)<br>
  nnb = 0;<br>
  tab[i]=nnb;<br>
  puiss = puiss / 2;<br>
  }</p>
      <p class="Style14"> for (i=0, j=0; tab[i] != 5; i++) // on convertit le binaire en puissance de 2 : par <br>
  {<span class="Style15">________________________________</span>// exemple (11101)b = 16 + 8+ 4 + 1<br>
  <span class="Style15">___</span>if (tab[i] == 1)<br>
  <span class="Style15">____</span>{<br>
  <span class="Style15">______</span>var = puissance(2,i);<br>
  <span class="Style15">______</span>tab2[j] = var;<br>
  <span class="Style15">______</span>j++;<br>
  <span class="Style15">____</span>}<br>
  }</p>
      <p class="Style14"> l = j; // on sauvegarde la valeur de j cad le nombre d'element ds le tableau tab2[]</p>
      <p class="Style14"> resultat[0]=0;<br>
  resultat[1]=nb; <span class="Style15">_______</span>/* On met dans le tableau resultat[] les restes du nombre nb par les */<br>
  nvar2 = nb;<span class="Style15"> ___________</span>/* puissances successives jusqu'&agrave; la puissance egal au plus grand nombre */<br>
  nvar = nb;<span class="Style15">_____________</span>/* du tableau tab2[] par le modulo mod */<br>
  for (i=2; i&lt;=tab2[j-1]+1; i++)<br>
  <span class="Style15">_</span>{ <span class="Style15">_________________________</span>/* Par exemple pour 29 = 16 + 8 + 4 +1 et pour nb =3 on et dans le tableau */<br>
  <span class="Style15">___</span>nvar2 = nvar * nvar2; <span class="Style15">___</span>/* les restes de 3^1, 3^2 jusqu'&agrave; 3^16 par le modulo mod */<br>
  <span class="Style15">___</span>nvar2 = nvar2%mod;<br>
  <span class="Style15">___</span>resultat[i] = nvar2;<br>
  <span class="Style15">_</span>}<br>
      </p>
      <p class="Style14"> for (i=0, res=1; i&lt;l; i++) /* Dans la case i du tableau resultat se trouve nb^i */<br>
        <span class="Style15">_</span>{<span class="Style15">_______________</span>/* Donc &agrave; partir du tableau tab2[i] qui contient la d&eacute;composition de la puissance puiss*/<br>
  <span class="Style15">___</span>caze=tab2[i]; <span class="Style15">___</span>/* res = res * resultat[caze]; /* en puissance de 2 ( 29 = 16 + 8 + 4 + 1), on peut */ <br>
  <span class="Style15">_________________</span><span class="Style15">____</span>/* obtenir nb^puiss en multipliant */<br>
  <span class="Style15">___</span>if (res &gt; mod)<span class="Style15">____</span>/* par exemple nb^16, on multiplie les cases<br>
  <span class="Style15">______</span>res = res%mod; <span class="Style15"></span>/* resultat[16]*resultat[8]*resultat[4]*resultat[1] */<br>
  }<span class="Style15">____________________</span>/* pour obtenir enfin le chiifre crypt&eacute; on fait le resultat precedent modulo mod */<br>
      </p>
      <p class="Style14"> return res;<br>
        }</p></td>
  </tr>
</table>
 </p>
<blockquote>
  <p>&nbsp;</p>
  <p><em><u>
    <a name="4.3" id="4.3"></a><span class="Style17 Style6">4.3 D&eacute;cryptage</span> </u></em>
  </p>
    </p>
</blockquote>
<span class="style30">P</span><span class="Style6">our d&eacute;crypter C il suffit de calculer M = C^d (mod n) (car M <img src="Images/congru.gif" width="12" height="12"> C^d (mod n)) : </span>
<p class="Style2"><table width="762" border="1" align="center" bordercolor="#000000">
  <tr>
    <td width="752" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style14">unsigned long int cryptage(unsigned long int nb, unsigned long int puiss, unsigned long int mod)<br>
      {</span><span class="Style15">__________________________________________________</span><span class="Style14">// Remarque : c'est exactement la m&ecirc;me chose que pour cryptage <br>
      unsigned long int res = 1, nvar, nvar2;<br>
      unsigned long int resultat[100000];<br>
      int i, j, k,l; // compteurs<br>
      int nnb, compt, var, caze;<br>
      int tab[100000], tab2[100000];<br>
      int puissa = puiss; </span>
      <p class="Style14"> printf(&quot;\nDECRYPTAGE EN COURS...\n&quot;);<br>
        for (i=0; i&lt;100000; i++) // on remplit le tableau avec des 5<br>
        <span class="Style15">___</span>tab[i]=5;</p>
      <p class="Style14"> for (i=0, compt = -1; puiss &gt; 0; i++, compt++ ) // on convertit la puissance en binaire<br>
  {<br>
  if (puiss % 2 &gt; 0)<br>
  nnb = 1;<br>
  if (puiss % 2 == 0)<br>
  nnb = 0;<br>
  tab[i]=nnb;<br>
  puiss = puiss / 2;<br>
  }</p>
      <p class="Style14"> for (i=0, j=0; tab[i] != 5; i++) // on convertit le binaire en puissance de 2 : par <br>
  {<span class="Style15">________________________________</span>// exemple (11101)b = 16 + 8+ 4 + 1<br>
  <span class="Style15">___</span>if (tab[i] == 1)<br>
  <span class="Style15">____</span>{<br>
  <span class="Style15">______</span>var = puissance(2,i);<br>
  <span class="Style15">______</span>tab2[j] = var;<br>
  <span class="Style15">______</span>j++;<br>
  <span class="Style15">____</span>}<br>
  }</p>
      <p class="Style14"> l = j; // on sauvegarde la valeur de j cad le nombre d'element ds le tableau tab2[]</p>
      <p class="Style14"> resultat[0]=0;<br>
  resultat[1]=nb; <span class="Style15">_______</span>/* On met dans le tableau resultat[] les restes du nombre nb par les */<br>
  nvar2 = nb;<span class="Style15"> ___________</span>/* puissances successives jusqu'&agrave; la puissance egal au plus grand nombre */<br>
  nvar = nb;<span class="Style15">_____________</span>/* du tableau tab2[] par le modulo mod */<br>
  for (i=2; i&lt;=tab2[j-1]+1; i++)<br>
  <span class="Style15">_</span>{ <span class="Style15">_________________________</span>/* Par exemple pour 29 = 16 + 8 + 4 +1 et pour nb =3 on et dans le tableau */<br>
  <span class="Style15">___</span>nvar2 = nvar * nvar2; <span class="Style15">___</span>/* les restes de 3^1, 3^2 jusqu'&agrave; 3^16 par le modulo mod */<br>
  <span class="Style15">___</span>nvar2 = nvar2%mod;<br>
  <span class="Style15">___</span>resultat[i] = nvar2;<br>
  <span class="Style15">_</span>}<br>
      </p>
      <p class="Style14"> for (i=0, res=1; i&lt;l; i++) /* Dans la case i du tableau resultat se trouve nb^i */<br>
        <span class="Style15">_</span>{<span class="Style15">_______________</span>/* Donc &agrave; partir du tableau tab2[i] qui contient la d&eacute;composition de la puissance puiss*/<br>
  <span class="Style15">___</span>caze=tab2[i]; <span class="Style15">___</span>/* res = res * resultat[caze]; /* en puissance de 2 ( 29 = 16 + 8 + 4 + 1), on peut */ <br>
  <span class="Style15">_________________</span><span class="Style15">____</span>/* obtenir nb^puiss en multipliant */<br>
  <span class="Style15">___</span>if (res &gt; mod)<span class="Style15">____</span>/* par exemple nb^16, on multiplie les cases<br>
  <span class="Style15">______</span>res = res%mod; <span class="Style15"></span>/* resultat[16]*resultat[8]*resultat[4]*resultat[1] */<br>
  }<span class="Style15">____________________</span>/* pour obtenir enfin le chiifre crypt&eacute; on fait le resultat precedent modulo mod */<br>
      </p>
      <p class="Style14"> return res;<br>
        }</p></td>
  </tr>
</table></p>
<p class="Style2">&nbsp;</p>
<p class="Style2"><FONT size=2><STRONG><U><A name=5 id="5"></A></U></STRONG></FONT><STRONG><U><span class="Style12 Style17">5) Exemple concret </span></U></STRONG><br>
<blockquote>
  <em>  <u><a name="5.1" id="5.1"></a><span class="Style17 Style6">5.1 Choix des cl&eacute;s</span></u></em></p>
</blockquote>
  <span class="Style6"><span class="style30">T</span>out d'abord on choisit A=3, H=641, D=2, S=201, '-'=1 pour crypter des mots. <br>
  Puis on choisit deux nombres premiers p = 29 et q = 31 d'o&ugrave; n = 899.</span></span>
  <p class="Style4 Style17">- On calcule ensuite &phi;(n) = 28 *30 = 840.<br>
  - On choisit ensuite un cadenas d = 29 premier avec &phi;(n) (cad 840).<br>
  - On calcule maintenant e tel que ed <img src="Images/congru.gif" width="12" height="12"> 1 (mod 840) pour cela on utilise l'algorithme d'Euclide.<br>
  <span class="Style15">____</span>  840 = 28*29+28<br>
    <span class="Style15">___<span class="style25">_-</span></span>29 = 1*28+1<br>
    <u>puis :</u> <br>
    <span class="Style15">____</span>1 = 29-28<br>
    <span class="Style15">____</span>1 = 29 - (840 - 28*29)<br>
    <span class="Style15">____</span>1 = 29 * 29 - 840</p>
<p class="Style4 Style17">- On obtient donc e = 29 car 29*29 <img src="Images/congru.gif" width="12" height="12"> 1 (mod 840) (29*29-1 est divisible par 840).</p>
<p class="Style4 Style17">&nbsp;</p>
<blockquote>
  <em><u><a name="5.2" id="5.2"></a><span class="Style17 Style6">5.2 Cryptage</span></u></em></p>
</blockquote>
  <span class="style30">P</span><span class="Style6">our crypter le message M : AH-DHS cad M = (3, 641, 1, 2, 641, 201) il suffit de calculer C = (3^29 (mod 899), 641^29 (mod 899), 1^29 (mod 899), 2^29 (mod 899), 641^29 (mod 899), 201^9 (mod 899)).</span>
  <p class="Style4 Style17"><span class="style30">P</span>our se faire on peut utiliser le code joint &agrave; l'article mais si vous voulez le faire &agrave; la main je vais vous donner la technique que j'utilise.</p>
<p class="Style4 Style17"><span class="style30">T</span>out d'abord il faut &eacute;crire 29 en binaire : 29 = (11101)b -&gt; 29 = 16 + 8 + 4 + 1<br>
  On peut le faire directement si le chiffre n'est pas grand.<br>
</p>
<p class="Style4 Style17">3^29 = 3^1 * 3^4 * 3^8 * 3^16 = 3 * 81 * 268 * 803 = 641 (mod 899).<br>
</p>
<p class="Style4 Style17"><u>Explication :</u><br>
  3^8 = 6561 mais comme 6561 &gt; 899 on prend 268 car 6561 <img src="Images/congru.gif" width="12" height="12"> 268 (mod 899).<br>
  3^16 ==&gt; de m&ecirc;me.</p>
<p class="Style4 Style17">641^29 = 641^1 * 641^4 * 641^8 * 641^16 = 641 * 545 * 355 * 165 = 3 (mod 899).<br>
</p>
<p class="Style4 Style17"><u>De m&ecirc;me : </u><br>
  1^29 = 1 (mod 899).</p>
<p class="Style4 Style17">2^29 = 698 (mod 899).</p>
<p class="Style4 Style17">201^29 = 897 (mod 899).</p>
<p class="Style4 Style17">Le message envoy&eacute; sera donc C = (641, 3, 1, 698, 3, 897).</p>
<blockquote>
  <p>&nbsp;</p>
  <p><em><u><a name="5.3" id="5.3"></a><span class="Style17 Style6 Style6 Style6 Style6">5.3 D&eacute;cryptage</span> </u></em>
  </p>
    </p>
</blockquote>
  <span class="style30">P</span><span class="Style6">our d&eacute;crypter le message il suffit de calculer C^d (mod 899) &agrave; l'aide du code joint &agrave; l'article ou &agrave; la main comme je vais l'expliquer.
  </p>
  </span>
  <p class="Style4 Style17"><u>Dans cet exemple e = d donc le d&eacute;cryptage est tr&egrave;s facile, en effet : </u><br>
  641^29 <img src="Images/congru.gif" width="12" height="12"> 3 (mod 899) (calculer plus haut).<br>
  3^29  <img src="Images/congru.gif" width="12" height="12"> 641 (mod 899). <br>
  1^29 <img src="Images/congru.gif" width="12" height="12">1 (mod 899).<br>
  698^29 = -201^29 <img src="Images/congru.gif" width="12" height="12"> 2 (mod 899) car 698 - (-201) = 899.<br>
  3^29 <img src="Images/congru.gif" width="12" height="12"> 641 (mod 899).<br>
  897^29 = -2^29 = -698 <img src="Images/congru.gif" width="12" height="12"> 201 (mod 899) car 897 - (-2) = 899.</p>
<p class="Style4 Style17"><span class="style30">O</span>n obtient donc le message d&eacute;crypt&eacute; M' = (3, 641, 1, 2, 641, 201) cad M' = AH-DHS.<br>
  On a bien M = M'.</p>
<p class="Style4 Style17">Si e != d il suffit de faire comme pr&eacute;cedemment (pour le cryptage).<br>
</p>
<p class="Style4 Style17"><u>Exemple : </u><br>
  avec d = 15.<br>
  15 = 8 + 4 + 2 + 1.</p>
<p class="Style4 Style17">641^15 = 641^1 + 641^ 2 + 641^4 + 641^8 = 641 * 38 * 545 * 355 = 867 (mod 899).<br>
  Bien s&ucirc;r ici 867 ne correspond &agrave; aucune lettre.</p>
<p class="Style4 Style17"><span class="style30">O</span>n remarquera que 641^4 = (641^2)^2 donc si l'on connait 641^2 (mod 899) cad 38 pour trouver 641^4 (mod 899) il suffit de faire 38^2 (mod 899) cad 545 (de m&ecirc;me avec 641^8 avec 641^4).</p>
<p class="Style4">&nbsp;</p>
<p class="Style2"><FONT size=2><STRONG><U><A name=6 id="6"></A></U></STRONG></FONT><STRONG><U><span class="Style12 Style17">6) Cracker RSA</span></U></STRONG></p>
<p class="Style4 Style17"><span class="style30">E</span>n th&eacute;orie, cracker RSA n'a rien de diffcile il suffit juste de d&eacute;composer la cl&eacute; publique n en produit de facteurs premiers (par exemple 33 = 11 * 3) mais lorsque n d&eacute;passe 150 chiffres ce n'est plus du tout facile bien au contraire, aucun supercalculateur actuel n'est capable de factoriser n en un temps raisonnable.<br>
  <br>
  <span class="style30">U</span>ne autre technique, celle fois ci dites de brute force consiste &agrave; essayer tous les chiffres de 1 jusqu'&agrave; n et de le mettre &agrave; la puissance e (cl&eacute; publique) le tout modulo n jusqu'&agrave; trouver le m&ecirc;me chiffre que le crypt&eacute;, dans quelle cas on aurai trouv&eacute; le chiffre d&eacute;crypt&eacute;.</p>
<p class="Style4 Style17"><span class="style30">V</span>oici un petit code permettant de faire la derni&egrave;re technique cit&eacute;e.</p>
<table width="812" border="1" align="center" bordercolor="#000000">
  <tr>
    <td width="802" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style14">/* mod = cl&eacute; n et puiss = cl&eacute; e */<br>unsigned long int brutus_attack(unsigned long int nb, unsigned long int puiss, unsigned long int mod)<br>
        {</span><span class="Style14"><br>
        unsigned long int res = 1, nvar, nvar2;<br>
        unsigned long int resultat[100000];<br>
        int i, j, k,l; // compteurs<br>
        int nnb, compt, var, caze;<br>
        int tab[100000], tab2[100000];<br>
        int puissa = puiss; </span>
        <p class="Style14"> printf(&quot;\nTENTATIVE DE BRUTE FORCING EN COURS...\n&quot;);<br>
        for (i=0; i&lt;100000; i++) // on remplit le tableau avec des 5<br>
        <span class="Style15">___</span>tab[i]=5;</p>
        <p class="Style14"> for (i=0, compt = -1; puiss &gt; 0; i++, compt++ ) // on convertit la puissance en binaire<br>
        {<br>
        <span class="Style15">__</span>if (puiss % 2 &gt; 0)<br>
        <span class="Style15">__</span>nnb = 1;<br>
        <span class="Style15">__</span>if (puiss % 2 == 0)<br>
        <span class="Style15">__</span>nnb = 0;<br>
        <span class="Style15">__</span>tab[i]=nnb;<br>
        <span class="Style15">__</span>puiss = puiss / 2;<br>
        }</p>
        <p class="Style14"> for (i=0, j=0; tab[i] != 5; i++) // on convertit le binaire en puissance de 2 : par <br>
        {<span class="Style15">________________________________</span>// exemple (11101)b = 16 + 8+ 4 + 1<br>
        <span class="Style15">__</span>if (tab[i] == 1)<br>
        <span class="Style15">____</span>{<br>
        <span class="Style15">______</span>var = puissance(2,i);<br>
        <span class="Style15">______</span>tab2[j] = var;<br>
        <span class="Style15">______</span>j++;<br>
        <span class="Style15">____</span>}<br>
        }</p>
        <p class="Style14"> l = j; // on sauvegarde la valeur de j cad le nombre d'element ds le tableau tab2[]</p>
        <p class="Style14"> /* On essaye toutes les valeurs possibles de M^e (mod n) avec M &lt; n jusqu'&agrave; ce que le resultat egal &agrave; C*/<br>
        for (nb=1; nb &lt; mod; nb++)<br>
        <span class="style24">_</span>{<br>
        <span class="style24">___</span>resultat[0]=0;<br>
        <span class="style24">___</span>resultat[1]=nb; /* On met dans le tableau resultat[] les restes du nombre nb par les */<br>
        <span class="style24">___</span>nvar2 = nb; /* puissances successives jusqu'&agrave; la puissance egal au plus grand nombre */<br>
        <span class="style24">___</span>nvar = nb; /* du tableau tab2[] par le modulo mod */<br>
        <span class="style24">___</span>for (i=2; i&lt;=tab2[j-1]+1; i++)<br>
        <span class="style24">____</span>{ <span class="style24">______________________</span>/* Par exemple pour 29 = 16 + 8 + 4 +1 et pour nb =3 on et dans le tableau */<br>
        <span class="style24">______</span>nvar2 = nvar * nvar2; /* les restes de 3^1, 3^2 jusqu'&agrave; 3^16 par le modulo mod */<br>
        <span class="style24">______</span>nvar2 = nvar2%mod;<br>
        <span class="style24">______</span>resultat[i] = nvar2;<br>
        <span class="style24">____</span>}<br>
        </p>
        <p class="Style14"> <span class="Style15">___</span>for (i=0, res=1; i&lt;l; i++) /* Dans la case i du tableau resultat se trouve nb^i */<br>
            <span class="Style15">____</span>{<br>
            <span class="Style15">___</span>caze = tab2[i];<br>
            <span class="Style15">___</span>res = res * resultat[caze]; <br>
            <span class="Style15">___</span>if (res &gt; mod) <br>
            <span class="Style15">______</span>res = res%mod; <br>
            <span class="Style15">_</span>}<br>
            <span class="Style15">___</span>if ( res == c)<br>
            <span class="Style15">______</span>break;</p>
        <p class="Style14"> <span class="Style15">____</span>}<br>
            <span class="Style15">___</span>return res;<br>
        }</p></td>
  </tr>
</table>
<p class="Style4">&nbsp; </p>
<p class="Style2"><FONT size=2><STRONG><U><A name=7 id="7"></A></U></STRONG></FONT><STRONG><U><span class="Style12 Style17">7) Avantages et inconv&eacute;nients</span></U></STRONG></p>
<p class="Style4 Style17"><span class="style30">C</span>e syst&egrave;me reste de nos jours le syst&egrave;me cryptographique &agrave; cl&eacute; publique le plus utilis&eacute; et le plus s&ucirc;r. On estime qu'une clef RSA de 512Bits sera cass&eacute;e au bout d'environ 107 millions d'ann&eacute;es par une machine modeste (architecture x86, ~1Ghz), une clef de 1024Bits sera quant &agrave; elle 1.3x10^154 fois plus complexe &agrave; casser. Il permet &eacute;galement de valider l'authenticit&eacute; des personnes (l'utilisation d'une clef de d&eacute;cryptage erron&eacute;e entra&icirc;nera fatalement un d&eacute;cryptage faux).<br>
  <br>
  <span class="style30">E</span>n revanche ses calculs consomment &eacute;normement de m&eacute;moire, il est consid&eacute;r&eacute; comme 1000 fois plus lent que son concurrent direct le DES. Cet inconv&eacute;nient n'en est pas un sur un ordinateur r&eacute;cent mais il le devient quand il est question de ce type de cryptage pour une utilisation embarqu&eacute;e (de type carte bancaire ou t&eacute;l&eacute;phone portable [bien que quand je surf sur le wap avec mon t&eacute;l&eacute;phone portable les donn&eacute;es soit crypt&eacute;es en rsa])<br>
  <br>
  <span class="style30">D</span>e plus, le syst&egrave;me RSA r&eacute;cup&egrave;re &eacute;galement les avantages du principe de clefs publiques et priv&eacute;es. Appel&eacute; syst&egrave;me &agrave; clef asym&eacute;trique, dans lequel seule la clef de d&eacute;chiffrement doit &ecirc;tre tenue secr&egrave;te, la clef de chiffrement pouvant &ecirc;tre rendue publique, &agrave; condition qu'il soit impossible virtuellement d'en d&eacute;duire la clef secr&egrave;te. Cela am&egrave;ne de nombreux avantages, parmi lesquels
<p class="Style4 Style17">
<p class="Style4 Style17"><span class="style27"><FONT size=2><STRONG><U><A name=8 id="8"></A></U></STRONG></FONT><STRONG><U><span class="style26">8) Conclusion <br>
          <br>
</span></U></STRONG></span><span class="style30">E</span>n th&eacute;orie, le cryptosyst&egrave;me RSA n'est pas inviolable, il &quot;suffit juste&quot; de factoriser n en produit de facteurs premiers. Cependant la puissance actuelle des supercalculateurs ne permet pas de r&eacute;aliser ce travail &agrave; une &eacute;chelle de temps raisonnable (voire humaine) &agrave; partir du moment o&ugrave; n d&eacute;passe 150 chiffres.. A partir de l&agrave;, le RSA se r&eacute;v&egrave;le pour l'instant comme incassable.<BR>
  <br>
  <span class="style30">P</span>eut-on alors affirmer &agrave; partir de l&agrave; que le RSA a un long futur devant lui ?<BR>
  <BR>
  <span class="style30">O</span>n pourra r&eacute;pondre par l'affirmative tant que la puissance de calcul disponible ne soit suffisante pour faire le travail de factorisation en un temps raisonnable. Ce sera aussi le cas tant que l'on ne trouvera pas un algorithme permettant de factoriser en un temps raisonnable. Dans ces cas l&agrave; il faudra trouver une autre m&eacute;thode.<br>
  <BR>
  <span class="style30">A</span>insi, malgr&eacute; quelques inconv&eacute;nients (m&eacute;moire utilis&eacute;e, puissance n&eacute;cessaire, ...), le RSA est un cryptosyst&egrave;me proche de la perfection.
<p class="Style4 Style17">
<p class="Style4 Style17"><span class="style29"><u>9) R&eacute;f&eacute;rences</u></span><br>
  []<a href="http://www.commentcamarche.net/crypto/rsa.php3" target="_blank"> http://rsa.lissyx.dyndns.org/</a><br>
  []<a href="http://www.commentcamarche.net/crypto/rsa.php3" target="_blank"> http://www.commentcamarche.net/crypto/rsa.php3</a><br>
  []<a href="http://www.security-labs.org/index.php3?page=6" target="_blank"> http://www.security-labs.org/index.php3?page=6</a>
<p class="Style4"><span class="Style17"><br>
  <br>
  </span><span class="style31">V</span><span class="Style17">oici le code source de mon programme permettant de crypter, d&eacute;crypter et de brute forcer un chiffre.</span><br>
<br>
<br>
<br><u><span class="Style17">prototypes.h</span></u>
<p class="Style4"><table width="590" border="1" align="center" bordercolor="#000000">
  <tr>
    <td bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style14">typedef struct<br>
<span class="Style15">_</span>{<br>
<span class="Style15">___</span>unsigned long int p;<br>
<span class="Style15">___</span>unsigned long int q;<br>
<span class="Style15">___</span>unsigned long int n;<br>
<span class="Style15">___</span>unsigned long int phi;<br>
<span class="Style15">___</span>unsigned long int d;<br>
<span class="Style15">___</span>unsigned long int e;<br>
<span class="Style15">___</span>unsigned long int nb;<br>
<span class="Style15">_</span>}cle;<br>
    </span>
      <p class="Style14">unsigned long int puissance(int a, int b);<br>
        unsigned long int cryptage(unsigned long int nb, unsigned long int puiss, unsigned long int mod);<br>
        unsigned long int decryptage(unsigned long int nb, unsigned long int puiss, unsigned long int mod);<br>
        unsigned long int brutus_attack(unsigned long int c, unsigned long int puiss, unsigned long mod);<br>
        cle cleCryptage(void);<br>
        cle cleDecryptage(void);<br>
        cle cleCassage(void);<br>
        void demande(void);</p></td>
  </tr>
</table>
<p class="Style4"><br>
  <u><span class="Style17">cryptage.h</span></u>
  <br>
<table width="762" border="1" align="center" bordercolor="#000000">
  <tr>
    <td width="752" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style14">unsigned long int cryptage(unsigned long int nb, unsigned long int puiss, unsigned long int mod)<br>
        {<br>
        unsigned long int res = 1, nvar, nvar2;<br>
        unsigned long int resultat[100000];<br>
        int i, j, k,l; // compteurs<br>
        int nnb, compt, var, caze;<br>
        int tab[100000], tab2[100000];<br>
        int puissa = puiss; </span>
        <p class="Style14"> printf(&quot;\nCRYPTAGE EN COURS...\n&quot;);<br>
        for (i=0; i&lt;100000; i++) // on remplit le tableau avec des 5<br>
        <span class="Style15">___</span>tab[i]=5;</p>
        <p class="Style14"> for (i=0, compt = -1; puiss &gt; 0; i++, compt++ ) // on convertit la puissance en binaire<br>
        {<br>
        <span class="Style15">___</span>if (puiss % 2 &gt; 0)<br>
        <span class="Style15">___</span>nnb = 1;<br>
        <span class="Style15">___</span>if (puiss % 2 == 0)<br>
        <span class="Style15">___</span>nnb = 0;<br>
        <span class="Style15">___</span>tab[i]=nnb;<br>
        <span class="Style15">___</span>puiss = puiss / 2;<br>
        }</p>
        <p class="Style14"> for (i=0, j=0; tab[i] != 5; i++) // on convertit le binaire en puissance de 2 : par <br>
        {<span class="Style15">________________________________</span>// exemple (11101)b = 16 + 8+ 4 + 1<br>
        <span class="Style15">__</span>if (tab[i] == 1)<br>
        <span class="Style15">____</span>{<br>
        <span class="Style15">______</span>var = puissance(2,i);<br>
        <span class="Style15">______</span>tab2[j] = var;<br>
        <span class="Style15">______</span>j++;<br>
        <span class="Style15">____</span>}<br>
        }</p>
        <p class="Style14"> l = j; // on sauvegarde la valeur de j cad le nombre d'element ds le tableau tab2[]</p>
        <p class="Style14"> resultat[0]=0;<br>
        resultat[1]=nb; <span class="Style15">_______</span>/* On met dans le tableau resultat[] les restes du nombre nb par les */<br>
        nvar2 = nb;<span class="Style15"> ___________</span>/* puissances successives jusqu'&agrave; la puissance egal au plus grand nombre */<br>
        nvar = nb;<span class="Style15">_____________</span>/* du tableau tab2[] par le modulo mod */<br>
        for (i=2; i&lt;=tab2[j-1]+1; i++)<br>
        <span class="Style15">_</span>{ <span class="Style15">_________________________</span>/* Par exemple pour 29 = 16 + 8 + 4 +1 et pour nb =3 on et dans le tableau */<br>
        <span class="Style15">___</span>nvar2 = nvar * nvar2; <span class="Style15">___</span>/* les restes de 3^1, 3^2 jusqu'&agrave; 3^16 par le modulo mod */<br>
        <span class="Style15">___</span>nvar2 = nvar2%mod;<br>
        <span class="Style15">___</span>resultat[i] = nvar2;<br>
        <span class="Style15">_</span>}<br>
        </p>
        <p class="Style14"> for (i=0, res=1; i&lt;l; i++) /* Dans la case i du tableau resultat se trouve nb^i */<br>
            {<span class="Style15">_______________</span>/* Donc &agrave; partir du tableau tab2[i] qui contient la d&eacute;composition de la puissance puiss*/<br>
            <span class="Style15">___</span>caze=tab2[i]; <span class="Style15">___</span>/* res = res * resultat[caze]; /* en puissance de 2 ( 29 = 16 + 8 + 4 + 1), on peut */ <br>
            <span class="Style15">_________________</span><span class="Style15">____</span>/* obtenir nb^puiss en multipliant */<br>
            <span class="Style15">___</span>if (res &gt; mod)<span class="Style15">____</span>/* par exemple nb^16, on multiplie les cases<br>
            <span class="Style15">______</span>res = res%mod; <span class="Style15"></span>/* resultat[16]*resultat[8]*resultat[4]*resultat[1] */<br>
        }<span class="Style15">____________________</span>/* pour obtenir enfin le chiifre crypt&eacute; on fait le resultat precedent modulo mod */<br>
        </p>
        <p class="Style14"> return res;<br>
        }</p></td>
  </tr>
</table>
<p><br>
<u class="Style4 Style17">decryptage.h
</u></p>
<table width="762" border="1" align="center" bordercolor="#000000">
  <tr>
    <td width="752" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style15"></span><span class="Style14">// Remarque : c'est exactement la m&ecirc;me chose que pour cryptage()</span>    
      <p class="style6 style10"><span class="Style14">unsigned long int decryptage(unsigned long int nb, unsigned long int puiss, unsigned long int mod)<br>
        {</span><span class="Style15">______________________________________________</span><span class="Style14"><br>
        <span class="Style15">_</span>unsigned long int res = 1, nvar, nvar2;<br>
        <span class="Style15">_</span>unsigned long int resultat[100000];<br>
        <span class="Style15">_</span>int i, j, k,l; // compteurs<br>
        <span class="Style15">_</span>int nnb, compt, var, caze;<br>
        <span class="Style15">_</span>int tab[100000], tab2[100000];<br>
        <span class="Style15">_</span>int puissa = puiss; </span>
      <p class="Style14"> <span class="style6 style10"><span class="Style15">_</span></span>printf(&quot;\nDECRYPTAGE EN COURS...\n&quot;);<br>
        <span class="style6 style10"><span class="Style15">_</span></span>for (i=0; i&lt;100000; i++) // on remplit le tableau avec des 5<br>
        <span class="Style15">___</span>tab[i]=5;</p>
        <p class="Style14"> <span class="style6 style10"><span class="Style15">_</span></span>for (i=0, compt = -1; puiss &gt; 0; i++, compt++ ) // on convertit la puissance en binaire<br>
          <span class="style6 style10"><span class="Style15">_</span></span>{<br>
          <span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span>if (puiss % 2 &gt; 0)<br>
          <span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span>nnb = 1;<br>
          <span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span>if (puiss % 2 == 0)<br>
          <span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span>nnb = 0;<br>
          <span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span>tab[i]=nnb;<br>
          <span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span><span class="style6 style10"><span class="Style15">_</span></span>puiss = puiss / 2;<br>
          <span class="style6 style10"><span class="Style15">_</span></span>}</p>
        <p class="Style14"> for (i=0, j=0; tab[i] != 5; i++) // on convertit le binaire en puissance de 2 : par <br>
        {<span class="Style15">________________________________</span>// exemple (11101)b = 16 + 8+ 4 + 1<br>
        <span class="Style15">__</span>if (tab[i] == 1)<br>
        <span class="Style15">____</span>{<br>
        <span class="Style15">______</span>var = puissance(2,i);<br>
        <span class="Style15">______</span>tab2[j] = var;<br>
        <span class="Style15">______</span>j++;<br>
        <span class="Style15">____</span>}<br>
        }</p>
        <p class="Style14"> l = j; // on sauvegarde la valeur de j cad le nombre d'element ds le tableau tab2[]</p>
        <p class="Style14"> resultat[0]=0;<br>
        resultat[1]=nb; <span class="Style15">_______</span>/* On met dans le tableau resultat[] les restes du nombre nb par les */<br>
        nvar2 = nb;<span class="Style15"> ___________</span>/* puissances successives jusqu'&agrave; la puissance egal au plus grand nombre */<br>
        nvar = nb;<span class="Style15">_____________</span>/* du tableau tab2[] par le modulo mod */<br>
        for (i=2; i&lt;=tab2[j-1]+1; i++)<br>
        <span class="Style15">_</span>{ <span class="Style15">_________________________</span>/* Par exemple pour 29 = 16 + 8 + 4 +1 et pour nb =3 on et dans le tableau */<br>
        <span class="Style15">___</span>nvar2 = nvar * nvar2; <span class="Style15">___</span>/* les restes de 3^1, 3^2 jusqu'&agrave; 3^16 par le modulo mod */<br>
        <span class="Style15">___</span>nvar2 = nvar2%mod;<br>
        <span class="Style15">___</span>resultat[i] = nvar2;<br>
        <span class="Style15">_</span>}<br>
        </p>
        <p class="Style14"> for (i=0, res=1; i&lt;l; i++) /* Dans la case i du tableau resultat se trouve nb^i */<br>
            {<span class="Style15">_______________</span>/* Donc &agrave; partir du tableau tab2[i] qui contient la d&eacute;composition de la puissance puiss*/<br>
            <span class="Style15">___</span>caze=tab2[i]; <span class="Style15">___</span>/* res = res * resultat[caze]; /* en puissance de 2 ( 29 = 16 + 8 + 4 + 1), on peut */ <br>
            <span class="Style15">_________________</span><span class="Style15">____</span>/* obtenir nb^puiss en multipliant */<br>
            <span class="Style15">___</span>if (res &gt; mod)<span class="Style15">____</span>/* par exemple nb^16, on multiplie les cases<br>
            <span class="Style15">______</span>res = res%mod; <span class="Style15"></span>/* resultat[16]*resultat[8]*resultat[4]*resultat[1] */<br>
        }<span class="Style15">____________________</span>/* pour obtenir enfin le chiifre crypt&eacute; on fait le resultat precedent modulo mod */<br>
        </p>
        <p class="Style14"> return res;<br>
        }</p></td>
  </tr>
</table>
<p class="Style4"><span class="Style17"><FONT size=2><STRONG><U><span class="Style10"><br>
  </span></U></STRONG><U><span class="Style10"><span class="Style17">brutus_attack.h
  </span><br>
</span></U></FONT></span>
<table width="812" border="1" align="center" bordercolor="#000000">
  <tr>
    <td width="802" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style14">unsigned long int brutus_attack(unsigned long int c, unsigned long int puiss, unsigned long int mod)<br>
        {</span><span class="Style15">__________________________________________________</span><span class="Style14">/* mod = cl&eacute; n et puiss = cl&eacute; e */<br>
        unsigned long int res = 1, nvar, nvar2;<br>
        unsigned long int resultat[100000];<br>
        int i, j, k,l; // compteurs<br>
        int nnb, compt, var, caze;<br>
        int tab[100000], tab2[100000];<br>
        int puissa = puiss; </span>
        <p class="Style14"> printf(&quot;\nTENTATIVE DE BRUTE FORCING EN COURS...\n&quot;);<br>
        for (i=0; i&lt;100000; i++) // on remplit le tableau avec des 5<br>
        <span class="Style15">___</span>tab[i]=5;</p>
        <p class="Style14"> for (i=0, compt = -1; puiss &gt; 0; i++, compt++ ) // on convertit la puissance en binaire<br>
        {<br>
        <span class="Style15">___</span>if (puiss % 2 &gt; 0)<br>
        <span class="Style15">___</span>nnb = 1;<br>
        <span class="Style15">___</span>if (puiss % 2 == 0)<br>
        <span class="Style15">___</span>nnb = 0;<br>
        <span class="Style15">___</span>tab[i]=nnb;<br>
        <span class="Style15">___</span>puiss = puiss / 2;<br>
        }</p>
        <p class="Style14"> for (i=0, j=0; tab[i] != 5; i++) // on convertit le binaire en puissance de 2 : par <br>
        {<span class="Style15">________________________________</span>// exemple (11101)b = 16 + 8+ 4 + 1<br>
        <span class="Style15">___</span>if (tab[i] == 1)<br>
        <span class="Style15">____</span>{<br>
        <span class="Style15">______</span>var = puissance(2,i);<br>
        <span class="Style15">______</span>tab2[j] = var;<br>
        <span class="Style15">______</span>j++;<br>
        <span class="Style15">____</span>}<br>
        }</p>
        <p class="Style14"> l = j; // on sauvegarde la valeur de j cad le nombre d'element ds le tableau tab2[]</p>
        <p class="Style14">    /*   On essaye toutes les valeurs possibles de M^e (mod n) avec M &lt; n jusqu'&agrave; ce que le resultat egal &agrave; C*/<br>
for (nb=1; nb &lt; mod; nb++)<br>
<span class="style24">_</span>{<br>
<span class="style24">___</span>resultat[0]=0;<br>
<span class="style24">___</span>resultat[1]=nb; /* On met dans le tableau resultat[] les restes du nombre nb par les */<br>
<span class="style24">___</span>nvar2 = nb; /* puissances successives jusqu'&agrave; la puissance egal au plus grand nombre */<br>
<span class="style24">___</span>nvar = nb; /* du tableau tab2[] par le modulo mod */<br>
<span class="style24">___</span>for (i=2; i&lt;=tab2[j-1]+1; i++)<br>
<span class="style24">____</span>{ <span class="style24">______________________</span>/* Par exemple pour 29 = 16 + 8 + 4 +1 et pour nb =3 on et dans le tableau */<br>
<span class="style24">______</span>nvar2 = nvar * nvar2; /* les restes de 3^1, 3^2 jusqu'&agrave; 3^16 par le modulo mod */<br>
<span class="style24">______</span>nvar2 = nvar2%mod;<br>
<span class="style24">______</span>resultat[i] = nvar2;<br>
<span class="style24">____</span>}<br>
        </p>
        <p class="Style14"> <span class="Style15">___</span>for (i=0, res=1; i&lt;l; i++) /* Dans la case i du tableau resultat se trouve nb^i */<br>
          <span class="Style15">___</span>{<br>
          <span class="Style15">______</span>caze = tab2[i];<br>
  <span class="Style15">___</span><span class="Style15">___</span>res = res * resultat[caze]; <br>
  <span class="Style15">___</span><span class="Style15">___</span>if (res &gt; mod) <br>
          <span class="Style15">_________</span>res = res%mod; <br>
          <span class="Style15">___</span>}<br>
          <span class="Style15">___</span></p>
        <p class="Style14"><span class="Style15">___</span>if ( res == c)<br>
          <span class="Style15">______</span>break;</p>        <p class="Style14"> }<br>
          <span class="Style15">___</span>return res;<br>
        }</p>
    </td>
  </tr>
</table>
<p class="Style4"><span class="Style17"><FONT size=2><STRONG><U><span class="Style10"><br>
  </span></U></STRONG><U><span class="Style10"><span class="Style17">crypt-rsa-ge.c</span><br>
  </span></U><STRONG><U><span class="Style10"><br>
  </span></U></STRONG></FONT></span>
<table width="878" border="1" align="center" bordercolor="#000000">
  <tr>
    <td width="868" bordercolor="#FFFFFF" bgcolor="#FFFFFF"><p class="style6 style10"><span class="Style14">#include &lt;stdio.h&gt;<br>
  #include &quot;prototypes.h&quot;<br>
  #include &quot;cryptage.h&quot;<br>
  #include &quot;decryptage.h&quot;<br>
  #include &quot;brutus_attack.h&quot;
    </span>
      <p class="Style14">void demande(void)<br>
        {<br>
  int choix;<br>
  unsigned long int res, nb;<br>
  cle c;<br>
  FILE *premier;</p>
      <p class="Style14"> if ((premier = fopen(&quot;nb_premier_phi.txt&quot;,&quot;r&quot;)) != NULL)<br>
        <span class="style24">_</span>{ <span class="style24">____________________</span>/* On supprime les eventuels fichier r&eacute;sultant d'une */<br>
  <span class="style24">___</span>fclose(premier); <span class="style24">___</span>/* execution du programme */<br>
  <span class="style24">___</span>system(&quot;del nb_premier_phi.txt&quot;);<br>
  <span class="style24">_</span>}</p>
      <p class="Style14"> system(&quot;cls&quot;);<br>
  /*------------------------------------------Menu---------------------------------------------*/<br>
  printf(&quot;---------------------------[Bienvenue dans CRYPT-RSA-GE]---------------------------\n\n&quot;);<br>
  printf(&quot;----[Que voulez vous faire ?&quot;);</p>
      <p class="Style14"> printf(&quot;\n\n--------[1 Crypter un nombre\n&quot;);<br>
  printf(&quot;--------[2 Decrypter un nombre\n&quot;);<br>
  printf(&quot;--------[3 Tenter un cassage d'un chiffre crypte\n&quot;);<br>
  printf(&quot;--------[4 Quitter le programme\n&quot;);<br>
  printf(&quot;\nChoix : &quot;);<br>
  scanf(&quot;%d&quot;,&amp;choix);<br>
  printf(&quot;\n&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&deg;&quot;);<br>
  /*-------------------------------------------------------------------------------------------*/</p>
      <p class="Style14"> switch(choix)<br>
        <span class="style24">_</span>{<br>
        <span class="style24">___</span>case 1 : c = cleCryptage(); res = cryptage(c.nb, c.e, c.n); printf(&quot;Le nombre cypte est C = %lu&quot;,res); break;<br>
        <span class="style24">___</span>case 2 : c = cleDecryptage(); res = decryptage(c.nb, c.d, c.n); printf(&quot;Le nombre decypte est M = %lu&quot;,res); break; <br>
        <span class="style24">___</span>case 3 : c = cleCassage(); res = brutus_attack(c.nb, c.e, c.n); printf(&quot;Le nombre decypte est M = %lu&quot;,res); break;<br>
        <span class="style24">___</span>default: exit(0); /* si choix autre que 1, 2 ou 3 alors on sort du programme */<br>
        <span class="style24">_</span>}</p>
      <p class="Style14"> getch();<br>
  demande();<br>
  }</p>
      <p class="Style14">unsigned long int puissance(int a, int b)<br>
        {<br>
  int i;<br>
  unsigned long int res = 1;</p>
      <p class="Style14"> for (i=0; i&lt;b; i++)<br>
        <span class="style24">___</span>res = res * a;</p>
      <p class="Style14"> return res;<br>
        }</p>
      <p class="Style14">cle cleCryptage(void)<br>
        {<br>
  cle c;<br>
  unsigned long int i;<br>
  FILE *premier;</p>
      <p class="Style14"> premier = fopen(&quot;nb_premier_phi.txt&quot;,&quot;a&quot;); /* On cr&eacute;e un fichier pour stocker les nombres */<br>
  if (premier == NULL) /* premiers avec phi */<br>
  <span class="style24">_</span>{<br>
  <span class="style24">___</span>printf(&quot;\n\nErreur cr&eacute;ation du fichier nb_premier_phi.txt&quot;);<br>
  <span class="style24">___</span>exit(42);<br>
  <span class="style24">_</span>}</p>
      <p class="Style14"> printf (&quot;\n\nEntrez le nombre a crypter : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.nb);<br>
  printf(&quot;Entrez le nombre premier p : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.p);<br>
  printf(&quot;Entrez le nombre premier q : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.q);<br>
  printf(&quot;\nCALCUL DE LA CLE N EN COURS...&quot;);<br>
  c.n = c.p*c.q;<br>
  printf(&quot;\nLa cle n = %lu\n&quot;,c.n);<br>
  printf(&quot;\nCALCUL DE LA CLE PHI EN COURS...&quot;);<br>
  c.phi = (c.p-1)*(c.q-1);<br>
  printf(&quot;\nLa cle phi = %lu\n&quot;,c.phi);</p>
      <p class="Style14"> for (i = 2; i&lt; c.phi/2; i++) /* On incrit dans le fichier tous les nombres */<br>
        <span class="style24">___</span>if ( c.phi % i != 0) /* premiers avec phi jusqu'&agrave; phi / 2 */<br>
  <span class="style24">______</span>fprintf(premier,&quot;%lu\n&quot;,i);<br>
  fclose(premier);</p>
      <p class="Style14"> printf(&quot;\nUne liste des cles possibles d est disponible dans le fichier nb_premier_phi.txt&quot;);<br>
  printf(&quot;\nEntrez la cle d (premier avec phi) : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.d);<br>
  printf(&quot;\nCALCUL DE LA CLE E EN COURS...&quot;);</p>
      <p class="Style14"> for (c.e=1; c.e &lt; (c.phi*c.phi); c.e++) /* On recherche une chiffre tel que e*d-1 soit divisible par phi */<br>
        <span class="style24">___</span>if (((c.e*c.d) % c.phi) == 1)<br>
  <span class="style24">______</span>break;</p>
      <p class="Style14"> printf(&quot;\ne = %lu\n&quot;,c.e);<br>
  return c;</p>
      <p class="Style14">}</p>
      <p class="Style14">cle cleDecryptage(void)<br>
        {<br>
  cle c;<br>
  printf (&quot;\n\nEntrez le nombre a decrypter : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.nb);<br>
  printf(&quot;Entrez la cle prive d : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.d);<br>
  printf(&quot;Entrez la cle public n : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.n);<br>
  return c;<br>
  }</p>
      <p class="Style14">cle cleCassage(void)<br>
        {<br>
  cle c;<br>
  printf (&quot;\n\nEntrez le nombre a decrypter : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.nb);<br>
  printf(&quot;Entrez la cle public e : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.e);<br>
  printf(&quot;Entrez la cle public n : &quot;);<br>
  scanf(&quot;%lu&quot;,&amp;c.n);<br>
  return c;<br>
  }</p>
      <p class="Style14">int main(void)<br>
        {<br>
        system(&quot;title CRYPT-RSA-GE by Skyrunner&quot;);<br>
  demande();<br>
  return 0;</p>
      <p class="Style14">}</p></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><a href="page5.htm"><u>HAUT DE PAGE</u></a> </p>
<p align="center">&nbsp;</p>
<p align="right" class="style32">BY SKYRUNNER </p>
<p align="right" class="Style4 Style17 style33">Copyright &copy; 2005 ARENHACK - DHS
</body>
</html>
