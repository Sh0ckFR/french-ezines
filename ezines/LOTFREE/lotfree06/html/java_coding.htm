<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Java c0ding</title>
</head>
 <body bgcolor="#000000" text="#ff00ff">
 
<div align="center">   
<p><b><u><font size="6">Java c0ding<br>
     </font></u></b><font size="2">aka c0dit0, erg0 sum</font></p>
   
  <p align="left"><font size="2">Note &agrave; moi m&ecirc;me : putain pourquoi 
    je me suis lanc&eacute; dans cet article de programmation Java ?!?! Et merde 
    et merde et gal&egrave;re et GAL&Egrave;RE !!<br>
    Je suis d&eacute;j&agrave; &agrave; la seconde page web, arf !! Mais puisque 
    c'est commenc&eacute; on continue ;)</font></p>
  <p align="left"><font size="2">Pour ceux qui ne connaissent pinuts de la programmation 
    objet, vous allez voir c'est pas si difficile.<br>
    Tout d'abord la programmation objet (POO = Programmation Orient&eacute; Objet) 
    est une TECHNIQUE de programmation. Par exemple en C++ vous pouvez programmer 
    en objet mais vous n'y &ecirc;tes pas oblig&eacute;.<br>
    Avec Java par contre c'est obligatoire, c'est bien pour cela que je vous en 
    parle (si vous comprenez pas cette phrase jettez vous imm&eacute;diatement 
    par la fen&ecirc;tre. Pourquoi ? Sais pas !).</font></p>
  <p align="left"><font size="2"><u>Ne pas r&eacute;inventer la roue</u><br>
    Au fur et &agrave; mesure que les langages de programmation &eacute;voluaient, 
    le travail du programmeur &eacute;tait facilit&eacute;.<br>
    Vous connaissez tous la programmation proc&eacute;durale ; elle consite &agrave; 
    cr&eacute;er des fonctions capables de traiter un type fixe de donn&eacute;e. 
    Ce type de programmation est celui du C. Si vous cr&eacute;ez une fonction 
    qui prend deux int comme arguments et que vous lui filez deux caract&egrave;res, 
    la fonction vas vous tirez la gueule. Mais c'est la programmation de papa 
    tout &ccedil;a !!!<br>
    Dans C++ on peut par exemple cr&eacute;er objet 'couple'. Ce couple est constiu&eacute; 
    de deux &eacute;l&eacute;ments du m&ecirc;me type. Ce type peut &ecirc;tre 
    des pantoufles, des chats, des num&eacute;ros de LOTFREE, n'importe quoi.<br>
    Maintenant comment on fait pour savoir si les pantoufles, les chats etc sont 
    les m&ecirc;mes ?<br>
    En C vous allez gentiment faire une fonction egalChat(chat x,chat y), une 
    fonction egalPantoufle(pantoufle a, pantoufle b) etc<br>
    En C++ vous faites une class qui servira de mod&egrave;le :<br>
    <br>
    <font color="#ffffff">template &lt;class elem&gt; class couple{<br>
    elem p,s;<br>
    public:<br>
    void crecouple(elem x,elem y){p=x; s=y}<br>
    elem premier(){return p;}<br>
    elem second(){return s;}<br>
    friend int egal(couple a, couple b);<br>
    } </font></font></p>
  <p align="left"><font size="2">Vous inqui&eacute;tez pas on vas pas faire du 
    C++. C'est juste un exemple sur la POO. Le mot template signifie que la classe 
    couple est g&eacute;n&eacute;rique et quelle pourra accepter n'importe quel 
    type de donn&eacute;e.<br>
    Lors de la construction de cette classe il faut bien &eacute;videmment pouvoir 
    d&eacute;signer (m&ecirc;me si c'est de fa&ccedil;on abstraite) les donn&eacute;es 
    que on devra manipuler. Pour cela on d&eacute;clare une donn&eacute;e du type 
    'elem'.<br>
    Un couple est donc un objet qui contient deux &eacute;l&eacute;ments, l'un 
    est not&eacute; p comme premier, et l'autre s comme second.<br>
    On fait une fonction qui renvoit le premier &eacute;l&eacute;ment et une autre 
    pour le second. L&agrave; aucun probl&egrave;me.<br>
    Mais comment faire une fonction g&eacute;n&eacute;rique qui saura si les deux 
    &eacute;l&eacute;ments sont &eacute;gaux ?<br>
    En effet on ne compare pas 2 chats de la m&ecirc;me fa&ccedil;ons que l'on 
    compare deux pantoufles. L&agrave; encore on est limit&eacute;. Il va falloir 
    faire en sorte que chaque type de couple ai une fonction de comparaison qui 
    lui est propre.<br>
    En attendant si on veux cr&eacute;er un type couple de chat il nous suffira 
    taper :<br>
    <font color="#ffffff">typedef couple&lt;chat&gt; couple_de_chat;</font><br>
    Bien s&ucirc;r on consid&eacute;re que l'on a d&eacute;clar&eacute; un type 
    'chat' avant. De la m&ecirc;me fa&ccedil;on on peut dire qu'un point est compos&eacute; 
    de deux valeurs : abscisse et ordonn&eacute;e.<br>
    <font color="#ffffff">typedef couple &lt;float&gt; point;</font><br>
    A partir d'une simple notion de couple on a d&eacute;fini ce qu'&eacute;tait 
    un point. Maintenant pourquoi pas d&eacute;finir carr&eacute;ment une ligne 
    ?<br>
    <font color="#ffffff">typedef couple&lt;point&gt; ligne;</font><br>
    H&eacute; oui, une ligne c'est deux points.<br>
    Fantastique : vous avez compris l'un des avantages de la programmation objet 
    : la g&eacute;n&eacute;ricit&eacute;.</font></p>
  <p align="left"><font size="2">On vas profiter de cet exemple pour voir un autre 
    concept... Dans l'intro je vous ai parl&eacute; de droits d'acc&egrave;s aux 
    donn&eacute;es. En effet en C vous avez le mot cl&eacute; 'struct' qui permet 
    de rassembler plusieurs variables sous un seul nom. Par exemple on peut d&eacute;finir 
    un objet CD :<br>
    <font color="#ffffff">typedef struct{<br>
    char * artiste;<br>
    char * album;<br>
    int annee;<br>
    int categorie;<br>
    float prix;<br>
    } CD;</font></font></p>
  <p align="left"><font size="2">De cette mani&egrave;re on peut cr&eacute;er 
    le dernier Rancid de cette mani&egrave;re :<br>
    <font color="#ffffff">CD rancid_indestructible;</font><br>
    Mais l&agrave; les valeurs du CD ne sont pas fix&eacute;es, on est donc oblig&eacute; 
    de les mettre nous m&ecirc;me :<br>
    <font color="#ffffff">rancid_indestructible.artiste="rancid";<br>
    rancid_indestructible.album="indestructible";<br>
    rancid_indestructible.annee=2003;</font><br>
    C'est lourd non ? Et puis imaginons que l'on veuille prot&eacute;ger certaines 
    valeurs d'un CD. En effet sur un CD seul le prix change. Or l&agrave; si le 
    programmeur fait une erreur il en subit les cons&eacute;quences.<br>
    On peut consid&eacute;rer que la notion de 'class' que l'on trouve en C++ 
    et en Java est en fait une 'struct' avec des notions de droit.<br>
    Par d&eacute;faut tous les &eacute;l&eacute;ments d'une struct sont 'public', 
    c'est &agrave; dire que n'importe qui peut y acc&egrave;der.<br>
    A l'oppos&eacute; dans une class tous les &eacute;l&eacute;ments sont 'private' 
    par d&eacute;faut en C++. Cela veut dire que seul l'objet en lui m&ecirc;me 
    peut y acc&eacute;der.<br>
    Si vous regardez plus en d&eacute;tail l'exemple du couple vous appercevez 
    que nous avons d&eacute;clar&eacute; deux &eacute;l&eacute;ments p et s dans 
    une CLASSE couple. Donc ces deux &eacute;l&eacute;ments sont priv&eacute;s.<br>
    Si vous essayez de les modifiez de cette fa&ccedil;on :<br>
    <font color="#ffffff">monpoint.p=5;</font><br>
    (dans l'exemple d'un point) alors vous aurez une erreur. M&ecirc;me juste 
    un :<br>
    <font color="#ffffff">cout&lt;&lt;"Les absisses du point valent "&lt;&lt;monpoint.p&lt;&lt;endl;</font><br>
    Vous affichera une erreur. Alors que<br>
    <font color="#ffffff">cout&lt;&lt;"Les absisses du point valent "&lt;&lt;monpoint.premier()&lt;&lt;endl; 
    </font><br>
    affichera l'absisse du point. Pourquoi on a acc&egrave;s &agrave; la fonction 
    premier() ? Tout simplement parce que avant on a mis le mot cl&eacute; 'public:'<br>
    Ca y est vous avez compris un second avantage de la POO : l'encapsulation. 
    C'est le fait de pouvoir 'cacher' les valeurs de tel ou tel objet. Il reste 
    cependant un mot cl&eacute; interm&eacute;diaire 'protected' que l'on verras 
    tout &agrave; l'heure.</font></p>
  <p align="left"><font size="2"><u>Java dans la pratique</u><br>
    Maintenant on va utiliser la syntaxe Java. Vous inqui&eacute;tez pas : c'est 
    plus simple (pas de template).<br>
    Maintenant on est embauch&eacute; par un zoo pour faire un programme de gestion 
    des animaux. Tous les animaux sont diff&eacute;rents bien s&ucirc;r, ne serais-cequ'au 
    niveau de leur race... mais ils ont tous des points communs : ils ont un age, 
    un poids, voire un nom.<br>
    Vous pouvez bien entendu programmer b&eacute;tement et faire une classe chimpanz&eacute; 
    avec comme valeur l'age, le poids, le nom. Ensuite quand vous faire la classe 
    ours vous remmetez l'age, le poids...<br>
    STOP !!! Vous avez pas compris le principe de la programmation Objet ou quoi 
    ?<br>
    Il est bien evidemment possible de cr&eacute;er une classe comune :</font></p>
  <p align="left"><font size="2" color="#ffffff">class animal{<br>
    &nbsp; int age;<br>
    &nbsp; int poids;<br>
    &nbsp; String nom;<br>
    }</font></p>
  <p align="left"><font size="2">D&eacute;j&agrave; on remarque que les char* 
    c'est fini... Putain &ccedil;a fait du bien.<br>
    Maintenant cr&eacute;ons une classe kangourou qui contient les m&ecirc;me 
    &eacute;l&eacute;ments que tous les animaux mais aussi ses donn&eacute;es 
    propres :<br>
    <font color="#ffffff">class kangourou extends animal{<br>
    &nbsp; int longueur_de_saut;<br>
    } </font><br>
    Ca y est. Tout est fait dans le mot cl&eacute; 'extends'. Il est l&agrave; 
    pour dire que la classe kangourou 'h&eacute;rite' des donn&eacute;es de la 
    classe animal.<br>
    Bien, maintenant faisons un peu de pratique. On met le premier texte (classe 
    animal) dans un fichier que l'on nomme pet.java (pet=animal en anglais pour 
    ceux que j'ai vu rigoler (bande de nazes !!)).<br>
    <font color="#00FF00">[sirius@localhost java]$ javac pet.java<br>
    [sirius@localhost java]$ ls<br>
    animal.class pet.java</font></font></p>
  <p align="left"><font size="2">Comme vous pouvez le constater, notre fichier 
    pet.java ne s'est pas compil&eacute; en un pet.class mais en un animal.class<br>
    Cela veut dire que le compilateur ne prend en compte que le nom de la classe. 
    A partir de maintenant je vous conseillerais (c m&ecirc;me plus qu'un conseil) 
    de donner exactement le m&ecirc;me nom &agrave; votre fichier que celui donn&eacute; 
    &agrave; votre class.<br>
    Si vous faites une classe MaClasseJ4v4 alors le fichier devra s'appeler MaClasseJ4v4.java<br>
    Il faut aussi respecter majuscules et minuscules. Pourquoi il faut faire &ccedil;a 
    ? D&eacute;j&agrave; pour vous ce sera plus facile pour vous y retrouver dans 
    vos fichiers. Ensuite le compilateur Javac n'aime pas toujours que l'on donne 
    des noms diff&eacute;rents, on va voir pourquoi.<br>
    Maintenant on efface les deux fichiers et on met les deux classes dans un 
    fichier kangourou.java<br>
    <font color="#00FF00">[sirius@localhost java]$ javac kangourou.java<br>
    [sirius@localhost java]$ ls<br>
    animal.class kangourou.class kangourou.java</font><br>
    On remarque que plut&ocirc;t que de cr&eacute;er un seul fichier kangourou.class 
    il a cr&eacute;&eacute; deux fichiers .class correspondant chacun &agrave; 
    une des classes que l'on a d&eacute;fini. Bref autant mettre chaque classe 
    dans un fichier : la classe kangourou dans kangourou.java et la classe animal 
    dans animal.java<br>
    Faisons une autre exp&eacute;rience : on vient de faire ce que je viens de 
    dire (on a deux fichiers java). On enl&egrave;ve les fichiers .class<br>
    <font color="#00FF00">[sirius@localhost java]$ ls<br>
    animal.java kangourou.java</font><br>
    Que se passe t'il si on compile la classe kangourou sans avoir compil&eacute; 
    la classe dont elle h&eacute;rite ?<br>
    <font color="#00FF00">[sirius@localhost java]$ javac kangourou.java<br>
    [sirius@localhost java]$ ls<br>
    animal.class animal.java kangourou.class kangourou.java</font><br>
    Putain Fantomas est pass&eacute; !! Nan en fait c'est le compilateur qui a 
    lu qu'il avait besoin d'une class animal pour compiler la classe kangourou. 
    Alors il a pris ses baskets et il est all&eacute; chercher la classe en question 
    puis il a compil&eacute;. Ensuite il a tranquillement pu compiler kangourou.java<br>
    Maintenant r&eacute;p&eacute;tons cette op&eacute;ration mais cette fois on 
    a mit la class animal dans un fichier pet.java</font></p>
  <div align="left">
    <pre align="left"><font size="2">
     <font color="#00FF00">[sirius@localhost java]$ ls
     kangourou.java pet.java
     [sirius@localhost java]$ javac kangourou.java
     kangourou.java:1: cannot resolve symbol
     symbol : class animal 
     location: class kangourou
     class kangourou extends animal{
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   ^
     1 error</font></font></pre>
  </div>
  <p align="left"><font size="2">Comprenez par l&agrave; que le compilateur n'a 
    pas trouv&eacute; la classe animal. Pourquoi ? Parce quand il a mis ses baskets 
    pour aller chercher le fichier animal.java, il l'a pas trouv&eacute; !!! Voil&agrave; 
    pourquoi il faut que le nom de la classe = nom du fichier.java<br>
    Profitez en pour regarder les informations fournies par le compilateur. D'abord 
    il nous dit dans quel fichier et &agrave; quelle ligne se trouve l'erreur. 
    Jusque l&agrave; rien de particulier. Ensuite il nous dit le type d'erreur 
    : 'cannot resolve symbol'. C'est une erreur assez fr&eacute;quente. Elle est 
    li&eacute;e aux classes. Dans notre cas il n'a pas trouv&eacute; la classe 
    animal mais ce type d'erreur peut apparaitre si on fait r&eacute;f&eacute;rence 
    &agrave; une variable ou une fonction qui n'est pas pr&eacute;sente dans une 
    classe.</font></p>
  <p align="left"><font size="2"><u>Premier programme</u><br>
    On va passer le vitesse sup&eacute;rieure pour vous expliquer &ccedil;a. Modifier 
    votre fichier kangourou.java pour qu'il ressemble &agrave; &ccedil;a :</font></p>
  <p align="left"><font size="2" color="#FFFFFF">class kangourou extends animal{<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; private int longueur_de_saut;<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public static void main(String args[]){<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; kangourou Kangoo=new 
    kangourou();<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Kangoo.xpoids=25;<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Kangoo.nom="Kangoo";<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println("Le 
    poids de "+Kangoo.nom+" est de "+Kangoo.poids);<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Kangoo.longueur_de_saut=25;<br>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>
    }</font></p>
  <p align="left"><font size="2">Que se passe t'il si on compile kangourou.java 
    ?</font></p>
  <div align="left">
    <pre align="left"><font size="2">
<font color="#00FF00">     kangourou.java:5: cannot resolve symbol
     symbol&nbsp; : variable xpoids 
     location: class kangourou
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kangoo.xpoids=25;
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</font></font></pre>
    <p align="left"><font size="2">M&ecirc;me type d'erreur sauf qu'il s'agit 
      d'une variable inexistante dans la classe kangourou. Il s'agit souvent d'une 
      faute de frappe.<br>
      Si on &eacute;tudie un peu la nouvelle classe kangourou on remarque pas 
      mal de changements. En particulier l'apparition d'une nouvelle m&eacute;thode. 
      Jusqu'&agrave; pr&eacute;sent nous n'avions fait que des classes avec des 
      variables mais on avait pas fait de programmes &agrave; vraissemblement<font color="#FF00FF"> 
      parler.</font> Pour faire un programme il faut bien &eacute;videmment un 
      point d'entr&eacute;e (une expression tr&egrave;s courante en cracking ;). 
      Il s'agit s'implement du d&eacute;but du programme. Ce point d'entr&eacute;e 
      a toujours le m&ecirc;me profil (aprennez le par coeur) :</font></p>
    <p align="left"><font size="2" color="#FFFFFF">public static void main(String 
      [] args)</font></p>
    <p align="left"><font size="2">D&eacute;composons un peu &ccedil;a. Tout d'abord 
      le static permet de dire que la fonction est la m&ecirc;me pour toutes les 
      instances de la classe. Comme &ccedil;a doit pas vous sembler ultra clair 
      on va refaire un peu de POO.<br>
      Nous on a d&eacute;clar&eacute; une classe kangourou. C'est bien joli mais 
      c'est g&eacute;n&eacute;rique. En gros notre classe d&eacute;signe tous 
      les kangourous &agrave; travers le monde. Nous on veut travailler avec un 
      seul kangourou. Dans notre exemple on en veut un pr&eacute;cis qui s'appelle 
      Kangoo (comme la caisse). On peut dire que Kangoo est une instance de tous 
      les kangourous &agrave; travers le monde. On peut aussi entendre le terme 
      occurence mais il est moins rattach&eacute; &agrave; la programmation. Bref 
      une instance c'est un exemplaire.</font></p>
    <p align="left"><font size="2">Si on veut expliquer un peu plus le mot static 
      on peut par exemple mettre la variable moyenne_de_vie en static dans la 
      classe kangourou parce que tous les kangourous ont la m&ecirc;me moyenne 
      de vie (moyenne sur le monde).<br>
      public on a d&eacute;j&agrave; vu ; &ccedil;a veut dire que cette fonction 
      est accessible par tout le monde... heureusement parce que c'est le point 
      d'entr&eacute;e du programme.<br>
      void main je pense que vous connaissez (mais pour ceux qui n'ont pas encore 
      programm&eacute; &ccedil;a veut dire que c'est la fonction principale et 
      quelle ne renvoie aucun r&eacute;sultat).<br>
      Ensuite le String []args. Il s'agit &eacute;videmment des arguments du programme. 
      Quelle est la diff&eacute;rence avec le C ? Piou !! La classe String poss&egrave;de 
      pas mal de m&eacute;thodes et c'est largement &agrave; notre avantage. Le 
      nom de la String n'est pas fig&eacute;, rien ne vous emp&eacute;che de mettre 
      argv. Ensuite les crochets : ils peuvent &ecirc;tre aussi bien devant que 
      apr&egrave;s le nom de la cha&icirc;ne.<br>
      Autre sp&eacute;cificit&eacute; : le premier argument est accessible par 
      args[0] et le nombre d'agument s'obtient avec args.length(). Cette m&eacute;thode 
      renvoie un entier (int).</font></p>
    <p align="left"><font size="2"><u>Programmation Objet et droits d'acc&egrave;s</u><br>
      Je vous ai dit qu'en Java tout &eacute;tait des classes. String en est une 
      par exemple. Alors comment se fait-il qu'on ne fait pas appelle &agrave; 
      sa librairie ?<br>
      L'explication est simple. La librairie java.lang.* est charg&eacute;e automatiquement 
      car elle contient... le noyau de Java. Sans elle pas de programme !</font><br>
      <font size="2">Maintenant vous allez me demander pourquoi on ne charge pas 
      la classe int... Il y a quelques exceptions en Java : certains type basiques 
      ont &eacute;t&eacute; gard&eacute;s. Ainsi int, char, float, short, byte, 
      long, double et boolean ne sont pas des classes. En revanche les tableaux 
      (int [] ou byte [] etc) sont vraiment sp&eacute;ciaux, on peut les classer 
      entre les types basiques et les classes. On verra peut-&ecirc;tre &ccedil;a 
      (j'insiste sur le peut-&ecirc;tre). Le mot cl&eacute; null a aussi &eacute;t&eacute; 
      conserv&eacute;. Le type char a subit quelques modifications car il n'est 
      plus sur 1 mais sur 2 octets !! Oui 2 pour le prix d'1 (en dirait du Bellemare 
      au T.V. H.I.&Eacute;.). Pourquoi deux octets ? Pour respecter la norme unicode. 
      Ainsi on peut repr&eacute;senter tous les caract&egrave;res &agrave; travers 
      le monde. Tous ? Non ! Une bonne dose d'irr&eacute;ductibles caract&egrave;res 
      Chinois prennent trop de place pour en faire partie.<br>
      Pour en finir avec cette fonction main()... aprennez l&agrave; par c&#156;ur 
      et faites pas chier.</font></p>
    <p align="left"><font size="2">La premi&egrave;re op&eacute;ration de notre 
      programme est d'instancier un objet kangourou. Pour cela on utilise le m&ecirc;me 
      op&eacute;rateur qu'en C++, l'op&eacute;rateur new(). Cet op&eacute;rateur 
      permet de r&eacute;server de la place pour mettre au monde notre objet (un 
      kangourou dans notre cas). Dans notre cas le kangourou s'appelle Kangoo. 
      On verra la cr&eacute;ation d'objets plus en d&eacute;tail dans pas longtemps.</font></p>
    <p align="left"><font size="2">La ligne suivante est, une fois l'erreur corrig&eacute;e 
      (poids &agrave; la place de xpoids), une affectation tout ce qu'il y a de 
      plus simple. On pourrait se demander si cela va provoquer une erreur car 
      la classe kangourou ne poss&egrave;de pas d'attribut nomm&eacute; 'poids'. 
      Mais &ccedil;a marche parce que la classe kangourou h&eacute;rite de la 
      classe animal qui poss&egrave;de justement l'attribut poids.<br>
      Une classe h&eacute;rite des attributs et des m&eacute;thodes de son p&egrave;re. 
      La morale c'est vous pouvez &ecirc;tre con, c'est pas de votre faute mais 
      de celle de vos anc&egrave;tres LoL.</font></p>
    <p align="left"><font size="2">J'en voit certains qui cogitent. En effet puisque 
      l'attribut poids n'est pas public il doit &ecirc;tre private et par cons&eacute;quent 
      la classe kangourou, bien que fille de la classe animal, ne devrait pas 
      pouvoir acc&egrave;der &agrave; cet atribut. En fait &agrave; la diff&eacute;rence 
      de C++, le droit d'acc&egrave;s par d&eacute;faut est un droit qui s'appelle 
      'friendly' (nom non-officiel pomp&eacute; sur le C++).<br>
      Un &eacute;l&eacute;ment friendly est accessible uniquement aux classes 
      de son package (pour tout &agrave; l'heure). Or dans notre cas nous n'avons 
      pas d&eacute;fini de package donc l'acc&egrave;s se fait sans probl&egrave;me.</font></p>
    <p align="left"><font size="2">Il reste un type d'acc&egrave;s dont j'ai parl&eacute; 
      ya pas mal de temps : protected. Un &eacute;l&eacute;ment protected est 
      public vis &agrave; vis de son package, de sa classe et de ses sous classes 
      mais private vis &agrave; vis du reste.</font></p>
    <p align="left"><font size="2">Bref du plus accessible au moins accessible 
      on a : public ; protected ; friendly ; private</font></p>
    <p align="center"><font size="2"><img src="../media/oups_missile.gif" width="498" height="198"><br>
      Je sais que autant de texte &agrave; la suite c'est lourd alors je met une 
      image entre les deux. H&eacute;sitez pas &agrave; faire une pause aussi.</font></p>
    <p align="center">&nbsp;</p>
    <p align="left"><font size="2">Maintenant passons &agrave; un concept sympa 
      :<u> les packages</u>.<br>
      Dans l'intro j'ai dit que les packages &eacute;taient l'&eacute;quivalent 
      des librairies. Contrairement &agrave; de simples fichiers d'ent&ecirc;tes 
      dans le C et C++, les packages permettent de regrouper des classes par affinit&eacute;.<br>
      Java propose une bonne dose de packages que l'on utilise pour programmer. 
      Par exemple le package java.lang.* est automatiquement charg&eacute;. Il 
      permet d'utiliser les fonctions System etc.<br>
      Donc un package c'est un ensemble de classes. Le symbole &eacute;toile de 
      java.lang.* signifie que l'on prend toutes les classes du package java.lang.<br>
      Il est bien &eacute;videmment possible de cr&eacute;er ses propres packages 
      mais l&agrave; encore il y a des r&egrave;gles &agrave; respecter : Si on 
      veut cr&eacute;er un package MonPackage il faut d'abord cr&eacute;er un 
      r&eacute;pertoire du m&ecirc;me nom et y mettre les classes du package. 
      Ensuite il faut que les classes commencent par la ligne package MonPackage; 
      pour d&eacute;clarer la classe comme partie du package.</font></p>
    <p align="left"><font size="2">Les avantages : tout simplement la possibilit&eacute; 
      d'utiliser ses librairies personnels. Ainsi si on veut utiliser ses classes 
      perso on mettra dans notre programme : import MonPackage.*;<br>
      J'ai aussi parl&eacute; aussi d'afinit&eacute; et non sans raison puisque 
      les acc&egrave;s friendly et protected se basent sur les relations inter-classes. 
      En gros un package c'est un groupe de potes qui se connaissent bien, ils 
      se d&eacute;pannent quand ils sont dans la merde... Ils s'&eacute;changent 
      donc plus facilement les donn&eacute;es que deux classes &eacute;trang&egrave;res.<br>
      <img src="../media/potekro.gif" width="57" height="28"></font></p>
    <p align="left"><font size="2">Au niveau du compilateur : le compilateur recherche 
      le r&eacute;pertoire qui porte exactement le m&ecirc;me nom que le package. 
      Il regarde dans les librairies standart de Java, dans le r&eacute;pertoire 
      courant et dans les r&eacute;pertoires fix&eacute;s dans la variable $CLASSPATH. 
      Personnellement je ne l'ai pas fix&eacute; sous Linux car je met tout dans 
      le m&ecirc;me r&eacute;pertoire.</font></p>
    <p align="left"><font size="2">On reprend le travail avec nos classes habituelles 
      :<br>
      ---------------animal.java-------------<br>
      <font color="#FFFFFF">package p1;<br>
      class animal{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;protected int age;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int poids;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;String nom;<br>
      }</font><br>
      ------------fin animal.java----------</font></p>
    <p align="left"><font size="2">-----------kangourou.java----------<br>
      <font color="#FFFFFF">package p1;<br>
      class kangourou extends animal{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int longueur_de_saut;<br>
      }</font><br>
      ---------fin kangourou.java--------</font></p>
    <p align="left"><font size="2">--------------prog.java---------------<br>
      <font color="#FFFFFF">import p1.*;<br>
      public class prog{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;animal inconu;<br>
      <br>
      </font></font><font size="2" color="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;prog()<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inconu 
      = new animal();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inconu.age=5;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(Exception ex){System.out.println(ex);}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static void main(String []args)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prog p=new prog();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</font><font size="2"><br>
      ----------fin prog.java-------------</font></p>
    <p align="left"><font size="2">D&eacute;j&agrave; vous constatez que on a 
      une classe d&eacute;vou&eacute; &agrave; l'ex&eacute;cution du programme 
      ; c'est bien plus 'propre' niveau programmation. Comme &ccedil;a nos classes 
      animal et kangourou sont totalement ind&eacute;pendantes et on pourra les 
      r&eacute;utiliser quand on le voudra.<br>
      Les classes animal et kangourou font partie du package p1. Les fichiers 
      animal.java et kangourou.java se trouvent dans le r&eacute;pertoire p1 (qui 
      se trouve dans mon r&eacute;p courant). prog.java est dans le rep courant.</font></p>
    <p align="left"><font size="2">Quand on compile on a :</font></p>
    <pre align="left"><font size="2" color="#00FF00">prog.java:4: p1.animal is not public in p1; cannot be accessed from outside package
	animal inconu;
        ^
prog.java:11: p1.animal is not public in p1; cannot be accessed from outside package
			inconu = new animal();
                                     ^
prog.java:11: animal() is not public in p1.animal; cannot be accessed from outside package
			inconu = new animal();
                                 ^
prog.java:13: age has protected access in p1.animal
			inconu.age=5;
                              ^
4 errors</font>
</pre>
    <p><font size="2">Normal puisque on a pas d&eacute;clar&eacute; nos classes 
      comme public. Il faut mettre public class animal...<br>
      On va passer &agrave; une autre page car celle-ci est pas mal remplie.</font></p>
    <p><font size="2">Mais avant on va revoir tr&egrave;s rapidement ce que on 
      a vu et on va ajouter quelques truc :<br>
      Une classe est une description g&eacute;n&eacute;rique. Elle d&eacute;crit 
      un 'type'.<br>
      Une instance d'une classe est un 'objet'. Chaque objet a son existence propre 
      cependant ils peuvent avoir des valeurs communes que l'on d&eacute;clare 
      par static.<br>
      Pour cr&eacute;er un objet (une instance) on utilise la fonction new().<br>
      Une classe doit se trouver dans un fichier java du m&ecirc;me nom.<br>
      Par convention le nom d'une classe commence par une majuscule (et le nom 
      du fichier .java aussi par cons&eacute;quent).<br>
      En POO une variable est appel&eacute;e un 'attibut' et une fonction est 
      appel&eacute;e une 'm&eacute;thode'.<br>
      Par convention toujours, les noms des attributs et des m&eacute;thodes commencent 
      par une minuscules.<br>
      Il y a 4 types d'acc&egrave;s : private (accessible seulement par l'objet 
      lui m&ecirc;me), friendly (par d&eacute;faut), protected (accessible si 
      dans la m&ecirc;me 'famille') et public (accessible par tous).<br>
      La notion de packages permet de cr&eacute;er des librairies et/ou de faire 
      un syst&egrave;me d'affinit&eacute;.<br>
      La fonction principale a toujours le m&ecirc;me profil : public static void 
      main(String []args).</font></p>
    <p><font size="2">Pour ce qui est des conventions, des fois je les respecte 
      des fois non...<br>
      Je viens de voir que j'ai oubli&eacute; quelques concepts importants, on 
      y go.</font></p>
  </div>
</div>
 
</body>
</html>
