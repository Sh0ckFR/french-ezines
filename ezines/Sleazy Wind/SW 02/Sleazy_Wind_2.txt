% pwd
/users/bclinton

% ls
Archives               Mail                  mailing.lists
News                   bin                   src

% ls -a
Archives               Mail                  mailing.lists
News                   bin                   src
.Sleazy_Wind_1.txt     .Sleazy_Wind_2.txt

% more .Sleazy_Wind_2.txt
Can't read file (need root access)

% su
Password :

$ more .Sleazy_Wind_2.txt



/SSSSS                                        WW          WW
\SS       LL    EEEE   AA   ZZZZ  Y YY         WW   /\   WW    II  NNN  N  DDDD
 \SS      LL    EE_   AAAA    Z    YY           WW /WW\ WW     II  NNNN N  DD DD
  SS\     LL    EE    A__A   Z     Y             WWWWWWWW      II  NN NNN  DD DD
   SS\    LLLL  EEEE  A  A  ZZZZ  Y               WW  WW       II  NN  NN  DDDD
SSSSS/                                             W  W

							NEUMBEUR THOU
                                              http://members.xoom.com/SleazyWind/

<MadDany>Ca y est on l'a remporté notre prix pour le logo. Par contre BlueBird.... désolé c pas grave.... ça doit être le VOTE FOR ME qui allait pas.... ;)
<BluebirD>grmllll :o)



*** £~(%-$ù'*(-}'*($-#
<MadDany> Tout le staff a fait un rush ces derniers jours pour que le zine puisse paraître dans les temps, càd pour cette date symbolique du 1er Janvier 2000 donc bonne année à tous !!! J'espère que ce nouveau numéro vous plaira car il a demandé à tout le monde des efforts considérables, alors bonne lecture et bon tout ce que vous voulez ! :)

Je tiens à remercier tous ceux qui nous ont écrits (ils se reconnaîtront ;) et ont aimé notre premier zine, et surtout qui nous ont motivés pour écrire ce deuxième zine (parce que mine de rien c'est super long). Et je tiens en particulier à rendre un hommage à une personne que l'on a tendance à oublier, l'inventeur du CD. Parce que les CD c'est bien ! D'abord c'est joli, en générale y a une jolie étiquette d'un côté, et ça fait des reflets partout ambiance disco de l'autre. On peut l'utiliser pour décorer son sapin de noël ou ses chaussures par exemple, l'été on peut s'amuser au frisbee avec ou se faire un pendentif en passant une ficelle par le trou. Et pis accessoirement on peut aussi le mettre dans un lecteur de CD et alors là c'est la classe parce que vous pouvez LIRE ce qu'il y a sur le cd. Je tiens donc à rendre un hommage spécial à l'inventeur du lecteur de CD parce que le frisbee et la déco disco ça va un moment mais après c quand même un peu chiant. 
<Zero-cooL>je tiens également à rendre hommage à tous les blaireaux qui ont chié dans leurs frocs pour le soit disant bogue du siècle qui me fait bien pitié
<MadDany>alors là je suis pas d'accord avec toi, le bug ça existe, pour les vieilles applications qui utilisent les dates complètes ça peut générer des erreurs imprévisibles et ça c'est indéniable.

Et alors là attention planquez vous les alminches le staff de Sleazy Wind s'est agrandi de 50 % ce qui fait qu'on est... 3 ! ;) Bienvenue donc à Zero-cooL (dont vous avez pu admirer l'intervention un peu plus haut) parmi nous !

<Zero-cooL>merci merci pour vos acclamations
<MadDany>de rien de rien :)

Sommaire de ce numéro : (ben ouais on va pas remettre le sommaire du numéro précédent quoi)
1/Le bios, de Zero-cooL
2/Tcp/ip, de BlueBird
3/Les réseaux, de MadDany
*** FIN DU £~(%-$ù'*(-}'*($-#






            ------------------------------------------------------------------------------------

LE BIOS   par Zero-cooL

Avant toutes choses je pense que les personnes expérimentées peuvent sauter le premier paragraphe même si quelques révisions ne peuvent faire de mal à personnes. Pour les novices cela vous permettra d’apprendre quelques termes techniques et de faire un peu d’histoire (je suis sur que ce que j’évoque la même pas la moitié d’entre vous le savait hein bande d’ignorants :o).

            ------------------------------------------------------------------------------------

                                     1°) INTRODUCTION ET GENERALITES

                  
                                                                                                                                      -----------------------
1.1 : rappel historique :
-----------------------
 
A la fin des années 1970, le fabricant de circuit intégrer Intel Corporation conçoit un microprocesseur en deux versions, le 8086 et le 8088. IBM exploite le 8088 pour réaliser un ordinateur personnel professionnel. Son système d’exploitation est réalisé conjointement avec une toute nouvelle entreprise, Microsoft. Il s’articule en deux parties, l’une fixe,  le BIOS, l’autre constituée de fichiers de programmes et d’utilitaires. Ce système d’exploitation est baptisé DOS (Disk operating system, système d’exploitation orienté disque). Ce fut en 1981 qu’IBM présente son PC et son système d’exploitation. Par la suite de nombreuses entreprises décident de fabriquer des ordinateurs similaires et compatibles avec leurs homologues d’IBM. Cela ne pose aucun problème, les constituants sont disponibles librement sur le marché et Microsoft vend volontiers les licences de son système d’exploitation. Seul le BIOS reste domaine réservé d’IBM, dont la politique est de 
ne pas accorder de licences. Pour la concurrence, il importe donc de développer un BIOS qui ne puisse pas être considéré par IBM comme une copie du sien. C’est en 1983 qu la société Compaq Computer Corporation parvient à élaborer un tel BIOS, en collaboration avec une autre entreprise qui avait souhaite conserver l’anonymat. Il n’est pas exclu qu’il s’agisse de Phœnix software Associates. Compaq présente immédiatement un PC fonctionnellement semblable a l’IBM PC XT d’origine. Peu après, Phœnix Technologies propose un ensemble BIOS composé d’un texte source d’un BIOS compatible IBM et d’une version DOS. Des fabricants tels AMI, Award et Mr Bios suivent le mouvement et développent à leur tour un texte source de BIOS compatible IBM. 



----------------
1.2 : Définition : 
----------------

 Le BIOS (pour Basic Input Output System) est le composant primaire d'un PC. Il est responsable de toutes les tâches d'initialisation d'un PC, d'une manière générale, il contrôle toutes les entrées/sorties primaires telles que le clavier, les ports série, parallèle et les différentes cartes (vidéo, son, etc.) par le biais d'interruptions en conjonction avec le CPU (Central Processing Unit). En fait, le BIOS est l'endroit où sont stockées toutes les informations de base concernant la configuration du matériel d'un ordinateur et ce sont les premières informations lues et exigées au démarrage de l'ordinateur (sans BIOS vous êtes très mal !!) . Les informations du BIOS sont emmagasinées dans une puce appelé CMOS (Complementary Metal Oxide Semiconductor) qui est gardée sous alimentation constante par la batterie de sauvegarde (pile ou accumulateur) de l'ordinateur. De cette façon, les informations contenues dans le CMOS restent toujours disponibles même si l'ordinateur est hors tension .



-------------------------------------------
1.3 : fonctionnement général et BIOS flash : 
-------------------------------------------

Lors de l'initialisation du PC, le BIOS va procéder à un certain nombre de tests, afin de déterminer si la configuration et le fonctionnement du PC sont corrects. Le plus visible est le test de mémoire RAM (Random Access Memory) qui s'affiche sous forme de décompte en haut de l'écran. En fait, le BIOS va pousser ses investigations beaucoup plus loin et tester la plupart des composants. En cas d'erreur, un message est affiché ou, si cela n'est pas possible, un certain nombre de bips vont permettre de déterminer le type de problème. La signification des bips est expliquée sur le manuel de votre carte mère car ils diffèrent suivant les constructeurs . Cette procédure est appelée POST ( Power On Self-Test ). De nombreux paramètres d'un bios sont éditables. Cela va des simples préférences (boot sur A ou C, date et heure) à la gestion du " plug & play " en passant par des réglages beaucoup plus fins et plus complexes comme la gestion de la RAM. Puisque ces paramètres doivent être modifiés facilement, ils sont stockés dans une petite mémoire de 64 octets : le CMOS. La plupart de ces paramètres sont détectés grâce à l'autodétection du BIOS ce qui soulage largement l'utilisateur. Afin de rendre les mises à jours plus simples de plus en plus de constructeurs de cartes-mères adoptent des BIOS de type flash. Leur nom est issu du fait qu'ils sont stockés dans une mémoire flash, et non dans une simple PROM (Programmable Read Only Memory). Ils peuvent ainsi être mis à jour par logiciel. Auparavant, il était quasi impossible de remplacer un BIOS car la distribution de ce type de circuits se faisait de manière quasi confidentielle (les vilains cachottiers). Désormais, il suffit de se procurer une image du BIOS, sous forme d'un simple fichier binaire, pour updater son BIOS. Une carte-mère disposant d'un BIOS Flash est généralement fournie avec une disquette. Celle-ci contient un utilitaire permettant d'écrire dans la mémoire flash. Si ce n'est pas le cas, avant d'updater un BIOS, il faut être sûr d'avoir choisi une version supportée par votre matériel. Préparer une disquette système saine, ne contenant aucun résident ou gestionnaire de mémoire. Sur celle-ci devra se trouver le logiciel "flasheur" ainsi que le futur Bios. Il se peut qu'il soit nécessaire de désactiver le jumper protégeant en écriture le Bios. Ensuite, il faudra booter sur la disquette précitée et sauvegarder le BIOS actuel. Enfin, un nouveau boot sur cette même disquette permettra de mettre à jour le BIOS. Attention, ne pas tenter ces opérations avec un gestionnaire de mémoire (Himem.sys, ... ) chargé. Si la machine venait à planter pendant l'update, il faut savoir que de nombreuses carte-mères sont capables de restaurer le BIOS à l'aide d'un simple jumper.  
Les BIOS flash disposent de fonctionnalités avancées et jouissent d'une excellente réputation. Un BIOS de type flash peut, en théorie, être agressé par des virus. En effet, sa forme logicielle le met a portée d'une telle menace. Pour éviter ce type de problème, de nombreux constructeurs proposent une protection matérielle contre l'écriture. Elle se présente généralement sous la forme d'un jumper situé sur la carte-mère. 



--------------------
1.4 : accès au bios :
--------------------

Il n'est normalement pas utile d'accéder au BIOS  mais dans le cas contraire il est bon de connaître les différentes techniques spécifiques à chaque BIOS. Les types de BIOS les plus répandus sont les types " AMI ", " AWARD " ou encore " Phoenix ".  Pour accéder à un BIOS AMI ou Award, il suffit d'appuyer sur la touche DEL pendant l'initialisation du PC. Certains BIOS peuvent être appelés par les touches CTRL + ESC ou CTRL + S. Sur les Compaq, la touche F10 est utilisée, lorsqu'un carré blanc clignote en haut à droite de l'écran. Une autre solution consiste à simuler une panne, par exemple en débranchant le clavier. De nombreux BIOS proposeront alors de mettre à jour le CMOS, et laisseront ainsi la possibilité d'y accéder afin d’opérer en toute tranquilité.


Voilà pour toutes les généralités on rentre maintenant dans le "hard" :o)

            ------------------------------------------------------------------------------------

                              2°) DESCRIPTIF DETAILLE D’UN BIOS AWARD  (4.51)



--------------------------
2.1 : Standard Cmos Setup
---------------------------

Date : Permet de régler la date (noonnnnn c’est vrai ????). Le format de la date est <jour>, <mois> <date> <année>
Time : Règle l’heure (putain il est trop bon ce Zero-cooL). Le format de l'heure est <heure>:<minute>:<seconde>. L'heure est calculée sur la base de 24-heures.
Primary Master, Slave, Secondary Master, Slave : Ces catégories identifies les types de disques durs qui ont étés installés dans l'ordinateur. Il y a 46 type prédéfinies et un type définissable par l'utilisateur. Les types 1 à 46 sont prédéfinis, le type "User" est définissable par l'utilisateur. Le type "User" est quasiment toujours utilisé. 
Si vous utilisez le type "User" vous devrez connaitre et entrer les informations ci dessous : 
	Cyls : nombre de cylindre 
	Heads : nombre de têtes 
	Precomp : Précompensation d'ecriture 
	Landz : Zone d'atterissage de la tête 
	Sectors : Nombre de secteurs 
	Mode : Mode de fonctionnement du disque dur 
Ces informations peuvent être entrées automatiquement en utilisant IDE HDD AUTO DETECTION (ce que je vous conseille fortement).
Video : Cette option définit l'écran principal utilisé par la machine. Il faut savoir que dans des cas assez rarissimes, il est possible de brancher SIMULTANEMENT 2 dispositifs d'affichages (avec 2 cartes vidéo et donc 2 écrans), il faut alors indiquer à l'ordinateur quel est l'écran qui sera utilisé comme écran primaire. 
En général, Les valeurs possibles pour cette option sont :
	Mono pour un écran graphique monochrome (norme Hercules) ou MDA pour un écran de type Texte monochrome 
	CGA ( 40 ou 80 ) pour un écran graphique 4 couleurs (norme CGA) 
	EGA/VGA pour un écran graphique couleur (norme VGA ou mieux). C'est la valeur la plus utilisée de nos jours puisque les ordinateurs actuels ont au minimum une carte VGA. On peut utiliser avec cette option les adaptateurs EGA, VGA, SEGA ou PGA. 
Drive A/B : La catégorie identifie le type de lecteur de disquettes A ou B qui ont étés installés dans l'ordinateur 
	None : pas de lecteur de disquette 
	360K, 5.25 in : Lecteur 5"1/4 double densité 
	1.2M, 5.25 in : Lecteur 5"1/4 haute densité 
	720K, 3.5 in : Lecteur 3"1/2 double densité 
	1.44M, 3.5 in : Lecteur 3"1/2 haute densité 

Error/Halt : La catégorie determine quand l'ordinateur s'arretera si une erreur est détectée durant la mise en route 
	No errors : Pas d'arrêt 
	All errors : Arrêt sur toutes les erreurs 
	All, but keyboard : Arrêt sur toutes les erreurs, sauf erreur clavier 
	All but diskette : Arrêt sur toutes les erreurs, sauf erreur disquette 
	All but disk / Key : Arrêt sur toutes les erreurs, sauf erreur clavier et disquette 



--------------------------
2.2 : Bios Feature Setup
--------------------------

Virus Warning : Quand cette fonction est activée, le Bios Award protégera le secteur de boot et la table de partition du disque dur contre toute tentative de modification. Lors de toute tentative, le BIOS arrêtera le système et un message d'erreur apparaîtra. Attention, de fausse alarme peuvent être causées par des programmes de diagnostics, de formatage ou de partitionnage. (Il est fortement déconseillé d’activer cette option car elle provoque de graves conflits avec windows 95/98 lors d’une réinstallation).

CPU Internal Cache / CPU External Cache : Active ou non la mémoire cache intégré dans le CPU, autre nom: mémoire cache de 1er niveau. Seuls les 486 et au dessus disposent de cette mémoire donc à désactiver avec les 386 (mais qui en possède encore un de nos jours ?) et à activer pour les 486 et plus. Si on sélectionne cette mémoire en son absence, le système "plantera". 

Quick Power on Self Test : Cette catégorie accélère les tests automatiques lors de l'allumage de votre machine. Lors de l'activation de cette catégorie, le BIOS raccourci ou saute certain tests si Enabled : tests de démarrage limité au décompte de la mémoire donc plus Disabled : test complet de démarrage, décompte et test de la mémoire et du reste du système

Boot Sequence : Cette catégorie détermine quel sera le premier lecteur où chercher le système d'exploitation C, A: séquence de boot d'abord sur le disque dur C puis sur le lecteur de disquette A. Il est recommandé de le 
régler comme ceci : A,C: séquence de boot d'abord sur le lecteur de disquette A puis sur le disque dur C

Swap Floppy Drive : Permet d'échanger le lecteur de disquette A avec le lecteur de disquette B : Utile pour éviter l'échange manuel des connections de la nappe FDD (nappe qui permet de connecter les lecteurs de disquettes). La permutation est logicielle. On peut obtenir le même résultat en inversant les lecteurs sur la nappe qui les relient au contrôleur. Disabled: l'ordre des connexions sur la nappe FDD est respecté: 1er lecteur = A, 2e lecteur = B .

Boot Up Floppy Seek : Pendant le POST, le BIOS détermine si l'unité de disquette installée possède 40 ou 80 pistes. Il y a 40 pistes pour le type 360 K, et 80 pistes pour les types 720 K, 1,2 M et 1,44 M. Enabled: recherche et test des lecteurs de disquettes au démarrage (diode des lecteurs clignote au démarrage) Disabled: aucun test de la présence des lecteurs de disquettes au boot . Plus rapide et silencieux !

Boot Up Numlock Status : On: active le verrouillage numérique du pavé numérique du clavier dès le démarrage du système Off: désactive le verrouillage numérique du clavier au démarrage

Boot Up System Speed :  High: au démarrage, le CPU fonctionne à sa vitesse la plus élevée (mode Turbo)  Low : au démarrage, le CPU est à la vitesse lente (utile en cas de conflits matériels ou lorsque la vitesse du bus est trop élevée pour certaine cartes)

Gate A20 Option : La ligne A20 (Option signal A20) fait référence aux premiers 64 Ko de la mémoire étendue ( lignes AO à A19 ) ou "mémoire haute". Cette option permet à la ligne A20, qui est supportée par certains chipsets, d'accéder à la mémoire au-dessus de 1 Mo ( 220 bit = 1048576 Ko ) En principe, les accès mémoire supérieurs à cette limite sont gérés par le contrôleur clavier ( 8042 ou 8742 ). En activant cette option ( réglage enabled ), l'accès est plus rapide. Toutefois, certains programmes (des logiciels de backup, par exemple) ne supportent pas enabled. 

IDE HDD Block Mode : Enable : transferts rapides avec le disk dur par l'intermédiaire de gros blocs de données (le HD doit être un EIDE mais qui n’en a pas un aujourd’hui)  Disable: transferts en mode traditionnel avec le DD (en cas de conflits ou de HD anciens).

Typematic Rate Setting : Enable : active la personnalisation de la vitesse de répétition des touches du clavier grâce aux 2 options qui suivent. Disable : laisse le clavier avec comportement de répétition des touches standard 

Typematic Rate (Chars/ Sec) Valeurs permettant de régler la vitesse de répétition des touches, les valeurs numérique sont comprisent entre 6 et 30 caractères / seconde (tout dépend de votre vitesse de frappe).

Typematic Delay (msec) : Temps en millisecondes après lequel la répétition de la touche qui est restée enfoncée se déclenche. Valeurs entre 250 et 1000 ms

Security Option (Password) : Moment d'activation du mot de passe. Le mot de passe, s'il existe (voir sections Password), est demandé soit avec l'option : Setup: Permet simplement d'accéder au SETUP, au moment de l'appel du SETUP. C'est le mot de passe SUPERVISOR PASSWORD qui est demandé. System: Un mot de passe sera systématiquement demandé à chaque démarrage, afin de pouvoir utiliser la machine sinon pas de boot. C'est le mot de passe USER PASSWORD qui est demandé. Remarque: Si aucun mot de passe n'existe dans les sections Password, aucune demande de mot de passe n'est faite. ATTENTION : NE PAS OUBLIER LES MOTS DE PASSE !! (en cas d’oubli voir dans le 3°) )

OS/2 Onboard Memory > 64Mo  : Enabled : active la gestion de la RAM spécifique compatible avec OS/2 lorsque il y a plus de 64Mo installés Disabled: pas de gestion spécifique OS/2 (pas d'OS/2 installé) ou (OS/2 installé et RAM < 64Mo).En fait cette option permettait simplement de corriger une mauvaise gestion de la RAM par OS/2 aujourd'hui ce problème est corrigé.

PCI VGA Palette Snoop Type carte VGA PCI : Doit être activée s'il y a une carte MPEG installée dans le système et désactivée dans les autres cas. Cette option permet de contrôler la façon dont une carte graphique MPEG PCI peut espionner les cycles d'écriture dans les registres de la palette couleur d'une carte vidéo VGA ISA.

Video BIOS Shadow : Enabled: permet la recopie de la ROM contenant le BIOS vidéo dans la RAM pour accélérer les affichages(à activer dans la plupart des cas de figures). (shadowing des 64Ko situés à partir de l'adresse C0000)  Disabled: interdit la recopie du BIOS vidéo en RAM (problèmes de carte vidéo)

XXXX-XXXX Shadow : Enabled: permet la recopie de la zone ROM située à l'adresse XXXX - XXXX dans la RAM pour accélérer les accès. (shadowing de certaines cartes d'extension explicitement demandé) Disabled: interdit la recopie ROM spécifiée en RAM (absences de cartes d'extensions ou shadowing non significatif)  Les valeurs XXXXX-XXXXX sont en général: C8000-CBFFF, CC000-CCFFF, D0000-D3FFF,D4000-D7FFF, D8000-DB000, DC000-DFFFF (ceci peut servir pour certains périphériques : cartes scsi, modems)



---------------------------
2.3 : Chipset Feature setup
---------------------------

DRAM RAS#  Precharge Time :Détermine le nombre de cycle d'horloge alloué au Row Address Strobe avant le rafraîchissement de la mémoire vive. Si un temps insuffisant est alloué les données peuvent être perdues. 

DRAM R/W Leadoff Timing : Règle le nombre de cycle d'horloge avant la lecture et l'écriture dans la mémoire vive. 

DRAM RAS to CAS Delay : Lors du rafraîchissement de la mémoire les lignes et les colonnes sont adressées séparément. Cette catégorie détermine le nombre de cycle d'horloge nécessaire à la transition entre l'adressage des lignes (RAS) et l'adressage des colonnes (CAS) . 

DRAM Read Burst Timing : Cette catégorie détermine la vitesse de lecture en mode rafale sur la mémoire vive. Plus les chiffres sont bas, plus vite le système adressera la mémoire rapidement.  

DRAM Write Burst Timing : Cette catégorie détermine la vitesse d'écriture en mode rafale sur la mémoire vive. Plus les chiffres sont bas, plus le système adressera la mémoire rapidement. 

PCI Bursting : Le bus PCI peut utiliser un mode qui permet de transmettre les données en mode rafale. Cette entrée permet d'activer ce mode. 

PCI Concurrency :Permet d'activer plus d'un périphérique PCI à la fois. 

PCI Streaming : Permet la transmission des données sur le bus PCI sans l'intervention du microprocesseur. 

8 Bit I/O Recovery Time : Permet de régler le nombre de cycle d'horloge pendant lesquels le système attendra la fin d'une requête d'entrée/sortie en 8 bits. 

16 Bit I/O Recovery Time : Permet de régler le nombre de cycle d'horloge pendant lesquels le système attendra la fin d'une requête d'entrée/sortie en 16bits. 

System Bios Cacheable : Cette fonction permet la mise en antémémoire (mémoire cache) des accès à la ROM système. 

Video Bios Cacheable : Cette fonction permet la mise en antémémoire (mémoire cache) des accès à la ROM vidéo. 

IDE HDD Block Mode : Cette fonction permet au contrôleur de votre disque dur d'utiliser le "fast block mode" pour accélérer le transfert des données entre votre disque dur et la carte mère. 

IDE PIO : Les contrôleurs de disque dur EIDE peuvent supporter jusqu'à 4 disques dur séparés; 2 sur le bus primaire, 2 sur le bus secondaire. Sur chacun des bus, les 2 disques dur fonctionnent avec une relation Maître / Esclave.

PIO signifie Programmed Input Output. Plutôt que d'avoir une série de commande du BIOS pour effectuer un transfert entre disques dur et carte mère, le PIO autorise le BIOS à signifier au contrôleur ce dont il a besoin. Le contrôleur et le CPU gèrent alors complètement la tâche d'eux mêmes. Ceci est plus simple, plus efficace et plus rapide. Votre système supporte 5 modes, numérotés de 0 à 4. Quand Auto est sélectionné, le BIOS choisira le meilleur mode automatiquement. 

On-Chip PCI IDE : Comme indiqué ci dessus, votre système inclus deux contrôleurs IDE qui opère tous deux sur le bus PCI. Ces deux lignes vous permettent d'activer ou de désactiver ces contrôleurs pour  en rajouter un autre plus spécialisé ou plus performant. 

PCI Slot IDE 2nd Channel : Ceci vous permet de désigner une carte contrôleur IDE PCI comme votre contrôleur IDE secondaire. 

On board FDD Controleur : Permet d'activer ou de désactiver le contrôleur de disquette intégré à votre carte mère. 

On Board Parallel Mode : Permet de spécifier le mode de fonctionnement de votre port parallèle : Mode standard (SPP) ou mode amélioré, plus rapide et bidirectionnel (EPP/ECP) 

On Board Parallel Port :Permet de désactiver ou d'activer le port parallèle de votre carte mère. Vous pouvez aussi spécifier l'adresse de base de celui ci. 

On board Serial Port : Permet de désactiver ou d'activer les ports série de votre carte mère. Vous pouvez aussi spécifier le numéro de ceux ci. 



-----------------------------
2.4 : PCI configuration setup
-----------------------------

Slot x Using INT# : Certains périphériques PCI utilisent une, voire plusieurs interruptions, pour signaler qu'ils ont besoin d'utiliser le bus ; certains autres périphériques n'en ont pas besoin. 
Auto autorise le contrôleur PCI à allouer automatiquement les interruptions.
INT#A - INT#D signifie que le périphérique nécessite de 1 à 4 interruptions pour fonctionner. 
1st/2nd/3rd/4th Available IRQ : Permet de spécifier quelles seront les IRQ utilisables par les périphériques du bus PCI. 
PCI IRQ Activated by : Détermine la manière dont le bus PCI reconnaît la demande d'IRQ par un périphérique. Ne changez pas cette configuration, à moins que ce soit spécifié dans la documentation d'un périphérique. 
PCI IDE IRQ Map to : Cette catégorie permet de configurer le type de contrôleur IDE utilisé (PCI ou ISA). Si vous avez un contrôleur IDE sur un slot PCI, vous pouvez indiquer ici quel slot est utilisé et quel INT# est associée.  



--------------------------
2.5 : Load Setup Default
--------------------------

Cette fonction règle tous les paramètres pour une utilisation optimale. Si votre micro ordinateur n'a pas l'air de vouloir fonctionner correctement avec ces réglages, vous pouvez, à l'interieur de chaque page, utiliser le "Load Bios Default" qui règle les paramètres pour une sécurité maximale de fonctionnement, mais avec des performances inférieures. 



-----------------------
2.6 : Password Setting
-----------------------

Permet de spécifier le mot de passe qui sera demandé, soit à l'allumage de la machine, soit lors de la modification du setup.



------------------------------
2.7 : IDE HDD autodetection
------------------------------

Permet de détecter automatiquement les disques durs connectés sur les contrôleurs primaire et secondaire. 


Et c’est fini pour le descriptif des principales fonctions d’un BIOS AWARD (je pense que la majorité des PC français sont équipés d’un bios AWARD je n’est donc pas jugé nécessaire de faire le descriptif d’un BIOS AMI).
<MadDany> arf moi j’ai un bios ami... ;(

            ------------------------------------------------------------------------------------

                                          3°)CONCLUSION

Voilà c’est tout pour cet article. La prochaine fois je pense détailler le coté optimisation et overcloking à partir du bios. Si vous avez des remarques, des conseils, des suggestions, des chèques merci de m’écrire à : zerocooll@youpy.fr
De plus je pense intégrer certains utilitaires dans le site de SW afin que vous puissiez bidouiller à souhait bande de veinards !!
A voir bientôt sur : http://members.xoom.com/SleazyWind
                                                                                                                                                                                                         by Zero-cooL©
                                                                                                                                                                                                           1999-2000
                                                                                                                                                                                                       for SleazyWind nø2
 
 
 -------------------------------------------------------------------------------------


/SSSSS                                        WW          WW
\SS       LL    EEEE   AA   ZZZZ  Y YY         WW   /\   WW    II  NNN  N  DDDD
 \SS      LL    EE_   AAAA    Z    YY           WW /WW\ WW     II  NNNN N  DD DD
  SS\     LL    EE    A__A   Z     Y             WWWWWWWW      II  NN NNN  DD DD
   SS\    LLLL  EEEE  A  A  ZZZZ  Y               WW  WW       II  NN  NN  DDDD
SSSSS/                                             W  W

							NEUMBEUR THOU
                                              http://members.xoom.com/SleazyWind/


---------------------------------------------------------------------------------------


 ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ
 ÑÑ************T___C___P***************I___P************ÑÑ
 ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ

         _____:::::=====[Le Reseau Tcp/Ip]=====:::::_____
                             P A R
                      B L U E    B I R D



 1/ Le TCP/IP c'est quoi ?
 ~~~~~~~~~~~~~~~~~~~~~~~~~

 <MadDany>Cui cui les carottes volent bas.... hihihi je suis déjà en train de lui fouttre le souk alors qu'il a  même pas commencé son article... c pas permis ça...  :o) 

 <Zero-cooL>moi je le respecte bluebird rien que son pseudo si tu traduis ca veut dire oiseau bleu :o)))

 <MadDany>ah bon ? putain je suis sur le cul là, on me dit jamais rien à moi... j'ai du passer pour le roi des   andouilles ;)

 <Bluebird>Le TCP IP est un protocole reseau securise. Comprendre securise, car les
 problemes de transmission de donnees (morceau de donnee manquant, etc...)
 sont theoriquement impossible. Theoriquement, car nous allons le voir tout
 a l'heure.
       


 2/ Ca marche comment le TCP/IP ?
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Une connexion TCP/IP se fait en trois temps:
 La machine 1 envoie un paquet SYN (SYNchronisation) a la machine 2.
 La machine 2 repond par un paquet SYN (toujours la meme chose) et un paquet
 ACK (ACKnowledgement = agrement, c-a-d que la machine 2 accepte la
 connexion).
 La machine 1 envoie apres la reception des paquets SYN & ACK de la machine 2
 une paquet ACK a la machine 2. La machine 1 indique ainsi a la machine 2
 qu'elle est prete.

 A QUOI SERT UN PAQUET DE SYNCHRONISATION ?
 C'est simple a comprendre: lors d'une connexion avec tcp-ip, pour eviter
 les pertes de donnees, chaque "morceau" de donnee (tcp/ip fragmente les
 informations envoyees a travers le reseau) a son numero propre. Le premier
 paquet est en general le paquet nø 0, meme pour si des raisons de securite
 il devrait etre aleatoire. Ainsi, si la machine 2 ne recoit que 674 paquets
 sur les 675 que lui envoyait la machine 1, elle va automatiquement aller
 regarder quel paquet il lui manque (par exemple le paquet 675), et va
 demander a la machine 1 de lui reenvoyer le paquet numero 675.
 TCP/IP utilise aussi les nø de paquets pour reconstituer les fichiers, pour
 remettre les fragments dans l'ordre.


 
 Formatage des fragments TCP:

 ------------------------------------------------------------------------
 | PORT SOURCE                     | PORT DESTINATION                   |
 |----------------------------------------------------------------------|
 |                   NUMERO     DE     SEQUENCE                         |
 |----------------------------------------------------------------------|
 |                   NUMERO     D'ACQUITTEMENT                          |
 |----------------------------------------------------------------------|
 |DEPLACEMENT|RESERVE  |FLAGS      |      FENETRE                       |
 |----------------------------------------------------------------------|
 |  SOMME DE CONTROLE              |       POINTEUR NECESSAIRE          |
 |----------------------------------------------------------------------|
 |                OPTIONS                       |       Bourrage        |
 |----------------------------------------------------------------------|
 |D E B U T       D E      L A       Z O N E      D E     D O N N E E S |
 |......................................................................|
 |......................................................................|
 |......................................................................|
 |F I N           D E      L A       Z O N E      D E     D O N N E E S |
 |______________________________________________________________________|

 TCP utilise des numeros d'acquittement. Si la machine Y ne recoit pas le
 paquet 675 comme je l'expliqueais plus haut, elle se rend compte qu'il manque
 un paquet, de plus, n'ayant pas recu le 675ieme paquet, elle n'a pas pu
 envoyer d'acquittement, c-a-d qu'elle n'a pas dit a la machine X qu'elle
 avait bien recu le paquet 675. La machine X reenvoye alors automatiquement
 le paquet numero 675.

 Explications des termes inconnus trouves dans le schema de formattage:
 Numero d'acquittement: voir le paragraphe juste au dessous du schema.
 Flags: Ce sont les diferrentes commandes que l'on peut trouver dans
        un paquet TCP. Il existe differents flags (fanions, drapeaux)
        SYN (deja vu) ACK (deja vu) RST (reset, pour recommencer la connexion)
        FIN (indique le début de la fin de la connexion, après avoir reçu un 
        paquet FIN le receveur envoie un ACK et s'attend à ne plus recevoir de
        données) Je n'ai cite ici que les plus courants.
 
 Fenetre: Taille maximale du prochain segment envoye. Disons qu'un ordinateur
          ait une vitesse de connexion de 14 400 bauds, et qu'il dialogue
          avec un ordinateur qui a une vitesse de connexion de 56 000 bauds,
          tcp calculera automatiquement la taille d'un paquet recevable
          entierement avant le depassement du time-out (L'ordinateur recepteur
          a un certain temps pour envoyer un acquittement a l'ordinateur
          expediteur. Une fois ce temps depasse, soit la connexion s'acheve
          automatiquement, dans notre cas le paquet sera tout simplement
          reenvoye.) Donc si le paquet est trop gros, le time-out sera
          depasse et le paquet en question sera reenvoye infiniment. Grace
          a la Fenetre TCP/IP evit ce genre de desagrement. Imaginez-vous en
          train de telecharger un fichier de 60 Mo, et d'un seul coup
          a 5 minutes de la fin du telechargement un des paquets est trop
          grand et la connexion se "reboote". Vous etes repartis pour 5 ou 6
          heures de telechargement :o)


<MadDany> Le timeout est utilisé en programmation pour libérer les connexions gelées sans 
tenir compte du type d'évènement ayant généré cette coupure (fin subite de la connexion à 
une des extrémités, ralentissement de la connexion...). En java les timeouts sont employés
en créant un socket et en appelant la méthode setSoTimeout(int) de ce socket, où int
est un entier défini sur 32 bits. Les timeouts sont pratiques pour les applications clientes
mais vitaux pour les applications serveurs à threads multiples, en effet si un accident interrompt
la connexion entre le client et le serveur et que le serveur croit que le client est tjs
connecté, la connexion risque d'être définitivement bloquée sur le serveur qui se retrouvera
finalement avec des dizaines de connexions gaspillées, avec du gaspillage de la mémoire et
de l'overload en vue pour les grosses applications ou tout simplement de rendre le serveur
obsolète dans les cas de petits proxys n'aceptant que 2 ou 3 connexions simultanées. L'option
timeout permet au serveur de savoir quand libérer la connexion en cas d'accident et ainsi de libérer
ses ressources beaucoup plus efficacement. C'est ce qui se passe par exemple lorsque vous vous 
connectez avec telnet sur un serveur et qu'au bout de 60 secondes d'inactivité en générale la
connexion se termine. Je vous renvoie à l'article "Handling network timeouts" de David Reilly
pour un exemple d'implémentation des timeouts en java.


 Somme de controle: Une sorte de numero d'acquittement.

 Pointeur: C'est la passerelle par laquelle devra passer le prochain paquet envoye.
           Voir l'article sur les reseaux de MadDany.

 Options: Les differentes options.

 <MadDany>Ah ok ! On aurait pas dit hein vu le titre. C'est vrai que "Options" c pas évident... ;)
 <BluebirD> Ben oui je sais que c'etait dur, surtout pour toi qui est atteint par le syndrome
 de Down ...
 <MadDany>Le syndrome de qui ? Putain je suis sur qu'il m'insulte là...

 #"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#
 

 Maintenant, passons a la pratique.
 ----------------------------------

 Pour illustrer les failles du protocole TCP/IP, je vais expliquer la
 derniere attaque du Condor (eh oui, Kevin Mitnick), celle qui lui couta la
 liberte...

 Le 24 decembre 1994, en a peine 10 minutes, Kevin Mitnick s'introduit dans
 le serveur de Tsutomu Shimomura. Utilisation du IP Spoofing et la prediction
 de sequences TCP, sans reniflage.

 SEQUENCE ONE  (premiere approche)
 ------------

 14h09, Kevin commence a interroger une machine du reseau de Tsutomu afin de
 savoir qui est connecte dessus. Il trouve en quelques secondes l'adresse
 du serveur, ainsi qu'un terminal X.




 SEQUENCE TWO  (preparation de l'attaque)
 ------------

 Neuf minutes plus tard, K. sature la file d'attente d'un port du serveur
 avec des SYN, de facon a ne laisser que des connexions a moitie ouverte, ainsi
 le serveur ignorera les paquets SYN/ACK



 SEQUENCE THREE (2de partie)
 --------------

 Il enchaine immediatement en lancant une vingtaine de tentatives de
 connexion sur le terminal, afin de tester le comportement de sa pile TCP/IP,
 et ainsi pouvoir predire les numeros de sequence suivants.



 SEQUENCE FOUR (3eme partie)
 -------------
 
 K. forge un faux paquet SYN, sense venir du serveur et ayant pour
 destination le terminal X. K pense, avec raison, que le terminal fait
 confiance au serveur, et qu'il ne requiert pas de mot de passe en
 provenance de celui-ci.



 SEQUENCE FIVE (4eme partie)
 -------------

 Le terminal repond a la demande de connexion par un paquet SYN/ACK, que le
 serveur, paralyse, ne peut qu'ignorer.



 SEQUENCE SIX (5eme partie)
 ------------

 Mitnick, qui agit alors en aveugle ("the attacker is sitting off in some dark corner 
 of the Internet...", description de cette technique par daemon9 dans phrack), ne recoit 
 pas ce paquet, car l'adresse de retour est celle du serveur, mais il a prepare un faux 
 paquet de reponse (ACK) contenant le numero de sequence qu'il est en mesure de calculer.


 SEQUENCE SEVEN (6eme partie)
 --------------

 La connexion etant etablie, il introduit une commande qui autorise les
 connexions de ce terminal de partout. Puis il met "proprement" fin a cette
 connexion.


 SEQUENCE EIGHT (7eme et derniere partie youpy)
 --------------

 En quelques instants, il libere la file d'attente du serveur grace a une
 serie de paquets RST. Une vingtaines de secondes se sont ecoules depuis
 la "sequence two".

 Apres cela, Kevin Mitnick n'a plus eu qu'a se connecter sur le terminal X,
 celui ci pensant avoir recu du serveur l'ordre de s'ouvrir a toutes les
 connections.


Sources:
-TCP IP, administration de reseau, editions 0'REILLY®©, ecrit par Craig HUNT
et traduit par Eric DUMAS.
-Pirat'mag 



 Pourquoi ca a marche ?????????????
 Explications:
 Kevin Mitnick a FORGE un paquet.
 C'est a dire qu'il en a modifie l'entete, que je remets ici :
 ------------------------------------------------------------------------
 | PORT SOURCE                     | PORT DESTINATION                   |
 |----------------------------------------------------------------------|
 |                   NUMERO     DE     SEQUENCE                         |
 |----------------------------------------------------------------------|
 |                   NUMERO     D'ACQUITTEMENT                          |
 |----------------------------------------------------------------------|
 |DEPLACEMENT|RESERVE  |FLAGS      |      FENETRE                       |
 |----------------------------------------------------------------------|
 |  SOMME DE CONTROLE              |       POINTEUR NECESSAIRE          |
 |----------------------------------------------------------------------|
 |                OPTIONS                       |       Bourrage        |
 |----------------------------------------------------------------------|
 |D E B U T       D E      L A       Z O N E      D E     D O N N E E S |
 |......................................................................|
 |......................................................................|
 |......................................................................|
 |F I N           D E      L A       Z O N E      D E     D O N N E E S |
 |______________________________________________________________________|

 Donc, il a modifie l'entete, pour faire apparaitre, dans port source,
 l'adresse du serveur. Le terminal repond donc au serveur.
 Mais le serveur recoit le paquet de reponse mais n'en tient pas compte,
 etant surcharge de connexions a moitie ouvertes a gerer.
 Mais le terminal ne sait pas que le serveur ne tient pas compte de sa reponse
 Kevin Mitnick reforge alors un autre paquet et se fait passer pour le serveur.
 Le terminal X repond, le serveur recoit la reponse mais ne l'utilise pas, pour
 les memes raisons, ainsi de suite.


<MadDany>Les informations contenues dans ce dossier et dans celui sur les réseaux 
permettront d'écrire un dossier détaillé sur cette technique certainement au prochain
numéro de SW, il faut en effet connaître le fonctionnement de tcp/ip et des réseaux
pour pouvoir la mettre en oeuvre, donc on a une parfaite introduction sans le vouloir :o)



  #"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"
  ################IP SPOOF######################
  #"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"#"

 Ou comment cacher son ip ??????

 Pour eviter de se faire logger ou simplement par amusement, on peut
 vouloir cacher son ip.
 Voici comment faire.
 Il y a plusieurs solutions:



 I/ LES WINGATES
 ---------------

 Les WinGates sont des programmes permettant de splitter (partager) les connexions.
 Ils n'ont pas pour but original de faire du spoofing mais utilises par des petits
 malins ils sont tout de suite beaucoup plus rigolos... :o) 

 Schema d'une connexion sans WinGate
  ________                          _______
 |        |  src:vous,dst:serveur  |       |
 |V O U S |----------------------->|SERVEUR|
 |________|                        |_______|


 La le serveur a logge votre adresse IP, il sait qui vous etes.

 Schema d'une connexion avec un WINGATE :
  ________                          _______                           _______
 |        |  src:vous,dst:wingate  |       | src:wingate,dst:serveur |       |
 |V O U S |----------------------->|WINGATE|------------------------>|SERVEUR|
 |________|                        |_______|                         |_______|


 Cette fois ci c'est le WinGate qui a votre adresse IP, et le serveur a
 l'adresse IP du WinGate.
 En cas d'actions "illicites" sur le serveur, c'est l'ip du wingate qui
 est loggee et pas la votre. Mais vous n'etes pas intouchable pour autant,
 il suffit que le serveur et les responsables du WinGate travaillent
 ensemble et ils retrouveront votre adresse IP.
 Les Wingates sont utilises pour des connexions en FTP, Telnet, et tout
 ce qui est en mode console (meme pour IRC)

 Lors d'une utilisation sur IRC, il est possible que l'on essaye de vous
 nuker ...
 Avec l'utilisation d'une Wingate, un /DNS votrenick ne donnera que
 l'adresse IP de la WinGate.
 Pour utiliser une wingate sur IRC, faites, dans la fenetre "status":
 /server le_wingate PORT
 /quote le-nom-du-serveur-irc PORT
 /quote user nimportequoi nimportequoi nimportequoi@nimportequoi nimportequoi
 /quote nick le-nick-que-vous-voulez
 /quote join la-salle-a-joindre
 Et voila.
 Pour taper du texte allez simplement dans la fenetre de la salle de chat,
 et tapez:
 /quote le-texte-que-vous-voulez

 Et voila.

 (pour plus de détails sur les wingates vous pouvez vous referrer a l'article de 
 MadDany sur les wingates -comme c'est original- paru dans tua003)
Une liste de Wingates est dispo sur le site de Sleazy WInd, dans la rubrique telechergement.

 II/Les proxys
 -------------

 Les proxys fonctionnent comme les wingates, sauf que ceux ci sont utilises
 pour le HTTP, le SMTP, etc... (voir la section sur les proxys de MadDany)


 III/Les petites astuces
 -----------------------

 Sur ICQ, il y a des malins qui installent un crack sur leur version d'ICQ
 afin de pouvoir connaitre votre adresse IP. Mais vous ouvez camoufler votre
 ip sur ICQ, mais la ce n'est pas du vrai spoofing:

 Allez dans ICQ>Preferences>Onglet Connections>cocher "I'm using a permanent
 internet connection" puis "I am behind a Firewall or a Proxy">
 "Firewall Settings" >cocher "I am usinf a SOCKS4 proxy server">cliquer sur
 suite> Dans socks Host, l'ip que vous mettrez sera celle qui s'affichera
 lorsque quelqu'un demandera votre IP au serveur ICQ.
 ATTENTION: en procedant comme ceci vous empechez toute connexion tcp directe entre
 vos correspondants et vous, c-a-d que les messages que vous enverrez et que vous recevrez
 passeront par le serveur ICQ, et qu'il n'y aura pas de possibilité d'envoi de fichiers
 ni de sessions de chat


                  LLL         EEEEEEEEEEEE
                  LLL         EEEEEEEEEEEE
                  LLL         EEE
                  LLL         EEEEEEEEE
                  LLL         EEEEEEEEE
                  LLLLLLLLL   EEE
                  LLLLLLLLL   EEEEEEEEEEEE  M O T    D E   L A    F I N

                  "RAH PUTAIN CA FAIT CHIER LES ASCII !!!!
                   ET PUIS ON DIRAIT PAS MAIS ECRIRE UN DOSSIER
                   SUR LE TCP IP CA CHIE !!!!! :o)"

          ©®Bluebird bluebirdfr@hotmail.com, for SleazyWind nø2, Januar 2000
                                                        All Rights Reserveds


 @…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…
     " I F   Y O U   W A N T   T O    K I L L    A   M A N
       K E E P   C O O L   A N D   F U C K   A   C A T   !! "
 @…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…@…



  _______________
 |/!\ N E W S /!\|
 |_______________|

 Exploit Generator, un prog qui permet de spoofer comme l'a fait Mitnick
 sur le reseau de Tsutomu Shimomura, est dispo sur le site de Sleazy Wind:

 http://members.xoom.com/SleazyWind




 Pour m'envoyer un mail:
 bluebirdfr@hotmail.com

 Merci.
 Ceci conclut mon dossier sur le TCP/IP

 <Zero-cooL>y demande pas de chèques ou de photos la cure de désintoxycation à l'air de fonctionner ;op
 -------------------------------------------------------------------------------------


/SSSSS                                        WW          WW
\SS       LL    EEEE   AA   ZZZZ  Y YY         WW   /\   WW    II  NNN  N  DDDD
 \SS      LL    EE_   AAAA    Z    YY           WW /WW\ WW     II  NNNN N  DD DD
  SS\     LL    EE    A__A   Z     Y             WWWWWWWW      II  NN NNN  DD DD
   SS\    LLLL  EEEE  A  A  ZZZZ  Y               WW  WW       II  NN  NN  DDDD
SSSSS/                                             W  W

							NEUMBEUR THOU
                                              http://members.xoom.com/SleazyWind/


---------------------------------------------------------------------------------------

                         Les réseaux informatiques, by MadDany


                      And on the third day God created networks....



I. CONCEPTS FONDAMENTAUX
____________________________

Note : ce texte s'adresse à des personnes ayant des connaissances générales suffisamment avancées en informatique, càd que je ne passerai pas mon temps à redéfinir ce qu'est un octet ou l'hexadécimal, et que je pars du principe que vous connaissez globalement les différents OS et leur fonctionnement.



***Les différents types de commutation

Il existe 3 types principaux de commutation (manière dont les données sont transférées) : la commutation de circuits, la commutation de messages et la commutation de paquets. 

La commutation de circuits est la première à avoir fait son apparition. Le réseau téléphonique est un exemple de réseau à commutation de circuits. Dans ce cas un réseau un circuit dédié est matérialisé entre les deux utilisateurs, càd qu'aucune autre donnée que les données qu'ils ont à se transmettre ne transiteront par ce circuit tant que la liaison est maintenue, et aucune donnée ne peut être échangée avant la mise en place de ce circuit. De plus si l'échange de données cesse pendent un certain temps, la liaison qui est maintenue reste inutilisée pendant ce même temps. Pour optimiser le débit on peut alors concentrer des communications sur une même liaison. Mais des communications risquent d'avoir à attendre avant de pouvoir émettre, il va alors falloir mettre en place des zones de mémoire qui vont stocker les données en attendant une disponibilité de la liaison. La contrepartie de cette augmentation du débit est une complexification du système. Le schéma suivant montre un exemple de création de circuit sur un réseau à commutation de circuits. 

    \ |                                       (A, B, C... : autocommutateurs)
     +|
   ---A-------------------\                   (--+---+--- : circuit)
      |\                   \
      | +             /----E----
      |  -+---+---+-B/     | 
      |              \     |
      |               +    |
      |                \   |
      |                 +  |
      \                  \ /
   ----C------------------D-----
        \                  +
         \                  \



Un message est une suite de données formant un tout logique : un fichier, le secteur d'un disque... Un réseau à commutation de message est un réseau comportant de nombreux noeuds de commutation. Le message est émis puis transféré de noeud de commutation en noeud de commutation jusqu'au destinataire final. Le message ne peut être transmis au noeud suivant que lorsqu'il est complètement et correctement reçu par le noeud précédent. Voici donc dans le meilleur des cas le temps de transmission total d'un message :

       \   (1)  \        
Noeud1--\========\
         \   (2)  \   (1)  \
Noeud2----\~~~~~~~~\========\
           \        \   (2)  \   (3)  \
Noeud3------\--------\~~~~~~~~\========\---------->
             \        \        \        \       temps

(1) : message en cours d'émission vers le noeud suivant
(2) : message en cours de réception depuis le noeud précédent
(3) : émission du message vers le destinataire

Il faut ajouter à cela les temps d'attente aux noeuds et les délais de propagation. Le problème vient de la fiabilité des transmissions : en moyenne un bit a 10^(-5) chances d'être en erreur lors de la transmission, càd qu'un fichier de 100 000 octets n'a qu'une probabilité de 0.0003 d'être transmis correctement.



La commutation de paquets est une amélioration de la commutation de messages, le principe et la structure sont les mêmes, mais les données de l'utilisateurs ne sont plus transmis sous formes de messages mais de paquets, c'est à dire que les données sont découpées en groupes de données plus petits de longueur définis à l'avance sur l'ordinateur émetteur, ces paquets vont être acheminés de noeud en noeud puis réassemblés pour reconstituer le message d'origine sur l'ordinateur de destination (voir la section sur l'encapsulation plus loin). Autrement dit un réseau à commutation de paquets est un réseau à commutation de messages dont l'unité de transport de base est beaucoup plus petite. Le schéma suivant représente le temps de transmission d'un message constitué de 4 paquets sur un réseau à commutation de paquets.

       \p1\p2\p3\p4\      
Noeud1--\==\==\==\==\
         \  \p1\p2\p3\p4\
Noeud2----\~~\==\==\==\==\
           \  \  \p1\p2\p3\p4\        
Noeud3------\--\~~\==\==\==\==\---------->
             \  \  \  \  \  \  \       temps

Ce schéma montre bien la différence de temps nécessaire pour transmettre un message de même taille sur un réseau à commutation de messages et sur un réseau à commutation de paquets (p1 est reçu par le noeud1, puis l'envoie vers le noeud2 en même temps qu'il reçoit p2 et ainsi de suite). Maintenant que se passe-t-il si un message est reçu en erreur ? Là encore la commutation de paquets surpasse la commutation de messages :

       \   (1)  \        \        
Noeud1--\########\========\                            (commutation de
         \        \        \                              messages)
Noeud2----\--------\~~~~~~~~\========\
           \        \        \        \        \
Noeud3------\--------\--------\~~~~~~~~\========\---------->
             \        \        \        \        \       temps

(1) : message en erreur, il doit être à nouveau renvoyé au noeud pour pouvoir continuer à être transmis


       \p1\p1\p2\p3\p4\      
Noeud1--\##\==\==\==\==\
         \  \  \p1\p2\p3\p4\                           (commutation de
Noeud2----\--\~~\==\==\==\==\                              paquets)
           \  \  \  \p1\p2\p3\p4\        
Noeud3------\--\--\~~\==\==\==\==\---------->
             \  \  \  \  \  \  \  \       temps

A nouveau la différence est flagrante. La présence d'un message en erreur sur le réseau à commutation de messages nécesssite le renvoi de tout un message ce qui peut demander un temps considérable, alors que sur le réseau à commutation de paquets il n'est nécessaire de renvoyer que le paquet en erreur. 

Une fois émis sur le réseau les paquets sont indépendants les uns des autres, ils peuvent emprunter des routes différentes et arriver dans le désordre sans que cela pose de problème. Cela sgnifie aussi qu'ils peuvent être multiplexés temporellement sur une même liaison :

                    _________________
Message p___p2_    |                 |
               \p1_|                 |
                   |      Noeud      |
Message q---q2--q1-|       de        |---q2--q1--r2--p2--r1--p1--->
                   |   commutation   |
                r1_|                 |
Message r___r2_/   |_________________|


Internet avec tcp/ip est l'exemple le plus connu (arf ;) de réseau à commutation de paquets. Les paquets sont indépendant les uns des autres sur le réseau et peuvent évidemment emprunter des routes différentes (voir le section sur le routage plus loin) et être de taille variables. En revanche d'autres protocoles comme X.25 exigent que les paquets soient toujours émis sur la même route, ce qui implique qu'ils arriveront aussi dans l'ordre. Il existe d'autres types de commutations que je ne décrirais pas ici comme la commutation de trames ou la commutation de cellules qui sont des extensions de la commutation de paquets.



***Bases des réseaux informatiques

Le but fondamental d'un réseau informatique est de permettre à un ordinateur d'accéder aux ressources d'une autre machine, ou plus généralement de permettre à ces deux machines de communiquer entre elles. Il existe pour cela de nombreux types de réseaux, que l'on va définir par un réseau physique et un réseau logique. Le réseau physique est ce que vous voyez, câbles, cartes réseaux et ordinateurs, alors que le réseau logique est l'ensemble des normes permettant à ce réseau physique de fonctionner correctement.

La topologie physique d'un réseau est son organisation matérielle. On définit trois types de topologies physiques : en bus, en étoile ou en anneau. Les topologies en bus et en étoile sont généralement utilisées pour des réseaux ethernet alors que la topologie en étoile est plutôt réservée aux réseaux token ring. Les topologies en étoile sont aussi utilisées avec des réseaux FDDI (fiber distributed data interface), qui fonctionnent avec des câbles en fibres optiques.

Les termes que je viens d'employer, ethernet, token ring, FDDI, sont ce qu'on appelle des topologies logiques. Elles ne coexistent jamais sur le même réseau. Par comparaison avec le réseau routier, on pourrait définir les routes et les autoroutes comme le réseau physique et le code de la route serait la topologie logique. 



exemple de topologie en bus (ici 10BASE-2)

   station de       station de       station de
    travail          travail          travail  
       |                |                |
       |                |                |
-----bus---bus---bus---bus---bus---bus---bus---bus----
               |                  |
               |                  |
            serveur          imprimante
                               réseau

Un câble coaxial court d'un ordinateur à l'autre. Ce standard est le plus ancien mais aussi le plus vulnérable : si une des connexions tombe en panne le réseau ne fonctionne plus...


exemple de topologie en étoile (ici 10BASE-T)

   station de       station de
      travail       travail
            \       /
             \     /
              \   /
               hub
              / | \
             /  |  \
            /   |   \
  station de    |    imprimante
     travail    |    réseau
                |
             serveur

Dans ce type de réseau tous les ordinateurs se connectent à un hub (concentrateur), et c'est celui ci qui va gérer les communications entre les machines. Bien plus fiables que les topologies en bus, les topologies en étoile sont aussi plus coûteuses. On peut ici brancher et débrancher des ordinateurs du réseau à volonté sans risquer de le paralyser.



exemple de topologie en anneau

   station de             station de
      travail             travail
            \             /
             \           /
              \_________/
              /         \
             /           \
            |     MAU     |
            |             |
             \           /
              \_________/         
              /    |    \
             /     |     \
            /      |      \
  station de       |       imprimante
     travail       |       réseau
                   |
                serveur

Les topologies en anneau sont pratiquement semblables aux topologies en étoile, à ceci près qu'un MAU (multistation access unit) remplace le hub (MAU est le terme employé par IBM pour désigner les concentrateurs Token Ring). Le MAU gère les communications légèrement différemment mais c'est le même fonctionnement.



***Assimiler les notions de base

Vous avez vu jusqu'à maintenant ce qu'était une topologie physique et une topologie logique. Certains éléments essentiels d'un réseau n'ont pas été abordés, les voici donc :

(Rappel) Les MAU et les hubs sont des concentrateurs sur lesquels viennent se connecter tous les équipements du réseau

Les routeurs et les ponts sont chargés de véhiculer les données entre plusieurs réseaux

Imaginez que vous deviez communiquez avec un japonais alors que vous ne parlez que le français et votre interlocuteur uniquementy le japonais. Forcément ça serait pas évident. Le même problème est rencontré par les ordinateurs, ils doivent parler le même langage. On va pour cela déterminer des protocoles que les ordinateurs utiliseront pour communiquer entre eux sur un réseau. TCP/IP, IPX/SPX, NetBIOS et NetBEUI sont des protocoles (ou plus exactement des suites de protocoles, mais ce n'est pas le sujet abordé ici).



***Les différents types de réseaux

Outre la topologie physique et logique d'un réseau, sa configuration va déterminer de quel type de réseau il s'agit.

-les LAN (local area network) ou réseaux locaux sont généralement semblables aux réseaux proposés sur les schémas précédents. Les ordinateurs sont physiquement très proches, sur un seul site, les LAN sont le type de réseau le plus simple. Il n'est toutefois pas rare de voir des LAN d'entreprise composés de plusieurs centaines ou milliers d'ordinateurs. Les ordinateurs étant reliés directement par des câbles les taux de transfert de données sont très élevés : 10 Mbps en général.

-les MAN (metropolitan area network) sont des LAN qui se sont étendus au-delà de leur site géographique primaire, par exemple entre deux immeubles. La configuration est similaire à celle d'un LAN, mais à un point du réseau on ne pourra pas utiliser le câble classique, il faudra utiliser des moyens particuliers : lignes téléphoniques à haut débit, liaison radio, fibres optiques, laser... Les taux de transfert arrivent généralement à égaler ceux d'un LAN. Comme il s'agit d'un réseau unique, ce n'est pas la peine d'utiliser un routeur. 

-les WAN (wide area network) sont constitués d'un ensemble de MAN et de LAN reliés entre eux par des routeurs. La liaison se fait en générale par le téléphone entre les LAN et les MAN, ce qui implique une baisse énorme de la bande passante : 56 Kbps pour une ligne téléphonique analogique classique. Il est aussi possible de louer une ligne téléphonique T1 (les lignes des opérateurs de télécommunications) qui permettent de réaliser des transferts jusqu'à 1.5 Mbps, mais il va alors falloir débourser quelques milliers de francs par mois....

Voici donc les trois types de réseau de base. Il existe ensuite des nuances peu perceptibles entres LAN, MAN et WAN :

-les CAN (campus area network) sont semblables à des MAN. Ils tiennent leur nom du fait qu'ils sont généralement installés dans des universités. Des ponts et des répéteurs sont utilisés pour relier les différentes parties du réseau entre elles, ce qui fait qu'il apparait de manière très simple à l'utilisateur final (il n'a plus de moyens de savoir si le serveur auquel il se connecte est situé de l'autre côté de la pièce ou à l'autre bout du campus).

-les TAN (tiny area network) sont des petits LAN domestiques constitués de 2 ou 3 ordinateurs. C'est en générale les premiers réseaux que l'on établit, ils constituent un très bon début.



***Le modèle OSI

Un groupe appelé Open Systems Interconnect à créé dans les années 80 un assemblage logique de la structure des réseaux mais leur entreprise n'a pas été courronnée de succès, quasiment aucun composant actuel ne respecte les protocoles OSI. Et pourtant aujourd'hui ce modèle est un véritable pilier de la structure des réseaux, il représente la structure théorique de tout réseau. Ce modèle n'est pas particulièrement complexe et il peut être intéressant à connaître. Voici une représentation fonctionnelle du modèle OSI à 7 couches :

Couche 7            Couche Application       |                   | Couche Application
                                             |                   |
Couche 6            Couche Présentation      |E                 R| Couche Présentation 
                                             |M                 E|
Couche 5            Couche Session           |I                 C| Couche Session
                                             |S                 E|
Couche 4            Couche Transport         |S                 P| Couche Transport
                                             |I                 T|
Couche 3            Couche Réseau            |O                 I| Couche Réseau
                                             |N                 O|
Couche 2            Couche Liens de données  |                  N| Couche Liens de données
                                             |   TRANSMISSION    |
Couche 1            Couche Physique          |___________________| Couche Physique

Au fur et à mesure que l'on s'élève dans les couches OSI le niveau d'abstraction s'accroit. Chaque couche ne communique qu'avec celles de niveau immédiatement inférieur ou supérieur. Plus précisément chaque couche offre un service à la couche supérieure et utilise les services de la couche inférieure. Voici à quoi correspondent les différentes couches : 

Couche 7 : c'est le programme avec lequel interagit l'utilisateur (ftp, telnet...)

Couche 6 : c'est la phase de réécriture des données de manière à ce qu'elles puissent être utilisées par le système de l'ordinateur distant (d'UNIX à MSDOS par exemple)

Couche 5 : c'est la gestion des connexions entre les ordinateurs, elle s'occupe d'encapsuler les données et de les transmettre dans le bon ordre

Couche 4 : l'équivalent du tcp de tcp/ip. Elle s'assure que le destinataire a bien reçu les paquets transmis en surveillant le travail des trois couches qui sont au dessous d'elle. 

Couche 3 : fonctionne de concert avec la couche 2, elle s'occupe d'envoyer les paquets au bon ordinateur sur le réseau. (équivalent de l'ip de tcp/ip)

Couche 2 : c'est un ensemble de règles indiquant comment les paquets doivent être retransmis en trouvant un chemin sur le réseau pour que la couche 1 puisse faire son travail

Couche 1 : correspond aux câbles, hubs et aux autres matériels permettant la transmission physique des données sur le réseau





II. TRANSMISSION DES DONNEES
______________________________

***Encapsulation des données

Avant d'être transmises à d'autres ordinateurs sur un réseau, on dit que les données sont encapsulées, càd qu'elles sont découpées en paquets. Ce mode de transmission est particulièrement important, il permet notamment à plusieurs paquets d'un même flux d'emprunter des routes différentes pour atteindre leur destination. Lors de l'encapsulation des données celles-ci sont scindées en part égales. Puis l'ordinateur compte le nombre de bits qui les composent et leur attribue un numéro qui est inclus au paquet. Ainsi la route qu'empruntent les données n'a aucune importance, une fois toutes arrivées à destination l'ordinateur les assemble à partir des numéros de séquence et d'une checksum (somme de contrôle) pour vérifier que le compte des paquets est bon. Les paquets peuvent être de différentes catégories selon la topologie logique du réseau, on parle de trames Ethernet ou de datagrammes tcp/ip notamment. Cette distinction peut être importante car un datagramme peut être encapsulé dans une trame par exemple. 

Toute information émise sur un réseau est d'abord encapsulée selon le type de réseau et les protocoles utilisés. Dans chaque paquet sont incluses les informations suivantes : 
-l'adresse de retour, càd la source des paquets
-l'adresse de destination permettant le routage des paquets
-un numéro de séquence permettant de vérifier si tel paquet doit être classé avant ou après tel autre



***Règles de transmission des données selon la topologie logique

Les règles de transmission des données sur un réseau dépendent des topologies logiques définies dans la partie précédente. Nous allons donc voir ici plus précisément les particularités et le fonctionnement de chaque topologie logique. Il faut savoir que dans un réseau informatique, un seul ordinateur peut émettre sur un segment donné du réseau.

-Ethernet : Ethernet est fondé sur la norme CSMA/CD (carrier sense multiple access/collision detection). Le segment de réseau que les ordinateurs d'un réseau ethernet se partagent est appelé domaine de collision. Son nom vient du fait que si 2 ordinateurs tentent d'émettre en même temps sur le même domaine il se produit une collision. A ce moment les 2 ordinateurs cessent d'émettre, puis attendent un temps aléatoire avant de recommencer leur transmission, permettant ainsi de réguler le traffic. Mais vous comprenez que si trop d'ordinateurs veulent émettre des données en même temps sur le même domaine de collision il va se produire un véritable embouteillage qui ralentira considérablement le traffic sur cette portion du réseau. C'est une des principales limites d'Ethernet. 
            Ethernet est la topologie la plus répandue pour créer des réseaux. Quand des données sont émises sur le réseau elles sont émises à toutes les machines composant le réseau, bien que l'adresse de destination soit spécifiée dans le header (c'est l'adresse MAC qui est utilisée, l'adresse de la carte réseau). Ainsi toutes les machines reçoivent les paquets mais ne les acceptent que si l'adresse de destination spécifiée est effectivement leur adresse MAC. Ces particularités sont détaillées dans la partie suivante (sécurité).

-Token Ring et FDDI : les réseaux Token Ring sont mis en place sur des topologies en anneau ou en étoile. Sur ce type de réseau, un paquet circule en permanence, on l'appelle le jeton (token). Quand un ordinateur a besoin d'émettre, il attend que le jeton soit disponible, le prend dès que c'est le cas et transmet ses données, puis il libère le jeton pour permettre aux ordinateurs qui attendent toujours de transmettre à nouveau. Ce système permet d'éviter les collisions d'Ethernet mais pose toujours le même problème, si trop d'ordinateurs attendent le jeton le trafic sera énormément ralenti. 

-ATM (asynchronous transfer mode) : c'est une technologie de réseau émergente totalement nouvelle. Elle est censée pouvoir transmettre à la fois la voix ou les données que ce soit sur des câbles en cuivres ou en fibres optiques. Avec ATM les paquets sont appelés cellules et sont scindés tous les 53 octets. ATM définit entre autres une priorité de transmission pour chaque cellule et est notamment capable de router les cellules très rapidement, de 25 à 622 Mbps.



***Adressage IP

Je ne reviens pas sur ce qu'est une adresse IP, je voudrais plutôt aborder ici un problème étrange. On nous répète sans cesse qu'avec la popularité de l'internet, le système d'adressage IPv4 ne suffit plus. Un peu de mathématiques : une adresse IP classique de la forme xxx.xxx.xxx.xxx  comprend quatre octets, donc 32 bits. Soit théoriquement 2^32 adresses différentes (4 294 967 296). Or on est loin d'avoir atteint les 4 milliards d'ordinateurs sur internet. Le problème vient du système de répartition des blocs d'adresses. Pour éclaircir cela voyons plutôt les différents types d'adresses : (X est un octet invariable)

Classe     Préfixe bin.      Format de l'adresse      Nb de bits variables       Nb d'adresses dans le bloc
===========================================================================================================
A          0                 X.xxx.xxx.xxx            24                         16 777 216
B          10                X.X.xxx.xxx              16                         65536
C          110               X.X.X.xxx                8                          256

Si vous avez bien compris ce tableau la situation s'éclaircit. Imaginez qu'une entreprise ait besoin de 100 000 adresses IP réservées, elle va se procurer un bloc d'adresses de classe A pour répondre à ses besoins, gaspillant ainsi plus de 16 millions d'adresses IP qui ne seront jamais utilisées. De même si vous établissez un petit réseau et que vous voulez 10 adresses, vous prendrez un bloc d'adresses de classe C mais vous n'utiliserez que 10 adresses sur la plage de 256 qui vous est allouée. Il est alors facilement compréhensible qu'à cette vitesse les adresses IP soient très vite gâchées.

Pour remédier à cela on voit se profiler à l'horizon la nouvelle génération d'IP : IPv6. Il va certainement falloir vous habituer aux adresses de la forme x:x:x:x:x:x:x:x où chaque x représente un nombre hexadécimal de 16 bits, càd un nombre total d'adresses égal à 65536^8, je vous laisse calculer... Une autre solution a été aussi mise en place, il s'agit de la norme CIDR (classless interdomain routing), elle permet de combiner plusieurs blocs d'adresses de classe C et ainsi d'éviter de gaspiller les adresse IPv4 disponibles. Le problème est que tous les protocoles de routage ne supportent pas CIDR



Une adresse IP est constituée de deux parties : un identificateur de réseau et un identificateur de la machine membre de ce réseau. Pour une adresse de classe A par exemple, le X est l'adresse réseau et les 24 bits variables (xxx.xxx.xxx) constituent l'id machine. Par exemple une adresse de classe C pourrait être 137.58.121.10. L'id réseau de cette adresse est 137.58.121 et son id machine est 10. 

Un id réseau à 0 permet à des machines du même réseau de communiquer entre elles sans avoir à connaître l'adresse réseau réelle. Par exemple 137.58.121.10 veut émetre vers 137.58.121.21 mais en ne connaissant que l'id machine de destination (21). Elle peut donc émettre vers 0.0.0.21.  Il existe ensuite d'autres adresses spécifiques à un réseau, par exemples une adresse dont tous les bits de l'id machine sont à 1 est une adresse de broadcast (diffusion) désignant toutes les machines constitutives de ce réseau (137.58.121.255 désigne donc toutes les machines du réseau d'id 137.58.121). Inversement, un adresse dont tous les bits de l'id machine sont à 0 désigne la machine locale (137.58.121.0 par exemple). Ces concepts sont importants car le routage utilise les id réseaux. 



***Routage

Le routage est la détermination d'un chemin sur un réseau que les paquets devront suivre pour arriver à leur destination finale, les machines effectuant cette détermination sont appelés des routeurs (logique ;). On distingue deux types de routage : le routage direct et le routage indirect. 

Le routage direct est le transfert d'un paquet directement d'une machine à une autre sur un réseau local. La machine émettrice compare sa ou ses adresses réseaux à celle de l'adresse réseau de destination, et si elles sont effectivement égales le paquet est directement remis au destinataire sans intermédiaire. Le routage direct est un cas particulier et intervient toujours en fin de routage. 

Le routage indirect est utilisé pour transmettre des paquets sur un réseau distant, càd que les paquets vont devoir transiter par au moins une passerelle avant d'arriver à leur destination. Il est bien plus complexe que le routage direct car il fait intervenir des tables de routage. Ainsi la machine émettrice détermine que l'adresse réseau est différente de la sienne et transmet le paquet à une passerelle par défaut qui va se charger de déterminer la route pour atteindre la destination grâce à sa table de routage, elle va donc retransmettre le paquet à la passerelle suivante et ainsi de suite jusqu'à ce que le paquet arrive à destination. 

Les tables de routage contiennent les informations relatives aux différentes destinations. Etant donné la taille d'internet les tables de routage ne peuvent pas contenir les informations concernant toutes les destinations possibles, au lieu de celà elles stockent plutôt les adresse réseaux de destination ce qui permet un routage beaucoup plus rapide. Les données sont stockées sous la forme de paires adresse réseau/passerelle de destination (N/G). Ainsi si la machine M de destination a pour adresse réseau N, les paquets seront retransmis vers G. Il est possible pour un routeur possédant une table plutôt réduite de retransmettre les paquets à une passerelle par défaut possédant une table plus complète si ce routeur ne parvient pas à résoudre une requête de routage. Finalement l'algorithme utilisé par les routeurs pour retransmettre les données est : (pseudo-code emprunté à Benoît Boute et Frédéric Kaplan) 

Extraire l'adresse IP destination, Id, du datagramme;
Calculer l'adresse du réseau destination, In;
Si (In correspond à une adresse de réseau directement accessible) {
        envoyer le datagramme vers sa destination sur ce réseau
        (ceci suppose que l'on associe cette adresse In à une
        adresse physique, que l'on encapsule le datagramme
        et que la trame soit émise);
}
sinon {
        Si (Id est une route de machine à machine) 
                router le datagramme conformément aux indications de la table;
        sinon {
                Si (In apparaît dans la table de routage) 
                        router le datagramme selon les indications de la table;
                sinon {
                        Si (une route par défaut existe)
                                router le datagramme vers la passerelle par défaut;
                        sinon
                                déclarer une erreur de routage;
                }
        }
}



Les routeurs permettent de router des paquets sur un réseau local ou vers un réseau distant. Ils utilisent pour cela 4 sets de protocoles : RIP et OSPF pour router sur les réseaux internes et EGP et BGP pour router sur les réseaux externes.

RIP (Routing information protocol) : RIP est dépassé par OSPF. Il inclut une fonction de comptage des sauts effectués par un paquet (hops ou rebonds). Un paquet qui a deja ete route 16 fois est rejeté. La version 2 de RIP supporte CIDR.

OSPF (Open shortest path first) : Il permet de router les paquets sur le chemin le plus rapide, ce qui ne signifie pas forcement qu'il est le plus court. Il permet aussi de detecter les défaillances sur un chemin et de router automatiquement les paquets vers un autre chemin. OSPF supporte CIDR.

EGP (Exterior gateway protocol) : EGP est aujourd'hui trop limité et on lui préfère BGP. De plus EGP ne supporte pas CIDR.

BGP (Border gateway protocol) : BGP repose sur TCP pour s'assurer que les paquets ont été transmis correctement. Il dispose aussi d'une table de routage optimisée ce qui permet d'eviter de gaspiller la bande passante disponible. De plus il détecte automatiquement les défaillances d'une route, ce qui tient de l'exploit vu la taille des tables de routage sur Internet. BGP-4 supporte CIDR.

Plusieurs routeurs peuvent utiliser BGP pour retransmettre les paquets sur un réseau interne, mais cela implique qu'au moins un routeur du réseau implémente RIP ou OSPF. Si ce n'est pas le cas les paquets seront retransmis d'un routeur à l'autre en créant ainsi une boucle infinie qui fait crasher le reseau. 





III. EQUIPEMENTS RESEAUX ET SECURITE 
________________________________________

Ah, enfin... ;^) 

***Switches, hubs et MAU

Egalement appelés hubs ou MAU (voir précedemment), les concentrateurs permettent d'améliorer la fiabilité d'un réseau. Ils peuvent également être utilisées de différentes manières pour segmenter un réseau par exemple. Le fait que les ordinateurs d'un même segment ne puissent émettre en même temps sur un réseau (voir les spécifications ethernet et token ring) peut être assez handicapant, on peut pour cela utiliser des concentrateurs ou des commutateurs (switches). Voici le schéma d'un réseau qui a été segmenté à l'aide de hubs et d'un switch : 



serveur             serveur             routeur 
       \               |               /      \
        \___s2____    s3    _____s4___/        \
                  \    |   /                    \
                   \   |  /                     INTERNET
station de ---s1----switch
travail                |   \
                      s5    \__s6___
                       |            \
station de ___s5_____ hub            hub 
travail               /                 \
                     /                   \ 
                    s5                   s6
station de ________/                       \________ station de 
travail                                              travail


Ce réseau est donc composé de 6 segments : chaque machine reliée à un port dédié du commutateur constitue un seul segment, alors que les machines reliées aux hubs voient ainsi leurs médias partagés en constituant un segment partagé par toutes les machines connectées aux hubs. 



Les commutateurs ont une autre particularité intéressante : ils permettent de créer des VLAN (virtual lan). Imaginez le LAN d'une banque par exemple, il est peu probable que le directeur ait envie que les secrétaires puissent avoir accès aux informations contenues dans son ordinateur et ceux de ses conseillers. A plus forte raison si le réseau est connecté à internet pour que les employés chargés du service client puissent utiliser l'email, des informations sensibles contenues dans son ordinateur sont ainsi exposées à un risque potentiel inutile (nyark ;). A ce moment là on va pouvoir par exemple implémenter la configuration suivante : 

                                       conseiller1
                                         /
                                        /
                                       /
                directeur           hub-----------conseiller2
                     |               |
                 ____|_______________|____
                |    |_______________|    |
                |                         |
secrétaire______|__       switch        __|_______routeur--------INTERNET
                |  \___________________/  |
                |     |         |         |
                |_____|_________|_________|
                      |         |
                      |         |
                 employé1     employé2

(petit exercice : déterminez les différents segments sur ce schéma)


Le réseau est alors constitué de deux LAN isolés l'un par rapport à l'autre : un premier VLAN comprenant le directeur et ses deux conseillers, et un deuxième VLAN constitué des ordinateurs de la secrétaire, des deux employés et du routeur permettant l'accès à internet pour les employés de ce VLAN. Pratiquement, les ordinateurs de chaque VLAN n'ont même pas connaissance de la présence des ordinateurs membres d'autres VLAN. Les ordinateurs du directeur et du conseiller sont ainsi invulnérables à toute attaque venant d'un réseau extérieur à l'entreprise, pour peu que le commutateur ait été correctement configuré (de plus il faut toujours se méfier de sa secrétaire, des fois que ce soit un méchant hacker avec une perruque rousse...).



***Snif snif...

Nous l'avons vu avec les spécifications d'ethernet, les ordinateurs n'acceptent que les paquets dont le header mentionnent leur adresse MAC. Une carte en mode de promiscuité accepte tous les messages sans tenir compte de l'adresse spécifiée dans les headers. Autrement dit si une carte réseau en mode de promiscuité est placée dans un concentrateur ou un ordinateur du réseau elle va capturer tout le traffic de ce réseau et permettre de l'examiner (sniffing rulez ;). 

De nombreux sniffers permettent d'examiner ce traffic et de ne retenir que les paquets répondant à certains critères (contenant le mot login ou password par exemple.... ;). Le risque est évidemment énorme étant donné que par défaut les données sont transmises en clair sur les réseaux ethernet... Une attaque possible peut être par exemple de placer une machine en mode de promiscuité sur un réseau une fois que l'on a obtenu un accès root sur cette machine et d'espionner tranquillement tout ce qui s'y passe.

Il existe une parade à ce mode de promiscuité sur les réseaux ethernet : les hubs actifs. Ces hubs ne transmettent les paquets qu'à l'ordinateur de destination et non plus à tous les ordinateurs du réseau, rendant le mode de promiscuité inefficace. Il est possible d'employer un sniffer sur une macine qui n'est pas en mode de promiscuité, mais on ne pourra alors logger que l'activité de cette seule machine, ce qui peut tout de même être assez intéressant ;).

Cette partie n'est pas détaillée du tout car le but n'est pas de faire un article sur le sniffing, mais on ne peut pas parler des réseaux sans le mentionner. Vous trouverez des textes supplémentaires si vous voulez en apprendre plus dans la zone de téléchargement de notre site.



***Firewalls et proxys

On désigne par firewall tout équipement, matériel ou logiciel, permettant de filtrer l'entrée ou la sortie de paquets sur un réseau local. Ils sont très utilisés en matière de sécurité lorsqu'il s'agit de connecter un réseau local à internet. Ils peuvent être utilisés globalement de deux manières : pour limiter le traffic entrant et ainsi prévenir tout risque d'attaque potentiel, ou alors pour vérifier et restreindre les demandes de connexion du réseau interne vers le réseau distant. 

Dans le cadre de ce dossier je vais décrire les firewalls matériels. Il s'agit en générale d'ordinateurs dédiés à ce rôle, ou alors de routeurs configurés de manière à filtrer les paquets. Un firewall comporte deux cartes réseaux, une qui va être reliée au réseau interne et l'autre qui va le relier au réseau distant. Il pourra par exemple ne transmettre les paquets venant de l'extérieur que si la source est autorisée et authentifiée, empêchant tout individu à la moralité douteuse d'accéder au réseau protégé. 


      RESEAU INTERNE       ||              RESEAU DMZ                ||       RESEAU DISTANT
                           ||                                        ||
                           ||     _______________                    ||
                           ||    |               |                   ||
station de________         ||    |    carte2-----|---------routeur---||------INTERNET
travail           \        ||    |               |                   ||
                   \       ||    |   firewall    |                   ||
                    \      ||    |               |                   ||
station de----------hub ---||----|----carte1     |                   ||
travail              /     ||    |_______________|                   ||
                    /      ||                                        ||
                   /       ||                                        ||
station de________/        ||                                        ||
travail                    ||                                        ||
                           ||                                        ||
                           ||                                        ||



La partie comprenant le firewall est appelée réseau DMZ ou zone démilitarisée. il est aussi possible de n'avoir qu'une partie du réseau interne à protéger, auquel cas la configuration pourrait être la suivante :


ordinateur______                               ______ordinateur
protégé         \                             /      exposé
                 \                           /
                  \                         /
ordinateur--------hub-------firewall-------hub-------routeur-------INTERNET
protégé           /                         \
                 /                           \
                /                             \
ordinateur_____/                               \_____ordinateur
protégé                                              exposé



Un firewall peut être configuré pour ne permettre que certains services, les emails par exemple. Ainsi toute attaque autre qu'une attaque visant le serveur de mail interne est théoriquement impossible. Il peut aussi permettre de rejeter toute demande de connexion extérieure non identifiée, empêchant n'importe qui d'avoir accès au réseau interne; ou bien d'empêcher toute communication vers l'intérieur mais de permettre aux utilisateurs du réseau interne de communiquer librement avec l'extérieur. Ils ont ainsi une fonction primordiale dans la sécurité générale du réseau en fournissant un goulot d'étranglement de toutes les communications vers ou de l'extérieur. Il permet notamment à des réseaux comportant plusieurs dizaines de machines d'être protégés au travers d'une seule machine, ce qui facilite énormément le travail de l'admin réseau et diminue ses chances de commettre des erreurs. Cependant on peut voir la chose différemment, si ce point central du réseau est mis à mal tout le réseau devient alors vulnérable. Secure or not secure, here is  the question....



Les serveurs proxys (ou application gateways) sont des applications permettant l'ip masquerading, càd la dissimulation des adresse ip d'un réseaux interne aux yeux d'un réseau distant en la remplaçant par celle du proxy. Les proxys sont spécifiques à l'application et au protocole utilisés. L'ip masquerading joue aussi un rôle primordial dans la sécurité d'un réseau, si 50 utilisateurs du réseau sont sur internet et visitent un site, le serveur distant ne verra qu'un seul ip connecté et non celui de chaque utilisateur (du point de vue d'un LAN on parle d'ip masquerading, du point de vue d'un particulier comme vous on préfèrera parler de spoofing ;). Il va falloir pour cela configurer le logiciel client de chaque utilisateur du réseau interne pour qu'il envoie ses requêtes non pas directement sur internet mais au proxy. Lorsque le proxy reçoit cette requête il garde en mémoire l'ip de l'ordinateur ayant formulé cette requête puis la retransmet à l'adresse de destination, mais cette fois l'adresse source n'est pas celle de l'ordinateur client mais celle du proxy. L'ordinateur distant renvoie donc la réponse au proxy qui la retransmet à l'ordinateur ayant formulé la requête de départ. 

A nouveau les proxys permettent de concentrer (et surveiller) les requêtes des clients situés sur le réseau interne, ce qui permet de ne pas avoir à protéger chaque ordinateur individuellement. Pour un observateur situé en dehors du réseau, il n'y a qu'un seul ordinateur connecté à internet...

Un serveur proxy implémenté sur un firewall permet d'autoriser à certaines communications de transiter librement par le firewall.

Un réseau implémentant un proxy capturant toutes les requêtes des utilisateurs pourrait ressembler à ça :


station de    station de     station de 
 travail       travail        travail
    |             |              |
    |             |              |
    |             |              |
    |____________hub_____________|        |-------routeur-------INTERNET
                  |                       |
                  |                       |
                  |                       |
                  |-------firewall-------hub
                                          |
                                          |
                                          |
                                        proxy

(petit exercice : déterminez la zone protégée et la zone démilitarisée sur ce schéma)


Il est intéressant de constater à quel point on peut protéger un réseau avec un firewall bien configuré (j'insiste bien là-dessus... "a poorly configured firewall is no firewall at all"). On peut notamment cacher les noms DNS internes à l'extérieur par un jeu de serveurs DNS. Tout d'abord il faut implémenter un serveur DNS sur une machine accessible publiquement (dans la zone DMZ ou une partie non protégée du réseau), ce sera le serveur public qui semblera être votre serveur DNS. En réalité tout ce que ce serveur saura sera ce que vous voulez que l'extérieur sache. Ensuite il faut implémenter un serveur DNS dans une partie non accessible du réseau (derrière le firewall donc), mais ce serveur contiendra les informations normales, ce sera votre vrai serveur alors que la machine publique est une sorte de leurre. Il faut configurer le vrai serveur pour transmettre les requêtes qu'il ne peut résoudre au serveur public. Ensuite il faut configurer tous les clients DNS du réseaux pour qu'ils utilisent le serveur DNS interne, y compris le client sur le serveur public. Le firewall entre les deux serveurs doit bien entendu leur permettre de communiquer entre eux. La configuration peut alors ressembler à ça :


hote interne1_____                                            proxy
                  \                                             |
                   \                                            |
                    \                                           |
hote interne2-------hub-------serveur DNS-------firewall-------hub-------routeur-------INTERNET
                    /          privé                            |
                   /                                            |
                  /                                             |
hote interne3____/                                         serveur DNS
                                                             public


Maintenant voilà ce qui peut se passer si le réseau est configuré correctement :
1.L'hôte interne1 émet une requête DNS à propos de l'hôte interne2, il la transmet au serveur DNS privé et obtient sa réponse
2.L'hôte interne3 (ou le serveur DNS public) émet une requête à propos d'un hôte distant, il la transmet au serveur DNS privé qui la transmet au serveur DNS public, qui la transmet à internet et répond.
3.Un hôte distant émet une requête à propos d'un hôte interne, il la transmet au serveur DNS public qui répond "restricted".

Ceci n'est qu'un exemple de service transitant par un firewall et son utilisation, le but n'est pas ici de faire une liste exhaustive de ces techniques ni d'apprendre à les implémenter. Cet exemple a été inclus car il permet de mieux comprendre l'utilisation des firewalls.



Voili voilou, j'ai terminé mon dossier. M'enfin il est quand même sujet à des modifications dans les numéros à venir parce que je peux pas prétendre tout savoir sur les réseaux, loin de là !

***Références : 
- Les réseaux, Campus Press (couvre globalement les bases)
- Les réseaux, Eyrolles (couvre tout le reste ;)
- The Sniffer FAQ 1.7, Internet Security Systems, Inc.
- Les Firewalls, Trom
- The 411 on Fire Walls, GBoZ Of The Cybernetic Techno Ninjas
- Maximum Security, anonyme
- Le protocole Internet, Benoît Boute et Frédéric Kaplan 
- le rfc 1817, Y. Rekhter

 -------------------------------------------------------------------------------------


Vous pouvez écrire aux rédacteurs de ce zine, à savoir MadDany ,BlueBird et Zerocooll aux adresses suivantes :
MadDany : maddany@multimania.com
BlueBird : bluebirdfr@hotmail.com
Zerocooll: zerocooll@youpy.fr

A venir dans les prochains n° de SW :
- le cracking java
- l'ip spoofing 
- et pis le reste vous verrez bien :) 


***eof


$ shutdown
The system will shut down in 30 seconds...
The system will shut down in 10 seconds...
-