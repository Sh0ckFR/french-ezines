<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Programmation bash -> Part 1</title>
<style type="text/css">
<!--
.Style1 {
	font-size: 18px;
	color: #FF0000;
	font-weight: bold;
}
.Style4 {
	color: #990000;
	font-weight: bold;
}
.Style5 {color: #990000}
.Style6 {color: #990000; font-style: italic; }
-->
</style>
</head>

<body>
<div align="center" class="Style1">
  <p>------------<br>Programmation bash<br>------------</p>
</div>
<p class="Style4"> Introduction : </p>
<p> <span id="misp_compose_1" class="hm">Tos</span> au tard le <span id="misp_compose_2" class="hm">linuxien</span> aura besoin de programmer un <span id="misp_compose_3" class="hm">pti</span> script en <span id="misp_compose_4" class="hm">bash</span> (<span id="misp_compose_5" class="hm">shell</span> script in <span id="misp_compose_6" class="hm">english</span>) pour automatiser des taches ou autre (pour cr&eacute;e ses r&egrave;gles <span id="misp_compose_9" class="hm">iptables</span> a chaque d&eacute;marrage par exemple , ou encore pour effectuer des op&eacute;rations sur des fichiers) enfin tous ce que vous pourrez en trouver comme utilit&eacute; . Dans ce premiers et bref <span id="misp_compose_14" class="hm">tutos</span> nous verrons les bases du <span id="misp_compose_16" class="hm">shell</span> script (on fera des exercices pour que vous ne vous ennuyez pas vous inqui&eacute;tez pas ;)) . </p>
<p> Au programme :&nbsp; <br>
  <br>
  <span class="Style5">I/Connaissance minimale sur un script <span id="misp_compose_2" class="hm">shell</span>&nbsp; </span><br>
  <em>-Cr&eacute;ation d'un shell script et le rendre ex&eacute;cutable<br>
-Structure d'un script bash<br>
-D&eacute;claration et utilisation de variable </em><br><span class="Style5"><br>
II/Poussons un peu le bouchons </span><br>
<em> -Commande de bases<br>
-Variable sp&eacute;ciale<br>
-Structures de contr&ocirc;le (if , <span id="misp_compose_3" class="hm">else</span> et case) <br>
-Boucles (<span id="misp_compose_4" class="hm">while</span> , for) <br>
-Petit exemple <br>

</em><br>
<span class="Style5">III/Allez pour les moins paresseux on continue sur la lancer</span><br>
<em>-Manipulation des param&egrave;tre<br>
-Gestion de signaux<br>
-Un autre petit exemple </em></p>
<p>Allez on est parti ;)</p>
<p><span class="Style4">I/Connaisance minimale sur un script shell : </span></p>
<p class="Style5">&nbsp;&nbsp;&nbsp;1-1/Creation d'un shell script et le rendre executable : </p>
<p>Pour cree un shell script rien de plus simple , il faut cree un fichier ascii qui ne contient pas d'extension ou l'extension .sh si vous voulez vous y retrouvez et encore . Nous allons par exemple cree le fichier &quot;exp1&quot; donc dans notre shell &quot;<em>touch exp1</em>&quot; (ont peut faire d'une autre maniere mais nous on fais comme ca ..) une fois cree pour que le systeme &quot;sache&quot; qu'il faut l'executer nous allons tous le rendre executable . Pour cela nous utiliserons chmod :</p>
<table width="60%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td>touch exp1 &nbsp;&nbsp;#ont cr&eacute;e le fichier exp1 <br>
    chmod +x exp1 #ont rend le fichier exp1 executable </td>
  </tr>
</table>
<p>Voila notre pre-script est considerer comme executable et on peut commencer a travailler </p>
<p><span class="Style5">&nbsp;&nbsp;&nbsp;1-2/<em>Structure d'un script bash</em> : </span></p>
<p>Un shell script (et oui je speak english moi) devras toujours commencer par un ShiBang (#!) (ce n'est pas obligatoire mais c'est quand meme plus propre) cela permet au shell de &quot;savoir&quot; qu'elle programme elle doit utiliser pour interpreter le script , dans notre cas nous utiliserons bien sur le shell pour interpreter notre script donc nous commencerons toujours notre script par un : </p>
<table width="60%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td>#!/bin/bash <br>#ce qui suit le shibang est le chemin du programe qui doit l'interpreter </td>
  </tr>
</table>
<p>Les commentaire sont comme en php , ils sont pr&eacute;c&eacute;des d'une diese (#), ils ne serons pas interpreter mais vous permetent de vous y retrouver quand vous n'avez pas mis le nez dans un script depuis pas mal de temps par exemple (et oui faut faire un exemple pour les plus lents :P)</p>
<table width="60%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td>    #ceci ne sera pas interpreter</td>
  </tr>
</table>
<p>Bon allez on commence enfin a s'interesser en la programmation en elle meme</p>
<p><span class="Style5">&nbsp;&nbsp;&nbsp;1-3/<em>Declaration et utilisation de variable </em> : </span></p>
<p>Pour declarer une variable rien de plus simple , il sufit d'ecrire le nom de la variable et de la faire preceder de =&quot;valeur&quot; pour lui afecter &quot;valeur&quot; , une fois declarer l'utiliser est souvent utile ^^ , pour l'utiliser il vous sufit de faire preceder le nom de la variable que vous avez declarer par un dollard ($) , bon allez vu que j'explique mal un petit exemples s'impose : </p>
<table width="60%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td> #!/bin/bash
	<br>#J'espere que vous n'avez pas deja oublier a quoi servait le Shibang ;)<br>
	<br>
	VAR1="Valeur1"<br>VAR2="Valeur2"<br><br>echo "la variable 1 contien $VAR1 et la variable 2 contient $VAR2"<br>
	#echo permet d'aficher quelque chose sur la sortie standart (l'ecran)
	</td>
  </tr>
</table>
<p>Ce mini script afichera &quot;la variable 1 contien Valeur1 et la variable 2 contient Valeur2&quot; , ca n'a aucune utilit&eacute; mais la vous avez compris au moins , les exemples et les exercices sont le meileur moyens de retenir donc faites les tous les deux ;)</p>
<p class="Style4"><span class="Style5">II/Poussons un peu le bouchons </span>:</p>
<p class="Style5">&nbsp;&nbsp;&nbsp;2-1/<em>Commande de bases</em><em> </em>: </p>
<p><em>Source : <a href="http://www.linuxfocus.org/Francais/September2001/article216.shtml%20">http://www.linuxfocus.org/Francais/September2001/article216.shtml</a> (et oui je suis paresseux ;))</em></p>
<table width="90%" border="1" align="center" bordercolor="#333333">
  <tbody>
    <tr>
      <th width="30%">Syntaxe de la commande</th>
      <th>But</th>
    </tr>
    <tr>
      <td> echo "un texte"</td>
      <td> affiche un texte sur l'&eacute;cran</td>
    </tr>
    <tr>
      <td> ls</td>
      <td> liste des fichiers</td>
    </tr>
    <tr>
      <td> wc -l fichier<br>
        wc -w fichier<br>
        wc -c fichier</td>
      <td> compte les lignes du fichier, ou<br>
        compte les mots du fichier, ou<br>
        compte le nombre de caract&egrave;res </td>
    </tr>
    <tr>
      <td> cp fichier_source fichier_dest</td>
      <td> copie le fichier_source vers le fichier_dest</td>
    </tr>
    <tr>
      <td> mv ancien_nom nouveau_nom</td>
      <td> renomme ou d&eacute;place le fichier</td>
    </tr>
    <tr>
      <td> rm fichier</td>
      <td> efface le fichier</td>
    </tr>
    <tr>
      <td> grep 'pattern' fichier</td>
      <td> cherche des cha&icirc;nes de carat&egrave;res dans un fichier <br>
        Exemple: grep 'searchstring' file.txt</td>
    </tr>
    <tr>
      <td> cut -c num_colonne fichier </td>
      <td> r&eacute;cup&egrave;re les donn&eacute;es issues de colonnes de textes &agrave; largeur fixe.<br>
        Exemple : r&eacute;cup&egrave;re les caract&egrave;res des positions 5 &agrave; 9 <br>
        cut -b5-9 file.txt<br>
        Ne pas confondre cette commande avec la commande cat, qui a une utilisation totalement diff&eacute;rente. <br>
      </td>
    </tr>
    <tr>
      <td> cat file.txt</td>
      <td>&eacute;crit le contenu du fichier file.txt sur la sortie standard stdout (qui est par d&eacute;faut votre &eacute;cran)</td>
    </tr>
    <tr>
      <td>file fichier</td>
      <td>d&eacute;crit le type de fichier </td>
    </tr>
    <tr>
      <td>read var</td>
      <td>attend une frappe de l'utilisateur en entr&eacute;e et stocke cette valeur dans une variable (var)</td>
    </tr>
    <tr>
      <td>sort file.txt</td>
      <td>trie les lignes du fichier file.txt </td>
    </tr>
    <tr>
      <td>uniq, </td>
      <td>retire les lignes en double, utilis&eacute; parall&egrave;lement &agrave; sort, puisque uniq ne retire que les doublons sur des lignes cons&eacute;cutives.<br>
        Exemple : sort file.txt | uniq<br>
      </td>
    </tr>
    <tr>
      <td>expr</td>
      <td>pour faire des maths dans le shell<br>
        Exemple: ajouter 2 et 3<br>
        expr 2 "+" 3</td>
    </tr>
    <tr>
      <td>find</td>
      <td>recherche de fichier<br>
        Exemple : rechercher un nom :<br>
        find . -name nom_fichier -print<br>
        Cette commande poss&egrave;de &eacute;norm&eacute;ment d'options et de possibilit&eacute;s diff&eacute;rentes, rendant leur description impossible dans cet article. <br>
      </td>
    </tr>
    <tr>
      <td>tee</td>
      <td>&eacute;crit simultan&eacute;ment des donn&eacute;es vers stdout (l'&eacute;cran) et dans un fichier. <br>
        Elle s'utilise habituellement de cette mani&egrave;re : <br>
        commande | tee fichier_de_sortie<br>
        Affiche la sortie de la commande &agrave; l'&eacute;cran et l'&eacute;crit dans le fichier_de_sortie.</td>
    </tr>
    <tr>
      <td>basename fichier</td>
      <td>retourne le nom du fichier sans le chemin d'acc&egrave;s.<br>
        Exemple : basename /bin/tux<br>
        retourne seulement tux</td>
    </tr>
    <tr>
      <td>dirname fichier</td>
      <td>renvoie le nom du r&eacute;pertoire d'un fichier sans pr&eacute;ciser le nom de ce fichier<br>
        Exemple: dirname /bin/tux<br>
        retourne /bin</td>
    </tr>
    <tr>
      <td>head fichier</td>
      <td>affiche les premi&egrave;res lignes du d&eacute;but d'un fichier.</td>
    </tr>
    <tr>
      <td>tail fichier</td>
      <td>affiche les derni&egrave;res lignes de la fin d'un fichier</td>
    </tr>
    <tr>
      <td>sed</td>
      <td>sed est &agrave; la base un programme de recherche et de remplacement . Il lit le texte de l'entr&eacute;e standard (depuis un "pipe", par exemple) et &eacute;crit le r&eacute;sultat sur la sortie standard (stdout, l'&eacute;cran). Le mod&egrave;le &agrave; rechercher est une expression r&eacute;guli&egrave;re (voir la section R&eacute;ferences).<br>
        Ce mod&egrave;le de recherche (<i>'pattern'</i>) ne doit pas &ecirc;tre confondu avec la syntaxe des 'wildcards' du shell. Par exemple, pour remplacer dans un texte la cha&icirc;ne de caract&egrave;res linuxfocus par la cha&icirc;ne LinuxFocus, ex&eacute;cutez : <br>
        cat text.file | sed 's/linuxfocus/LinuxFocus/' &gt; newtext.file <br>
        Cette commande remplace la premi&egrave;re occurrence de la cha&icirc;ne linuxfocus par la cha&icirc;ne LinuxFocus. S'il y a des lignes contenant plusieurs fois la cha&icirc;ne linuxfocus et que vous vouliez toutes les remplacer, tapez :<br>
        cat text.file | sed 's/linuxfocus/LinuxFocus/g' &gt; newtext.file <br>
      </td>
    </tr>
    <tr>
      <td>awk</td>
      <td> La plupart du temps, awk est utilis&eacute; pour extraire des blocs d'une ligne de texte. Le s&eacute;parateur par d&eacute;faut est l'espace. Utilisez l'option -F pour d&eacute;finir un autre s&eacute;parateur. <br>
            <pre>   cat fichier.txt | awk -F, '{print $1 "," $3 }'  <br>

    </pre>
        Ici, la virgule (,) est utilis&eacute;e comme s&eacute;parateur et nous affichons les premi&egrave;re et troisi&egrave;me ($1$3) colonnes. Si fichier.txt contient les lignes suivantes :
        <pre><small>Adam Bor, 34, India
Kerry Miller, 22, USA
</small>
</pre>
        Le r&eacute;sultat sera :
        <pre><small>Adam Bor, India
Kerry Miller, USA
</small>
</pre>
        Vous pouvez faire beaucoup plus avec awk mais ce qui pr&eacute;c&egrave;de est l'usage le plus courant. </td>
    </tr>
  </tbody>
</table>
<br>
<span class="Style5">&nbsp;&nbsp;&nbsp;2-2/<em>Variable speciale</em>: </span><br>
<b></b>
<p>Lorsqu'un shell interprete un shell script il initialise certaine variable , dites speciales , qui ne sont accessibles que en lectures seulement et qui permettent au shell scripteur  . Voila une liste des variables speciales (celle la je l'ai faites car je suis quand meme pas paresseux a ce point :</p>
<table width="100%"  border="1" bordercolor="#333333">
  <tr>
    <td width="14%">$$</td>
    <td width="86%">Contient le PID du script , il peut vous servir par exemple quand vous voulez ensuite faire un kill sans le chercher .. (c'est plus utile que l'ont ne le crois)</td>
  </tr>
  <tr>
    <td>$?</td>
    <td>Cette variable changera tous au long du script , elle contiendera le code de retour de la dernier fonction (A note que si elle est egale a 0 c'est que la fonction c'est derouler sans encombre)</td>
  </tr>
  <tr>
    <td>$*</td>
    <td>Ensemble des parametre passer lors de l'appel de script <br>
      E      xemple : Pour un appel ./script arg1 arg2 la variable $* contiendera ./script arg1 arg2</td>
  </tr>
  <tr>
    <td>$#</td>
    <td>Contient le nombre d'argument passer lors ed l'appel <br>
    E      xemple : Lors de l'appel de script precedant $# contiendera 3</td>
  </tr>
  <tr>
    <td>Variables positionels</td>
    <td>Ce sont les variable qui designe l'argument , <br>
    Toujours en suivant l'exemple: (et oui j'aime bien mon exemple) de l'appel precedant $0 contiendera ./script $1 contiendera arg1 et $2 contiendera arg2</td>
  </tr>
</table>
<p><span class="Style5">&nbsp;&nbsp;&nbsp;2-3/<em>Structures de controle (if , else et case) </em>: </span></p>
<p>Dans n'importe qu'elle script il est tres utile , voir meme indispensable d'utiliser des structures de controle pour controler (c'etais dur a deviner ca non ?) , dans ce paragraphe ont expliquera les if , else , et case . </p>
<p>If : Permet de faire des verification sur a peu pres tous ce que ont peut imaginer :</p>
<table width="50%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td><code>if instructions<br>
then<br>
&nbsp;&nbsp;#1er bloc d'instructions<br>
else<br>
&nbsp;&nbsp;#2nd bloc d'instructions<br>
fi</code> </td>
  </tr>
</table>
<p>if (en anglais &quot;si&quot;) si l'intruction ou les instructions (il peux y en avoir plusieurs) renvoi vrai alors les instructions qui figure dans then (en anglais &quot;quand&quot;) seront execute alors que si ces instructions renvoi faux alors les instructions figurant dans le else seront executer (en anglais &quot;sinon&quot;) . Bon vu que j'arrive pas du tout a expliquer ca je vais l'illustrer par un petit exemples </p>
<table width="50%"  border="1" align="center" bordercolor="#33333">
  <tr>
    <td><p>#!/bin/bash</p>
      var1 = 2 <br>var2=1<br>if var1 > var2<br>then<br>echo "$var1 est bien superieur a $var2"<br>else<br>echo "Euhh la y a un leger probleme"<br>
    fi</td>
  </tr>
</table>
<p>Si au lieu d'instructions vous souhaitez comparez le resultat a diverses possibilites alors il serais plus simple , plus propre et plus rapide d'utiliser l'instruction case , cette fois je vais meme pas essayer d'expliquer donc un exemple sufira :</p>
<table width="50%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td><code>case $variable in<br>
&nbsp;valeur1)<br>
&nbsp;&nbsp;#1er bloc d'instructions<br>
&nbsp;&nbsp;;;<br>
&nbsp;valeur2)<br>
&nbsp;&nbsp;#2&egrave;me bloc d'instructions<br>
&nbsp;&nbsp;;;<br>
&nbsp;valeur3)<br>
&nbsp;&nbsp;#3&egrave;me bloc d'instructions<br>
&nbsp;&nbsp;;;<br>
&nbsp;*)<br>
&nbsp;&nbsp;#Traitement des autres valeurs<br>
&nbsp;&nbsp;;;<br>
esac</code> </td>
  </tr>
</table>
<p> Entre case et in se trouve la cha&icirc;ne &agrave; comparer <br>
  si variable est egale a valeur1 alors le 1 blog d'instructions s'executera <br>
  si variable est egale a valeur2 alors le 2 blog d'instructions s'executera <br>...<br>
  <code>esac</code> : fin du blod de test : </p>
<p><span class="Style5">&nbsp;&nbsp;&nbsp;2-4/<em>Boucles (<span id="misp_compose_4" class="hm">while</span> , for)</em><em> </em>: </span></p>
<p>On a parfois de faire le meme traitement plusieurs fois de suite , c'est meme plus souvent que parfois ;) , pour cela nous pouvons utiliser les boucles while et for qui permettent de repter une operation plusieurs fois de maniere controler . Bon apres une chtites introduction comme ca on va commencer par expliquer la synthaxe de la boucle while pour ensuite continuer sur la lancer avec la boucle for . Apres pour que vous ne soyez pas trop perdu nous etudierons un petits exemple . </p>
<p>Pour le while le traitement est repeter tant que l'instruction est vrai : </p>
<table width="50%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td><code>while instructions<br>
do<br>
&nbsp;&nbsp;# Traitement &agrave; r&eacute;p&eacute;ter<br>
done</code></td>
  </tr>
</table>
<p>Tant que l'instructions est vrai alors le traitement est repter , (on peut faire le contraire avec until et la synthaxe est la meme) , la fin des instructions a repteter sont situer grace au done . </p>
<p>Le for est legerement differend car le nombre d'iteration est deja connu a l'avance , de meme la synthaxe de for est largement diferentes de while et until : </p>
<table width="50%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td><code>for variable in liste_de_valeurs<br>
do<br>
&nbsp;&nbsp;# Traitement &agrave; r&eacute;p&eacute;ter<br>
done</code> </td>
  </tr>
</table>
<p> La liste suivant le <em>in</em> est constitu&eacute;e de plusieurs valeurs s&eacute;par&eacute;es par des espaces. Le traitement sera alors r&eacute;p&eacute;t&eacute; et on aura acc&egrave;s &agrave; $variable qui prendra successivement ces valeurs dans l'ordre indiqu&eacute;. D&egrave;s que toutes les valeurs auront &eacute;t&eacute; parcourues, la boucle s'arr&ecirc;tera. . Bon allez un petits exemple s'impose :</p>
<p class="Style5">&nbsp;&nbsp;&nbsp;2-5/<em>Petit exemple </em></p>
<p>A note que le ! signifie diferend en programmation </p>
<table width="50%"  border="1" align="center" bordercolor="#333333">
  <tr>
    <td>
!#/bin/bash<br>
#cette exemple renomera certains fichiers fichiers<br>
#premier if si $1 n'existe pas on affiche un message d'erreur<br>
#et on quite le script avec l'etat 1<br>
if [ !$1 ]<br>
&nbsp;then<br>
&nbsp;&nbsp;echo &quot;Usage du script :&quot;<br>
&nbsp;&nbsp;echo &quot;$0 Nom_du_repertoire&quot;<br>
&nbsp;&nbsp;exit 1<br>
fi<br>
DIR=$1
<br>#verifie si ce que contient dir est un repertoire <br>
if [ -d $DIR]<br>
&nbsp;then <br>
&nbsp;&nbsp;echo &quot;$DIR est bien un repertoire ..&quot;<br>
&nbsp;else<br>
&nbsp;&nbsp;echo &quot;$DIR n'est pas un repertoire&quot;<br>
&nbsp;&nbsp;exit 1<br>
fi<br>
#une fois ces verification nous allons renomer les fichier du repetoire choisi une #premier fois qui contient des majucule en minuscule<br>
<p>for a in `ls $DIR`<br>
&nbsp;do<br>
&nbsp;&nbsp;newname=`echo $a | tr A-Z a-z`<br>
&nbsp;&nbsp;mv $DIR/$a $DIR/$newname<br>
&nbsp;done
<br>#et ensuite chercher les sous repertoire et faire pareil<br>
for SREP in `find -type d`<br>
&nbsp;do<br>
&nbsp;&nbsp;for a in $SREP<br>
&nbsp;&nbsp;&nbsp;do<br>
&nbsp;&nbsp;&nbsp;if [ -f $a ]<br>
&nbsp;&nbsp;&nbsp;&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newname=`echo $a | tr A-Z a-z`<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mv $a $newname<br>
&nbsp;&nbsp;&nbsp;&nbsp;fi<br>
&nbsp;&nbsp;&nbsp;done<br>
&nbsp;&nbsp;done</td>
  </tr>
</table>
</body>
</html>
