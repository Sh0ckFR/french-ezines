<html>
<head>
<title>Progra: PERL/CGI script</title>

</head>
<body bgcolor="#FFFFF8" text="#000000" link="#339966" vlink="#339966" alink="#339966">
<div style="text-align:justify;"><font face="Verdana" size=2> </font>
  <table width="283" border="0" cellspacing="0" cellpadding="0" background="IMAGES/fnd_stitre.jpg" height="40">
    <tr> 
      <td width="23">&nbsp;</td>
      <td width="294"><font face="Verdana, Arial, Helvetica, sans-serif" color="#FFCC00"><font color="#CCCCCC" size="2">PERL 
        / CGI scripts</font></font></td>
    </tr>
  </table>
  <font face="Verdana" size=2>
  <p>&nbsp; 
  <p>Le perl est un language prenant le meilleur du C, des outils de scripts sous 
    Unix, et un peu de Pascal. Il a été créé en 1988 par Larry Wall. Actuellement 
    c'est l'un des languages les plus utilisés pour les applications internet 
    (les cgi par exemple). 
  <p> Le PERL est un language qui ne nécessite aucune compilation : on écrit un 
    script et on l'execute pour voir directement son résultat. Mais il est tout 
    de même possible de le compiler : si vous êtes sous windows, télécharger un 
    compilateur sur <a href="http://www.activestate.com">http://www.activestate.com</a> 
    ou bien allez consulter nos archives; si vous êtes sous linux, je vous conseil 
    d'utiliser l'interpréteur fournit avec votre version. Il doit se trouver dans 
    /usr/bin/perl. 
  <p> L'avantage du perl, c'est que c'est un language qui est "très" facile. En 
    effet le célebre "Hello World" tient en deux petites lignes comme on peut 
    le voir dans le fichier hello.pl : 
  <p> <b>#!/usr/bin/perl</b><br>
    <b>print "Hello World\n";</b><br>
  <p> Tandis que l'équivalent en C est un peu plus compliqué. C'est un code beaucoup 
    plus long, et il y a beaucoup plus de risques de bugs ( evidemment pas dans 
    un code aussi court et aussi basique ! ) : 
  <p> <b>#include <stdio.h><br>
    main()<br>
    {<br>
    printf"Hello World\";<br>
    return 0;<<br>
    }<br>
    </b> 
  </font> 
  <p><font face="Verdana" size="2"> Maintenant, pour executer ce programme, un 
    simple "perl./nom_du_programme" sera suffisant. Vous pouvez aussi rendre ce 
    programme executable grace à la commande "chmode +x ./nom_du_prog", puis en 
    l'executant par "./nom_du_prog". <br>
    <br>
    <br>
    <b><u>1 - Les variables</u></b><br>
    <br>
    <br>
    Passons maintenant au choses sérieuses. Tout d'abord, le stockage des variables. 
    Cette tâche est très facile en perl, puisque on a juste besoin de la déclarer, 
    et c'est tout. Si on veut stocker une chaine de caractere, il suffit de faire 
    cela : </font>
  <font face="Verdana" size=2> 
  <p> <b>$nom = "MedGi";</b> 
  <p> Notez qu'une variable commence toujours par '$'. Si maintenant vous voulez 
    stocker un nombre, il vous suffira de faire cela : 
  <p> <b>$nombre = 180;</b> 
  <p> Enfin, pour afficher ces variables, il vous suffit de mettre cette ligne 
    : 
  <p> <b>print "$nom a un QI de $nombre :]\n";</b> 
  </font>
  <p><font face="Verdana" size="2"> Ceci affichera : 'MedGi a un QI de 180 :]' 
    ... <br>
    <br>
    <br>
    <u><b>2 - Les tableaux</b></u></font><font face="Verdana" size="2"><br>
    <br>
    <br>
    On peut aussi stocker les variables dans un tableau indexé. Il suffit de remplacer 
    le '$' par un '@'. Par exemple : </font>
  <font face="Verdana" size=2> 
  <p> <b>@site = ("madchat","skreel","securiweb");</b> 
  <p> Ce tableau contient trois éléments que l'on peut afficher ainsi : '$site[2]', 
    qui correspond à la variable contenant 'securiweb'. En effet, les éléments 
    sont ici numérotés de 0 à 2. Vous pouvez ajouter une variable grace à la commande 
    'push' ('pop' pour en enlever une). De plus, la fonction push retourne la 
    taille de la liste apres modification : 
  <p> <b># Apres opération, $a vaut 4.<br>
    $new = push(@site,"nouveau_site")<br>
    </b> 
  </font>
  <p><font face="Verdana" size="2"> Il y a encore beaucoup d'autre opération possible, 
    tel 'sort', pour trier la liste et 'reverse' pour inverser tout les éléments. 
    Notez que les commentaires sont précédés du signe # <br>
    <br>
    <br>
    <u><b>3 - Les tables de hash</b></u></font><font face="Verdana" size="2"><br>
    <br>
    <br>
    Les tableaux utilisant les préfixe '%' sont des tables de hash : il suffit 
    de donner une clef comme paramètre pour trouver la valeure qui lui est associée. 
    Le nombre d'éléments dans ces tableaux est donc toujours pair : </font>
  <font face="Verdana" size=2> 
  <p> <b>%qi = ("MedGi","180","LamerZ",25");</b> 
  <p> Il suffit d'utiliser l'instruction '$qi{"LamerZ"} pour trouver le QI de 
    LamerZ. Pour ajouter de nouveaux éléments, faites tout simplement : 
  </font>
  <p> <font face="Verdana" size="2"><b>$qi{"HaxorZ"}="30";</b> <br>
    <br>
    <br>
    <u><b>4 - Boucles & Conditions</b></u></font><font face="Verdana" size="2"><br>
    <br>
    <br>
    Tous ceux qui ont déja programmé savent ce qu'est une condition. Pour les 
    autres, voici un petit exemple : </font>
  <font face="Verdana" size=2> 
  <p> <b>if (condition) { # condition est vraie }<br>
    else { # condition est fausse }</b> 
  <p> Ici, condition est une expression Perl. Pour utiliser les conditions, vous 
    devez connaitres les opérateurs de comparaison : 
  <p><br>
  <table border="0"  width="68.5%">
    <tr> 
      <td>&nbsp;</td>
      <td>&nbsp;<font size="2" face="Verdana"><b>Nombres</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>Chaînes</b></font></td>
    </tr>
    <tr> 
      <td>&nbsp;<font size="2" face="Verdana"><b>egal</b></font></td>
      <td>&nbsp;<font size="2" face="Terminal, Verdana"><b>==</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana, Arial"><b>eq</b></font></td>
    </tr>
    <tr> 
      <td>&nbsp;<font size="2" face="Verdana"><b>différent</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>!=</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>ne</b></font></td>
    </tr>
    <tr> 
      <td>&nbsp;<font size="2" face="Verdana"><b>Supérieur</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>&gt;</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>gt</b></font></td>
    </tr>
    <tr> 
      <td>&nbsp;<font size="2" face="Verdana"><b>Inférieur</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>&lt;</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>lt</b></font></td>
    </tr>
    <tr> 
      <td>&nbsp;<font size="2" face="Verdana"><b>Supérieur ou égal</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>&gt;=</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>ge</b></font></td>
    </tr>
    <tr> 
      <td>&nbsp;<font size="2" face="Verdana"><b>Inférieur ou égal</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>&lt;=</b></font></td>
      <td>&nbsp;<font size="2" face="Verdana"><b>le</b></font></td>
    </tr>
  </table>
  <p><br>
    A eux s'ajoute différents opérateurs comme '&&' (et), '||' (ou) et '!' (non). 
    Voyons maintenant les boucles. La construction est assez proche du C. Nous 
    ne verrons ici que la boucle 'while' et la boucle 'for', mais sachez qu'il 
    y en a d'autre de disponible, 
  <p> Voici un exemple de la boucle while'. En gros, tant que '$variable' est 
    supérieure à 0, 'Commandes' est executé : 
  <p> <b>while ($variable >= 0)<br>
    {<br>
    Commandes;<br>
    }<br>
    </b> 
  <p> Et voici un exemple de la boucle for. Ici, il y à un compte à rebours allant 
    de 10 à 1, puis affichant le texte 'BOOOM !'. La variable '$_' est en fait 
    une variable "magique" :) ! [Explication un peu plus loin ...] : 
  </font>
  <p> <font face="Verdana" size="2"><b>for((10,9,8,7,6,5,4,3,2,1,"BOOOM !"))<br>
    {<br>
    print "$_\n";<br>
    }</b> <br>
    <br>
    <br>
    <u><b>5 - Le traitement de fichiers</b></u></font><font face="Verdana" size="2"><br>
    <br>
    <br>
    Dans un shell UNIX, les connexion entrées/sorties sont gérées par '&lt;STDIN>' 
    et '&lt;STDOUT>'. Voici un exemple de script utilisant ces fonctions : </font>
  <font face="Verdana" size=2> 
  <p> <b>print "Entrez votre Nick :";<br>
    $nick = &lt;STDIN&gt;; <br>
    print "Votre nick est $nick\n";</b> 
  <p> A noter que '\n' sert à revenir à la ligne. Pour ouvrir d'autre descripteurs 
    de fichiers, on utilise la commande 'open'. Par exemple, pour afficher le 
    contenu du fichier '/etc/passwd', on utilisera le script suivant : 
  <p> <b>open(OF,"/etc/passwd") || die "Impossible d'ouvrir ce fichier !";<br>
    while($ligne = &lt;OF>) <br>
    { <br>
    print $ligne;<br>
    } </b> 
  </font>
  <p><font face="Verdana" size="2"> A noter que l'instruction 'die' permet de 
    terminer l'application, si l'on n'arrive pas à ouvrir le fichier. <br>
    <br>
    <br>
    <u><b>6 - Les Expressions Régulières (E.R)</b></u></font><font face="Verdana" size="2"><br>
    <br>
    <br>
    .&nbsp; Remplace n'importe quel caractère<br>
    ^&nbsp; Début de ligne<br>
    $&nbsp; Fin de ligne<br>
    *&nbsp; 0 ou plusieurs itérations de l'E.R précédente.<br>
    +&nbsp; 1 ou plusieurs itérations de l'E.R précédente.<br>
    {m,M}&nbsp; minimum m et Maximum M itération de l'E.R précédente.<br>
    [ ... ]&nbsp; Dénote une classe de caractère à appareiller. Exemple : [A-Z 
    ] dénote tout les caractères majuscules.<br>
    ( ... | ... | ... )&nbsp; On choisit une des 3 alternatives.<br>
    \w&nbsp; n'importe quel caractère.<br>
    \s&nbsp; un espace<br>
    \d&nbsp; un chiffre<br>
    \b&nbsp; permet de délimiter un mot<br>
    \n, \r, \f, ...&nbsp; Pareil que en C<br>
    \1 ... \9&nbsp; référence aux expressions déja trouvées, celles entre ()<br>
    <br>
    <br>
    <br>
    <u><b>7 - CGI (Common Gateway Interface)</b></u></font><font face="Verdana" size="2"><br>
    <br>
    <br>
    Maintenant que vous avez les bases du perl nous allons programmer votre premier 
    CGI. Il faut savoir que les CGI ne sont pas authorisé partout. En effet, des 
    hébergeurs comme MultiMania les refuse, pour la simple raison qu'ils permettent 
    d'acceder au fichier d'un visiteur en toute libertée... </font>
  <font face="Verdana" size=2>
  <p> Bon revenons à notre CGI. Nous allons coder un mini-moteur de recherche 
    pour votre page web. La première étape est bien évidemment de créer la page 
    web avec le formulaire : 
  <p><br>
  <form method="get" action="bin/search.cgi">
    <center>
      <p>Entrez un mot clé : 
        <input name="search" type="text">
        <input type="submit">
        <br>
        <b>Cet exemple ne fonctionnera que si vous etes sous linux !<br>
        </b>Trouvez le source du script dans bin/search.cgi </p>
      </center>
  </form>
  <p><br>
    --- 
  <p> <b>&lt;html><br>
    &lt;head><br>
    &lt;title>Search Engine -=- by MedGi&lt;/title><br>
    &lt;/head><br>
    &lt;body><br>
    &lt;form method="get" action="search.cgi"><br>
    &lt;center><br>
    Entrez un mot clé :<br>
    &lt;input name="search" type="text">&lt;/input><br>
    &lt;input type="submit">&lt;/input><br>
    &lt;/center><br>
    &lt;/form><br>
    &lt;/body><br>
    &lt;/html></b> 
  <p> --- 
  <p> 
  <p> Nous obtenons alors une zone de texte modifiable, et un bouton, qui permet 
    de lancer le programme 'search.cgi', qui effectuera la recherche. Ce qu'à 
    tapé l'utilisateur sera stocké dans une variable d'environnement nommée 'QUERY_STRING', 
    sous la forme 'search= mot_clef'. On va donc récupérer ce mot clef : 
  <p> <b>$SEARCH = $ENV{QUERY_STRING}</b> 
  <p> et isoler ce qui se trouve après 'search=' : On remplace 'search=' par rien 
    du tout. Si l'opération se passe mal, on arrete tout à l'aide de la commande 
    'die'. 
  <p> <b>$SEARCH =~s/^search=//o || die "Err0r !";</b> 
  <p> '=~' est un opérateur assez particulier : il indique que l'opération qui 
    suit porte sur la variable qui précède car, par défaut c'est $_ qui est utilisée 
    (sic!). Nous allons ensuite effectuer une recherche dans chaque fichier HTML 
    : 
  <p> On récupère le contenu du repertoire courant, on cherche les éléments dont 
    l'extension est '.html', et on les place dans une structure linéaire quelquoncque, 
    qu'on scanne... Tout d'abord, indiquons que l'on ne s'intéresse qu'aux fichiers 
    '.html' : 
  <p> <b>while (&lt;*.html>)</b> 
  <p> Chaque nom sera temporairement présent dans '$_'. Copions les dans une autre 
    variable, $FICHIER. Maintenant, il faut ouvrir ce fichier pour effectuer la 
    recherche : 
  <p> <b>open FICHIER;</b> 
  <p> Seulement, pendant que le CGI scanne le fichier, il risque de tomber sur 
    des tags HTML, qui risquent de perturber la recherche et l'affichage. Nous 
    allons donc à nouveau utiliser l'instruction '/s' pour effacer tout ce qui 
    est contenu entre '<' et '>' : 
  <p> <b>s/<[^>]+>//go</b> 
  <p> Il s'agit du même principe que précédemment, mais au lieu de '\w' (n'importe 
    quelle lettre), on cherche plutot une succession de caractères autres que 
    le '>' entre le tag : c'est le rôle de '[^>]'. L'option 'g' signifie que le 
    remplacement peut avoir lieu plusieurs fois sur la même chaine. L'option 'o' 
    signifie que l'expression à rechercher est constante, et qu'elle peut être 
    compilée définitivement. Maintenant, affichons la ligne contenant le mot clef 
    recherché : 
  <p> <b>print"$_\n" if /$SEARCH/i;</b> 
  <p> <b># /$SEARCH/i est vérifié si $SEARCH est trouvé dans $_<br>
    # 'i' indique de ne pas faire la distinction entre minuscule et majuscules.</b> 
  <p> Voilà c'est tout pour notre moteur de recherche. Le reste ne sert qu'à contenter 
    les navigateurs web. Voici donc le script final : 
  <p> <u><b>8 - Fichier search.cgi</b></u>
  <p> #!/usr/bin/perl<br>
    # Search Engine by MedGi<br>
    # -= medgi@caramail.com =- 
  <p> $SEARCH = $ENV{QUERY_STRING};<br>
    $RECH =~s/^search=//o || die "Err0r !";<br>
    print "Content-type: text/html\n\n";<br>
    print "&lt;HTML>&lt;HEAD>&lt;TITLE> Recherche de [$SEARCH]&lt;/TITLE>&lt;/HEAD>&lt;BODY>\n";<br>
    &lt;while (&lt;*.html>)<br>
    {<br>
    $FICHIER = $_;<br>
    OPEN FICHIER;<br>
    while(&lt;FICHIER>)<br>
    {<br>
    s/<[^>]+>//go;<br>
    print "&lt;A HREF="\"$FICHIER\">&lt;B>$FICHIER&lt;/B> : ";<br>
    print "&lt;EM>$_&lt;/EM>&lt;/A>&lt;BR> \n" if /$SEARCH/i; <br>
    }<br>
    close FICHIER;<br>
    } <br>
    print "&lt;/BODY>&lt;/HTML>\n"; 
  <p> # Merci a Jedi pour son aide...<br>
    # N'hesitez pas a me mail vos questions. 
  <p> <br>
    Voilà, c'est la fin de cet article. Si vous n'avez pas tout compris, contactez-moi. 
    Bien sur, je ne vous ai donné qu'un minime aperçu du PERL, et des CGI; a vous 
    de continuer. Si vous avez codé des CGI intéressants, envoyer les moi à l'adresse 
    suivant : <a href="mailto:medgi@tipiak.net">medgi@tipiak.net</a>. Merci !
  </font></div>
</body>
</html>
