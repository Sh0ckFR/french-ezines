 
<html>
<head>
<title>HackinG /Progra.</title>
<meta http-equiv="Content-Type" content="text/html; charset=">
</head>
<body bgcolor="#FFFFF8" text="#000000" link="#339966" vlink="#339966" alink="#339966">
<table width="283" border="0" cellspacing="0" cellpadding="0" background="images/fnd_stitre.jpg" height="40">
  <tr> 
    <td width="23">&nbsp;</td>
    <td width="294"><font face="Verdana, Arial, Helvetica, sans-serif" color="#FFCC00"><font face="Verdana, Arial, Helvetica, sans-serif" color="#FFCC00"><font color="#CCCCCC" size="2">Compression 
      de donn&eacute;es</font></font></font></td>
  </tr>
</table>
<p> 
  <p>&nbsp;</p>
  <p align="center">&nbsp;</p>
  <p align="center"><font size="6"><strong>STRUCTURES DYNAMIQUES</strong></font></p>
  <p align="center"><font size="5"><strong>COMPRESSION DE DONNEES</strong></font></p>
  <p>&nbsp;</p>
<p></p>
<p align="center"><img src="images/split.jpg" width="600" height="25"> 
</p>
<p>
  <p>&nbsp;</p>
  <p><font color="#FF0000" size="4"><strong><u><font face="Verdana, Arial, Helvetica, sans-serif" size="2">I- 
    A PROPOS DE LA COMPRESSION DE DONNEES</font></u></strong></font></p>
  <p><font color="#FF0000" size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>II- 
    CODAGE DE HUFFMAN</u></strong></font></p>
  <blockquote> 
    <p><font color="#FF0000" size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>1- 
      Algorithme</u></strong></font></p>
  </blockquote>
  <blockquote> 
    <p><font color="#FF0000" size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>2- 
      Décodage</u></strong></font></p>
  </blockquote>
  
<p><font color="#FF0000" size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>III- 
  CODING</u></strong></font><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><a
href="files/Huffman.pas"><font color="#FF0000"><strong><u>file://huffman.pas</u></strong></font></a></font></p>
  <p><font color="#FF0000" size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>IV- 
    LIMITATION DU PROGRAMME</u></strong></font></p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La dernière fois 
    nous avons vu quelques structures dynamiques. En apparence assez abstraites, 
    nous avons essayé d&#146;en donner quelques applications. Nous allons ici 
    voir un très bon exemple d&#146;application&nbsp;: la compression de donnée. 
    Il n&#146;est pas question ici de débattre sur les méthodes de compression 
    de donnée (on réservera une série d&#146;articles intéressant s&#146;il y 
    a suffisamment de demande&nbsp;:) mais de voir une des méthodes les plus populaires&nbsp;: 
    le codage de Huffman. Le codage de Huffman est assez simple à comprendre mais 
    vraiment difficile à implémenter pour le programmeur débutant.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Après une légère 
    introduction à la compression de donnée, nous allons étudier le codage de 
    Huffman et surtout son implentation. Etant donnée que le dernier article rédigé 
    en Pascal n&#146;a suscité aucune critique, nous allons continuer dans ce 
    langage.</font></p>
  <p>&nbsp;</p>
  <p><font color="#FF0000" size="4"><strong><u><font face="Verdana, Arial, Helvetica, sans-serif" size="2">I- 
    A PROPOS DE LA COMPRESSION DE DONNEES</font></u></strong></font></p>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Bien que le prix 
    du Mega-Octet soit relativement faible, il est toujours frustrant de gaspiller 
    de précieux octets. Et lorsqu&#146;il s&#146;agit de transmettre un fichier, 
    le facteur 10 peut cette fois ci coûter très cher. C&#146;est pourquoi on 
    utilise souvent des utilitaires de compressions de données&nbsp;: Winzip est 
    certainement le plus connu des Windoziens, gzip, zoo, rar&#133;. Le principe 
    est simple&nbsp;: on sélectionne un fichier et on le &quot;&nbsp;zip&nbsp;&quot; 
    afin de réduire sa taille. Il est intéressant de voir que le fichier se suffit 
    à lui-même&nbsp;; il n&#146;y a en effet pas besoin de garder une autre trace 
    de la compression dans un fichier annexe.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On distingue 
    usuellement 2 types de compression&nbsp;: les compressions dites destructives 
    et les compressions dites non-destructives. La première catégories portent 
    sur les fichiers auxquels on tolère une légère variation du message. On toléra 
    par exemple une légère variation du contraste d&#146;une image (imperceptible 
    à l&#146;&#156;il humain) ou encore on supprimera certaines gammes d&#146;onde 
    inaudible pour l&#146;oreille humaine (MP3). Ensuite, on a les compression 
    non-destructive ( c&#146;est d&#146;ailleurs celles-ci auxquelles nous nous 
    intéresserons), le message est exactement le même avant la compression et 
    après la décompression&nbsp;: on ne peut par exemple envisager une variation 
    du code d&#146;un fichier exécutable.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">L&#146;idée générale 
    à dégager de ces algorithmes est un codage en fréquence. Tout fichier informatique 
    est codé avec des octets, ceux ci étant mis bout à bout ont une certaine signification. 
    L&#146;idée de la compression non-destructive est de codé les octets (et plus 
    généralement des blocs) n&#146;ont pas avec une taille fixe mais avec une 
    taille inversement proportionnelle à leurs fréquences d&#146;apparition. Ainsi, 
    au plus un caractère sera présent dans le fichier au moins il faudra de bits 
    (cette fois ci on raisonne en unité binaire) pour coder ce caractère.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On peut déjà 
    se poser une question concernant un tel fichier. Si les caractères sont codés 
    avec des tailles différentes, comment les reconnaître. En recevant 010100, 
    devrais-je lire 0101 00 ou 010 100&nbsp;? On peut préconiser dans un premier 
    temps d&#146;utiliser un caractère de contrôle pour délimiter les différents 
    bits. Mais dans le cas où il faut compresser des données, on risque de gonfler 
    considérablement le fichier et de perdre toute la place gagnée par le codage 
    en fréquence. Heureusement ce problème va se résoudre de lui même, notamment 
    grâce à la structure d&#146;arbre&#133;</font></p>
  <p>&nbsp;</p>
  <p><font color="#FF0000" size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>II- 
    CODAGE DE HUFFMAN</u></strong></font></p>
  <blockquote> 
    <p>&nbsp;</p>
    <p><font color="#FF0000" size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>1- 
      Algorithme</u></strong></font></p>
    <p>&nbsp;</p>
  </blockquote>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">L&#146;objet 
    avec lequel on va travailler sera l&#146;octet. La première étape du codage 
    de Huffman est de dénombrer les caractères présents dans le fichier&nbsp;; 
    cette étape consistera d&#146;une part à recenser les caractères et d&#146;autre 
    part à évaluer leur poids dans le fichier (c&#146;est-à-dire le nombre de 
    fois dans lequel ils apparaissent). Le plus simple est de prendre un exemple 
    sur la phrase &quot;&nbsp;tipiak_ititiation&nbsp;&quot;</font></p>
  <p>&nbsp;</p>
  <table border="1" cellpadding="4" cellspacing="1" width="491">
    <tr> 
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">t</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">i</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">p</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">a</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">_</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">n</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">o</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">k</font></td>
    </tr>
    <tr> 
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">4</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">6</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">2</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1</font></td>
      <td valign="top" width="13%"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1</font></td>
    </tr>
  </table>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><em>j&#146;ai 
    mis un t supplémentaire pour que l&#146;exemple marche bien&nbsp;:-) Cela 
    ne nuit pas à la généralisation&#133;</em></font></p>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On place le poids 
    et le caractère dans une liste chaînée. On va de plus demander à cette liste 
    d&#146;avoir une structure de liste triée.</font></p>
  <p>&nbsp;</p>
  
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/crypto/liste1.gif"
width="645" height="50"></font></p>
  <p align="center">&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On reconnais 
    ici la structure de liste chaînée. Que contient nos chaînons&nbsp;? on doit 
    stocker un couple ( chaîne , poids ). En fait, on va anticiper sur la suite&nbsp;; 
    on va en effet utiliser une structure d&#146;arbre. Notre schéma précédent 
    devient donc&nbsp;:</font></p>
  <p>&nbsp;</p>
  
<p><img src="images/crypto/liste2.gif" width="644" height="80"></p>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Nos arbres (chaque 
    couple est le père) ne possèdent dans un premier temps aucun fils. Apres avoir 
    initialisé notre liste, on va commencer l&#146;algorithme de construction 
    de Huffman.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le but de l&#146;algorithme 
    va être de construire un arbre dont les feuilles seront les caractères présents 
    dans le fichier et dont la feuille la plus proche du n&#156;ud principal (d&#146;un 
    point de vue&nbsp;: nombre de n&#156;ud les séparant) sera le caractère dont 
    le poids est le plus faible. On va pour cela effectuer une nouvelle opération 
    sur les arbres binaires&nbsp;: la fusion simple. On va l&#146;illustrer sur 
    un exemple&nbsp;:</font></p>
  
<p align="center"><font size="2"><img src="images/crypto/fusion.gif"
width="630" height="230"></font></p>
  <p align="center">&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va ainsi fusionner 
    chacun des arbres de la liste chaînée. Dans quel ordre opérer&nbsp;? La fusion 
    se fait à chaque fois sur les 2 plus petits couples de poids le plus faible. 
    Etant donnée, que la liste est triée, il suffira à chaque fois de fusionner 
    les deux premiers couples.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On peut d&#146;hors 
    et déjà faire deux remarques importantes&nbsp;:</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">-Apres avoir 
    fusionner deux arbres, il faudra replacer le nouvelle arbre dans la liste 
    chaîné. En effet, notre hypothèse de travail suppose que les deux plus petit 
    arbres de poids le plus faible sont situé en tête de liste. Donc, il faudra 
    créer une procédure pour insérer l&#146;arbre au bon endroit dans la liste 
    chaîné.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">-Si plusieurs 
    arbres de la listes chaînée ont le même poids, on fera un sous tri. On classera 
    les arbres par ordre décroissant de taille des chaînes. Donnons un exemple&nbsp;:</font></p>
  
<p align="center"><font size="2"><img src="images/crypto/tri.gif" width="578"
height="110"></font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va maintenant 
    suivre l&#146;algorithme de fusion décrit précédent étape par étape&nbsp;:</font></p>
  
<p align="center"><font size="2"><img src="images/crypto/h1.gif" width="672"
height="190"></font></p>
  
<p align="center"><font size="2"><img src="images/crypto/h2.gif" width="623"
height="211"></font></p>
  
<p align="center"><font size="2"><img src="images/crypto/h3.gif" width="604"
height="192"></font></p>
  
<p align="center"><font size="2"><img src="images/crypto/h4.gif" width="651"
height="211"></font></p>
  
<p align="center"><font size="2"><img src="images/crypto/h5.gif" width="593"
height="271"></font></p>
  
<p align="center"><font size="2"><img src="images/crypto/h6.gif" width="663"
height="257"></font></p>
  
<p align="center"><img src="images/crypto/h7.gif" width="686" height="322"></p>
  
<p align="center"><img src="images/crypto/h8.gif" width="694" height="313"></p>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">OUF&nbsp;!</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">J&#146;ai détaillé 
    chaque étape de la construction de l&#146;arbre (celle que nous suivrons d&#146;ailleurs). 
    On tiens bien compte à chaque fois des règles gérant la construction de l&#146;arbre 
    (notamment le cas où les poids sont égaux).</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va maintenant 
    prendre un point de vue un peu plus général&nbsp;; notre arbre ressemble finalement 
    à ça&nbsp;:</font></p>
  
<p><font size="2"><img src="images/crypto/squelette.gif" width="622"
height="253"></font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On a ici le squelette 
    de l&#146;arbre précédent. On peut déjà constater 2 choses. Tout d&#146;abord, 
    les feuilles de l&#146;arbre sont constituées par les caractères présent dans 
    le fichier&nbsp;: ceci est en fait une évidence lorsque l&#146;on regarde 
    comment à été construit l&#146;arbre. Ensuite, on constate un point fondamentale 
    du codage de Huffman&nbsp;: les caractères de poids le plus forts sont situés 
    en hauteur dans l&#146;arbre (t,i) tandis que les caractères de poids le plus 
    faible sont eux placé en bas de l&#146;arbre (n, o, p..). On a donc créé un 
    algorithme permettant de séparer les caractères de poids faible et de poids 
    important.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Afin d&#146;utiliser 
    ces propriétés de l&#146;arbre de Huffman, on va orienter l&#146;arbre. Pour 
    se déplacer sur le sous arbre gauche, on comptera 0 et pour se déplacer vers 
    la droite on comptera 1.</font></p>
  
<p><font size="2"><img src="images/crypto/parcour.gif" width="602" height="337"></font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va donc recoder 
    entièrement les caractères présents dans le fichier en déterminant le chemin 
    à suivre pour chaque arbre. On obtient donc le tableau suivant&nbsp;:</font></p>
  <table border="1" cellpadding="4" cellspacing="1" width="165">
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">_</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">000</font></p>
      </td>
    </tr>
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">a</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">001</font></p>
      </td>
    </tr>
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">t</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">01</font></p>
      </td>
    </tr>
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">o</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1000</font></p>
      </td>
    </tr>
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">n</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1001</font></p>
      </td>
    </tr>
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">p</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1010</font></p>
      </td>
    </tr>
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">k</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1011</font></p>
      </td>
    </tr>
    <tr> 
      <td valign="top" width="49%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">i</font></p>
      </td>
      <td valign="top" width="51%"> 
        <p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif">11</font></p>
      </td>
    </tr>
  </table>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On constate bien 
    le codage en fréquence dont on parlait au début de l&#146;article. Les caractères 
    les plus fréquents sont codés avec un nombre de bit moindre (conséquence directe 
    de leur place dans l&#146;arbre).</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le recodage des 
    caractères est remarquable à première vu, mais il faut bien voir qu&#146;à 
    chaque arbre associe son recodage. Il faudra lors de la décompression trouver 
    le moyen de reconstituer cette arbre pour retrouver le code de chaque caractère.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Un rapide calcul 
    montre que sans compression de Huffman, il faut 17 *8 bits = 136 bits. Tandis 
    qu&#146;en utilisant le tableau précédent, la phrase &quot;&nbsp;tipiak_ititiation&nbsp;&quot; 
    ce code avec les bits suivants&nbsp;:</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">01 11 1010 11 
    001 1011 000 11 01 11 01 11 001 01 11 1000 1001 soit 45 bits. On comblera 
    les bits par des zéros pour avoir un multiple de 8.</font></p>
  <p>&nbsp;</p>
  <blockquote> 
    <p><font color="#FF0000" size="3"><strong><u><font face="Verdana, Arial, Helvetica, sans-serif" size="2">2- 
      Décodage</font></u></strong></font></p>
    <p>&nbsp;</p>
  </blockquote>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Pour le décodage 
    d&#146;une séquence binaire, il faut bien garder à l&#146;esprit qu&#146;à 
    un fichier compressé correspond un et un seul arbre. Donc, on ne pourra dissocier 
    arbre et fichier binaire. Ainsi, si je reçoie la séquence précédente&nbsp;: 
    01 11 1010 11 001 1011 000 11 01 11 01 11 001 01 11 1000 1001 il suffira de 
    parcourir l&#146;arbre précédent pour retrouver de manière unique la phrase 
    &quot;&nbsp;tipiak_ititiation&nbsp;&quot;.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Toute la difficulté 
    réside donc dans le fait de pouvoir stocker l&#146;arbre dans un fichier.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Quelques propriétés 
    du codage de Huffman</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le codage de 
    Huffman possède 3 propriétés intéressantes&nbsp;:</font></p>
  <ul>
    <li><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Affixe&nbsp;: 
      Il n&#146;a pas besoin comme on l&#146;avais évoqué dans l&#146;introduction 
      de caractère delimitateur entre chaque caractère recodé. La séparation des 
      caractères se fait de manière unique lors du parcours de l&#146;arbre&nbsp;: 
      on a fini un caractère lorsque l&#146;on atteint une feuille.</font></li>
    <li><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Fragile&nbsp;: 
      S&#146;il manque 1 seul bit, l&#146;ensemble du décodage est corrompu. C&#146;est 
      pourquoi on associe souvent une fonction de hachage afin de vérifier l&#146;intégrité 
      du fichier.</font></li>
    <li><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Optimal&nbsp;: 
      Attention, il faut bien comprendre ce que signifie le terme optimal ici. 
      On désigne un code optimal comme étant le meilleur de sa catégorie&nbsp;: 
      on ne peut construire d&#146;algorithme plus performant que le codage de 
      Huffman dans le codage caractère par caractère. C&#146;est d&#146;ailleurs 
      ce qui confère au codage de Huffman sa popularité&nbsp;: il est optimal 
      du point de vue de la théorie de l&#146;information.</font></li>
  </ul>
  <p><font size="2"></font>&nbsp;</p>
  
<p><font color="#FF0000" size="4"><strong><u><font face="Verdana, Arial, Helvetica, sans-serif" size="2">III- 
  CODING</font></u></strong></font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><a
href="files/Huffman.pas">file:huffman.pas</a></font></p>
  
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Nous venons de 
  voir la théorie, passons à la pratique&#133;</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le codage de 
    Huffman est assez délicat à implémenter mais il se révèle un véritable jeux 
    d&#146;enfant si on pense à poser correctement les objets avec lesquels on 
    va manipuler&nbsp;: arbre, liste, couple&#133;.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Je vous préviens 
    tout de suite que la manière dont je vais programmer le code de Huffman n&#146;est 
    absolument pas la meilleure mais n&#146;est pas non-plus obsolète. Sans entrée 
    dans la théorie de la complexité, si une procédures doit ce codé en un temps 
    proportionnel à log(n) (parcours d&#146;un arbre) alors les procédures qu 
    vont suivre respecteront ce temps de parcours. Par contre une optimisation 
    pourrai se faire au niveau des cycles par exemple. (Chose perdu d&#146;avance 
    pour un programme écrit en pascal&nbsp;:-)</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Commençons donc 
    naturellement par les Type de données&nbsp;:</font></p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">CONST 
        nb_car_max= 255 ; { Nombre de caractère maximal à dénombrer &#150; On 
        travail ici avec des octets</font> 
        <p><font size="2" face="Courier New, Courier, mono">On pourrait envisager 
          travailler avec des nibbles }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">TYPE</font></p>
        <p><font size="2" face="Courier New, Courier, mono">str = string[nb_car_max]; 
          { Type chaîne pour la concaténation des caractères }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">tab_car = array [1..nb_car_max] 
          of char; { Caractère présent sur les nb_car_max }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">tab_int = array [1..nb_car_max] 
          of longint; { Nombre d'occurence &#150; on utilise un longint}</font></p>
        <p><font size="2" face="Courier New, Courier, mono">paire = record</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">poids: longint; 
            { on reprend les notations lors de la description de l&#146;algorithme 
            }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">chaine: str;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">arbre = ^n&#156;ud; 
          { Structure d'arbre binaire avec ( poids, chaine ) }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">noeud = record</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">info: paire</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">fg,fd: arbre;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">pdoublet= ^doublet;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">doublet = record</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">rac: arbre; { Structure 
            de liste chainé dont la composante est un couple (arbre, poids) }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">suiv: pdoublet;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va poser un 
    certain nombre de variable global pour éviter de trop gros passage en argument.</font></p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">VAR</font> 
        <p><font size="2" face="Courier New, Courier, mono">VarBit : array [1..8] 
          of byte ; { Contient les puissances de 2 }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">nb_car : longint; 
          { Nombre de caractère distinct }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">frequence: tab_int; 
          { cf. Déclaration des types }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">car : tab_car;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BufferTexte : string; 
          {Stockage temporaire du code binaire en string &#150; On verra par la 
          suite son usage }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">huff : arbre; { Arbre 
          de Huffman }</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Comme dans tous 
    programmes, il y la phase d&#146;initialisation des données&nbsp;:</font></p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">PROCEDURE 
        Initialisations(nomfichier: string);</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Lecture du fichier 
          et mise-a-jour des tableaux pour construire l'arbre }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR j:longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">PROCEDURE Initialisations(nomfichier: 
          string);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">{ Lecture du fichier 
          et mise-a-jour des tableaux pour construire l'arbre }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR j:longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">car_cour:char;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">entree: file of char;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">nb_car:=0;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">for j:=1 to nb_car_max 
          do begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">frequence[j]:=0; 
            { On mets à zeros les differents tableaux pou la construction</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">car[j]:='0';</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">assign(entree, nomfichier); 
          { Ouverture du fichier }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">reset(entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while not(eof(entree)) 
          do begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">read(entree,car_cour); 
            { OPTIMISATION&nbsp;: On pourrait utiliser un buffer pour accelerer 
            par 1000 les transferts fichier par exemple }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">j:=1;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">WHILE (j&lt;=nb_car) 
            and (car_cour &lt;&gt; car[j]) do inc(j);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">if (j&gt;nb_car) 
            then begin</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">car[j]:=car_cour; 
            { Tant que le fichier n&#146;est pas fini, on incrémente les différents 
            compteur&nbsp;: présence du caractère ou poids du caractère }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">inc(nb_car);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">frequence[j]:= frequence[j]+1;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">close(entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va commencer 
    l&#146;algorithme de création&nbsp;: construction de la liste chaînée initiale. 
    Pour cela on va créer 2 procédures&nbsp;: une procédure d&#146;insertion et 
    une procédure de création.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La procédure 
    d&#146;insertion aura pour but d&#146;insérer dans la liste un couple (caractère, 
    poids) (c&#146;est-à-dire un arbre sans fils)&nbsp;; cette procédure devra 
    insérer au bon endroit en respectant l&#146;ordre des poids (ordre décroissant 
    d&#146;après les explications de l&#146;algorithme). Afin d&#146;anticiper 
    sur ce qui va suivre, on va prendre en compte le cas particulier ou plusieurs 
    couples ont le même poids. D&#146;après la description de l&#146;algorithme, 
    il faut dans ce cas trier dans l&#146;ordre décroissant les chaînons.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La procédure 
    de création suit le schéma classique de la création d&#146;une liste trié. 
    On commence par un liste vide NIL et on insère au fur et à mesure les couples 
    recensé par Initialisation. On obtient ainsi les procédures suivantes&nbsp;:</font></p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">FUNCTION 
        Insere(d, lst: pdoublet): pdoublet;</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Insertion dans la 
          liste chainée triée }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">{ Argument&nbsp;: 
          d à inserer dans lst }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">if (lst=nil) then 
          insere:=d</font></p>
        <p><font size="2" face="Courier New, Courier, mono">else</font></p>
        <p><font size="2" face="Courier New, Courier, mono">IF (d^.rac^.info.poids&lt;=lst^.rac^.info.poids) 
          then begin { Première relation d&#146;ordre }</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">if (d^.rac^.info.poids=lst^.rac^.info.poids) 
            and</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">(length(d^.rac^.info.chaine)&lt;=length(lst^.rac^.info.cha 
            ne)) then { 2nd relation d&#146;ordre }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">{ Cas d&#146;égalité 
            }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">begin</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">d^.suiv:=lst;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">insere:= d;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">else begin</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">lst^.suiv:= insere(d, 
            lst^.suiv); { Insertion en tête &#150; Appel Récursif }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">insere:= lst;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">else begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">lst^.suiv:= insere(d, 
            lst^.suiv); { Insertion en tête &#150; Appel Récursif}</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">insere:= lst;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">FUNCTION 
        CreerListe : pdoublet;</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Création de la liste 
          initiale (triée) avant de faire les fusions des cases de poids le moins 
          fort }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR d,liste_provisoire:pdoublet;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">arb_solo:arbre;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">j:longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">liste_provisoire:=nil;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">for j:=1 to nb_car 
          do begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">new(arb_solo);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">arb_solo^.info.chaine:=car[j];</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">arb_solo^.info.poids:= 
            frequence[j];</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">arb_solo^.fg:=nil;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">arb_solo^.fd:=nil;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">new(d);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">d^.rac:=arb_solo;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">d^.suiv:=Nil;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">liste_provisoire:=Insere(d, 
            liste_provisoire);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">Creerliste:=liste_provisoire;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  
<p><font size="2"><img src="images/crypto/insertion.gif" width="356"
height="207"></font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On commence maintenant 
    la fusion des arbres pour créer l&#146;arbre de Huffman. Afin d&#146;alléger 
    le code, on va utiliser une procédure Fusion, dont le but (vous l&#146;aurez 
    deviné&nbsp;:-) est de fusionner deux arbres vu dans la description de l&#146;algorithme. 
    La procédure CreerArbre va fusionner à chaque fois les deux plus petits couples 
    de poids le plus faible (c&#146;est-à-dire les deux premiers chainons de la 
    liste car celle-ci est triée) jusqu&#146;à obtenir un seul et unique chaînon. 
    Ceci marque en effet la fin de la création de l&#146;arbre.</font></p>
  <p>&nbsp;</p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">FUNCTION 
        Fusion(a1, a2:arbre) :arbre;</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Fusion de 2 arbres 
          }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR a:arbre;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">new(a);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">a^.info.chaine:=concat(a1^.info.chaine, 
          a2^.info.chaine); {Fusion simple d&#146;arbre }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">a^.info.poids:=a1^.info.poids+a2^.info.poids;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">a^.fg:=a1;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">a^.fd:=a2;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">fusion:=a;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">FUNCTION 
        CreerArbre(lst: pdoublet): arbre;</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Création de l'arbre 
          de Huffman en effectuant des fusions successives }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR p:pdoublet;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">a:arbre;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">p:=lst;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while (p^.suiv &lt;&gt; 
          nil) do begin {Tant que la liste est non vide }</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">a:=fusion(p^.rac, 
            p^.suiv^.rac); { On fusionne les 2 premiers chaînons }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">lst:=p^.suiv^.suiv;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">p^.rac:=a;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">p^.suiv:=nil;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">p:=Insere(p, lst); 
            { et on insère le nouvelle arbre dans le liste trié }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">CreerArbre:=p^.rac;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La fonction renvoie 
    l&#146;arbre de Huffman. Il nous reste maintenant à chaque fois à parcourir 
    l&#146;arbre pour retrouver le code d&#146;un caractère (suivant la méthode 
    décrite dans l&#146;algorithme&nbsp;: 1 à droite, 0 à gauche). Le première 
    idée que l&#146;on pourrais avoir serait de placer exactement dans un tableau 
    les n valeurs de recodage des caractères présents dans le fichier. Mais nous 
    perdons là tout l&#146;intérêt d&#146;arbre binaire&nbsp;! Souvenez vous dans 
    l&#146;article précédent nous avons vu comment la recherche dans un ABR (Arbre 
    Binaire de Recherche) est rapide Ici ce ne sont pas les nombres qui font notre 
    relation d&#146;ordre mais l&#146;appartenance ou non du caractère dans la 
    chaîne. Pour parcourir cette arbre on va étudier si le caractère que l&#146;on 
    veut coder est oui ou non dans le sous-arbre choisi par exemple&nbsp;:</font></p>
  
<p><font size="2"><img src="images/crypto/ln.gif" width="743" height="330"></font></p>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On voit donc 
    qu&#146;on retrouve bien notre structure d&#146;ABR de l&#146;article précédent</font></p>
  <p>&nbsp;</p>
  
<p><img src="images/crypto/Image0.gif" width="786" height="344"></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Tout cela pour 
    dire qu&#146;il faut favoriser cette structure pour retrouver un temps de 
    recherche en ln(n). Le temps de recherche dans un ABR est beaucoup plus court 
    que dans un tableau par exemple.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Reste maintenant 
    à écrire cette procédure de recherche. Pour cela on va d&#146;abord écrire 
    une procédure d&#146;appartenance à une chaîne de caractère&nbsp;:</font></p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">FUNCTION 
        Appartient(c: char ; ch: str): boolean;</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Teste si c est dans 
          ch }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR j,l:longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">l:=length(ch);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">j:=1;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while ((j&lt;=l) and 
          (c &lt;&gt; ch[j])) do inc(j); {On parcours la chaîne sans jamais dépasser 
          la taille de la chaîne }</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">if (j&gt;l) then 
            appartient:= false else appartient:= true;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Dans la fonction 
    code_un_car, on va tout simplement parcourir l&#146;arbre jusqu&#146;à obtenir 
    la feuille désirée. On se promène dans l&#146;arbre en testant à chaque fois 
    l&#146;appartenance du caractère dans les chaînes des sous arbres.</font></p>
  <p>&nbsp;</p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">FUNCTION 
        Code_un_car(c:char; huff:arbre):string;</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Retourne l'équivalent 
          d'un caractère dans l'arbre de Huffman }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR i:integer;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">h_g:arbre;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">s,zero,un:string; 
          { s contiendra un string contenant la traduction du code en binaire 
          010 ó &quot;&nbsp;010&nbsp;&quot;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">i:=0;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">zero:='0';</font></p>
        <p><font size="2" face="Courier New, Courier, mono">un:='1';</font></p>
        <p><font size="2" face="Courier New, Courier, mono">s:='';</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while length(huff^.info.chaine)&gt;1 
          do begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">inc(i);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">h_g:=huff^.fg;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">if Appartient(c, 
            h_g^.info.chaine) { Si le caractère appartient u sous arbre gauche 
            alors +&nbsp;&quot;&nbsp;0&nbsp;&quot; } then begin</font></p>
        </blockquote>
        <blockquote> 
          <blockquote> 
            <p><font size="2" face="Courier New, Courier, mono">s:=concat(s,zero);</font></p>
          </blockquote>
        </blockquote>
        <blockquote> 
          <blockquote> 
            <p><font size="2" face="Courier New, Courier, mono">huff:=h_g;</font></p>
          </blockquote>
        </blockquote>
        <blockquote> 
          <blockquote> 
            <p><font size="2" face="Courier New, Courier, mono">end</font></p>
          </blockquote>
        </blockquote>
        <blockquote> 
          <blockquote> 
            <p><font size="2" face="Courier New, Courier, mono">else begin { sinon 
              +&nbsp;&quot;&nbsp;1&nbsp;&quot; }</font></p>
          </blockquote>
        </blockquote>
        <blockquote> 
          <blockquote> 
            <p><font size="2" face="Courier New, Courier, mono">s:=concat(s,un);</font></p>
          </blockquote>
        </blockquote>
        <blockquote> 
          <blockquote> 
            <p><font size="2" face="Courier New, Courier, mono">huff:=huff^.fd;</font></p>
          </blockquote>
        </blockquote>
        <blockquote> 
          <blockquote> 
            <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
          </blockquote>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">code_un_car:=s; { 
          On renvoie la traduction binaire du code considéré }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On arrive au 
    point final du codage de Huffman&nbsp;: la compression effective du fichier. 
    Ici le codage est relativement délicat car on est (pour la première fois) 
    confronté à une difficulté technique qu&#146;il faudra contourner. Il faut 
    savoir que l&#146;écriture et la lecture d&#146;un fichier ne peut se faire 
    que par multiple de 8 bits. On ne peut concevoir d&#146;écrire bit par bit 
    le fichier informatique. On va donc utiliser un buffer de 8 bits (un buffer 
    plus grand augmenterai encore la vitesse de transfert mais on s&#146;égarerai 
    de l&#146;objectif de ce tutorial). Souvent le codage d&#146;un caractère 
    entraînera un code inférieur à 8 bits&nbsp;: il faudra attendre un autre caractère 
    pour que (au moins) 8 bits du buffer soit présent. Là seulement on pourra 
    écrire physiquement sur le disque dur. Afin de prévoir la décompression du 
    fichier, on va stocker la taille initiale du fichier traiter.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le but de ce 
    tutorial est de coder la méthode de Huffman et en aucun cas de construire 
    un logiciel de compression de données. C&#146;est pourquoi le même programme 
    compressera et décompressera un fichier. Ceci implique une chose&nbsp;: le 
    programme ne stocke pas l&#146;arbre dans le fichier. Un véritable logiciel 
    stockerai dans un header l&#146;arbre afin d&#146;obtenir un file totalement 
    indépendant. Ici on simplifie le problème en gardant en mémoire vive l&#146;arbre 
    de Huffman. Je restreint donc délibérément l&#146;usage de ce programme comme 
    programme d&#146;application. Toutefois, ceux qui sont intéressé ou éprouve 
    des difficultés à concrétiser un tel header peuvent toujours me joindre à 
    mon adresse email, je me ferai un plaisir de leurs expliquer. Par ailleurs, 
    ceci est un très bon exemple pour évaluer votre autonomie à un moment donner 
    de l&#146;explication du codage de Huffman.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">En accord avec 
    ce qui suit on trouve donc la procédure suivante pour compresser un fichier&nbsp;:</font></p>
  <table border="1" cellpadding="4" cellspacing="1" width="614">
    <tr> 
      <td valign="top"><font size="2" face="Courier New, Courier, mono">PROCEDURE 
        CompressFichier(nom_entree, nom_sortie:string;arb: arbre);</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Compression du fichier 
          nom_entree =&gt; nom_sortie grace à l'arbre arb }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR entree: File of 
          char;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">sortie: File of byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">sortie_temp: file 
          of longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">L : longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">i,j:longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">temp: byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">PROCEDURE LectureBufferTexte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">{ Ajoute un caractère 
          au buffer &#150; on parle ici du code binaire équivalen t}</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR temp:string;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">buff:char;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">read(entree,Buff);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">temp:=Code_un_car(Buff, 
          arb);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BufferTexte:=Concat(BufferTexte,temp);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">FUNCTION GetByte:byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">{ Convertit le buffer 
          en sa représentation binaire }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR i,bit:byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">bit:=0;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">For i:=1 to 8 do</font></p>
        <p><font size="2" face="Courier New, Courier, mono">if (BufferTexte[i]='1') 
          then begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">bit:= bit or VARBit[i]; 
            { on utilise les puissances de 2 }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">Delete(BufferTexte, 
          1 ,8);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">GetByte:=bit;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">PROCEDURE EcritureBuffer;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">{ Ecriture du buffer 
          dans le fichier }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR temp:byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while (length(BufferTexte)&gt;=8) 
          do begin{ Des que 8 bits sont retenue on ecris sur le disque dur }</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">temp:= GetByte;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">write(sortie, temp);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">PROCEDURE ClearBuffer;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">{ Purge les bits restant 
          du buffer }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR bit:byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">i:integer;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">bit:=0;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">for i:=1 to length(BufferTexte) 
          do</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">if (BufferTexte[i]='1') 
            then bit:= bit or VARBit[i];</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">write(sortie, bit);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN { Procedure 
          principale }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">assign(entree, nom_entree); 
          { ouverture du fichier en lecture }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">reset(entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">assign(sortie_temp, 
          nom_sortie);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">rewrite(sortie_temp);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">L:=Filesize(entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">write(sortie_temp, 
          L); { Ecriture de la taille du fichier }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">close(sortie_temp);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">assign(sortie, nom_sortie); 
          { ouverture du fichier en écriture }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">reset(sortie);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">seek(sortie, Filesize(sortie));</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BufferTexte:=''; { 
          buffer initialement vide }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while not(eof(entree)) 
          do begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">LectureBufferTexte; 
            { On ajoute un caractère au buffer }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">EcritureBuffer; 
            { On écris si on peut }</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">ClearBuffer; { on 
          purge tout le buffer }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">close(sortie);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">close(entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Entamons maintenant 
    la phase de décompression. Comme évoqué précédemment, on suppose que l&#146;arbre 
    déjà en mémoire. Il suffirait dans le cas pratique de le stocker dans le fichier 
    compressé en prenant garde de ne pas gaspiller les octets précieusement gagnés&nbsp;:) 
    La décompression est beaucoup plus rapide que la compression. On décompte 
    bit par bit le fichier. Et on parcours au fur et à mesure l&#146;arbre suivant 
    les bits reçu. La procédure de décompression en deviens naturelle. On utilise 
    la taille du fichier précédemment stocké dans le header comme condition d&#146;arrêt.</font></p>
  <p>&nbsp;</p>
  <table border="1" cellpadding="4" cellspacing="1">
    <tr> 
      <td><font size="2" face="Courier New, Courier, mono">PROCEDURE DecompressFichier(nom_entree, 
        nom_sortie:string ;arb:arbre);</font> 
        <p><font size="2" face="Courier New, Courier, mono">{ Parcours de l'arbre 
          à chaque caractère lu }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">{ Sortie dans le fichier 
          nom_sortie }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR entree: File of 
          byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">sortie: File of char;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">entree_temp: File 
          of Longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">L,j:longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">bit,octet:byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">i,k:longint;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">c:char;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">FUNCTION Decodecar(arb:arbre 
          ; VAR i:longint; VAR bit:byte) :char;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">VAR stop:boolean;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">bit_temp: byte;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">stop:=false;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while (not(stop) and 
          not(keypressed) )do begin</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while ((i&lt;=8) and 
          not(stop)) do begin</font></p>
        <p><font size="2" face="Courier New, Courier, mono">bit_temp := bit and 
          VARBit[i];</font></p>
        <p><font size="2" face="Courier New, Courier, mono">if (bit_temp=VARBit[i]) 
          then begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">arb:=arb^.fd;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">else begin</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">arb:=arb^.fg;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">inc(i);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">if (length(arb^.info.chaine)=1) 
          then begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">stop:=true;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">DecodeCar:=arb^.info.chaine[1];</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">if (i&gt;8) then begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">i:=1;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">read(entree, bit);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">BEGIN</font></p>
        <p><font size="2" face="Courier New, Courier, mono">assign(entree_temp, 
          nom_entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">reset(entree_temp);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">read(entree_temp, 
          L);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">assign(entree, nom_entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">assign(sortie, nom_sortie);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">reset(entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">seek(entree, 4);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">rewrite(sortie); { 
          lecture de la taille du fchier }</font></p>
        <p><font size="2" face="Courier New, Courier, mono">read(entree, bit);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">i:=1;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">j:=1;</font></p>
        <p><font size="2" face="Courier New, Courier, mono">while ((j&lt;L) and 
          not(keypressed) )do begin</font></p>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">inc(j) ;</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">c:=DecodeCar(arb,i,bit);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">write(sortie,c);</font></p>
        </blockquote>
        <blockquote> 
          <p><font size="2" face="Courier New, Courier, mono">end;</font></p>
        </blockquote>
        <p><font size="2" face="Courier New, Courier, mono">close(sortie);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">close(entree);</font></p>
        <p><font size="2" face="Courier New, Courier, mono">END;</font></p>
      </td>
    </tr>
  </table>
  <p>&nbsp;</p>
  <p><font color="#FF0000" size="4"><strong><u><font face="Verdana, Arial, Helvetica, sans-serif" size="2">IV- 
    LIMITATION DU PROGRAMME</font></u></strong></font></p>
  <p>&nbsp;</p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Si on relie la 
    démarche suivie, on tiens en compte que le fichier possède des caractéristiques 
    statistiques particulières (fréquence d&#146;un caractère particulièrement 
    élevé). Toutefois, il arrive que ces singularités n&#146;apparaissent pas 
    sur certain type de fichier. Dans de telle situation le codage de Huffman 
    est catastrophique&nbsp;: le fichier compressé est parfois plus grand que 
    le fichier non-compressé&nbsp;! On comprendra donc pourquoi le programme précédent 
    fonctionne surtout pour les fichiers images et textes.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Il faut savoir 
    que les méthodes utilisées par Winzip sont des méthode dites Lempev Ziv ou 
    compression par dictionnaire. L&#146;idée générale est la même que pour la 
    compression de Huffman, mise à part qu&#146;au lieu de traiter un seul et 
    unique caractère, on traite un mot entier. Dans un tableau on répertorie les 
    mots les plus fréquemment utilisés et on détermine un code plus court pour 
    représenter ces mots. Le codage de la méthode par dictionnaire sera peut-être 
    évoquées dans de futurs articles.</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Les sources gracieusement 
    offertes ne vous donneront en aucun cas après compilation d&#146;un logiciel 
    tout fait. Afin d&#146;en obtenir un, il vous faudra mettre main à la patte&nbsp;; 
    d&#146;une part en intégrant dans le header l&#146;arbre binaire (je répète 
    qu&#146;en cas de difficulté vous pouvez toujours me mailer&nbsp;:), d&#146;autre 
    part il faudra séparer le programme de compression et décompression pour mettre 
    inline vos arguments (fichier compressé etc)&#133; Et après même tout ces 
    efforts vous risquez d&#146;être déçu par les résultats obtenu mais croyez 
    moi vous aurez appris déjà beaucoup&#133;.</font></p>
  <p>&nbsp;</p>
  <hr>
  <p><font color="#FFFFFF" size="2"
face="Verdana, Arial, Helvetica, sans-serif">Pour toutes questions, commentaires, 
    critiques, erreurs:</font><font
color="#FFFFFF"> </font><a href="mailto:sabrina@inorbit.com"><font
size="2" face="Verdana, Arial, Helvetica, sans-serif">sabrina@inorbit.com</font></a></p>
<p></p>
</body>
</html>
