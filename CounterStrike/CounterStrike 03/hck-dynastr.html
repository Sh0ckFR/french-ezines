<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Sabrina Generator">
<title>LISTE CHAINEE ET ARBRE BINAIRE</title>
</head>

<body bgcolor="#FFFFF8" text="#000000" link="#339966" vlink="#339966" alink="#339966">
<table width="283" border="0" cellspacing="0" cellpadding="0" background="IMAGES/fnd_stitre.jpg" height="40">
  <tr> 
    <td width="23">&nbsp;</td>
    <td width="294"><font face="Verdana, Arial, Helvetica, sans-serif" font color="#CCCCCC" size="2">STRUCTURES 
      DYNAMIQUES </font></td>
  </tr>
</table>
<p align="left"><br>
  <font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>I- 
  TEMPS ET ESPACE D'UN PROGRAMME</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>II- 
  STRUCTURES DE DONNEES</u></strong></font></p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>1-LES 
    TABLEAUX</u></strong></font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>2- 
    LISTE CHAINEE</u></strong></font></p>
</blockquote>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>3- 
    STRUCTURE D'ARBRE BINAIRE </u></strong>(On se limite au cas des ABR)</font></p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>III- 
  POUR ALLER UN PEU PLUS LOIN</u></strong></font></p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>1- 
    LES AVL</u></strong></font></p>
</blockquote>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>2- 
    LES n-ARBRES</u></strong></font></p>
</blockquote>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>3- 
    2 EXEMPLES D'APPLICATION</u></strong></font></p>
</blockquote>
<p align="center"><img src="images/split.jpg" width="600" height="25"></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="2">L'ensemble des 
  procédures sont en PASCAL. S'il y a suffisament de demande une version en C/C++ 
  sera disponible.</font></p>
<p><font face="Verdana, Arial, Helvetica, sans-serif" size="2">Sources Pascal 
  disponible: <a href="bin/ABR.PAS">abr.pas</a> <a href="bin/FILE.PAS">file.pas</a> 
  <a
href="bin/PILE.PAS">pile.pas</a></font></p>
<p align="center"><img src="images/split.jpg" width="600" height="25"></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Lorsque les premiers 
  ordinateurs apparurent, ceux-ci ne possédez que très peu de mémoire et chaque 
  octet étaient précieux. Ainsi, les informaticiens ont créé des structures de 
  données permettant d'utiliser le moins de place possible. Par ailleurs, ces 
  structures de données avaient l'avantage supplémentaire d'être ultrarapide.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">A l'heure où les 
  données se comptent en Tera-octet et où les fréquences d'horloge frisent le 
  Giga-Hertz, il est normal de remettre en cause de tel structure de données. 
  Il ne faut pas se le cacher, le traitement de l'information a lui aussi augmenté 
  proportionnellement à la taille des disques durs. Le problème est maintenant 
  devenu: Comment gérer de telles informations ? Ceci ne réduisant absolument 
  pas l'importance de ces structures de données.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Pour bien comprendre 
  l'importance de structure de liste chaînée et Arbre binaire, nous allons commencer 
  par évoquer/rappeler la notion d'espace et de temps dans un programme.</font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>I- TEMPS 
  ET ESPACE D'UN PROGRAMME</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Si un jour vous 
  voulez programmer quelque chose d'un peu sérieux, vous serez amené à négocier 
  certains paramètres intrinsèques d'un programme. Dans ces grandes lignes, un 
  programme peut être caractériser par 4 points: Le temps, L'espace, La portabilité 
  et L'évolution.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le temps est souvent 
  le paramètre le plus important d'un programme. Il détermine si le programme 
  fait son travail en un temps raisonnable. Par exemple, un traitement de texte, 
  prenant 1 sec à afficher un caractère frappé, n'a pas un temps raisonnable. 
  Par contre, un programme décryptant un ficher de password Unix de 100 user en 
  1 heure sera considéré comme un programme plus que raisonnable. Voir peut-être 
  trop raisonnable car il a du certainement sacrifier d'autres critères&#133;</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">L'espace, on désigne 
  par ce terme la place que nécessite un programme. Pour reprendre les exemples 
  précédents, on peut dire que le traitement de texte prenant 1sec pour afficher 
  une touche mais ne nécessitant que quelques centaines d'octets pour fonctionner 
  sera (contrairement à ce que l'on pouvait d'abord imaginer) un très bon traitement 
  de texte. Par contre, notre programme de décryptage, utilisant 1 Tera-Octet 
  de texte pour effectuer une attaque en 1 heure, sera tout simplement inexploitable 
  car trop gourmand en mémoire.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La portabilité 
  est la faculté qu'à un programme à s'adapter à une situation : changement de 
  système d'exploitation, erreur non-géré&#133; Tandis que l'évolution sera considérée 
  comme la facilité à mettre à jour le programme. Mais nous ne nous intéressons 
  pas à ces aspects pour la suite.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ainsi, nos deux 
  programmes ont semblé dans un premier temps obsolète pour l'un (le traitement 
  de texte) et extraordinaire pour l'autre (programme de décryptage). Or, ces 
  programmes seront tout à fait adapter pour d'abord une machine ne disposant 
  que de quelques kilo-octets de mémoire et ensuite une machine possédant une 
  RAM de 1 Tera-Octet. On a touchait là le point essentiel du choix d'une structure 
  de données: Evaluez la structure en fonction de vos besoins.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Nous allons voir 
  ici la structure de liste chaînée permettant de perdre en vitesse et gagné en 
  mémoire. Puis, la structure d'Arbre Binaire gagnant, elle, sur les 2 critères. 
  Toutefois, par soucis de clarté, nous allons faire un rappel sur la structure 
  de tableau.</font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>II- 
  STRUCTURES DE DONNEES</u></strong></font></p>
<p>&nbsp;</p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>1-LES 
    TABLEAUX</u></strong></font></p>
  <p>&nbsp;</p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le tableau (array) 
  est la première donnée comme vous avez du connaître. Intuitive et simple, elle 
  est présente dans tous les langages de programmations évolués. Elle fait parti 
  des structures dites statiques car fixé une fois pour tout lors de l'exécution 
  d'un programme. Sa déclaration précise toujours la taille du tableau. Celle-ci 
  doit être de type constant, quel que soit le langage utilisé.</font></p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">En C: int tab[100];</font></p>
</blockquote>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">En Pascal: tab 
    : array[1..100] of integer;</font></p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ces déclarations 
  précisent la création d'un tableau de 100 entiers: l'allocation mémoire de 100 
  fois la taille d'un integer. </font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>AVANTAGE 
      DU TYPE TABLEAU</u></strong></font></p>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le type tableau 
  donne un accès immédiat à l'élément désigner: il représente physiquement une 
  adresse. Par ailleurs, le tableau est assez simple d'utilisation. Les procédures 
  d'écriture, de lecture du tableau tiennent souvent en une seule ligne de code. 
  Le tableau permet d'avoir un code source précis et clair. Ce point est fondamental 
  pour quiconque ne désirant pas un programme ultra performant, lisible et facilement 
  modifiable. Par ailleurs, un avantage qui paraîtra après comme un défaut: la 
  taille du tableau est fixée. Le programmeur sait donc exactement quelle taille 
  il occupe et les limites inférieures et supérieures pour y accéder.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>INCONVENIENT</u></strong></font></p>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Comme nous l'avons 
  évoqué précédemment, la structure Tableau fait parti des structures dites statiques 
  qui comme toutes les structures statiques ont le défaut d'avoir une taille fixe 
  durant toute l'exécution du programme. C'est-à-dire qu'elle n'évolue pas en 
  fonction de la demande du programme. Prenons l'exemple d'un programme gérant 
  le stockage d'une succession de login/password. On va d'abord créer un tableau 
  T de taille 100 par exemple. Votre programme fonctionnera correctement tant 
  que votre nombre de login/password n'excédera pas 100 entrés. Mais si vous n'avez 
  pas géré une procédure de contrôle, votre programme aura un comportement plus 
  que particulier en cas de débordement (un appel au-delà de la valeur limite 
  du tableau):</font></p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">VAR T:array [ 
    1..100 ] of LoginPass;</font></p>
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Struct LoginPass 
    T [100];</font></p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Une technique usuellement 
  utilisée par le programmeur amateur consiste à attribuer à la taille de T une 
  valeur très importante: 10000 par exemple. Bien entendu, si une telle méthode 
  vous protège d'une erreur de débordement du tableau, elle consomme une quantité 
  de mémoire excessive avec tous les défauts que cela impose à l'utilisateur.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>2- 
    LISTE CHAINEE</u></strong></font></p>
  <blockquote> 
    <p>&nbsp;</p>
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PREMIERE 
      APPROCHE</u></strong></font></p>
    <p>&nbsp;</p>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La structure de 
  Liste Chaînée arrive pour venir combler le défaut du type Tableau. La liste 
  Chaînée fait parti des structures dites dynamiques, c'est-à-dire évoluant au 
  fils du programme, en fonction de son utilisation. Pour donner une première 
  approche du type liste chaîné, on la compare souvent à un train auquel est attaché 
  des wagon (cette approche en apparence simpliste se révèle d'une aide précieuse 
  pour la suite :).</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/wagon.gif" width="741"
height="72"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Chaque wagon est 
  relier à 2 autres wagons: en étant dans le wagon 2, on peut uniquement aller 
  dans le wagon 3. Par contre, si je suis au wagon 1 et veux aller au wagon 4, 
  je devrais obligatoirement passer par le wagon 2 et 3. Traduisons informatiquement 
  le raisonnement précédent: les wagons sont remplacer par des records et les 
  flèches par des pointeurs.</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/type.gif" width="726"
height="202"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le dernier pointeur 
  (celui de Record 4) pointe vers&#133;.rien ! Le rien en informatique désigne 
  une adresse spécifique: NULL ou NIL.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On voit donc apparaître 
  la structure Liste Chaînées. Ainsi, en reprenant notre exemple précédent pour 
  le stockage de Login/Password, à chaque nouveau login on rajoutera un wagon 
  en tête en prenant garde de bien faire pointer le nouveau pointeur vers Record 
  1.</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/NRecord.gif"
width="835" height="186"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On créé la liste 
  au fur et à mesure du déroulemant du programme. On se rend bien compte ici que 
  le concept est totalement différent du tableau. Notre programme gére le mieux 
  possible l'espace mémoire disponible: il n'alloue une plage mémoire que si c'est 
  vraiment nécessaire.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>IMPLEMANTATION 
      DE LA STRUCTURE DE LISTE CHAINEE</u></strong></font></p>
  </blockquote>
  <p>&nbsp;</p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On définie en PASCAL:</font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/ptype.gif" width="593" height="111"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La définition donnée 
  ici est suffisamment générale pour que vous puissiez les adapter quel que soit 
  la situation. Etudions maintenant quelques procédure élémentaire pour manipuler 
  correctement la structure de liste chaînée.</font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  CREER</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Une fois votre 
  type mis en place, il faut placer votre premier élément. Cette procédure va 
  recevoir en argument notre premier objet et pointera vers l'objet suivant NIL.</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/creer.gif" width="212"
height="55"></font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/pcreer.gif" width="416" height="121"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  TETE ET SUIVANT</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ces deux procédures, 
  très simples, renvoient respectivement la liste suivant et l'objet courant de 
  la liste (l'objet en tête):</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/ptete.gif" width="289"
height="54"></font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/psuiv.gif" width="321"
height="69"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  EST_VIDE</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Cette procédure 
  nous servira pour la suite, elle teste si une liste est vide, c'est-à-dire si 
  elle pointe vers NIL.</font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/pestvide.gif" width="350" height="68"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  AJOUTE</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Il existe 2 façons 
  d'ajouter un élément dans une liste chaîné: soit en tête, soit en queue. Nous 
  verrons plus loin les répercutions sur le code de l'un ou l'autre. On va opter 
  ici pour le modèle plus simple dit de Pile. C'est à dire que l'on va ajouter 
  en tête de la liste:</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/ajouter.gif"
width="770" height="190"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/pajouter.gif" width="427"
height="125"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La fonction Ajouter 
  ajoute, à la liste L, le record LNouvRecord composé du champ Obj.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On peut construire 
  une fonction Ajouter un peu plus évoluer, qui ajoute à la k<sup>ieme</sup> position 
  de la liste L. On fera en sorte que si k est supérieur à la taille de la liste, 
  l'objet sera ajouté à la fin de la liste. On en déduit la procédure AjouterK:</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/pajouterk.gif" width="595"
height="275"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Attention, la procédure 
  AjouteK ne s'utilise qu'exceptionnellement ! En effet, en parcourant une liste 
  de cette manière, on prend un temps de parcours proportionnel à k.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Dans un tableau 
  T, on accède immédiatement à l'élément tandis qu'ici on prend un certain temps 
  pour y accéder. C'est exactement ce dont on parlait dans l'introduction: on 
  gagne en espace mémoire (on crée un record que lorsque nous en avons besoin) 
  par contre on perd en temps pour accéder à un élément. Toutefois, du fait de 
  la forme particulière du type liste chaînée, on utilise très peu un accès au 
  k<sup>ieme</sup> élément car souvent on n'en a tout simplement pas besoin. Nous 
  verrons des exemples plus tard de programme utilisant les listes: on crée souvent 
  une relation d'ordre sur les éléments pour trier les éléments.</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/ajouterk.gif"
width="687" height="335"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  SUPPRIMER</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On procède un peu 
  comme AjouterK dans le parcours de la liste, sauf qu'au lieu d'ajouter un élément, 
  on saute le k<sup>ieme</sup>.</font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/psupprk.gif" width="567" height="251"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Là encore on utilisera 
  avec précaution une tel procédure car elle prend un temps proportionnel à la 
  taille de k pour supprimer un élément.</font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  D'INSERTION DANS UNE LISTE TRIEE</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Comme évoqué précédemment, 
  on manipule souvent des listes triées: ceci permet d'accélérer le traitement 
  de la liste. On va supposer ici que la liste est une liste d'entier (integer), 
  la relation utilisé sera la relation naturelle d'inégalité sur les entiers. 
  On triera la liste dans le sens décroissant, on aura donc les 2 propriétés suivantes:</font></p>
<ul>
  <li><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La liste vide 
    est triée.</font></li>
  <li><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Les éléments 
    situés après un élément i de la liste sont inférieurs ou égaux à i.</font></li>
</ul>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le parcours de 
  la liste L se fera comme pour la fonction AjouterK ou SupprimerK sauf que la 
  condition d'arrêter ne portera pas sur k mais sur la comparaison de l'objet 
  à insérer vis-à-vis de ses voisins. Il faut en effet maintenir la structure 
  de liste trié, donc on insère l'objet tel qu'il soit compris entre son successeur 
  et son prédécesseur (dans la relation d'ordre imposé sur l'objet).</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/pinserer.gif" width="612"
height="371"></font></p>
<blockquote> 
  <blockquote> 
    <p>&nbsp;</p>
  </blockquote>
</blockquote>
<blockquote> 
  <blockquote> 
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>DIFFERENTS 
      TYPE DE CONSIDERATION D'UNE LISTE CHAINEE</u></strong></font></p>
  </blockquote>
</blockquote>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <blockquote> 
      <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><em><strong><u>LE 
        TYPE PILE</u></strong></em></font></p>
    </blockquote>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Le type pile est 
  celui que nous avons utilisé jusqu'à présent. C'est certainement le plus intuitive 
  et la plus utile. En effet, ceux qui on fait un peu d'asm ne manqueront pas 
  de faire l'analogie entre la pile au sens asm et la pile ici définie. Lors d'un 
  appel de fonction, par exemple, on empile les données dans la pile de l'ordinateur 
  et on dépile pour les récupérer. Les listes chaînées que nous avons vu jusqu'à 
  présent sont de type Pile, nous n'insisterons donc pas plus.</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/pile.gif" width="790"
height="224"></font></p>
<p align="center">&nbsp;</p>
<blockquote> 
  <blockquote> 
    <blockquote> 
      <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><em><strong><u>LE 
        TYPE FILE</u></strong></em></font></p>
    </blockquote>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ce type est très 
  proche de la structure de Pile. En fait, dans une file le premier entré est 
  le premier sorti contrairement à une pile où le premier entrer est le dernier 
  sorti (le premier se trouve en bas de la pile).</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La structure de 
  File est une liste chaînée où on retire les éléments en début de liste mais 
  on ajoute en fin de liste.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Pour implémenter 
  une telle structure on va devoir créer 2 pointeurs: le premier pointera vers 
  le dernier élément entrée, le second vers le premier élément sortant.</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/ftype.gif" width="598" height="133"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/file.gif" width="826"
height="166"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On retrouve les 
  structures précédentes légèrement modifier:</font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/fcreer.gif" width="319" height="66"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/festvide.gif" width="360" height="61"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/fdefiler.gif" width="288" height="66"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/fenfiler.gif" width="401"
height="133"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Un dessin pour 
  expliquer la procédure ENFILER (l'équivalent de la procédure AJOUTER):</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/ajoutef.gif"
width="833" height="263"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La fonction ENFILE 
  donnera la situation suivante:</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/ajouteff.gif"
width="833" height="261"></font></p>
<p align="center">&nbsp;</p>
<blockquote> 
  <blockquote> 
    <blockquote> 
      <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><em><strong><u>LE 
        TYPE LISTE DOUBLE CHAINE</u></strong></em></font></p>
    </blockquote>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La liste double 
  chaînée est la forme un peu plus évolué d'une liste chaîné classique. En effet, 
  un n&#156;ud de la liste chaîné à un lien vers son suivant et un autre vers 
  son précédent.</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/listed.gif"
width="661" height="80"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">A noter ici que 
  le numéro du record n'a plus vraiment d'importance ; ce qui compte en revanche 
  c'est la position du pointeur. On aura une déclaration comme pour une liste 
  chaîne sauf qu'il faudra rajouter un nouveau champs.</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/Tdouble.gif" width="577" height="106"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Les fonctions d'ajout 
  et de suppression ne pose pas plus de problème. On prendra garde de mettre à 
  jour le champ précédent et de préciser si les fonctions ajoutent ou suppriment 
  à droite ou à gauche du pointeur courant.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <blockquote> 
      <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><em><strong><u>LES 
        LISTES CYCLIQUES</u></strong></em></font></p>
    </blockquote>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Une liste cyclique 
  est une liste de type particulière ou le pointeur final ne pointe plus sur Nil 
  mais sur le premier élément de la liste. La liste cyclique est en apparence 
  facile à manipuler mais il fut bien faire attention lors de l'ajout de maintenir 
  le type liste cyclique et surtout de faire attention de ne pas boucler. En effet, 
  lors de la recherche d'un élément par exemple, on fera attention de ne pas tourner 
  en rond si l'élément à supprimer n'apparaît pas dans la liste cyclique</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/listec.gif"
width="572" height="520"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">A noter que cette 
  liste peut être également doublement chaînée.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>CONCLUSION 
      SUR LES LISTES CHAINEES</u></strong></font></p>
  </blockquote>
  <p>&nbsp;</p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Comme vous l'avez 
  sûrement découvert, la structure de liste chaînée est une structure nécessitant 
  quelques procédures de base pour les manipuler (contrairement à ce qui pouvait 
  se passer avec un tableau) ; mais au final elles se trouvent très simple à manipuler 
  une fois ces procédures élémentaires créer. On touche là un point relativement 
  important de cette structure. Imaginons nos procédures de base implémenté dans 
  une unité (.tpu en PASCAL ou .h/.hpp en C/C++), imaginons ensuite que l'on donne 
  à un autre programmeur notre unité en lui fournissant simplement les en-tête 
  de nos procédures. Notre programmeur n'a pas besoin de savoir comment a était 
  implémenté notre structure de données. Il stocke, supprime, accède grâce aux 
  procédures de base sans jamais savoir comment sont représentés les données.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>3- 
    STRUCTURE D'ARBRE BINAIRE</u></strong></font></p>
</blockquote>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Une liste chaînée 
  est une structure unidirectionnelle: Pourquoi de pas la rendre bidirectionnel 
  ? C'est exactement l'idée développée dans un arbre binaire. Un arbre binaire 
  se présente comme un arbre généalogique retourné. On garde d'ailleurs les termes 
  de père, fils, oncle&#133;.</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/arbre.gif" width="565" height="322"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On désigne par 
  A la racine de l'arbre. B et E sont les fils de A et sont les pères de C, D 
  et F. Comme on le voit sur l'exemple, E ne possède qu'un fils: F est le fils 
  gauche de E.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La théorie des 
  Arbres Binaires est très importante et très vaste. On va se restreindre au cas 
  des ABR (Arbre Binaire de Recherche). Les autres types d'arbre seront vu ultérieurement.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>MISE 
      EN PLACE D'UN ABR</u></strong></font></p>
    <p>&nbsp;</p>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Un ABR est un arbre 
  servant en autre à trier des données. Il permet d'avoir un accès très rapide 
  sur une donnée (en fait, on peut démontrer que l'ABR donne l'accès le plus rapide 
  possible à une donnée sans hypothèse supplémentaire).</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Dans un ABR, le 
  père est inférieur ou égale que son fils droit mais plus grand strictement que 
  son fils gauche. Cette propriété doit être répété dans TOUS sous arbre de l'arbre 
  principal.</font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/abr.gif" width="786" height="344"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">A noté qu'une fois 
  encore, i n'est pas nécessairement un entier: il suffit de décréter une relation 
  d'ordre entre les éléments (c'est-à-dire pouvoir les classer).</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/atype.gif" width="588" height="95"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On crée les procédures 
  de base pour manipuler les arbres binaires. Les premières procédures ne posant 
  pas de difficultés particulières, elles peuvent se dispenser d'explications.</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/acreer.gif" width="391" height="105"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/agauche.gif" width="323" height="68"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/adroit.gif" width="315" height="68"></font></p>
<p align="center">&nbsp;</p>
<blockquote> 
  <blockquote> 
    <p>&nbsp;</p>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  DE RECHERCHE D'UN ELEMENT</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Cette procédure 
  nous informe de la présence ou non d'un élément dans l'arbre. La valeur de retour 
  sera de type boolean.</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/arech.gif" width="589" height="122"></font></p>
<p align="center">&nbsp;</p>
<p align="left">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  INSERTION DANS UN ABR</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On veut insérer 
  un élément dans l'ABR. Il faudra donc savoir où le placer: Fils Gauche ou Fils 
  Droit. Pour cela on utilise donc la propriété locale d'un ABR: Le père est plus 
  petit ou égale que son fils droit et plus grand strictement que son fils gauche. 
  L'arbre binaire se prédispose aux procédures récursives (c'est-à-dire s'appelant 
  elles même). </font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/ainserer.gif" width="586"
height="108"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>PROCEDURE 
  SUPPRESSION DANS UN ABR</u></strong></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ici les choses 
  se compliquent un peu. Pour supprimer un élément d'un ABR, il ne suffit pas 
  de supprimer l'élément correspondant. Il faut aussi reformer un ABR après avoir 
  supprimer l'élément. Pour cela, il faut envisager 3 cas différents. Supposons 
  que l'on est trouvé l'élément dans un des n&#156;uds de l'arbre:</font></p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1<sup>er</sup> 
    Cas: Si le N&#156;ud ne possède pas de fils droit: On place le fils gauche 
    à la place du n&#156;ud</font></p>
</blockquote>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">2<sup>nd</sup> 
    Cas: Si le N&#156;ud ne possède pas de fils gauche: On place le fils droit 
    à la place du noeud</font></p>
</blockquote>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">3eme Cas: Si 
    le N&#156;ud possède un fils gauche et droit: On prend le plus petit élément 
    du fils droit pour le déplacer vers le n&#156;ud à supprimer</font></p>
</blockquote>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Explication du 
  3eme cas:</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/abrsuppr.gif"
width="604" height="531"></font></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Comme évoqué plus 
  haut, on veut reconstruire un ABR après suppression de 40. Or, comme l'arbre 
  est un ABR, tous les éléments à droite de 40 seront plus grand. On va chercher 
  le meilleurs candidat possible pour remplacer 40. En réfléchissant un peu, on 
  se rend compte que le seul bon candidat est le plus petit élément des éléments 
  du fils droit de 40. C'est-à-dire ici 43</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/recherche.gif"
width="492" height="530"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Il faut ici faire 
  une remarque très importante. Notre plus petit élément du fils droit de l'élément 
  à supprimer ne possède pas de fils gauche ! En effet, s'il possède un fils gauche 
  alors étant donner que notre arbre est un ABR: on pourrait trouver un élément 
  encore plus petit à gauche de 43 par exemple.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Comment procéder 
  ? On va créer une fonction annexe RECHERCHE_MIN qui va effectuer 2 choses:</font></p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">1/ Retourner 
    le plus petit élément du sous arbre droit de l'élément à supprimer (renvoyer 
    43 dans notre exemple précédent)</font></p>
</blockquote>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">2/ Supprimer 
    ce plus petit élément et ajuster l'ABR</font></p>
  <p>&nbsp;</p>
</blockquote>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/recherchrm.gif"
width="775" height="360"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On en déduit la 
  procédure de suppression et de recherche du minimum suivante:</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/asuppr.gif"
width="616" height="497"></font></p>
<p>&nbsp;</p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>INTERET 
    DE LA REPRESENTATION ARBRE SUR UN EXEMPLE</u></strong></font></p>
  <p>&nbsp;</p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Pour ne pas rentrer 
  dans des domaines trop techniques de temps de calcul d'un Algorithme (cycle), 
  on va essayer de voir en quoi la représentation d'arbre binaire est rapide, 
  beaucoup plus rapide que le tableau.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va ici trier 
  par insertion des éléments par 2 structures différentes: le tableau et l'arbre 
  binaire. On suppose que l'on veuille insérer un élément (on prendra comme depuis 
  le début un entier pour simplifier, mais tout objet munit d'une relation d'ordre 
  est satisfaisant) dans la structure choisit. Cette structure est à l'origine 
  déjà triée. En insérant cette élément on veut maintenir cette structure triée: 
  on appelle cette algorithme le tri par insertion.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Type Tableau</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/t.gif" width="838"
height="35"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Type ABR (on suppose 
  avoir inséré les éléments dans l'ordre suivant 16, 12,29, 25, 33, 35, 6, 15, 
  5)</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/a.gif" width="571"
height="261"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On veut maintenant 
  insérer l'élément 7. Pour notre structure tableau, nous devrons déplacer les 
  éléments supérieurs à 6 pour pouvoir avoir une case où mettre le 7.</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/deplac.gif"
width="836" height="157"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Pour notre ABR, 
  les choses sont plus simples, il suffit en effet de descendre l'arbre pour rajouter 
  une feuille à droite de 6:</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/inserta.gif"
width="564" height="262"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Maintenant, comptons 
  le nombre d'opération que l'on a effectué: 7 déplacements/parcours pour le tableau 
  et seulement 3 déplacements pour l'arbre. On a donc été deux fois plus vite 
  (même un peu plus encore car déplacer un élément peut être lent - pensez si 
  notre entier représenté un fichier).</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Bien sûr, notre 
  exemple a été choisi de tel manière que notre ABR ne soit pas déséquilibré. 
  Au pire des cas, on pourrait imaginer que notre ABR soit filiforme: c'est-à-dire 
  une liste chaînée ! Mais en général (statistiquement parlant), l'ABR reste correctement 
  équilibré et ressemble de près ou de loin à un arbre.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Nous voyons donc 
  que si notre d'élément était de 1000 000. Il faudrait effectuer en moyenne 500 
  000 déplacement pour insérer un élément (en moyenne signifie statistiquement 
  - ici on voit facilement qu'en moyenne on insérera autant d'élément à droite 
  qu'à gauche du milieu donc bien 500000 en moyenne) ; par contre pour notre arbre 
  binaire, on voit que le nombre de déplacement moyen à effectué sera la hauteur 
  moyenne de l'arbre soit LN(1000 000) = 14.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">14 contre 500 000 
  !!! La rapidité de l'ABR est écrasante.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">J'ai cru voir quelques 
  froncement de sourcil lors de la lecture de LN. Si un arbre possède n d'éléments, 
  en supposant qu'il soit équilibré (chaque père possède deux fils - en triangle) 
  on aura la relation Hauteur = LN( n )</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">La fonction LN 
  est présente sur toutes machines à calculé, comme la fonction cosinus.</font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/ln.gif" width="813"
height="345"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>III- 
  POUR ALLER UN PEU PLUS LOIN</u></strong></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Sachez qu'il existe 
  d'autres types d'arbres. Il possède chacun des caractéristiques propres. L'ABR 
  est le plus simple d'entre eux. Il est très satisfaisant pour classer et rechercher 
  des éléments. Mais il existe également:</font></p>
<p>&nbsp;</p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>1- 
    LES AVL</u></strong></font></p>
  <p>&nbsp;</p>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Nous avons vu que 
  les ABR peuvent présenter des déséquilibres et ainsi perdre leur fameuse hauteur 
  en LN(n). Le cas le plus dramatique est le cas où ces arbres deviennent filiforme, 
  c'est-à-dire des listes chaînées. Les AVL sont des arbres plus élaborés qui 
  maintienne cette structure d'arbre équilibré. Les procédure qui en découlent 
  sont très complexe et feront sûrement l'objet d'un prochain texte. Ces arbres 
  sont d'une importance capital et représentent ce qui est le plus rapide dans 
  l'accès de données.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>2- 
    LES n-ARBRES</u></strong></font></p>
</blockquote>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ces arbres ne pointent 
  plus vers 2 fils mais vers n fils. Généralement, on représente n fils dans un 
  tableau ou dans une liste chaînée (plus économique en place).</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Exemple de 4-Arbre</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/4arbre.gif"
width="642" height="242"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Si vous êtes plutôt 
  Liste:</font></p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/Tnarbrel.gif" width="577"
height="197"></font></p>
<p align="center">&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/larbre.gif"
width="640" height="449"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Si vous êtes plutôt 
  tableau:</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/Tnarbret.gif"
width="617" height="105"></font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/tarbre.gif"
width="605" height="336"></font></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><strong><u>3- 
      2 EXEMPLES D'APPLICATION</u></strong></font></p>
    <p>&nbsp;</p>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">L'objet de ce qui 
  suit n'est pas de créer une application à proprement dit mais d'ouvrir les étapes 
  fondamentales à la représentation informatiques des objets manipulés. Nous allons 
  voir 2 exemples. Tout d'abord, comment représenter un réseau dans la mémoire 
  de l'ordinateur: ce réseau pourra être parcouru et modifier. La structure utilisée 
  doit être souple et peu gourmande en mémoire. Ensuite, nous allons étudier comment 
  représenter de manière très compact une word list (ensemble de mots appartenant 
  au dictionnaire permettant souvent de trouver un mot de passe).</font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <blockquote> 
      <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><em><strong><u>REPRESENTER 
        UN RESEAU</u></strong></em></font></p>
    </blockquote>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On va se limiter 
  à des réseaux assez simple. Les réseaux plus complexe ne sont que l'extension 
  des notions introduites ici. De manière général, un réseau est constitué de 
  serveurs auxquels sont connectés des clients:</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/intranett.gif"
width="725" height="484"></font></p>
<p>&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On suppose ici 
  que les clients ne sont pas interconnectés (ce qui est faux en théorie) mais 
  ceci ne restreint en rien le problème comme nous le verrons plus loin. On va 
  donc définir un type <i>serveur</i> comme un n-arbre: on va utiliser ici le 
  type liste chainé.</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/reseaue.gif"
width="822" height="327"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ces réseaux (encore 
  appelé Intranet) sont ensuite interconnectés par un réseau plus vaste: le réseau 
  Internet par exemple.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/internet.gif" width="867"
height="661"></font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Les serveurs sont 
  interconnectés: 1 est connecté avec (2, 3, 4) ; 2 avec (1, 4) ; 3 avec 1 ; 4 
  avec (1, 2). Ce genre de réseau peut se représenter de 2 manières: un n-arbre 
  ou un tableau de liste. On va choisir ici un tableau de liste. (On parle ici 
  plus de graphe que d'arbre - la notion de graphe est beaucoup plus générale 
  qu'un arbre)</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">T sera notre tableau 
  contenant au maximum N serveurs interconnectés: T[1] représentera le premier 
  serveur, T[2] le second etc&#133; T sera un tableau de liste. La liste aura 
  2 champs: le numéro du serveur, le type <i>serveur</i>.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Ce qui donne ici:</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/listab.gif"
width="400" height="245"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Chaque maillon 
  de la liste chaîné possède un type champ et un numéro pour l'identifier. Il 
  en découle la déclaration de type suivant.</font></p>
<p>&nbsp;</p>
<p align="center"><font face="Verdana, Arial, Helvetica, sans-serif" size="2"><img src="images/dynastr/tinternet.gif" width="621"
height="341"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Pour ajouter un 
  ordinateur dans le réseau, il suffira de rajouter à la fin du tableau un élément 
  en complétant la liste des ordinateurs associés.</font></p>
<p>&nbsp;</p>
<blockquote> 
  <blockquote> 
    <blockquote> 
      <p><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><em><strong><u>REPRESENTER 
        UNE WORD LIST</u></strong></em></font></p>
      <p>&nbsp;</p>
    </blockquote>
  </blockquote>
</blockquote>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Une word list est 
  usuellement représenté comme une succession de mot dans un fichier. L'attaque 
  d'un password charge souvent une partie de ces mots en mémoire pour ensuite 
  les passer au crible afin de casser le password. L'intérêt des arbres va consister 
  à pouvoir charger le plus de mot possible en mémoire. Notre programme de cassage 
  fera moins d'appel disque dur et donc gagnera plus de temps.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Soit la word liste 
  de 10 mots: Arbore, Arbre, Reseau, Resiste, Web, Week</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Cette liste est 
  caractéristique d'une word list: mots classés alphabétiquement. Deux mots qui 
  se succèdent (d'une même séquence) ont souvent un début similaire. Utilisons 
  l'arbre suivant pour représenter ces mots:</font></p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/wlist.gif" width="410"
height="400"></font></p>
<p align="center">&nbsp;</p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">On utilise un n-arbre 
  avec le type Liste Chaîné comme second champ. Toutefois, étant donnée qu'une 
  word liste contient souvent tous les lettres possibles, on peut raisonnablement 
  remplacer la liste par un tableau: la perte de place ne sera pas sensible.</font></p>
<p><font size="2" face="Verdana, Arial, Helvetica, sans-serif">Au lieu de stocker 
  tous les mots linéairement, ce qui représente 31 octets, on garde en mémoire 
  le n-arbre qui ne compte plus que 22 octets. Au plus, votre word list est complète 
  au moins votre arbre prendra de la place. </font></p>
<p>&nbsp;</p>
<p align="center"><font size="2" face="Verdana, Arial, Helvetica, sans-serif"><img src="images/dynastr/twordl.gif"
width="517" height="172"></font></p>
</body>
</html>
