<html>

<!-- Mirrored from frenchezines.free.fr/tries/shmeitcorp/5/Malade/2%20-%20hErmol%20crackme%20v1.0.html by HTTrack Website Copier/3.x [XR&CO'2007], Thu, 07 Aug 2008 04:41:16 GMT -->
<head>
<title>hErmol crackme v1.0</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head>
<body bgcolor="#000000" text="#FFFFFF" link="#FFFFFF" vlink="#FFFFFF" alink="#FFFFFF" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="670" border="0">
  <tr>
    <td><p><font size="2" face="Arial, Helvetica, sans-serif"><b>hErmol crackme 
        v1.0</b> <strong>[<a href="Malade/2%20-%20hErmol%20crackme%20v1.0.zip">zip</a>]</strong></font></p>
      <ul>
        <li><font size="2" face="Arial, Helvetica, sans-serif"><b>Type de la protection 
          :</b> KeyFile </font>
        <li><font size="2" face="Arial, Helvetica, sans-serif"><b>Méthode utilisée 
          :</b> debugging </font>
        <li><font size="2" face="Arial, Helvetica, sans-serif"><b>Outils utilisés 
          :</b> </font><font face="Arial, Helvetica, sans-serif"> 
          <ul>
            <font size="2"> <a href="http://protools.owns.it/">désassembleur (IDA 
            v4.1.7.600)</a><br>
            <a href="http://home.t-online.de/home/Ollydbg/" target="_blank">debugger 
            (OllyDbg v1.06)<br>
            </a><a href="http://www.bpsoft.com/" target="_blank">éditeur hexadécimal 
            (Hex Workshop v3.11)<br>
            </a><a href="http://protools.owns.it/">unpacker (ProcDump32 v1.6.2)</a><br>
            <a href="http://www.mesa-sys.com/~snaker/peid" target="_blank">détecteur 
            de compression (PE iDentifier v0.8)</a> </font> 
          </ul>
          </font>
      </ul>
      <p><font size="2" face="Arial, Helvetica, sans-serif"> Ici une autre manière 
        de protéger un programme : le keyfile, c'est un fichier qui est utilisé 
        au démarrage du programme et qui indique si celui-ci est enregistré ou 
        non.<br>
        <br>
        On exécute le programme et on aperçoit une très belle fenêtre nous disant 
        que nous sommes en mode shareware :-/ On le désassemble, et là on voit 
        3 choses...<br>
        <br>
        Tout d'abord un énorme vide, beaucoup de valeurs hexadécimales et un peu 
        de code... Le programme ne serait-il pas compressé ? On ouvre PEiD, 'Open 
        File', on sélectionne notre crackme, et on voit s'afficher <em>'UPX 0.89.6 
        - 1.02 / 1.05 - 1.22 -> Markus & Lazlo</em>'.<br>
        <br>
        On pourrait faire du manual unpacking comme c'est de l'UPX, mais bon, 
        il existe des programmes pour ça, donc autant s'en servir, c'est là pour 
        ça. On ouvre ProcDump, puis 'Unpack', on choisit 'UPX' (ben oui comme 
        c'est de l'UPX, ça paraît normal, non ?). On ouvre le programme compressé, 
        on attend qu'il s'ouvre dans la barre des tâches, et on fait 'OK'. On 
        sauvegarde ensuite le fichier décompressé.<br>
        <br>
        On réouvre notre fichier avec IDA, on regarde à peu près et on voit beaucoup 
        beaucoup beaucoup, mais attention, quand je dis beaucoup beaucoup, c'est 
        vraiment beaucoup beaucoup ! donc on voit beaucoup de nop...<br>
        arf, ce qui rend le code pas très lisible, car entre chaque instruction, 
        il y a environ 200 lignes de nop, alors pour tracer... pas grave, on va 
        agir autrement, ça va nous retarder, mais ça sera plus facile pour plus 
        tard. On regarde d'abord si le programme appelle quelques fonctions intéressantes, 
        on va dans 'Jump', 'Jump to name...', et là on cherche une fonction qui 
        ouvre un fichier, généralement c'est l'API <strong>CreateFile</strong>.</font></p>
      <p><font size="2" face="Arial, Helvetica, sans-serif">Hum pas de CreateFile, 
        hum je sais pas si vous avez vu, mais y a une autre API intéressante là, 
        non ? Et _lopen ? Donc on double-clique dessus, et on arrive à ceci : 
        <br>
        <br>
        <font color="#FFFF00" face="Courier New, Courier, mono">.idata:004070BC</font> 
        <font color="#000000" face="Courier New, Courier, mono">.......</font><font color="#FFFFFF" face="Courier New, Courier, mono">; 
        HFILE __stdcall _lopen(LPCSTR lpPathName,int iReadWrite)<br>
        </font><font color="#FF00FF" face="Courier New, Courier, mono">.idata:004070BC</font> 
        <font size="2" face="Arial, Helvetica, sans-serif"><font color="#000000" face="Courier New, Courier, mono">.......</font><font color="#FFFFFF" face="Courier New, Courier, mono"></font></font><font color="#FFFF00" face="Courier New, Courier, mono">extrn</font> 
        <font color="#FF00FF" face="Courier New, Courier, mono">_lopen</font><font color="#C0C0C0" face="Courier New, Courier, mono">:dword</font> 
        </font> </p>
      <p><font size="2" face="Arial, Helvetica, sans-serif"> Mais à aucun moment 
        le programme ne l'appelle, hum, bizarre... pourtant ça convient très bien 
        à notre crackme cette fonction... Il faut savoir que certains packers 
        transforment le code en data ce qui le rend donc illisible, alors allons 
        donc voir le PE du programme, on ouvre ProcDump, 'PE Editor', et on ouvre 
        notre fichier compressé, ensuite 'Sections', et là quelque chose qui devrait 
        vous sauter aux yeux, non ?<br>
        <br>
        Bon je vous aide, dans le PE, une section code est 0x??????20, et là la 
        section code est 0x??????80 qui correspond à des données non initialisées, 
        alors, je vous avais pas dit ça ?<br>
        <br>
        Bon on change la section .code de E0000080 en E0000020 (pour cela clic-droit 
        sur .code, 'Edit section', 'Section Characteristics'...). On fait 'OK', 
        et on recommence.<br>
        <font size="1">(NDOracle : Pour en savoir plus sur la structure du PE 
        et les sections reportez vous au tutorial d'Anubis pr&eacute;sent dans 
        ce Memento)<font size="2">.<br>
        <br>
        </font></font>Hum déjà il est plus long à désassembler, bon signe. Un 
        petit 'Jump to name _lopen' et on voit du changement !<br>
        <br>
        <font color="#C0C0C0" face="Courier New, Courier, mono">.code:0040485A</font> 
        <font size="2" face="Arial, Helvetica, sans-serif"><font color="#000000" face="Courier New, Courier, mono">.......</font><font color="#FFFFFF" face="Courier New, Courier, mono"></font></font><font color="#FFFFFF" face="Courier New, Courier, mono">; 
        HFILE __stdcall _lopen(LPCSTR lpPathName,int iReadWrite)<br>
        </font><font color="#C0C0C0" face="Courier New, Courier, mono">.code:0040485A</font> 
        <font color="#FFFF00" face="Courier New, Courier, mono">_lopen proc near</font> 
        <font color="#00FF00" face="Courier New, Courier, mono">; CODE XREF: sub_4013B0+6C8|p<br>
        </font><font color="#FFFF00" face="Courier New, Courier, mono">.code:0040485A</font> 
        <font size="2" face="Arial, Helvetica, sans-serif"><font color="#000000" face="Courier New, Courier, mono">.......</font><font color="#FFFFFF" face="Courier New, Courier, mono"></font></font><font color="#C0C0C0" face="Courier New, Courier, mono">jmp 
        ds:</font><font color="#FF00FF" face="Courier New, Courier, mono">__imp__lopen<br>
        </font><font color="#C0C0C0" face="Courier New, Courier, mono">.code:0040485A</font> 
        <font color="#FFFF00" face="Courier New, Courier, mono">_lopen endp</font> 
        <br>
        <br>
        </font> <font size="2" face="Arial, Helvetica, sans-serif"> Maintenant 
        nous allons extraire le code assembleur qui nous intéresse pour ensuite 
        supprimer tous les NOP, on pourra donc avoir un code désassemblé plus 
        lisible :o) On va donc commencer à copier à l'adresse 401A78, mais autant 
        prendre les arguments, donc on va prendre un peu plus haut.<br>
        <strong> En supprimant ensuite tous les NOP, voici ce qu'on obtient : 
        </strong></font></p>
      <p><font size="2" face="Courier New, Courier, mono">0040187D 6A 02 <font color="#000000">......</font><font color="#000000">..</font>PUSH 
        2<br>
        004019AB 68 29514000 <font color="#000000">..</font>PUSH _crackme.00405129 
        ; ASCII &quot;CRACKME.KEY&quot;<br>
        00401A78 E8 DD2D0000 <font color="#000000">..</font>CALL &lt;JMP.&amp;kernel32._lopen&gt;<br>
        00401A7D 83F8 FF <font color="#000000">......</font>CMP EAX,-1<br>
        00401A80 0F85 5D020000 JNZ _crackme.00401CE3<br>
        00401A86 E9 BE100000 <font color="#000000">..</font>JMP _crackme.00402B49<br>
        00401CE3 A3 E3664000 <font color="#000000">..</font>MOV DWORD PTR DS:[4066E3],EAX<br>
        00401DB0 33C9 <font color="#000000">.........</font>XOR ECX,ECX<br>
        00401DB2 1E <font color="#000000">...........</font>PUSH DS<br>
        00401DB3 07 <font color="#000000">...........</font>POP ES <font color="#000000">...</font><font color="#000000">...</font><font color="#000000">...</font><font color="#000000">...</font><font color="#000000">...</font><font color="#000000">...</font><font color="#000000">.</font>; 
        Modification of segment register<br>
        00401DB4 BE AE534000 <font color="#000000">..</font>MOV ESI,_crackme.004053AE<br>
        00401E81 87F3 <font color="#000000">.........</font>XCHG EBX,ESI<br>
        00401F4B 6A 01 <font color="#000000">........</font>PUSH 1<br>
        00401F4D 68 9A674000 <font color="#000000">..</font>PUSH _crackme.0040679A<br>
        00401F52 FF35 E3664000 PUSH DWORD PTR DS:[4066E3]<br>
        00401F58 E8 09290000 <font color="#000000">..</font>CALL &lt;JMP.&amp;kernel32._hread&gt;<br>
        00401F5D 83F8 01 <font color="#000000">......</font>CMP EAX,1<br>
        00401F60 0F85 6D110000 JNZ _crackme.004030D3<br>
        0040202E 33C9 <font color="#000000">.........</font>XOR ECX,ECX<br>
        004020F8 BF 9A674000 <font color="#000000">..</font>MOV EDI,_crackme.0040679A<br>
        004021C5 92 <font color="#000000">...........</font>XCHG EAX,EDX<br>
        0040228E C1E0 04 <font color="#000000">......</font>SHL EAX,4<br>
        00402359 C1E0 08 <font color="#000000">......</font>SHL EAX,8<br>
        00402424 C1E0 08 <font color="#000000">......</font>SHL EAX,8<br>
        004024EF C1E0 04 <font color="#000000">......</font>SHL EAX,4<br>
        004025BA C1E0 08 <font color="#000000">......</font>SHL EAX,8<br>
        00402685 87CA <font color="#000000">.........</font>XCHG EDX,ECX<br>
        0040274F 031D E9664000 ADD EBX,DWORD PTR DS:[4066E9]<br>
        0040281D 87F3 <font color="#000000">.........</font>XCHG EBX,ESI<br>
        004028E7 46 <font color="#000000">...........</font>INC ESI<br>
        004029B0 8A06 <font color="#000000">.........</font>MOV AL,BYTE PTR DS:[ESI]<br>
        004029B2 AF <font color="#000000">...........</font>SCAS DWORD PTR ES:[EDI]<br>
        00402A7B 0F84 00F4FFFF JE _crackme.00401E81<br>
        00402B49 92 <font color="#000000">...........</font>XCHG EAX,EDX<br>
        00402C12 C1E0 02 <font color="#000000">......</font>SHL EAX,2<br>
        00402CDD C1E0 08 <font color="#000000">......</font>SHL EAX,8<br>
        00402DA8 C1E0 03 <font color="#000000">......</font>SHL EAX,3<br>
        00402E73 C1E0 04 <font color="#000000">......</font>SHL EAX,4<br>
        00402F3E C1E0 06 <font color="#000000">......</font>SHL EAX,6<br>
        00403009 87CA <font color="#000000">.........</font>XCHG EDX,ECX<br>
        0040319B BE AE534000 <font color="#000000">..</font>MOV ESI,_crackme.004053AE<br>
        004031A0 2BDE <font color="#000000">.........</font>SUB EBX,ESI<br>
        0040326A 81FB 00080000 CMP EBX,800<br>
        00403270 75 09 <font color="#000000">........</font>JNZ SHORT _crackme.0040327B<br>
        00403274 E9 45030000 <font color="#000000">..</font>JMP _crackme.004035BE<br>
        0040327B 40 <font color="#000000">...........</font>INC EAX<br>
        0040327C 5E <font color="#000000">...........</font>POP ESI<br>
        0040327D 5F <font color="#000000">...........</font>POP EDI<br>
        0040327E 5B <font color="#000000">...........</font>POP EBX<br>
        0040327F C9 <font color="#000000">...........</font>LEAVE<br>
        00403280 C2 1000 <font color="#000000">......</font>RETN 10</font> </p>
      <p><font size="2" face="Arial, Helvetica, sans-serif"> On y comprend déjà 
        beaucoup mieux, non ? Pas grave, on va étudier ça ensemble.<br>
        Nous allons reprendre le programme ligne par ligne :<br>
        <br>
        </font><font size="2" face="Courier New, Courier, mono">0040187D 6A 02 
        <font color="#000000">......</font><font color="#000000">..</font>PUSH 
        2<br>
        004019AB 68 29514000 <font color="#000000">..</font>PUSH _crackme.00405129 
        ; ASCII &quot;CRACKME.KEY&quot;<br>
        00401A78 E8 DD2D0000 <font color="#000000">..</font>CALL &lt;JMP.&amp;kernel32._lopen&gt;</font><font size="2" face="Arial, Helvetica, sans-serif"> 
        </font></p>
      <p><font size="2" face="Arial, Helvetica, sans-serif"> Tout d'abord on ouvre 
        le fichier "CRACKME.KEY" en lecture/écriture (2). <br>
        </font><font size="2" face="Courier New, Courier, mono">00401DB4 BE AE534000 
        <font color="#000000">..</font>MOV ESI,_crackme.004053AE<br>
        00401E81 87F3 <font color="#000000">.........</font>XCHG EBX,ESI</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        </font> <br>
        <font size="2" face="Arial, Helvetica, sans-serif"> On initialise ESI 
        à 004053AE qu'on a placé dans EBX en permutant les registres avec 'XCHG 
        EBX,ESI'.<br>
        </font><font size="2" face="Courier New, Courier, mono">00401F4B 6A 01 
        <font color="#000000">........</font>PUSH 1<br>
        00401F4D 68 9A674000 <font color="#000000">..</font>PUSH _crackme.0040679A<br>
        00401F52 FF35 E3664000 PUSH DWORD PTR DS:[4066E3]<br>
        00401F58 E8 09290000 <font color="#000000">..</font>CALL &lt;JMP.&amp;kernel32._hread&gt;</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        </font> <br>
        <font size="2" face="Arial, Helvetica, sans-serif"> On va lire ensuite 
        caractère par caractère (ce qui correspond au 'PUSH 1' en 00401F4B) le 
        fichier. On verra ensuite que beaucoup de code ne sert à rien ici, ah 
        là là vraiment pour embêter le monde hein ! ;op<br>
        </font><font size="2" face="Courier New, Courier, mono">0040274F 031D 
        E9664000 ADD EBX,DWORD PTR DS:[4066E9]</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        </font> <font size="2" face="Arial, Helvetica, sans-serif"> <br>
        On ajoute ensuite à EBX la valeur se trouvant à l'adresse 4066E9 qui est 
        0xFF.<br>
        </font><font size="2" face="Courier New, Courier, mono">0040281D 87F3 
        <font color="#000000">.........</font>XCHG EBX,ESI<br>
        004028E7 46 <font color="#000000">...........</font>INC ESI</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        </font> <font size="2" face="Arial, Helvetica, sans-serif"> <br>
        On repermute les registres, et on ajoute 1 à ESI, en fait c'est comme 
        si on ajoutait 1 à EBX avant la permutation. On a en fait ajouté 0x100 
        en tout à la valeur se trouvant à l'origine dans ESI.<br>
        Vient ensuite une expression peut-être inconnue : <br>
        </font><font size="2" face="Courier New, Courier, mono">004029B0 8A06 
        <font color="#000000">.........</font>MOV AL,BYTE PTR DS:[ESI]<br>
        004029B2 AF <font color="#000000">...........</font>SCAS DWORD PTR ES:[EDI]</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        </font> <font size="2" face="Arial, Helvetica, sans-serif"> <br>
        Cette instruction permet de chercher si un caractère stocké dans AL/AX/EAX 
        se trouve dans une chaîne pointée par EDI. On cherche tout simplement 
        à vérifier si le caractère lu dans notre fichier correspond au caractère 
        trouvé après s'être déplacé de 0x100 à partir de 004053AE. <br>
        </font><font size="2" face="Courier New, Courier, mono">00402A7B 0F84 
        00F4FFFF JE _crackme.00401E81</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        <br>
        </font> <font size="2" face="Arial, Helvetica, sans-serif"> Si c'est le 
        cas, on retourne plus haut pour lire le caractère suivant, et on fait 
        la même opération.<br>
        </font><font size="2" face="Courier New, Courier, mono">00401F58 E8 09290000 
        <font color="#000000">..</font>CALL &lt;JMP.&amp;kernel32._hread&gt;<br>
        00401F5D 83F8 01 <font color="#000000">......</font>CMP EAX,1<br>
        00401F60 0F85 6D110000 JNZ _crackme.004030D3</font><font size="2" face="Arial, Helvetica, sans-serif"> 
        </font> <br>
        <br>
        <font size="2" face="Arial, Helvetica, sans-serif"> S'il n'y a plus de 
        caractères à lire, on saute directement en 004030D3, qui est un NOP, donc 
        l'instruction rencontrée sera en 0040319B.<br>
        </font><font size="2" face="Courier New, Courier, mono">0040319B BE AE534000 
        <font color="#000000">..</font>MOV ESI,_crackme.004053AE<br>
        004031A0 2BDE <font color="#000000">.........</font>SUB EBX,ESI</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        </font> <br>
        <font size="2" face="Arial, Helvetica, sans-serif"> On soustrait ensuite 
        à EBX, la valeur d'origine, c'est-à-dire qu'on saura combien on a additionné.<br>
        </font><font size="2" face="Courier New, Courier, mono">0040326A 81FB 
        00080000 CMP EBX,800<br>
        00403270 75 09 <font color="#000000">........</font>JNZ SHORT _crackme.0040327B<br>
        00403274 E9 45030000 <font color="#000000">..</font>JMP _crackme.004035BE</font><font size="2" face="Arial, Helvetica, sans-serif"><br>
        </font> <br>
        <font size="2" face="Arial, Helvetica, sans-serif"> Si on a additionné 
        0x800, c'est tout bon, et comme on ajoutait 0x100 à chaque passage, ça 
        veut dire qu'on a lu 8 caractères, il ne reste plus qu'à les trouver.<br>
        <br>
        Ce qui est très facile maintenant qu'on a compris comment fonctionnait 
        le crackme. On est donc parti de l'adresse <strong>004053AE</strong>, 
        puis on a lu le caractère qui s'y trouvé tous les 100 octets plus loin. 
        On va donc rechercher les octets suivants : 004054AE, 004055AE, 004056AE, 
        004057AE, 004058AE, 004059AE, 00405AAE, 00405BAE.<br>
        Et on y trouve : 0x89 , 0x8B , 0x05 , 0xE2 , 0x00 , 0x32 , 0x87 , 0x95.<br>
        <br>
        On ouvre donc le fichier 'crackme.key' avec un éditeur hexadécimal, et 
        on met ces valeurs : 898B 05E2 0032 8795, on sauvegarde, on relance le 
        crackme, et le bon message s'affiche !<br>
        <br>
        Vous avez donc vu que certaines instructions n'étaient pas utilisées, 
        alors voici le code réellement utilisée :<br>
        </font><font size="2" face="Courier New, Courier, mono">0040187D 6A 02 
        <font color="#000000">......</font><font color="#000000">..</font>PUSH 
        2<br>
        004019AB 68 29514000 <font color="#000000">..</font>PUSH _crackme.00405129 
        ; ASCII &quot;CRACKME.KEY&quot;<br>
        00401A78 E8 DD2D0000 <font color="#000000">..</font>CALL &lt;JMP.&amp;kernel32._lopen&gt;<br>
        00401A7D 83F8 FF <font color="#000000">......</font>CMP EAX,-1<br>
        00401A80 0F85 5D020000 JNZ _crackme.00401CE3<br>
        00401A86 E9 BE100000 <font color="#000000">..</font>JMP _crackme.00402B49<br>
        00401CE3 A3 E3664000 <font color="#000000">..</font>MOV DWORD PTR DS:[4066E3],EAX<br>
        ...<br>
        00401DB4 BE AE534000 <font color="#000000">..</font>MOV ESI,_crackme.004053AE<br>
        00401E81 87F3 <font color="#000000">.........</font>XCHG EBX,ESI<br>
        00401F4B 6A 01 <font color="#000000">........</font>PUSH 1<br>
        00401F4D 68 9A674000 <font color="#000000">..</font>PUSH _crackme.0040679A<br>
        00401F52 FF35 E3664000 PUSH DWORD PTR DS:[4066E3]<br>
        00401F58 E8 09290000 <font color="#000000">..</font>CALL &lt;JMP.&amp;kernel32._hread&gt;<br>
        00401F5D 83F8 01 <font color="#000000">......</font>CMP EAX,1<br>
        00401F60 0F85 6D110000 JNZ _crackme.004030D3<br>
        ...<br>
        004020F8 BF 9A674000 <font color="#000000">..</font>MOV EDI,_crackme.0040679A<br>
        ...<br>
        </font><font size="2" face="Courier New, Courier, mono">0040274F 031D 
        E9664000 ADD EBX,DWORD PTR DS:[4066E9]<br>
        0040281D 87F3 <font color="#000000">.........</font>XCHG EBX,ESI<br>
        004028E7 46 <font color="#000000">...........</font>INC ESI<br>
        004029B0 8A06 <font color="#000000">.........</font>MOV AL,BYTE PTR DS:[ESI]<br>
        004029B2 AF <font color="#000000">...........</font>SCAS DWORD PTR ES:[EDI]<br>
        00402A7B 0F84 00F4FFFF JE _crackme.00401E81<br>
        ...<br>
        0040319B BE AE534000 <font color="#000000">..</font>MOV ESI,_crackme.004053AE<br>
        004031A0 2BDE <font color="#000000">.........</font>SUB EBX,ESI<br>
        0040326A 81FB 00080000 CMP EBX,800<br>
        00403270 75 09 <font color="#000000">........</font>JNZ SHORT _crackme.0040327B<br>
        00403274 E9 45030000 <font color="#000000">..</font>JMP _crackme.004035BE<br>
        0040327B 40 <font color="#000000">...........</font>INC EAX<br>
        0040327C 5E <font color="#000000">...........</font>POP ESI<br>
        0040327D 5F <font color="#000000">...........</font>POP EDI<br>
        0040327E 5B <font color="#000000">...........</font>POP EBX<br>
        0040327F C9 <font color="#000000">...........</font>LEAVE<br>
        00403280 C2 1000 <font color="#000000">......</font>RETN 10</font> <font size="2" face="Arial, Helvetica, sans-serif"><br>
        <br>
        </font><font size="2" face="Arial, Helvetica, sans-serif">Le début de 
        ce tut est assez long, mais vous pouvez très bien y aller au feeling sans 
        devoir unpacker le prog, vous tracez, vous regardez, vous cherchez, et 
        vous arriverez au même résultat, mais la méthode décrite ici est "plus 
        propre".<br>
        <br>
        <u><img src="images/le_malade.jpg" width="192" height="32"></u> </font></p>
      </td>
  </tr>
</table>
</body>

<!-- Mirrored from frenchezines.free.fr/tries/shmeitcorp/5/Malade/2%20-%20hErmol%20crackme%20v1.0.html by HTTrack Website Copier/3.x [XR&CO'2007], Thu, 07 Aug 2008 04:41:16 GMT -->
</html>