<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
<!--  formamus.htm version 02 February 1998 
      INSTRUCTIONS FOR SUBMITTING: DO NOT USE HTML EDITORS!
      SEARCH THIS TEXT FOR THE STRING "Your_" 
      AND REPLACE WITH WHATEVER YOU WANT TO PUBLISH! 
      THANKS A LOT: this will allow automated retrieval -->

	<META NAME="GENERATOR" Content="Visual Page 2.0 for Windows - Trial Version">
	<TITLE>Piece of Christal's Page</TITLE>
</HEAD>

<BODY BACKGROUND="../Christal2/fondopri.jpg" TEXT="black" BGCOLOR="#000099" LINK="red" VLINK="#99CCFF">

<P ALIGN="RIGHT"><FONT SIZE="5" COLOR="#FFCC00" FACE="Arial Black">Crackme</FONT><FONT SIZE="4" COLOR="yellow"
FACE="Arial Black"> V3.0</FONT><FONT SIZE="4" COLOR="blue" FACE="Arial Black"> </FONT><FONT SIZE="4" COLOR="#FFCC00"
FACE="Arial Black">de</FONT><FONT SIZE="5" COLOR="#FFCC00" FACE="Arial Black"> Cosh et FTP Xpert 1.30</FONT></P>

<BLOCKQUOTE>
	<P><FONT SIZE="2" COLOR="white" FACE="Arial">By Christal</FONT>
</BLOCKQUOTE>

<CENTER>
<P>
<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="91%">
	<TR>
		<TD WIDTH="100%" BGCOLOR="#FFFF99">
			<P><B><U><FONT SIZE="4" COLOR="blue" FACE="Arial">CrackMe 3 de Cosh</FONT></U></B></P>

			<P><FONT SIZE="2" FACE="Arial">Commen&ccedil;ons pas d&eacute;limiter notre &quot;espace de travail&quot;...<BR>
			Celui ci va &ecirc;tre compris, &agrave; priori, entre la saisie des champs du CrackMe et l'affichage de la MessageBox
			&quot;code invalide&quot;...<BR>
			<BR>
			La saisie des messages, au moins dans les programmes &eacute;crit en C (ces API ne sont pas sollicit&eacute;es
			par les programmes &eacute;crits en Delphi ou en VB), se fait g&eacute;n&eacute;ralement par le biais des API GetWindowTextA
			et GetDlgItemTextA. (according to Rhayader).<BR>
			Pour commenc&eacute;, j'ai utilis&eacute; le breakpoint &quot;action&quot; suivant:<BR>
			<BR>
			</FONT><B><FONT SIZE="2" FACE="Arial">GetWindowtext</FONT></B><FONT SIZE="2" FACE="Arial">, d&eacute;clar&eacute;
			comme ceci:<BR>
			<BR>
			int GetWindowtext (HWND hWnd, LPTSTR IpString, int MaxCount),<BR>
			<BR>
			Au moment du break, la pile (stack) ressemblera &agrave; ceci:</FONT></P>
			<PRE><FONT SIZE="2" FACE="Courier New">[ESP+0Ch]   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> - contiendra nMaxCount</FONT><FONT
			SIZE="2" FACE="Courier New">
[ESP+08h]   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> - contiendra IpString</FONT><FONT SIZE="2" FACE="Courier New">
[ESP+04h]    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">- contiendra hwnd</FONT><FONT SIZE="2" FACE="Courier New">
[ESP+00h]    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">- contiendra le Return EIP</FONT></PRE>
			<P><FONT SIZE="2" FACE="Arial">Au retour de la fonction API appel&eacute;e, GetWindowText placera le texte saisi
			&agrave; l'adresse point&eacute;e par IpString, si bien qu'il faudra utiliser le caract&egrave;re * pour lire le
			contenu de l'adresse point&eacute;e. (D *ESP+8)<BR>
			<BR>
			En posant un point d'arr&ecirc;t de ce genre, vous obtiendrez un break avec affichage du contenu du champ saisi:<BR>
			<BR>
			</FONT><B><FONT SIZE="2" FACE="Arial">Bpx GetWindowTextA Do &quot;D esp-&gt;8;&quot;</FONT></B><FONT SIZE="2" FACE="Arial">,
			et en appuyant sur F12 vous reviendrez &agrave; la fonction appelante.<BR>
			Pour vous &eacute;pargner le F12, vous pouvez aussi entrer:<BR>
			<BR>
			</FONT><B><FONT SIZE="2" FACE="Arial">Bpx GetWindowTextA Do &quot;D esp-&gt;8;P RET;&quot;</FONT></B><FONT SIZE="2"
			FACE="Arial"> qui vous ferra retourner au call appelant automatiquement.<BR>
			<BR>
			L'API GetDlgItemText fonctionne sur le m&ecirc;me principe, mais les adresses ne seront pas les m&ecirc;mes. Une
			autre diff&eacute;rence sera</FONT><I><FONT SIZE="2" FACE="Arial"> nIDDlgItem</FONT></I><FONT SIZE="2" FACE="Arial">,
			qui est l'ID du contr&ocirc;le qui saisi le texte de la pile:</FONT></P>
			<PRE><FONT SIZE="2" FACE="Courier New">[ESP+10h]   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> - contiendra nMaxCount</FONT><FONT
			SIZE="2" FACE="Courier New">
[ESP+0Ch]   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> - contiendra IpString</FONT><FONT SIZE="2" FACE="Courier New">
[ESP+08h]    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">- contiendra nIDDlgItem</FONT><FONT SIZE="2"
			FACE="Courier New">
[ESP+04h]    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">- contiendra hwnd</FONT><FONT SIZE="2" FACE="Courier New">
[ESP+00h]    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">- contiendra le Return EIP</FONT></PRE>
			<P><FONT SIZE="2" FACE="Arial">Le breakpoint &agrave; poser sera alors:<BR>
			<BR>
			</FONT><B><FONT SIZE="2" FACE="Arial">Bpx GetDlgItemTextA Do &quot;D esp-&gt;C; P RET;&quot;</FONT></B><FONT SIZE="2"
			FACE="Arial"><BR>
			<BR>
			Au break sur le BPX pos&eacute;, vous aurez le contenu du buffet de saisi d'affich&eacute; dans la fen&ecirc;tre
			des Datas. Il ne suffira plus que de poser un BPR adresse_de_d&eacute;but adresse_de_fin du champ saisi pour pouvoir
			suivre &agrave; la trace ce qu'il va advenir du contenu de cette adresse (vous pouvez vous attendre &agrave; ce
			que ce contenu soit transvas&eacute; dans une [m&eacute;moire] de travail du genre [EBP-20], sur laquelle il faudra
			poser un nouveau BPR).<BR>
			<BR>
			Cette &quot;m&eacute;thode&quot; est finalement sensiblement &eacute;quivalente &agrave; la recherche du s&eacute;rial
			entr&eacute; en m&eacute;moire par un:<BR>
			S 0 L FFFFFFFF &quot;s&eacute;rial entr&eacute;&quot;, &agrave; la diff&eacute;rence que vous pouvez mieux suivre
			les manipulations faites sur le contenu du champ saisi.<BR>
			<BR>
			Dans le cas de notre </FONT><A HREF="../zips/cosh3.exe"><FONT SIZE="2" FACE="Arial">crackme</FONT></A><FONT SIZE="2" FACE="Arial">,
			voici la totalit&eacute; de la routine du g&eacute;n&eacute;rateur:</FONT></P>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:00401533  CALL      0040189E           </FONT><FONT SIZE="2" COLOR="blue"
				FACE="Courier New"> &gt; saisi du 1er champ</FONT><FONT SIZE="2" FACE="Courier New">
(retour &agrave; cette adresse apr&egrave;s un F12, qui suit le break dans SoftIce)
:00401538  MOV       ECX,[EBP-20]        
:0040153B  ADD       ECX,000000E4
:00401541  PUSH      ECX                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; D * ECX = &quot;nom entr&eacute;&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401542  MOV       ECX,[EBP-20]
:00401545  ADD       ECX,60
:00401548  CALL      0040189E           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; saisi du 2&egrave;me champ</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040154D  MOV       EDX,[EBP-20]
:00401550  ADD       EDX,000000E0
:00401556  PUSH      EDX                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; D * EDX = &quot;s&eacute;rial entr&eacute;&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401557  LEA       ECX,[EBP-1C]        </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; [EBP-1C]= nom -&gt; ECX</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040155A  CALL      00401898           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; call MFC42</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040155F  MOV       EAX,[EBP-20]
:00401562  ADD       EAX,000000E4
:00401567  PUSH      EAX                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; D * EAX = &quot;s&eacute;rial entr&eacute;&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401568  LEA       ECX,[EBP-10]        </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; [EBP-10]= s&eacute;rial -&gt; ECX</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040156B  CALL      00401898           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; call MFC42</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401570  XOR       EAX,EAX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; mise &agrave; 0 des registres</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401572  XOR       EBX,EBX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; qui vont &ecirc;tre utilis&eacute;s</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401574  XOR       ECX,ECX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; pour le cryptage </FONT><FONT
				SIZE="2" FACE="Courier New">
:00401576  MOV       ECX,00000001        </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; initialisation de la cl&eacute; de cryptage</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040157B  XOR       EDX,EDX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; mise &agrave; 0 du registre EDX</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040157D  MOV       EAX,[EBP-1C]        </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; place le nom dans EAX</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401580  MOV       BL,[EAX]          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  &gt; met un caract&egrave;re du nom dans BL    </FONT><FONT
				SIZE="2" FACE="Courier New">
:00401582  XOR       BL,CL               </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; crypte ce caract&egrave;re</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401584  MOV       [EAX],BL            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; le place dans EAX</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401586  INC       ECX                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; ajoute 1 &agrave; la cl&eacute; de cryptage</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401587  INC       EAX                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; caract&egrave;re suivant</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401588  CMP       BYTE PTR [EAX],00  </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; reste-t-il des caract&egrave;res?</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040158B  JNZ       00401580            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; oui -&gt; boucle       </FONT><FONT
				SIZE="2" FACE="Courier New">
:0040158D  XOR       EAX,EAX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; non, passe au s&eacute;rial</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040158F  XOR       EBX,EBX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; en remettant les </FONT><FONT
				SIZE="2" FACE="Courier New">
:00401591  XOR       ECX,ECX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; registres &agrave; 0</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401593  MOV       ECX,0000000A       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; initialisation de la cl&eacute; de cryptage</FONT><FONT
				SIZE="2" FACE="Courier New">
:00401598  XOR       EDX,EDX       
:0040159A  MOV       EAX,[EBP-10]       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; place le s&eacute;rial dans EAX</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040159D  MOV       BL,[EAX]            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; 1 caract&egrave;re du s&eacute;rial dans BL</FONT><FONT
				SIZE="2" FACE="Courier New">
:0040159F  XOR       BL,CL               </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; crypte ce caract&egrave;re</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015A1  MOV       [EAX],BL            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; le place dans EAX</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015A3  INC       ECX                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; ajoute 1 &agrave; la cl&eacute; de cryptage</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015A4  INC       EAX                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; caract&egrave;re suivant</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015A5  CMP       BYTE PTR [EAX],00  </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; encore des caract&egrave;res ?</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015A8  JNZ       0040159D            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; oui -&gt; boucle</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015AA  MOV       EAX,[EBP-1C]       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; place le nom crypt&eacute; dans EAX</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015AD  MOV       EDX,[EBP-10]     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">   &gt; place le s&eacute;rial crypt&eacute; dans EDX</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015B0  XOR       ECX,ECX             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; ECX mis &agrave; 00</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015B2  MOV       BL,[EAX]           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; 1 caract&egrave;re du nom dans BL</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015B4  MOV       CL,[EDX]            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; 1 caract&egrave;re du s&eacute;rial dans CL</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015B6  CMP       BL,CL              </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; compare ces 2 caract&egrave;res</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015B8  JNZ       004015C3           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; si &lt;&gt; saute en bad boy</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015BA  INC       EAX                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; caract suivant du nom</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015BB  INC       EDX                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; caract&egrave;re suivant du s&eacute;rial</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015BC  CMP       BYTE PTR [EAX],00   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; encore des caract&egrave;res pour le nom ?</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015BF  JNZ       004015B0            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">&gt; oui -&gt; boucle</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015C1  JMP       004015D9           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; non -&gt; le code est OK</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015C3  PUSH      00                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  &gt; routine Bad Boy</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015C5  PUSH      0040306C           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; pousse sur la pile, les</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015CA  PUSH      00403040          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  &gt; infos de la MessageBox</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015CF  MOV       ECX,[EBP-20]
:004015D2  CALL      00401892           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; affichage de la MessageBox</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015D7  JMP       004015ED
:004015D9  PUSH      00                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> &gt; routine Good Boy</FONT><FONT
				SIZE="2" FACE="Courier New">
:004015DB  PUSH      00403034     
:004015E0  PUSH      00403020
:004015E5  MOV       ECX,[EBP-20]
:004015E8  CALL      00401892
etc....</FONT></PRE>
			</BLOCKQUOTE>
			<P><U><FONT SIZE="2" FACE="Arial">Analysons un peu ces lignes</FONT></U><FONT SIZE="2" FACE="Arial">:<BR>
			<BR>
			&middot; Le s&eacute;rial et le nom sont saisis par l'API GetWindowTextA<BR>
			&middot; Le contenu du 1er champ est plac&eacute; &agrave; l'adresse point&eacute;e par EAX<BR>
			&middot; Les caract&egrave;res sont charg&eacute;s 1 a 1 dans BL<BR>
			&middot; le Xor BL, CL va crypter ce caract&egrave;re: en d&eacute;but de routine, CL va recevoir la valeur 01
			qui va &ecirc;tre la cl&eacute; de cryptage. Cette cl&eacute; changera &agrave; chaque fois par incr&eacute;mentation.<BR>
			&middot; Puis le caract&egrave;re crypt&eacute; va &ecirc;tre replac&eacute; dans EAX, et remplacera le caract&egrave;re
			entr&eacute;.<BR>
			<BR>
			Le principe va &ecirc;tre le m&ecirc;me pour le s&eacute;rial, &agrave; ceci pr&eacute;s que la cl&eacute; de cryptage
			sera &eacute;gale &agrave; 10d (0Ah) au d&eacute;marrage. Puis les caract&egrave;res du s&eacute;rial et du nom
			vont &ecirc;tre compar&eacute;s un &agrave; un, jusqu'&agrave; concurrence du nombre de caract&egrave;res contenus
			dans le 1er champ du formulaire de saisie (le cmp byte ptr [EAX], 00 v&eacute;rifie que le dernier byte saisie
			n'est pas un 00). Le s&eacute;rial peut donc avoir n'importe quel taille sup&eacute;rieure &agrave; celle du nom.
			<BR>
			<BR>
			Le principe de la validation du s&eacute;rial est donc bas&eacute; sur ce sch&eacute;ma:<BR>
			<BR>
			</FONT><B><FONT SIZE="2" FACE="Arial">1er champ Xor CL = 2eme champ Xor CL+10</FONT></B><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			avec CL qui variera de 01 &agrave; {01+ nombre de caract&egrave;res entr&eacute;s dans le champ}.<BR>
			<BR>
			A titre d'exemple, en entrant &quot;Christal&quot; dans le premier champ, vous allez obtenir &quot;bjqmvrfd&quot;
			apr&egrave;s cryptage, et le second champ donnera &quot;&gt;35&gt;=:&quot; pour &quot;489335&quot; d'entr&eacute;.<BR>
			Ensuite, &quot;b&quot; -&gt; 6A sera compar&eacute; &agrave; &quot;&gt;&quot; -&gt; 3E, et vous irez en routine
			Bad Boy.<BR>
			Tombeur 4, dans une &eacute;tude de ce Crackme, avait d&eacute;j&agrave; montr&eacute; comment patcher le programme
			pour obliger celui ci &agrave; aller syst&eacute;matiquement en routine Good Boy:</FONT></P>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:004015B8  7509          jne       004015C3</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">Il peut y avoir d'autres solutions:</FONT></P>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:004015AA  8B45E4        MOV       EAX,[EBP-1C]
:004015AD  8B55F0        MOV       EDX,[EBP-10]
:004015B0  33C9          XOR       ECX,ECX
:004015B2  8A18          MOV       BL,[EAX]
:004015B4  8A0A          MOV       CL,[EDX]
:004015B6  3AD9          CMP       BL,CL
:004015B8  7509          JNZ       004015C3</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">En 004015AD vous pouvez remplacer EBP-10 (s&eacute;rial crypt&eacute; -&gt; 8B55F0)
			par EBP-1C (nom crypt&eacute; -&gt; 8B55E4), si bien qu'en fait le nom que vous aurez entr&eacute; sera compar&eacute;
			avec lui m&ecirc;me, et vous irez en routine Good Boy.<BR>
			<BR>
			Un noppage du JNZ 004015C3 vous amm&egrave;nes &eacute;galement vers la routine Good Boy.<BR>
			<BR>
			Vous pouvez aussi supprimer les deux cl&eacute;s de cryptage (Xor BL, CL) et entrer le m&ecirc;me s&eacute;rial
			(ou nom) dans les deux champs. L&agrave; encore vous irez en routine good Boy. Pas tr&egrave;s int&eacute;ressant...<BR>
			<BR>
			Nous verrons tout &agrave; l'heure comment s'amuser avec ces diff&eacute;rentes options...<BR>
			<BR>
			Le plus simple est quand m&ecirc;me de trouver quel devrait &ecirc;tre le s&eacute;rial &agrave; entrer pour le
			nom de votre choix:<BR>
			Dans le cas de cryptage comme celui ci, on ne peut pas &eacute;tablir une grille de proportion (du genre si &quot;4&quot;
			-&gt; 52 Ascii = &quot;&gt;&quot; -&gt; 62 Ascii, alors &quot;8&quot; -&gt; 56 Ascii = valeur ascii du bon s&eacute;rial).<BR>
			<BR>
			Comme on sait que le nom crypt&eacute; (cl&eacute; 01) va &ecirc;tre compar&eacute; au s&eacute;rial crypt&eacute;
			(cl&eacute; 0A), il est facile (mais cela oblige &agrave; utiliser un d&eacute;buggeur, ou &agrave; &eacute;crire
			une routine dans le langage de son choix)  d'entrer votre nom dans le premier champ, et votre nom crypt&eacute;
			dans le second, soit:</FONT></P>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">1er  champ:   Christal
2eme champ:   bjqmvrfd</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">Puis de provoquer un break en 004015AD pour lire le s&eacute;rial crypt&eacute;
			par un &quot; d EDX&quot;.<BR>
			Dans mon cas, j'obtiens &quot;ha}`x}vu&quot;. Il ne reste plus qu'&agrave; remplir la dialogbox ainsi:</FONT></P>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">1er  champ:   Christal
2eme champ:   ha}`x}vu</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">&quot;Christal&quot; et &quot;ha}`x}vu&quot;, une fois crypt&eacute; vont donner
			&quot;bjqmvrfd&quot;, et la comparaison dans la boucle en 004015B6 nous enverra vers la routine Good Boy! <BR>
			CQFD!<BR>
			<BR>
			Nous voici maintenant &agrave; la t&ecirc;te de tout un panel de possibilit&eacute;s.<BR>
			Laquelle choisir?<BR>
			Pourquoi pas toutes?<BR>
			<BR>
			J'ai donc opt&eacute; pour un &quot;</FONT><A HREF="../zips/multifct.exe"><FONT SIZE="2" FACE="Arial">General anti-Cosh3</FONT></A><FONT
			SIZE="2" FACE="Arial">&quot; qui pourrait aussi bien patcher le programme (mais uniquement en m&eacute;moire) que
			de d&eacute;livrer le bon serial en reprennant le g&eacute;n&eacute;rateur de code. Ayant utilis&eacute; la bonne
			vieille technique du Coup&eacute;/Coll&eacute;, les commentaires de l'extrait du source ci dessous sont identiques
			&agrave; ceux du Dead Listing.<BR>
			Je tient &agrave; pr&eacute;ciser que n'&eacute;tant pas programmeur du tout, les extraits de source (ormi ceux
			que j'ai reproduit) sont tr&egrave;s loin d'&ecirc;tre optimis&eacute;s, et pour tout dire, probablement tr&egrave;s
			mal &eacute;crit. Sorry!</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="67%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="#FFFFCC">
						<PRE><FONT SIZE="2" FACE="Courier New">      invoke GetWindowTextA,hwndEdit1,ADDR buffer,13 
      &gt; saisie limite &agrave; 13, la taille de mon champ d'&eacute;dition

;========================================================================= 
;                             Key File generator
;=========================================================================  
      cmp       eax ,2                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; 2 caract&egrave;res mini &agrave; entrer</FONT><FONT
						SIZE="2" FACE="Courier New">
      jl        Trop_court
      XOR       EAX,EAX               ; </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">mise &agrave; z&eacute;ro de tous les registres</FONT><FONT
						SIZE="2" FACE="Courier New">
      XOR       EBX,EBX               </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; de travail</FONT><FONT
						SIZE="2" FACE="Courier New">
      XOR       ECX,ECX
      XOR       EDX,EDX
      INC       ECX                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; initilisation de la cl&eacute; de cryptage</FONT><FONT
						SIZE="2" FACE="Courier New">
      LEA       EAX,[offset buffer]   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; eax = Name</FONT><FONT
						SIZE="2" FACE="Courier New">
loop1:
      MOV       BL,[EAX]             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; BL = caract&egrave;re du Name</FONT><FONT
						SIZE="2" FACE="Courier New">
      XOR       BL,CL                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; CL = cl&eacute; de cryptage</FONT><FONT
						SIZE="2" FACE="Courier New">
      MOV       [EAX],BL             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; sauvegarde du r&eacute;sultat</FONT><FONT
						SIZE="2" FACE="Courier New">
      INC       ECX                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; incr&eacute;mente cl&eacute; de cryptage</FONT><FONT
						SIZE="2" FACE="Courier New">
      INC       EAX                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; passe au caract&egrave;re suivant </FONT><FONT
						SIZE="2" FACE="Courier New"> 
      CMP       BYTE PTR [EAX],00     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; est-ce le dernier caract&egrave;re?</FONT><FONT
						SIZE="2" FACE="Courier New">
      JNZ       loop1                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Non -&gt; loop</FONT><FONT
						SIZE="2" FACE="Courier New">
      XOR       EAX,EAX               </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; remise &agrave; z&eacute;ro des registres</FONT><FONT
						SIZE="2" FACE="Courier New">
      XOR       EBX,EBX
      XOR       ECX,ECX
      XOR       EDX,EDX               
      MOV       ECX,0000000Ah        </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; cl&eacute; de cryptage = 0Ah</FONT><FONT
						SIZE="2" FACE="Courier New">
      LEA       EAX,[offset buffer]</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">   ; EAX = Name crypyt&eacute;
</FONT><FONT SIZE="2" FACE="Courier New">loop2:
      MOV       BL,[EAX]              </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; un caract&egrave;re dans BL</FONT><FONT
						SIZE="2" FACE="Courier New">
      XOR       BL,CL                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; crypt&eacute; avec la cl&eacute;</FONT><FONT
						SIZE="2" FACE="Courier New">
      MOV       [EAX],BL              </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; et replac&eacute; dans le buffer</FONT><FONT
						SIZE="2" FACE="Courier New">
      INC       ECX                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; incr&eacute;mente la cl&eacute; de cryptage</FONT><FONT
						SIZE="2" FACE="Courier New">
      INC       EAX                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; passe au caract&egrave;re suivant</FONT><FONT
						SIZE="2" FACE="Courier New">
      CMP       BYTE PTR [EAX],00     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; est-ce le dernier</FONT><FONT
						SIZE="2" FACE="Courier New">
      JNZ       loop2                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; Non -&gt; loop</FONT><FONT
						SIZE="2" FACE="Courier New">
      jmp       Affiche               </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; fin de la g&eacute;n&eacute;ration du bon serial</FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</P>
</CENTER>
			<P><FONT SIZE="2" FACE="Arial">Dans l'un de ses extraordinaires textes sur la programmation ASM, Izcelion proposait
			une routine permettant de patcher un programme en m&eacute;moire. Par chance, Morgatte nous en a fait une traduction
			fid&egrave;le et inspir&eacute;e qui vous donnera toutes les explications (voir Dossier n&deg;9):</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="67%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="#FFFFCC">
						<PRE><FONT SIZE="2" FACE="Courier New">      .IF  ax==IDM_patch                          </FONT><FONT SIZE="2"
						COLOR="blue" FACE="Courier New"> ; menu &quot;Patch&quot; selectionn&eacute;?</FONT><FONT SIZE="2" FACE="Courier New">
;=========================================================================
;             issue d'un exemple d'Izcelion traduit par Morgatte
;=========================================================================
   cmp       byte ptr [Flag_process],01            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; le process est d&eacute;j&agrave; cr&eacute;&eacute;?</FONT><FONT
						SIZE="2" FACE="Courier New">
   jne       run_memory                            </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; alors Go_Out</FONT><FONT
						SIZE="2" FACE="Courier New">
           
   invoke    SetWindowTextA,hwndEdit2,ADDR in_use  </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; affichage dans</FONT><FONT
						SIZE="2" FACE="Courier New">
   invoke    SetWindowTextA,hwndEdit1,ADDR in_use2 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; les champs d'&eacute;dition</FONT><FONT
						SIZE="2" FACE="Courier New">
   jmp       Go_out_memory

run_memory:          
   invoke   GetStartupInfo,addr startinfo  </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; r&eacute;cup&egrave;re les propri&eacute;t&eacute;s du process    </FONT><FONT
						SIZE="2" FACE="Courier New">
   invoke   CreateProcess, addr Name_of_exe, NULL, NULL, NULL, FALSE, \
   DEBUG_PROCESS+ DEBUG_ONLY_THIS_PROCESS, NULL, NULL, \ 
   addr     startinfo, addr pi             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; m&eacute;morise les Process_informations
         </FONT><FONT SIZE="2" FACE="Courier New">
   cmp   eax,0                             </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; si la cr&eacute;ation du process a &eacute;chou&eacute;</FONT><FONT
						SIZE="2" FACE="Courier New">
   jne   File_founded                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; c'est que le fichier n'a pas &eacute;t&eacute; trouv&eacute;</FONT><FONT
						SIZE="2" FACE="Courier New">
   invoke GetOpenFileName, ADDR ofn       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; ouverture de la boite OpenFile</FONT><FONT
						SIZE="2" FACE="Courier New">

.if eax==TRUE 
   invoke GetStartupInfo,addr startinfo    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; et on relance la machine...</FONT><FONT
						SIZE="2" FACE="Courier New">
   invoke CreateProcess, addr buffer, NULL, NULL, NULL, FALSE, \
   DEBUG_PROCESS+ DEBUG_ONLY_THIS_PROCESS, NULL, NULL, \ 
   addr startinfo, addr pi
.endif

File_founded:
     	 .while TRUE                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; d&eacute;but de la boucle Debug Apis</FONT><FONT
						SIZE="2" FACE="Courier New">
	 invoke WaitForDebugEvent, addr DBEvent, INFINITE

	 .break .if DBEvent.dwDebugEventCode==EXIT_PROCESS_DEBUG_EVENT
      				
	 .if DBEvent.dwDebugEventCode==CREATE_PROCESS_DEBUG_EVENT      
                                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; pr&eacute;paration affichage informations</FONT><FONT
						SIZE="2" FACE="Courier New">
		invoke wsprintf, addr buffer, addr ProcessInfo, \
		  DBEvent.u.CreateProcessInfo.hFile, \
      	  DBEvent.u.CreateProcessInfo.hProcess, \
      	  DBEvent.u.CreateProcessInfo.hThread, \
      	  DBEvent.u.CreateProcessInfo.lpBaseOfImage, \
      	  DBEvent.u.CreateProcessInfo.lpStartAddress, \
              offset1, patch1
      
           invoke MessageBox,0, addr buffer, addr AppName, \
      	  MB_OK+MB_ICONINFORMATION     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; affichage des informations sur le process</FONT><FONT
						SIZE="2" FACE="Courier New">
      
      	invoke WriteProcessMemory, DBEvent.u.CreateProcessInfo.hProcess, \
      	  offset1, addr patch1, 2, NULL </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; le process est patch&eacute; en m&eacute;moire  </FONT><FONT
						SIZE="2" FACE="Courier New">  
      				
      	 .elseif DBEvent.dwDebugEventCode==EXCEPTION_DEBUG_EVENT
      	   .if DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_BREAKPOINT
      		   invoke ContinueDebugEvent, DBEvent.dwProcessId, \
      		   DBEvent.dwThreadId, DBG_CONTINUE.continue
      		   .endif                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; sortie de la boucle</FONT><FONT
						SIZE="2" FACE="Courier New">
      		 .endif
      	invoke ContinueDebugEvent, DBEvent.dwProcessId, \  </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; fin de la boucle</FONT><FONT
						SIZE="2" FACE="Courier New">
      	DBEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED
      .endw

     invoke CloseHandle,pi.hProcess        </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; fermeture du process</FONT><FONT
						SIZE="2" FACE="Courier New">
     invoke CloseHandle,pi.hThread
     mov    byte ptr [Flag_process],01     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Flag anti plantage</FONT><FONT
						SIZE="2" FACE="Courier New">

Go_out_memory:       
     .ENDIF            </FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</P>
</CENTER>
			<P><FONT SIZE="2" FACE="Arial">Il y a aussi possible d'utiliser une m&eacute;thode que Pulsar avait employ&eacute;
			dans l'un de ses programmes:<BR>
			la modification de la valeur plac&eacute;e dans le registre EDX, en la remplacant par celle plac&eacute;e dans
			EAX.</FONT>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:004015AA 8B45E4 MOV EAX,[EBP-1C]
:004015AD 8B55F0 MOV EDX,[EBP-10]</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">Pour cela, je vais utiliser les Debug Registers.<BR>
			Pour plus d'explication sur ces Debug Apis et les Debug Registers, reportez vous au </FONT><A HREF="http://christal.citeweb.net/antisice.htm"
			target="_blank"><FONT SIZE="2" FACE="Arial">Dossier n&deg;9 du Groupe de travail</FONT></A><FONT SIZE="2" FACE="Arial">.</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="80%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="#FFFFCC">
						<PRE><FONT SIZE="2" FACE="Courier New">;=========================================================================
;                             Debug proc&eacute;dures
;=========================================================================	

contexte proc
        pushad
        mov    dword ptr [context], CONTEXT_i486 \
        or CONTEXT_DEBUG_REGISTERS
        push   offset context
        push   dword ptr [hThread]
        Call   GetThreadContext
        mov    dword ptr [context + 184], 004015B2h    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; regEIP</FONT><FONT
						SIZE="2" FACE="Courier New">
        or     dword ptr [context+18h], 00000003h      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; DR7</FONT><FONT
						SIZE="2" FACE="Courier New">
        and    dword ptr [context+18h], FFF0FFFFh      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; DR7</FONT><FONT
						SIZE="2" FACE="Courier New">
        or     dword ptr [context+14h], 00000001h      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; DR6</FONT><FONT
						SIZE="2" FACE="Courier New">
        push   offset context
        push   dword ptr [hThread]
        Call   SetThreadContext
        popad
ret
contexte endp

;=========================================================================

contexte2 proc
        pushad
        mov    dword ptr [context], CONTEXT_i486 \
        or CONTEXT_CONTROL or CONTEXT_INTEGER or CONTEXT_SEGMENTS
        push   offset context
        push   dword ptr [hThread]
        Call   GetThreadContext
        mov    eax, dword ptr [context+176d]
        mov    dword ptr [context+168d], eax
        push   offset context
        push   dword ptr [hThread]
        Call   SetThreadContext
        popad
ret
contexte2 endp

;=========================================================================

contexte3 proc
        pushad
        mov    dword ptr [context], CONTEXT_i486 \
        or CONTEXT_DEBUG_REGISTERS
        push   offset context
        push   dword ptr [hThread]
        Call   GetThreadContext
        mov    dword ptr [context+04], 00000000
        and    dword ptr [context+18h], -256
        and    dword ptr [context+14h], FFFFFFF8h
        push   offset context
        push   dword ptr [hThread]
        Call   SetThreadContext
        popad
ret
contexte3 endp

;=========================================================================
;           source reconstitu&eacute; &agrave; partir d'un programme de Pulsar
;=========================================================================

debug_patch proc 
          invoke    SetWindowTextA,hwndEdit2,NULL
          cmp       byte ptr [Flag_process],01     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; le process est d&eacute;j&agrave; cr&eacute;&eacute;?</FONT><FONT
						SIZE="2" FACE="Courier New">
          jne       run_proc
          invoke    SetWindowTextA,hwndEdit2,ADDR in_use 
          invoke    SetWindowTextA,hwndEdit1,ADDR in_use2 
          jmp       Go_out_process
run_proc:          
          invoke    MessageBoxA,NULL, ADDR Name_entered, ADDR run_process, MB_OK
          invoke    SetWindowTextA,hwndEdit1,ADDR methode 
          
          push      offset StartupInfo
          Call      GetStartupInfoA
          
          invoke   CreateProcess, addr Name_of_exe,  addr Name_of_exe, NULL, NULL,\
          FALSE, DEBUG_PROCESS + DEBUG_ONLY_THIS_PROCESS , NULL,\ 
          NULL, ADDR StartupInfo, ADDR lp_process_info
          
          cmp       eax,0
          jne       File_founded2
          invoke    GetOpenFileName, ADDR ofn

    .if eax==TRUE 
          invoke   CreateProcess, addr buffer,  addr buffer, NULL, NULL,\
          FALSE, DEBUG_PROCESS + DEBUG_ONLY_THIS_PROCESS , NULL,\ 
          NULL, ADDR StartupInfo, ADDR lp_process_info
    .endif

File_founded2:
          mov      esi, dword ptr [lp_process_info+04]
          mov      dword ptr [hThread], esi  
          mov      esi, dword ptr [lp_process_info+08] 
          mov      dword ptr [hProcess], esi 
 
          Xor       esi,esi
          jmp       continue2
loop_debug:
          push      esi
          invoke    WaitForDebugEvent,ADDR debug_event,FFFFFFFFh
          cmp       dword ptr [debug_event],CREATE_PROCESS_DEBUG_EVENT
          jne       continue1
          call      contexte
          
          invoke ContinueDebugEvent, debug_event.dwProcessId,\
          debug_event.dwThreadId, DBG_CONTINUE 
          jmp       do_continue
continue1:
          cmp       dword  ptr [debug_event], 00000001
          jne       continue3
          mov       dword  ptr [lp_process_info+10h],CONTEXT_i486 or CONTEXT_CONTROL\
          or CONTEXT_INTEGER or CONTEXT_SEGMENTS
          push      offset lp_process_info +10h
          push      dword  ptr [lp_process_info+04]
          Call      GetThreadContext
          cmp       dword  ptr [lp_process_info+200d], 004015b2h
          jne       continue4
          
          call      contexte2
          call      contexte3
continue4:
          invoke ContinueDebugEvent, debug_event.dwProcessId,\
          debug_event.dwThreadId, DBG_CONTINUE 
          jmp       do_continue
continue3:
          cmp       dword ptr [debug_event], 00000005
          jne       not_handled
          pop       esi
          jmp       Go_out_process
          jmp       do_continue
not_handled:
          invoke ContinueDebugEvent, debug_event.dwProcessId,\
          debug_event.dwThreadId, DBG_CONTINUE 
do_continue:
          pop       esi
continue2:
          or        esi, esi
          je        loop_debug
 
Go_out_process:
          mov       byte ptr [Flag_process],01
          PUSH      DWORD PTR [hProcess]
          CALL      CloseHandle 
          PUSH      DWORD PTR [hThread]
          Call      CloseHandle

          ret
debug_patch endp</FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</P>
</CENTER>
			<P><B><U><FONT SIZE="4" FACE="Arial">Debug Registers</FONT></U></B><FONT SIZE="2" FACE="Arial"> (extrait du Dossier
			n&deg;9)</FONT><B><U><FONT SIZE="4" FACE="Arial"></FONT></U></B></P>

			<P><FONT SIZE="2" FACE="Arial">Vous vous &ecirc;tes d&eacute;j&agrave; demand&eacute; pourquoi les BPM (BreakPoint
			on Memory) n'&eacute;taient limit&eacute;s qu'&agrave; quatre?</FONT></P>

			<P><FONT SIZE="2" FACE="Arial">Tout simplement parce qu'il n'existe, dans l'architecture Win32, que quatre endroits
			o&ugrave; stocker les adresses lineaires de ces breakpoints: DR0, DR1, DR2, DR3. Les DR4 et DR5 sont r&eacute;serv&eacute;s,
			le DR7 &quot;configure&quot; le type de Break &agrave; ex&eacute;cuter &agrave; une adresse donn&eacute;e, le DR6
			sert aux debuggeurs.</FONT></P>
			<P><FONT SIZE="2" FACE="Arial">Reprennont l'exemple du source ci dessus: </FONT><I><FONT SIZE="2" FACE="Arial">activation
			du BreakPoint</FONT></I></P>
			<PRE><FONT SIZE="2" FACE="Courier New">        mov    dword ptr [context+B8h], 004014E1h      </FONT><FONT SIZE="2"
			COLOR="blue" FACE="Courier New">; regEIP</FONT><FONT SIZE="2" FACE="Courier New">
        or     dword ptr [context+18h], 00000003h     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; DR7</FONT><FONT
			SIZE="2" FACE="Courier New">
        and    dword ptr [context+18h], FFF0FFFFh      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; DR7</FONT></PRE>
			<P><FONT SIZE="2" FACE="Arial">Pour &ecirc;tre exact, il faudrait l'&eacute;crire ainsi:</FONT></P>
			<PRE><FONT SIZE="2" FACE="Courier New">        mov    dword ptr [context+B8h], 004014E1h                         </FONT><FONT
			SIZE="2" COLOR="blue" FACE="Courier New">; regEIP</FONT><FONT SIZE="2" FACE="Courier New">
        or     dword ptr [context+18h], 00000000000000000000000000000011b </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; DR7</FONT><FONT
			SIZE="2" FACE="Courier New">
        and    dword ptr [context+18h], 11111111111100001111111111111111b </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; DR7</FONT></PRE>
			<P><FONT SIZE="2" FACE="Arial">La repr&eacute;sentation en binaire va permettre de mieux comprendre le fonctionnement
			global.</FONT></P>
			<P><FONT SIZE="2" FACE="Arial">Dans une architecte 32 bytes, le tableau g&eacute;n&eacute;ral des Debug Registers
			est le suivant:</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="71%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="#FFFFCC">
						<PRE><FONT SIZE="2" FACE="Courier New">      31  29  27  25  23  21  19  17  15    12    9 8 7 6 5 4 3 2 1 0
     |---+---+---+---+---+---+---+---+---+-+-----+-+-+-+-+-+-+-+-+-+-|
     |LEN|R/W|LEN|R/W|LEN|R/W|LEN|R/W|   | |     |G|L|G|L|G|L|G|L|G|L|
     |   |   |   |   |   |   |   |   |0 0|0|0 0 0| | | | | | | | | | | DR7
     | 3 | 3 | 2 | 2 | 1 | 1 | 0 | 0 |   | |     |E|E|3|3|2|2|1|1|0|0|
     |              (10 &agrave; 12 et 14 &agrave; 15 sont reserved)               |
     |---+---+---+---+---+---+---+---+-+-+-+-----+-+-+-+-+-+-+-+-+-+-|
     |                               |B|B|B|                 |B|B|B|B|
     |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0| | | |0 0 0 0 0 0 0 0 0| | | | | DR6
     |                               |T|S|D|                 |3|2|1|0|
     |---------------+---------------+-+-+-+---------+-------+-+-+-+-|
     |                            RESERVED                           | DR5
     |---------------+---------------+---------------+---------------|
     |                            RESERVED                           | DR4
     |---------------+---------------+---------------+---------------|
     |                 BREAKPOINT 3 LINEAR ADDRESS                   | DR3
     |---------------+---------------+---------------+---------------|
     |                 BREAKPOINT 2 LINEAR ADDRESS                   | DR2
     |---------------+---------------+---------------+---------------|
     |                 BREAKPOINT 1 LINEAR ADDRESS                   | DR1
     |---------------+---------------+---------------+---------------|
     |                 BREAKPOINT 0 LINEAR ADDRESS                   | DR0
     |---------------+---------------+----------------+--------------|</FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</P>
</CENTER>
			<PRE><FONT SIZE="2" FACE="Arial">Les bytes 10 &agrave; 15 (reserved):</FONT></PRE>
			<BLOCKQUOTE>
				<BLOCKQUOTE>
					<BLOCKQUOTE>
						<BLOCKQUOTE>
							<PRE><FONT SIZE="2" FACE="Courier New">31                  15 14 13 12 11 10         0
+------------------+--+--+--+--+--+--+--------+
|                  | T| T| G| I|  |  |        |
|                  | 2| R| D| R|  |  |        |
+------------------+--+--+--+--+--+--+--------+
                     |  |  |  |
                     |  |  |  +- IceBp    1=INT01 causes emulator
                     |  |  |              to break emulation
                     |  |  |              0=CPU handles INT01
                     |  |  +---- Global   Debug 
                     |  +------- Trace1   1=Generate special address
                     |                    cycles after code dis-
                     |                    continuities.  On Pentium,
                     |                    these cycles are called
                     |                    Branch Trace Messages.
                     +---------- Trace2   1=Unknown.</FONT></PRE>
						</BLOCKQUOTE>
					</BLOCKQUOTE>
				</BLOCKQUOTE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">Dans l'exemple utilis&eacute;, les OR et AND vont servir &agrave; conserver les
			informations du DR7 (d'&eacute;ventuels autres BPM), et &agrave; ne modifier que celles qui vont directement concerner
			le DR0 dans lequel le BreakPoint attendu (en 004014E1) va &ecirc;tre pos&eacute;. Si aucun BreakPoint nest pos&eacute;,
			les bits sont tous &agrave; 0.</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="67%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="#FFFFCC">
						<PRE><FONT SIZE="2" FACE="Courier New">      31  29  27  25  23  21  19  17  15    12    9 8 7 6 5 4 3 2 1 0
     |---+---+---+---+---+---+---+---+---+-+-----+-+-+-+-+-+-+-+-+-+-|
     |LEN|R/W|LEN|R/W|LEN|R/W|LEN|R/W|   | |     |G|L|G|L|G|L|G|L|G|L|
       00  00  00  00  00  00  00  00 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> </FONT><FONT SIZE="2"
						FACE="Courier New">00 0  0 00 0 0 0 0 0 0 0 0 1 1
</FONT><FONT SIZE="2" COLOR="red" FACE="Courier New"> +</FONT><FONT SIZE="2" FACE="Courier New">     11  11  11  11  11  11  00  00  11 1  1 11 1 1 1 1 1 1 1 1 1 1
</FONT><FONT SIZE="2" COLOR="red" FACE="Courier New"> =    -----------------------------------------------------------------</FONT><FONT
						SIZE="2" FACE="Courier New">
       00  00  00  00   00  00 11  11  00 0  0 00 0 0 0 0 0 0 0 0 1 1
</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">                               ------                             ---
                                  |                                | 
                                  +---------------DR0--------------+</FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</P>
</CENTER>
			<P><B><FONT SIZE="2" FACE="Arial">Quelques explications:</FONT></B><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			</FONT><U><FONT SIZE="2" FACE="Arial">Debug Address Registers (DR0-DR3)</FONT></U><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			Chacun de ces registres contient l'adresse lineaire (par exemple 00401000) associ&eacute;e avec l'une des quatre
			conditions possibles. Ces conditions sont d&eacute;finies dans le DR7.<BR>
			<BR>
			</FONT><U><FONT SIZE="2" FACE="Arial">Debug Control Register (DR7)</FONT></U><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			A chaque adresse lineaire des registres DR0 &agrave; DR3, correspond un champ R/W. Le processeur interpr&egrave;te
			ces bits ainsi:<BR>
			<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">00 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">Break
			on instruction execution only<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">01 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">Break
			on data writes only<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">10 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">undefined<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">11 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">Break
			on data reads or writes but not instruction fetches</FONT><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			Les champs LEN0 &agrave; LEN3 pr&eacute;cisent, quant &agrave; eux, la longeur des items &agrave; monitorer.<BR>
			Les valeurs des champs sont interpr&eacute;t&eacute;s de cette fa&ccedil;on:<BR>
			<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">00 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">one-byte
			length<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">01 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">two-byte
			length<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">10 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">undefined<BR>
			</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">11 -- </FONT><FONT SIZE="2" COLOR="blue" FACE="Arial">four-byte
			length</FONT><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			Si RWn est egal &agrave; 00 (instruction execution), alors LENn doit aussi &ecirc;tre &eacute;gal &agrave; 00.
			Toute autre valeur est ignor&eacute;e.<BR>
			<BR>
			Les champs L0 &agrave; L3 (Local) et G0 &agrave; G3 (Global), &eacute;galement li&eacute; &agrave; l'un des quatre
			DR0-DR3, activent (ou d&eacute;sactivent suivant l'&eacute;tat) l'adresse du breakpoint selectionn&eacute;.<BR>
			<BR>
			</FONT><U><FONT SIZE="2" FACE="Arial">Debug Status Register (DR6)</FONT></U><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			Le DR6 sert principalement aux d&eacute;buggeurs pour d&eacute;terminer quelle &quot;debug condition&quot; est
			arriv&eacute;e. Dans le source ci dessus, il n'est pas n&eacute;cessaire de s'en occuper.<BR>
			
<HR ALIGN="CENTER">
<BR>
			</FONT><B><U><FONT SIZE="4" COLOR="blue" FACE="Arial">FTP Xpert 1.30</FONT></U></B><FONT SIZE="2" FACE="Arial"><BR>
			<BR>
			Dans ce second exemple de g&eacute;n&eacute;rateur, le serial est tout aussi facile &agrave; trouver, voir plus
			facile encore, mais son g&eacute;n&eacute;rateur donne une impression un peu brouillon... <BR>
			<BR>
			</FONT><U><FONT SIZE="2" FACE="Arial">D&eacute;finition des champs de recherche:<BR>
			</FONT></U><FONT SIZE="2" FACE="Arial"><BR>
			en premier, il convient de trouver:</FONT></P>
			<PRE><FONT SIZE="2" FACE="Arial">O&ugrave; le serial est saisi:                                                    </FONT><FONT
			SIZE="2" COLOR="blue" FACE="Arial">    BPX Hmemcpy</FONT><FONT SIZE="2" FACE="Arial">
O&ugrave; la MessageBox &quot;mauvais num&eacute;ro&quot; s'affiche:         </FONT><FONT SIZE="2" COLOR="blue"
			FACE="Arial">Trace F10</FONT></PRE>
			<P><FONT SIZE="2" FACE="Arial">puis de rechercher les contr&ocirc;les &eacute;ventuels.<BR>
			Dans ce programme, la lecture est assez facile, et pour tout dire classique:<BR>
			<BR>
			Saisie du name<BR>
			Si absent Go Out<BR>
			Saisie du serial entr&eacute;<BR>
			Si absent Go Out<BR>
			Saisie du Name<BR>
			G&eacute;n&eacute;ration du bon serial<BR>
			Saisie du Serial entr&eacute;<BR>
			Comparaison<BR>
			Si diff&eacute;rent, affichage d'une autre MessageBox &quot;mauvais code&quot;.</FONT></P>
			<PRE><FONT SIZE="2" FACE="Courier New">:004BAOB2 call 0043F328                          </FONT><FONT SIZE="2" COLOR="blue"
			FACE="Courier New">saisie du Name</FONT><FONT SIZE="2" FACE="Courier New">
:004BAOB7 cmp  dword ptr [ebp-08], 00000000      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">si absent</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BAOBB je   004BA1C9                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">Goto end</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BAOC1 lea  edx, dword ptr [ebp-0C]
:004BAOC4 mov  eax, dword ptr [ebx+000002D4]
:004BAOCA call 0043F328                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">saisie du serial</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BAOCF cmp  dword ptr [ebp-0C], 00000000      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">si absent</FONT><FONT
			SIZE="2" FACE="Courier New">  
:004BAOD3 jne  004BAOF2</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">                          Goto &quot;Mauvais num&eacute;ro&quot;
</FONT><FONT SIZE="2" FACE="Courier New">:004BAOD5 push 00000030

</FONT><FONT SIZE="2" COLOR="green" FACE="Courier New">* Possible StringData Ref from Code 0bj -&gt;&quot;FTP Expert&quot;
</FONT><FONT SIZE="2" FACE="Courier New">:004BAOD7 mov  ecx, 004BA1F8

</FONT><FONT SIZE="2" COLOR="green" FACE="Courier New">* Possible StringData Ref from Code 0bj -&gt;&quot;Mauvais num&quot;
</FONT><FONT SIZE="2" FACE="Courier New">:004BAODC mov  edx, 004BA204
:004BAOE1 mov  eax, dword ptr [004F4944]
:004BAOE6 mov  eax, dword ptr [eax]
:004BAOE8 call 00463820
:004BAOED jmp  004BA1C9                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> Goto end</FONT><FONT
			SIZE="2" FACE="Courier New">

* Referenced by a (U)nconditional or (C)onditiona1 Jump at Address:
|:004BAOD3(C)
I
:004BAOF2 lea  edx, dword ptr [ebp-10]
:004BAOF5 mov  eax, dword ptr [ebx+000002D4]
:004BAOFB call 0043F328                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">    saisie du name</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BA100 mov  edx, dword ptr [ebp-10]
:004BA103 lea  ecx, dword ptr [ebp-04]
:004BA106 mov  eax, dword ptr [004F4828]
:004BA10B mov  eax, dword ptr [eax]
:004BA10D call 004C60AO                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">g&eacute;neration du bon serial</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BA112 lea  edx, dword ptr [ebp-14]
:004BA115 mov  eax, dword ptr [ebx+000002D8]
:004BA11B call 0043F328                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> saisie du serial</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BA120 mov  edx, dword ptr [ebp-14]           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">serial entr&eacute; dans edx</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BA123 mov  eax, dword ptr [ebp-04]          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> bon serial dans eax</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BA126 call 00404138                        </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  contr&ocirc;le des deux serials</FONT><FONT
			SIZE="2" FACE="Courier New">
:004BA12B jne  004BA1Bl                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">bad boy</FONT><FONT
			SIZE="2" FACE="Courier New">

etc...

</FONT><FONT SIZE="2" COLOR="green" FACE="Courier New">* Possible StringData Ref from Code 0bj -&gt;&quot;FTP Expert&quot;
</FONT><FONT SIZE="2" FACE="Courier New">:004BA171 mov  ecx, 004BA1F8

</FONT><FONT SIZE="2" COLOR="green" FACE="Courier New">* Possible StringData Ref from Code 0bj -&gt;&quot;Merci de votre enregistrement. &quot;
                                        -&gt;&quot;Le logiciel est maintenant assign&quot;
</FONT><FONT SIZE="2" FACE="Courier New">:004BA176 mov  edx, 004BA228
:004BA17B mov  eax, dword ptr [004F4944]
etc...
:004BA1AF jmp  004BA1C9

</FONT><FONT SIZE="2" COLOR="green" FACE="Courier New">* Possible StringData Ref from Code 0bj -&gt;&quot;FTP Expert&quot;
</FONT><FONT SIZE="2" FACE="Courier New">:004BA1B3 mov  ecx, 004BA1F8

</FONT><FONT SIZE="2" COLOR="green" FACE="Courier New">* Possible StringData Ref from Code 0bj -&gt;&quot;Mauvais num&quot;
</FONT><FONT SIZE="2" FACE="Courier New">:004BA1B8 mov  edx, 004BA204
:004BA1BD mov  eax, dword ptr [004F4944]
etc...
:004BA1EB ret</FONT></PRE>
			<P><FONT SIZE="2" FACE="Arial">Vous imaginez bien que c'est dans le call 004C60A0 que nous allons trainer nos gu&ecirc;tres...<BR>
			Pour trouver que ce call &eacute;tait celui du g&eacute;n&eacute;rateur, rien n'a &eacute;t&eacute; plus simple,
			il a suffit de faire s'afficher l'adresse de stockage du bon serial dans la fen&ecirc;tre des Datas, et de recommencer
			le Trace On &agrave; partir de la saisie des champs.</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="67%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="black">
						<PRE><FONT SIZE="2" COLOR="white" FACE="Courier New">EAX=011A2004   EBX=011EBFEC   ECX=0076E2B8   EDX=011EC548   ESI=011EE704        
EDI=0076E448   EBP=0076E2BC   ESP=0076E28C   EIP=004C60A0   o d </FONT><FONT SIZE="2" COLOR="#00CCFF" FACE="Courier New">I</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New"> s z a p c     
CS=017F   DS=0187   SS=0187   ES=0187   FS=3DCF   GS=0000                       
</FONT><FONT SIZE="2" COLOR="#00CC00" FACE="Courier New">-----FTPXPERT!CODE+000C5294-----------------------byte--------------PROT---(0)--
</FONT><FONT SIZE="2" COLOR="white" FACE="Courier New">0187:004C6294 46 48 59 45 53 54 59 55-4C 50 56 42 4E 4D 43 52  FHYESTYULPVBNMCR
0187:004C62A4 59 35 36 37 41 41 38 32-33 34 34 35 32 31 33 34  Y567AA8234452134
0187:004C62B4 00 00 00 00 FF FF FF FF-01 00 00 00 2D 00 00 00  ............-...
</FONT><FONT SIZE="2" COLOR="#00CC00" FACE="Courier New">-------------------------------------------------------------------------PROT32-
</FONT><FONT SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60A0  PUSH      EBP                </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; entr&eacute;e du Call</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
etc...                                          
017F:004C60B9  MOV       [EBP-04],EDX       </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; Name entr&eacute;</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60BC  MOV       EAX,[EBP-04]                                           
etc...                                          
017F:004C60D2  LEA       EDX,[EBP-14]                                           
017F:004C60D5  MOV       EAX,004C6294       </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; string (voir Data)</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60DA  CALL      00408EAC           </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; routine (voir ci dessous)</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60DF  LEA       EDX,[EBP-0C]                
017F:004C60E2  MOV       EAX,[EBP-04]       </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; Name entr&eacute; </FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60E5  CALL      00408EAC           </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; routine (voir ci dessous)</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60EA  XOR       EDI,EDI                       
017F:004C60EC  LEA       EAX,[EBP-10]                                           
017F:004C60EF  CALL      00403DA8                                               
017F:004C60F4  MOV       EAX,[EBP-04]       </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; Name entr&eacute;</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60F7  CALL      00404028           </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; calcul de la taille du Name entr&eacute;</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C60FC  MOV       ESI,EAX            </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; EAX = taille du Name entr&eacute;</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">

</FONT><FONT SIZE="2" COLOR="#00CC00" FACE="Courier New">------------------------------------FTPXPERT!CODE+000C50A0----------------------</FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</P>
</CENTER>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:00408ECD 8A02   mov a1, byte ptr [edx]    </FONT><FONT SIZE="2" COLOR="blue"
				FACE="Courier New"> ; Name entr&eacute; </FONT><FONT SIZE="2" FACE="Courier New">
:00408ECF 3C61   cmp a1, 61                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; compare avec &quot;a&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408Edl 7206   jb 00408ED9                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; branchement si inf&eacute;rieur</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408ED3 3C7A   cmp a1, 7A                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; compare avec &quot;z&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408ED5 7702   ja 00408ED9                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; branchement si sup&eacute;rieur</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408ED7 2C20   sub a1, 20                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; soustrait 20h &agrave; la valeur ASCII</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408ED9 8806   mov byte ptr [esi], al     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; enregistre le caract&egrave;re valid&eacute;</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408EDB 42     inc edx                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; passe au caract&egrave;re suivant</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408EDC 46     inc esi                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; incr&eacute;mente adresse de &quot;r&eacute;ception&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408EDD 4B     dec ebx                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; d&eacute;cr&eacute;mente la taille du Name</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408EDE 85DB   test ebx, ebx              </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; contr&ocirc;le qu'il reste des caract&egrave;res</FONT><FONT
				SIZE="2" FACE="Courier New">
:00408EE0 75EB   jne 00408ECD               </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; sinon boucle</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">Dans cette boucle, chaque caract&egrave;re du Name entr&eacute; va &ecirc;tre contr&ocirc;l&eacute;.<BR>
			Tous les caract&egrave;res en minuscule (compris entre a et z) vont &ecirc;tre transform&eacute; en majuscule.</FONT></P>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:004C6107 lea eax, dword ptr [ebp-1C]      
:004C610A mov edx, dword ptr [ebp-0C]       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Name entr&eacute; en majuscule</FONT><FONT
				SIZE="2" FACE="Courier New">
:004C610D mov dl, byte ptr [edx+ebx-01]</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">     ; un caract&egrave;re du name dans DL</FONT><FONT
				SIZE="2" FACE="Courier New">
:004C6111 call 00403F50                      
:004C6116 mov eax, dword ptr [ebp-1C]     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; EAX = caract&egrave;re (de DL)</FONT><FONT
				SIZE="2" FACE="Courier New">
:004C6119 mov edx, dword ptr [ebp-14]     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; string &quot;FHYESTYULPVBNMCR...&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:004C611C call 00404314                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; cherche la correspondance</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">le Call 00404314 va servir, &agrave; partir d'une lettre pr&eacute;l&eacute;v&eacute;e
			dans le Name Entr&eacute;, &agrave; en rechercher son &eacute;quivalent dans la string &quot;FHYESTYULPVBNMCR...&quot;.
			D&eacute;s qu'il aura trouv&eacute;, il sortira du call avec dans EAX la position du caract&egrave;re.<BR>
			Par exemple, si le Name que vous avez entr&eacute; est snake, il deviendra SNAKE, la lettre &quot;S&quot; vaudra
			5, &quot;N&quot; vaudra 13, et ainsi de suite...<BR>
			<BR>
			Si l'une des lettre du Name Entr&eacute;, converti en majuscule si besoin est, n'est pas trouv&eacute;e dans la
			string, la lettre est ignor&eacute;e. Cette routine boucle sur le Name Entr&eacute; jusqu'&agrave; &eacute;puisement
			du nombre de caract&egrave;res (fin de la boucle en 004C6141), et g&eacute;n&egrave;re un Nouveau Name, d&eacute;barass&eacute;
			des caract&egrave;res non valid&eacute;s. Ainsi, SNAKE deviendra SNAE, ce qui est d&eacute;j&agrave; moins ppppo&eacute;tique...</FONT></P>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:004C6143 lea eax, dword ptr [ebp-0C]
:004C6146 mov edx, dword ptr [ebp-10]       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Name en majuscule tronqu&eacute;: SNAE</FONT><FONT
				SIZE="2" FACE="Courier New">
:004C6149 call 00403E40                     
:004C614E mov eax, dword ptr [ebp-0C]
:004C6151 call 00404028                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; mesure la taille du &quot;nouveau Name&quot;</FONT><FONT
				SIZE="2" FACE="Courier New">
:004C6156 cmp eax, 00000018                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; fait-il 24 caract&egrave;res de long? </FONT><FONT
				SIZE="2" FACE="Courier New">
:004C6159 jge 004C6189                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; saut si sup&eacute;rieur ou &eacute;gal</FONT><FONT
				SIZE="2" FACE="Courier New">
:004C615B mov esi, 00000018               </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; sinon passe &agrave; la suite</FONT><FONT
				SIZE="2" FACE="Courier New">
etc...

:004C616B lea eax, dword ptr [ebp-24]       
:004C616E mov edx, dword ptr [ebp-14]       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; string &quot;FHYESTYULPVBNMCR...&quot; </FONT><FONT
				SIZE="2" FACE="Courier New">
:004C6171 mov dl, byte ptr [edx+ebx-01]</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">     ; dl = un caracat&egrave;re de la string</FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial"><BR>
			De 004C6187 &agrave; 004C616B, le programme va boucler jusqu'&agrave; cr&eacute;er une nouvelle chaine.<BR>
			Les premiers caract&egrave;res vont &ecirc;tre ceux du nouveau Name, suivi de la string et &agrave; concurence
			de 24 carac&egrave;res:</FONT></P>
			<CENTER>
			<P><B><FONT SIZE="2" FACE="Arial">SNAEFHYESTYULPVBNMCRY56A</FONT></B><FONT SIZE="2" FACE="Arial"><BR>
			
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="67%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="black">
						<PRE><FONT SIZE="2" COLOR="white" FACE="Courier New">EAX=011EC590   EBX=00000002   ECX=00000006   EDX=00000001   ESI=00000013        
EDI=00000013   EBP=0076E288   ESP=0076E244   EIP=004C61BC   o d </FONT><FONT SIZE="2" COLOR="#00CCFF" FACE="Courier New">I S </FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">z </FONT><FONT SIZE="2" COLOR="#66FFFF" FACE="Courier New">A</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New"> p </FONT><FONT SIZE="2" COLOR="#66FFFF" FACE="Courier New">C</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">     
CS=017F   DS=0187   SS=0187   ES=0187   FS=3DCF   GS=0000   DS:011EC591=48      
</FONT><FONT SIZE="2" COLOR="lime" FACE="Courier New">--------------------------------------------------byte--------------PROT---(2)--
</FONT><FONT SIZE="2" COLOR="white" FACE="Courier New">0187:011EC590 43 48 52 53 54 41 4C 46-48 59 45 53 54 59 55 4C  CHRSTALFHYESTYUL
0187:011EC5A0 50 56 42 4E 4D 43 52 59-00 C5 1E 01 AC C5 1E 01  PVBNMCRY........
</FONT><FONT SIZE="2" COLOR="lime" FACE="Courier New">-------------------------------------------------------------------------PROT32-
</FONT><FONT SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61B9  MOV       EAX,[EBP-0C]    </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; EAX pointe sur la nouvelle chaine</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61BC  MOV       AL,[EBX+EAX-01]</FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New"> ; AL = un caract&egrave;re de cette cha&icirc;ne</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61C0  MOV       [EBP-15],AL     </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; plac&eacute; dans [EBP-15] </FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61C3  LEA       EAX,[EBP-28]   </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New"> ; string FHYESTYULPVBNMCRY56AA82344...</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61C6  MOV       DL,[EBP-15]     </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; DL = un caract&egrave;re de cette string</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61C9  CALL      00403F50                                                 
017F:004C61CE  MOV       EAX,[EBP-28]    </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; EAX = caract&egrave;re AL</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61dl  MOV       EDX,[EBP-14]   </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New"> ; EDX = FHYESTYULPVBNMCRY56AA...</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61D4  CALL      00404314        </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; recherche de la correspondance</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61D9  MOV       ESI,EAX         </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; ESI = place du car AL dans la string</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61DB  MOV       EAX,[EBP-14]    </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; EAX = FHYESTYULPVBNMCRY56AA...</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">

</FONT><FONT SIZE="2" COLOR="lime" FACE="Courier New">------------------------------------FTPXPERT!CODE+000C51B9----------------------</FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</FONT></P>
</CENTER>
			<P><FONT SIZE="2" FACE="Arial">On arrive maintenant au coeur du g&eacute;n&eacute;rateur.<BR>
			A l'aide de la nouvelle chaine cr&eacute;&eacute;e, le programme va de nouveau chercher la position du caract&egrave;re
			selectionn&eacute; dans la string. Par souci de raccourci, nous dirons que cette position s'appellera Pos, et que
			les r&eacute;sultats li&eacute;s aux bidouilles de Pos vaudront ResN.</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="67%">
				<TR>
					<TD WIDTH="100%" BGCOLOR="black">
						<PRE><FONT SIZE="2" COLOR="white" FACE="Courier New">EAX=0076E2B8   EBX=00000019   ECX=00000006   EDX=011EE358   ESI=0000000C        
EDI=0000000C   EBP=0076E288   ESP=0076E244   EIP=004C6247   o d </FONT><FONT SIZE="2" COLOR="#0099FF" FACE="Courier New">I</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New"> s </FONT><FONT SIZE="2" COLOR="#00CCFF" FACE="Courier New">Z</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New"> a </FONT><FONT SIZE="2" COLOR="#00CCFF" FACE="Courier New">P </FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">c     
CS=017F   DS=0187   SS=0187   ES=0187   FS=3DCF   GS=0000                       
</FONT><FONT SIZE="2" COLOR="lime" FACE="Courier New">--------------------------------------------------byte--------------PROT---(2)--
</FONT><FONT SIZE="2" COLOR="white" FACE="Courier New">0187:011EE358 36 41 59 35 34 34 2D 4C-50 4E 37 46 41 2D 41 35  6AY544-LPN7FA-A5
0187:011EE368 41 31 33 55 2D 4E 50 46-37 53 42 00 74 E3 1E 01  A13U-NPF7SB.t...
0187:011EE378 74 E3 1E 01 34 00 00 00-00 00 00 00 00 00 00 00  t...4...........
0187:011EE388 00 00 00 00 40 00 00 00-1B 00 00 00 00 00 00 00  ....@...........
</FONT><FONT SIZE="2" COLOR="lime" FACE="Courier New">-------------------------------------------------------------------------PROT32-
</FONT><FONT SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61DE  CALL      00404028        </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; calcul de la taille de la string </FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61E3  PUSH      EAX             </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; EAX vaut 20h pouss&eacute; sur la pile </FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61E4  MOV       EAX,ESI         </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; et ESI est &eacute;gal &agrave; Pos</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61E6  IMUL      ESI             </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; Pos x Pos = Res1</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61E8  SUB       EAX,ESI         </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; Res1 - Pos = Res2</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61EA  ADD       EAX,EDI        </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New"> ; Res2 + Reste = Res3</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61EC  POP       EDX             </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; r&eacute;cup&egrave;re 20h sur la pile</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61ED  MOV       ECX,EDX         </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; ECX = 20h</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61EF  CDQ                       </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; Convert Double to Quad</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61F0  IDIV      ECX             </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; Res3 / 20h =&gt; reste dans EDX </FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61F2  MOV       ESI,EDX         </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; le reste est mis dans ESI</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61F4  INC       ESI             </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New">; +1 (au cas ou le reste serait = 0)</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">
017F:004C61F5  MOV       EDI,ESI        </FONT><FONT SIZE="2" COLOR="yellow" FACE="Courier New"> ; puis plac&eacute; dans EDI</FONT><FONT
						SIZE="2" COLOR="white" FACE="Courier New">

</FONT><FONT SIZE="2" COLOR="lime" FACE="Courier New">------------------------------------FTPXPERT!CODE+000C51EC----------------------</FONT></PRE>
					</TD>
				</TR>
			</TABLE>
</P>
</CENTER>
			<P><FONT SIZE="2" FACE="Arial">Prenons un exemple concret:<BR>
			CHRS.....<BR>
			Le &quot;C&quot; &agrave; sa correspondance dans le string &quot;FHYESTYULPVBNMCRY56AA82344...&quot; en 15&egrave;me
			position (0F).</FONT></P>
			<PRE><FONT SIZE="2" FACE="Courier New">0F x 0F    = E1      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">Pos x pos</FONT><FONT
			SIZE="2" FACE="Courier New">
E1 - 0F    = D2      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">Res1 - Pos</FONT><FONT SIZE="2" FACE="Courier New">
D2 + Reste = D2     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> (au d&eacute;part le Reste vaut 00)</FONT><FONT
			SIZE="2" FACE="Courier New">
D2 / 20    =  6      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">la partie enti&egrave;re est &eacute;gal &agrave; 6, le Reste est &eacute;gal &agrave; 12</FONT><FONT
			SIZE="2" FACE="Courier New">
12 +  1    = 13      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">pointeur dans la string (13h = 19d), soit le chiffre 6</FONT><FONT
			SIZE="2" COLOR="blue" FACE="Arial">  </FONT></PRE>
			<P><FONT SIZE="2" FACE="Arial">Ce reste va devenir un pointeur dans la string &quot;FHYESTYULPVBNMCRY56AA82344...&quot;</FONT>
			<BLOCKQUOTE>
				<PRE><FONT SIZE="2" FACE="Courier New">:004C61F7  mov eax, dword ptr [ebp-14]  </FONT><FONT SIZE="2" COLOR="blue"
				FACE="Courier New"> ; &quot;FHYESTYULPVBNMCRY56AA82344...&quot;</FONT><FONT SIZE="2" FACE="Courier New">
:004C61FA  mov al, byte ptr [eax+esi-01]</FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; r&eacute;cup&egrave;re le caract&egrave;re point&eacute; dans la string</FONT><FONT
				SIZE="2" FACE="Arial"></FONT></PRE>
			</BLOCKQUOTE>
			<P><FONT SIZE="2" FACE="Arial">C'est ce chiffre qui va devenir le premier caract&egrave;re du bon serial.<BR>
			Une fois que les dixhuit caract&egrave;res de la nouvelle cha&icirc;ne ont &eacute;t&eacute; trait&eacute;s, s&eacute;par&eacute;s
			tous les 6 caract&egrave;res par un s&eacute;parateur, vous avez votre bon serial.</FONT></P>
			<CENTER>
			<P>
			<TABLE BORDER="0" CELLPADDING="8" CELLSPACING="0" WIDTH="79%" BGCOLOR="#FFFFCC">
				<TR>
					<TD WIDTH="100%">
						<PRE><FONT SIZE="2" FACE="Courier New">;========================================================================= 
;                             Generator FTP Xpert  
;=========================================================================
generateur2:

      mov  dword ptr [lg_name], eax     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; enregistre la taille du Name</FONT><FONT
						SIZE="2" FACE="Courier New">
      xor  ebx,ebx
      xor  edx,edx                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; incr&eacute;mente buffer</FONT><FONT
						SIZE="2" FACE="Courier New">

minus_majus:
      mov  al, byte ptr [ebx+buffer]    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Al = un caract&egrave;re du Name entr&eacute; </FONT><FONT
						SIZE="2" FACE="Courier New">
      cmp  al, 00                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; si c'est le dernier</FONT><FONT
						SIZE="2" FACE="Courier New">
      je   end_test                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; le contr&ocirc;le des caract&egrave;res est fini</FONT><FONT
						SIZE="2" FACE="Courier New">
      cmp  al, 61h                     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; compare avec &quot;a&quot;</FONT><FONT
						SIZE="2" FACE="Courier New">
      jb   superieur                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; branchement si inf&eacute;rieur</FONT><FONT
						SIZE="2" FACE="Courier New">
      cmp  al, 7Ah                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; compare avec &quot;z&quot;</FONT><FONT
						SIZE="2" FACE="Courier New">
      ja   superieur                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; branchement si sup&eacute;rieur</FONT><FONT
						SIZE="2" FACE="Courier New">
      sub  al, 20h                     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; soustrait 20 &agrave; la valeur ASCII</FONT><FONT
						SIZE="2" FACE="Courier New">

superieur:
      mov  byte ptr [ebx+buffer], al   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; enregistre le caract&egrave;re valid&eacute;</FONT><FONT
						SIZE="2" FACE="Courier New">
      inc  ebx                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">    ; passe au caract&egrave;re suivant</FONT><FONT
						SIZE="2" FACE="Courier New">
      jne  minus_majus                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; sinon boucle</FONT><FONT
						SIZE="2" FACE="Courier New">

end_test:
      xor  ecx,ecx
      lea  edx, dword ptr [buffer]      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Name entr&eacute; en majuscule</FONT><FONT
						SIZE="2" FACE="Courier New">
      lea  edi, dword ptr [ftpstring]   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; string &quot;FHYESTYULPVBNMCR...&quot;</FONT><FONT
						SIZE="2" FACE="Courier New">

suivant_name:
      call position                     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; cherche la correspondance</FONT><FONT
						SIZE="2" FACE="Courier New">
      cmp  esi, 20h                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; si toute la string a &eacute;t&eacute; trait&eacute;e</FONT><FONT
						SIZE="2" FACE="Courier New">
      jge  non_valid                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; le caract&egrave;re n'est pas valide </FONT><FONT
						SIZE="2" FACE="Courier New">
      mov  byte ptr [ecx+buffer2],al   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; sinon cr&eacute;ation d'un nouveau Name</FONT><FONT
						SIZE="2" FACE="Courier New">
      inc  ecx                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; incr&eacute;mente adresse du nouveau Name</FONT><FONT
						SIZE="2" FACE="Courier New">

non_valid:
      inc  edx                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; passe au caract&egrave;re suivant du name</FONT><FONT
						SIZE="2" FACE="Courier New">
      cmp  byte ptr [edx],00           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; est-ce le dernier ?</FONT><FONT
						SIZE="2" FACE="Courier New">
      jne  suivant_name                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Non -&gt; continue</FONT><FONT
						SIZE="2" FACE="Courier New">
      invoke lstrcat, ADDR buffer2,ADDR ftpstring </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; concat&egrave;ne le Name et la string</FONT><FONT
						SIZE="2" FACE="Courier New">
      push ebp                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; sauvegarde du registre EBP</FONT><FONT
						SIZE="2" FACE="Courier New">
      xor  ebp,ebp                     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; EBP m&eacute;morisera le reste de la division</FONT><FONT
						SIZE="2" FACE="Courier New">
      xor  ebx,ebx                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; EBX recevra le reste de la division</FONT><FONT
						SIZE="2" FACE="Courier New">


suite_serial:
      lea   edx, dword ptr [ebx+buffer2] </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; Name entr&eacute; en majuscule</FONT><FONT
						SIZE="2" FACE="Courier New">
      lea   edi, dword ptr [ftpstring]   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; string &quot;FHYESTYULPVBNMCR...&quot;</FONT><FONT
						SIZE="2" FACE="Courier New">
      call  position                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">   ; cherche la position du caract&egrave;re</FONT><FONT
						SIZE="2" FACE="Courier New">
      PUSH  20h                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; pousse 32 sur la pile</FONT><FONT
						SIZE="2" FACE="Courier New">
      MOV   EAX,ESI                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; et la place dans EAX</FONT><FONT
						SIZE="2" FACE="Courier New">
      IMUL  ESI                           </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; Pos x Pos = Res1</FONT><FONT
						SIZE="2" FACE="Courier New">
      SUB   EAX,ESI                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">   ; Res1 - Pos = Res2</FONT><FONT
						SIZE="2" FACE="Courier New">
      ADD   EAX,EBP                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; Res2 + Reste = Res3</FONT><FONT
						SIZE="2" FACE="Courier New">
      POP   EDX                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; r&eacute;cup&egrave;re 32 sur la pile</FONT><FONT
						SIZE="2" FACE="Courier New">
      MOV   ECX,EDX                    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">   ; ECX = 32</FONT><FONT
						SIZE="2" FACE="Courier New">
      CDQ                                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; Convert Double to Quad</FONT><FONT
						SIZE="2" FACE="Courier New">
      IDIV  ECX                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; Res3 / 32 -&gt; reste dans EDX </FONT><FONT
						SIZE="2" FACE="Courier New">
      MOV   ESI,EDX                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; le reste est mis dans ESI</FONT><FONT
						SIZE="2" FACE="Courier New">
      INC   ESI                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; +1 (au cas ou le reste serait = 0)</FONT><FONT
						SIZE="2" FACE="Courier New">
      MOV   EBP,ESI                       </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; puis plac&eacute; dans EDI</FONT><FONT
						SIZE="2" FACE="Courier New">
      mov   al, byte ptr [esi+edi-01]     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; r&eacute;cup&egrave;re le caract&egrave;re point&eacute; dans la string</FONT><FONT
						SIZE="2" FACE="Courier New">
      mov   byte ptr [ebx+serial],al     </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; et le m&eacute;morise dans serial</FONT><FONT
						SIZE="2" FACE="Courier New">
      inc   ebx                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">  ; incr&eacute;mente position suivante du serial</FONT><FONT
						SIZE="2" FACE="Courier New">
      cmp   ebx,20h                      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; est-ce que toute la string a &eacute;t&eacute; trait&eacute;e?</FONT><FONT
						SIZE="2" FACE="Courier New">
      jl    suite_serial                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; Non -&gt; loop</FONT><FONT
						SIZE="2" FACE="Courier New">
      POP   EBP                          </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; restore le registre EBP</FONT><FONT
						SIZE="2" FACE="Courier New"></FONT></PRE>
						<P><FONT SIZE="2" FACE="Courier New">; &quot;serial&quot; contient tous les caract&egrave;res du serial. Il reste
						&agrave; placer les s&eacute;parateurs   </FONT>
						<PRE><FONT SIZE="2" FACE="Courier New">      mov   ecx,6                         </FONT><FONT SIZE="2" COLOR="blue"
						FACE="Courier New">; les 6 premiers caract&egrave;res </FONT><FONT SIZE="2" FACE="Courier New">
      lea   esi, serial                  </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; du serial</FONT><FONT
						SIZE="2" FACE="Courier New">
      lea   edi, buffer                   </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; vont &ecirc;tre plac&eacute; dans le buffer</FONT><FONT
						SIZE="2" FACE="Courier New">
      rep   movsb 
      mov   byte ptr [buffer+6], &quot;-&quot;      </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; mise en place du premier s&eacute;parateur</FONT><FONT
						SIZE="2" FACE="Courier New">
      mov   ecx,6                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; les 6 caract&egrave;res suivants</FONT><FONT
						SIZE="2" FACE="Courier New">
      lea   esi, serial+6                </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; du serial g&eacute;n&eacute;r&eacute;</FONT><FONT
						SIZE="2" FACE="Courier New">
      lea   edi, buffer+7                 </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; sont plac&eacute; dans le buffer</FONT><FONT
						SIZE="2" FACE="Courier New">
      rep   movsb 
      mov   byte ptr [buffer+13], &quot;-&quot;    </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New"> ; mise en place du s&eacute;parateur</FONT><FONT
						SIZE="2" FACE="Courier New">
      mov   ecx,6                         </FONT><FONT SIZE="2" COLOR="blue" FACE="Courier New">; etc...</FONT><FONT
						SIZE="2" FACE="Courier New">
      lea   esi, serial+12
      lea   edi, buffer+14
      rep   movsb 
      mov   byte ptr [buffer+20], &quot;-&quot;
      mov   ecx,6
      lea   esi, serial+18
      lea   edi, buffer+21
      rep   movsb </FONT></PRE>
					</TD>
				</TR>
			</TABLE>

</CENTER>
		</TD>
	</TR>
</TABLE>
</P>
</CENTER>

<BLOCKQUOTE>
	<P><FONT SIZE="2" COLOR="white" FACE="Arial">Bonne Journ&eacute;e</FONT></P>

	<P><A HREF="mailto:christal@lemel.fr"><FONT SIZE="2" FACE="Arial">Christal</FONT></A>
</BLOCKQUOTE>


</BODY>

</HTML>