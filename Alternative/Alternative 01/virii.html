<html>
<head>
	<title>AlTeRnAtIvE I --> Virii par DDWay</title>
</head>

<body bgcolor=#000000 text=#FF0000>
<font face="Artistik" size="+3" color="Red"><div align="center">------------------</div>
<div align="center">------------------</div>
<div align="center">--   Les Virii	--</div>
<div align="center">------------------</div>
<div align="center">------------------</div></font><br>
<div align="center"><img src="ligne.gif" width=540 height=4 border=0 alt=""></div><br>

&nbsp;&nbsp;Par DDway<br><br>

(Ndrl : virii est le pluriel de virus informatique-)<br><br>

&nbsp;&nbsp;La Crapule m'a demand&eacute; un jour dans un mail explicite de faire un ch'tit
article. Pas de pot, c'est sur les virii informatiques<br><br>
Avant toute chose : vous m'apprendrez l'asm !!<br>
Bon d'accord :) on peut faire des virii en basic, en fichiers bat, en c, en c++
en pascal bref tous les langages existants et inimaginables (ndrl : le Perl,
je sais pas). Si vous voulez, on peut m&ecirc;me faire des virii BAT r&eacute;sidants en m&eacute;moire
sisi !<br><br>

&nbsp;&nbsp;Pour commencer, voici une liste de toutes les instruction asm du 386 et je ne continuerai
que si vous la connaissez par coeur 
(M..., elle est vachement longue !!)<br><br>

<table align="center" bgcolor="&#35;808080" cellspacing="2" cellpadding="2" border="0">
<tr>
    <td><font color="blue"><b>
AAA ajustement ascii de AL apr&egrave;s une addition<br>
AAD ajustement ascii de AX avant une division<br>
AAM ajustement ascii de AL apr&egrave;s multiplication<br>
AAS ajustement ascii de AL apr&egrave;s soustraction<br>
ADC addition avec retenu CF <br>
ADD addition sans retenu<br>
AND allez, chercher ...<br>
ARPL ajuste le niveau de privil&egrave;ge en mode prot&eacute;g&eacute;<br>
BOUND teste un nombre par rapport &agrave; des limites<br>
BSF cherche 1 bit de droite &agrave; gauche<br>
BSR cherche 1 bit de gauche &agrave; droite<br>
BSWAP conversion d'un registre au format INTEL<br>
BT charge 1 bit en CF<br>
BTC charge 1 bit en CF et compl&eacute;ment<br>
BTR charge 1 bit en CF puis le met &agrave; 0 dans la source<br>
BTS la m&ecirc;me chose mais il le met &agrave; 1 dans la source<br>
CALL appel de sous programme<br>
CBW convertit l'octet en AL en un mot en AX<br>
CDQ convertit un mot en EAX en un quadruple mot en EDX:EAX<br>
CLC met l'indicateur &agrave; 0 dans CF<br>
CLD met l'indicateur &agrave; 0 dans DF<br>
CLI met l'indicateur &agrave; 0 dans IF<br>
CLTS met &agrave; 0 l'indicateur de changement de contexte en mode prot&eacute;g&eacute;<br>
CMC compl&eacute;mente l'indicateur CF<br>
CMP comparaison logique <br>
CMPSB, CMPSW comparaison de cha&icirc;nes de caract&egrave;res<br>
CMPSD comparaisons pour les chaines de caract&egrave;res du 386<br>
CMPXCHG compare l'accumulateur avec AL, AX ou EAX<br>
CWD convertit le contenu de AX en un double mot DX:AX<br>
CWDE convertit le contenu de AX en un double mot dans EAX<br>
DAA ajustement d&eacute;cimal de AL apr&egrave;s une addition<br>
DAS ajustement d&eacute;cimal de AL apr&egrave;s une soustraction<br>
DEC d&eacute;cr&eacute;mentation<br>
DIV division non sign&eacute;e<br>
ENTER construit un cadre de pile pour une proc&eacute;dure de haut niveau<br>
ESC acc&egrave;s au coprocesseur (pour les b&ecirc;tes de l'optimisation)<br>
HLT arr&ecirc;t du processeur en attente d'un &eacute;v&ecirc;nement externe<br>
IBTS ins&egrave;re une chaine de bits en mode prot&eacute;g&eacute;<br>
IDIV division sign&eacute;e<br>
IMUL multiplication sign&eacute;e<br>
IN lit un octet sur le port sp&eacute;cifi&eacute;<br>
INC incr&eacute;mentation<br>
INSB, INSW lit une chaine sur un port<br>
INT interruption logicielle<br>
INTO active l'interruption 4 si l'indicateur OF est arm&eacute;<br>
IRET retour d'interruption<br>
IRETD retour d'interruption depuis un segment 32 bit<br>
JA saut si sup&eacute;rieur<br>
JAE saut si sup&eacute;rieur ou &eacute;gal<br>
JB saut si inf&eacute;rieur<br>
JBE saut si inf&eacute;rieur ou &eacute;gal<br>
JC saut si CF est &agrave; 1<br>
JNC saut si CF est &agrave; 0<br>
JCXZ saut si CX est &agrave; 0<br>
JECXZ saut si ECX est &agrave; 0<br>
JE saut si &eacute;gal<br>
JG saut si arithmetiquement sup&eacute;rieur ou &eacute;gal<br>
JMP saut &agrave; l'adresse indiqu&eacute;e<br>
JNA saut si non sup&eacute;rieur<br>
JNAE saut si non sup&eacute;rieur ou &eacute;gal<br>
JNB saut si non inf&eacute;rieur<br>
JNBE saut si non inf&eacute;rieur ou &eacute;gal<br>
JNE saut si non &eacute;gal<br>
JNG saut si arithmetiquement non sup&eacute;rieur<br>
JNGE non ! je l'ecris pas, devinez :)<br>
JNL saut si non inf&eacute;rieur arithmetiquement<br>
JNLE devinez<br>
JNO saut si l'indicateur OF est &agrave; 0<br>
JNP saut si parit&eacute; impaire ou pr&eacute;cisement PF &agrave; 0<br>
JNS saut si positif<br>
JNZ saut si diff&eacute;rent<br>
JO saut si OF est &agrave; 1<br>
JP saut si parit&eacute; paire<br>
JPE idem<br>
JPO idem que JNP<br>
JS saut si n&eacute;gatif<br>
JZ saut si &eacute;galit&eacute;<br>
LAHF charge en AH la partie basse du registre des indicateurs<br>
LDS charge une adresse physique en DS:registre<br>
LEA charge une adresse effective<br>
LEAVE lib&egrave;re la pile<br>
LES charge une adresse physique en ES:registre<br>
LFS charge une adresse physique en FS:registre<br>
LGDT charge le registre de la table des descripteurs globaux en mode prot&eacute;g&eacute;)<br>
LGS charge une adresse physique en GS:registre<br>
LIDT charge le registre de la table des descripteurs d'interruption en mode prot&eacute;g&eacute;<br>
LLDT charge le registre de la table des descripteurs locaux<br>
LMSW charge  (encore) le mot d'&eacute;tat de la machine en mode prot&eacute;g&eacute;<br>
LOCK verrouile le bus<br>
LODSB, LODSW charge en AL ou AX le contenu de DS:SI<br>
LODSD charge en EAX le contenu de DS:SI<br>
LOOP saut tant que CX <> 0<br>
LOOPE saut tant que CX<> 0 et ZF=1<br>
LOOPNZ saut tant que CX<>0 et ZF=0<br>
LOOPZ comme LOOPE<br>
LSL charge une limite de segment en mode prot&eacute;g&eacute;<br>
LSS charge une adresse physique en SS:registre<br>
LTR charge le registre de t&acirc;che en mode prot&eacute;g&eacute;<br>
MOV transfert de donn&eacute;e<br>
MOVS transfert une chaine de caract&egrave;re de DS:SI en ES:DI<br>
MOVSD transfert une chaine de caract&egrave;re double mot par double mot<br>
MOVSX transfert avec le signe<br>
MOVZX transfert avec une extension de 0<br>
MUL multiplication non sign&eacute;e<br>
NEG n&eacute;gation<br>
NOP ne fait rien (et oui !) (NB par Le_Magicien&nbsp; : en r&eacute;alit&eacute;, ex&eacute;cute l'instruction
XCHG AX, AX (c'est &agrave; dire &eacute;change les contenus respectifs des registres AX et AX). En gros,
une instruction qui fait quelque chose, mais qui ne change rien. Tr&egrave;s utilis&eacute;e en cassage de
protections de sharewares, mais pas tr&egrave;s utile dans la programmation de virii)<br>
NOT op&eacute;ration logique NON<br>
OR op&eacute;ration logique<br>
OUT transmet un octet ou un mot &agrave; un p&eacute;riph&eacute;rique<br>
OUTSB, OUTSW transmet une chaine de caract&egrave;res &agrave; un port<br>
OUTSD transmet un double mot &agrave; un port<br>
POP d&eacute;pile un mot<br>
POPA d&eacute;pile les registres<br>
POPAD d&eacute;pile tout les registres 32 bits<br>
POPF d&eacute;pile un mot et le transf&egrave;re vers le registre des indicateurs<br>
POPFD pareil que POPF avec un double mot sur 32 bits<br>
PUSH place sur le haut de la pile une valeur<br> 
PUSHA empile tous les registres<br>
PUSHAD empile tout les registres 32 bits<br>
PUSHF empile le registre des indicateurs<br>
PUSHFD empile le registre des indicateurs 32 bits<br>
RCL rotation &agrave; gauche &agrave; travers CF<br>
RCR rotation &agrave; droite &agrave; travers CF<br>
REPZ, REPNZ pr&eacute;fixe de rep&eacute;tition<br>
REPE, REPNE tra&icirc;tement des cha&icirc;ne de caract&egrave;res en association avec CX <br><br>
<div align="center">et les indicateurs</div><br>
RETN, RETF retour d'un sous-programme<br>
ROL rotation &agrave; gauche<br>
ROR rotation &agrave; droite<br>
SAHF copie de AH dans la partie basse du registre des indicateurs<br>
SAL d&eacute;calage &agrave; gauche avec introduction de 0<br>
SAR d&eacute;calage &agrave; droite avec signe<br>
SBB soustraction non sign&eacute;e avec prise en compte de CF<br>
SCASB, SCASW compare une cha&icirc;ne avec le contenu de AL ou AX<br>
SCASD compare une chaine avec EAX<br>
SETA initialisation &agrave; 1 si CF et ZF sont &agrave; 0, sinon initialisation &agrave; 0<br>
SETAE idem seulement si CF est &agrave; 0<br>
SETB idem si CF est &agrave; 1<br>
SETBE pareil si CF ou ZF est &agrave; 1<br>
SETE idem si ZF est &agrave; 1 (sinon toujours initialisation &agrave; 0)<br>
SETG pareil si ZF=0 et SF=OF<br>
SETGE pareil si SF=OF<br><br>
<div align="center">(Ndrl : tout le monde a du lacher l&agrave;)</div><br>
SETL idem si SF<>OF<br>
SETLE pareil si ZF=1 et SF<>OF<br>
SETNA pareil que SETBE<br>
SETNAE comme SETB<br>
SETNB comme SETAE<br>
SETNBE comme SETA<br>
SETNE initialisation &agrave; 1 si ZF=0 sinon initialisation &agrave; 0<br>
SETNG comme SETLE<br>
SETNGE comme SETL<br>
SETNL comme SETGE<br>
SETNLE comme SETG<br>
SETNO initialisation si OF=0 sinon init &agrave; 0<br>
SETNP idem si PF=0<br>
SETNS si SF=0<br>
SETNZ si ZF=0<br>
SETO si OF=1<br>
SETP si PF=1<br>
SETPE  comme SETP<br>
SETPO si PF=0<br>
SETS si SF=1<br>
SETZ si ZF=1<br>
SGDT sauvegarde le registre de la table des descripteurs globaux en mode prot&eacute;g&eacute;<br>
SHL aller voir SAL<br>
SHLD d&eacute;calage double &agrave; gauche<br>
SHR d&eacute;calage droite avec introduction &agrave; 0<br>
SHRD d&eacute;calage double &agrave; droite<br>
SIDT sauvegarde le registre de la table d'interruption en mode prot&eacute;g&eacute;<br>
SLDT pareil pour la table des descripteur locaux<br>
SMSW sauvegarde le mot d'&eacute;tat de la machine en mode prot&eacute;g&eacute;<br>
STC met &agrave; 1 l'indicateur CF<br>
STD pareil pour DF<br>
STI idem pour IF<br>
STIOSB, STIOSW transfert du contenu de AL en ES:DI<br>
STOSD transfert de EAX en ES:DI<br>
STR sauvegarde le registre de t&acirc;che (mode prot&eacute;g&eacute;)<br>
SUB soustraction non sign&eacute;e<br>
TEST teste si un bit est &agrave; 1<br>
VERR teste l'autorisation de lecture d'un segment sous le mode prot&eacute;g&eacute;<br>
VERW teste l'autorisation d'&eacute;criture dans un segment en mode prot&eacute;g&eacute;<br>
WAIT attend que la ligne busy ne soit pas active<br>
XADD addition sign&eacute;e<br>
XBTS prend une chaine de bit (mode prot&eacute;g&eacute;)<br>
XCHG &eacute;change le contenu de 2 registres (comme swap en basic)<br>
XLAT charge en AL l'octet de la table DS:BX+AL<br>
XOR op&eacute;ration logique tr&egrave;s connue (ou exclusif)<br><br>
<div align="center">RRRRRaaaaaaahhhhhhhh !!! C'&eacute;tait tr&egrave;s long :)</div></b></font>
</td>
</tr>
</table><br>

&nbsp;&nbsp; En r&eacute;alit&eacute;, pour faire des virii, vous n'aurez pas besoin de conna&icirc;tre 
toute cette liste mais si vous voulez cracker des logiciels et que le debogueur 
vous sort ce qui suit, &ccedil;a peut servir de comprendre ce que &ccedil;a signifie<br>:<br><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XCHG EAX, EBX<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IRET<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EDX, 00000001h<br><br>

&nbsp;&nbsp;Qui peut me dire ce que produit ce code ?<br><br>
<hr><br> 

<b><i><u><font size="+1">1-Les Base</font>s</u></i></b><br><br>
&nbsp;&nbsp;Pour commencer, qu'est-ce qu'un virus informatique ? (la bonne question :)<br><br>

&nbsp;&nbsp;Un virus informatique est un petit programme souvent d'une 100aine d'octets
&eacute;crit le plus souvent en assembleur qui cherche un programme h&ocirc;te pour se 
multiplier, certains d&eacute;truisent le programme h&ocirc;te (virus recouvrement) et les autres
le parasitent (non-recover virus, virus parasite, virus compagnon).<br>
&nbsp;&nbsp;Ainsi qu'un virus biologique a besoin d'une cellule h&ocirc;te pour se reproduire,
un virus informatique a BESOIN du prog h&ocirc;te
(les virii &agrave; recouvrement sont plus rapidement detect&eacute;s que les autres). Le virus 
informatique doit donc trouver tous les moyens possibles pour trouver des programmes h&ocirc;tes
pouvant l'accepter et &eacute;galement se prot&eacute;ger de ses pires ennemis : les Anti-Virus.<br><br>

&nbsp;&nbsp;Pour les bases, on va parler des programmes h&ocirc;tes ("il faut conna&icirc;tre son
ennemi"). Les 2 formats que l'on risque "d'attaquer" le plus sont bien sur les
fichier *.exe et *.com de MS-DOS (on pourrait s'attaquer aux ex&eacute;cutables de windows,
aux DLL, aux VXD... mais bon, pour un d&eacute;but voyons le plus simple).<br>
&nbsp;&nbsp;D'abord, les fichier *.com ou COre iMage, les plus simples et les plus vieux. Un fichier 
com est une image binaire de ce qui doit &ecirc;tre charg&eacute; en m&eacute;moire puis execut&eacute; par le processeur
On les stocke sur le DD sous une forme qui repr&eacute;sente exactement le contenu de la m&eacute;moire
(une image) lorsqu'ils sont charg&eacute;s. Ainsi, un programme com est charg&eacute; et lanc&eacute; rapidement
Le probl&egrave;me, c'est qu'un programme com est limit&eacute; 64Ko (un segment de m&eacute;moire), ce qui comprend
la PSP (256 -> 100h octets) et la pile (2 octet -> un mot). Ainsi, on ne peut pas avoir de segment 
de pile pr&eacute;d&eacute;fini pour les programme com. Ces limitation entrainent quelques probl&egrave;mes :<br>
&nbsp;&nbsp;&nbsp;&nbsp;- Un prog com ne peut pas contenir de r&eacute;f&eacute;rences directes &agrave; des adresses de segments ou de groupes<br>
&nbsp;&nbsp;&nbsp;&nbsp;- Pas d'appels longs directs<br>
&nbsp;&nbsp;&nbsp;&nbsp;- Pas de r&eacute;f&eacute;rences de segments par leurs noms<br>
&nbsp;&nbsp;&nbsp;&nbsp;- Donc toutes les proc&eacute;dure d'un programme com sont d&eacute;clar&eacute;es NEAR<br><br>

&nbsp;&nbsp;Pour Tasm : un programme com est de la forme TINY, il commence &agrave; l'offset 100h, pour cel&agrave;, utilisez
les directive STARTUPCODE ou org 100h. Pour un meilleur fonctionnement, il est indispensable de s&eacute;parer 
le code, les donn&eacute;es non initialis&eacute;es et les donn&eacute;es du programme avec CODESEG, UDATASEG et DATASEG.<br>
Pendant le chargement d'un programme com, les registres suivants sont d&eacute;finis :<br>
&nbsp;&nbsp;&nbsp;&nbsp;- CS, DS, ES et SS contiennent l'adresse du PSP et du programme<br>
&nbsp;&nbsp;&nbsp;&nbsp;- IP est initialis&eacute; &agrave; 100h (256)<br>
&nbsp;&nbsp;&nbsp;&nbsp;- SP est &agrave; 0FFFEh (dernier mot dans le segment du programme)<br><br>

&nbsp;&nbsp;Le DOS r&eacute;serve la totalit&eacute; de la m&eacute;moire disponible pour un programme com, ainsi pour le DOS, il ne reste
jamais assez de m&eacute;moire pour qu'il puisse appeler un autre programme. Lorsque l'on est sous DOS, si on tape
un nom de programme sans l'extension, celui-ci recherche d'abord le nom avec l'extension com, puis exe et 
enfin bat (tr&egrave;s int&eacute;ressant pour les virii compagnons)<br><br>

&nbsp;&nbsp;Les fichiers exe sont un tantinet plus complexes, car ils permettent la segmentation d'un programme sous DOS.
Celui-ci utilise donc plusieurs segments, il n'est donc plus limit&eacute; pour le code, la pile et les donn&eacute;es
Le fichier exe comporte des segments s&eacute;par&eacute;s pour la pile, le code et les donn&eacute;es.<br>
Lors d'un chargement de programme exe, DOS charge les registres de la mani&egrave;re suivante :<br>
&nbsp;&nbsp;&nbsp;&nbsp;- DS et ES contiennent l'adresse des paragraphes du PSP. Le PSP contient les arguments transmis au programme 
&nbsp;&nbsp;&nbsp;par la ligne de commande et un pointeur vers la chaine d'environnement du programme.<br>
&nbsp;&nbsp;&nbsp;&nbsp;- CS:IP contient l'adresse de d&eacute;part sp&eacute;cifi&eacute;e par END dans un des modules du programme ou bien 
&nbsp;&nbsp;&nbsp;la directive STARTUPCODE<br>
&nbsp;&nbsp;&nbsp;&nbsp;- SS:SP contient l'adresse du dernier mot sp&eacute;cifi&eacute; du segment de pile<br><br>

&nbsp;&nbsp;Les programmes exe sont charg&eacute;s &agrave; n'importe quelle adresse qui est un multiple entier de 16
Comme un programme exe comporte plusieurs segments, on est oblig&eacute; d'utiliser l'instruction FAR si l'on d&eacute;sire
par exemple appeler un sous programme dans un autre segment. Malheureusement
(c'&eacute;tait trop beau), une instruction FAR doit avoir non seulement l'indication de l'offset mais aussi du segment 
MAIS puisque que cette adresse peut varier &agrave; chaque ex&eacute;cution du programme, on est emmerd&eacute;. Ce probl&egrave;me a
&eacute;t&eacute; r&eacute;gl&eacute; en mettant au d&eacute;but de chaque prog une struture de donn&eacute;es qui contient les adresses et toutes les
r&eacute;f&eacute;rences de segment (un header, "en-t&ecirc;te" en fran&ccedil;ais).<br><br>

&nbsp;&nbsp;Un programme exe est charg&eacute; &agrave; l'aide de la fonction EXEC du DOS, celle-ci connait les diff&eacute;rentes adresses o&ugrave;
sont charg&eacute;s les diff&eacute;rents segments du programme exe. Elle peut ainsi inscrire les valeurs appropri&eacute;es dans 
les cellules de m&eacute;moire enregistr&eacute;es dans l'en-t&ecirc;te du fichier exe. On remarque aussi que la taille d'un fichier
exe sera toujours sup&eacute;rieure &agrave; la taille d'un fichier com pour une fonction &eacute;quivalente, le fichier exe sera 
&eacute;galement plus long &agrave; charger qu'un fichier com.<br><br>

&nbsp;&nbsp;Apr&egrave;s que les r&eacute;f&eacute;rences de segments &agrave; l'int&eacute;rieur du prog exe ont &eacute;t&eacute; (sisi, c'est bien
de l'indicatif apr&egrave;s : 'Apr&egrave;s que') adapt&eacute;es aux adresses effectives, la
fonction EXEC fixe les registres de segment DS et ES sur le d&eacute;but du PSP. Le programme exe peut donc facilement 
acc&eacute;der aux informations contenues dans la PSP. L'adresse de la pile et le contenu du pointeur de pile sont 
stock&eacute;s dans l'en-t&ecirc;te du fichier exe, pareil pour l'adresse du segment de code o&ugrave; se trouve la routine de 
lancement du programme et le compteur de programme.<br><br>

&nbsp;&nbsp;Pour terminer un prog exe, il suffit d'appeler la fonction 4Ch du DOS (interruption 21h) pour garder une
compatibilit&eacute; avec les versions ult&eacute;rieures du DOS<br><br>

&nbsp;&nbsp;Maintenant, petit cadeau, le Header d'un fichier exe<br><br>

<table align=center>
<tr><td>
<pre>Offset	Taille	     Contenu	    	   Description	



  00h  |  2   | 5a4dh='MZ'   		| signature d'un fichier exe

  02h  |  2   | long fichier mod 512	| Taille de la derni&egrave;re page

  04h  |  2   | long fichier div 512    | Compteur de page

  06h  |  2   | 			| Nombre d'entr&eacute;es dans la table de relogement

  08h  |  2   | multiple de 16		| Taille de l'en-t&ecirc;te en paragraphes

  0Ah  |  2   | 			| Nombre minimal de paragraphes n&eacute;cessaires

  0Ch  |  2   | 			| Nombre maximal de paragraphes n&eacute;cessaires

  0Eh  |  2   | SS initial		| valeur initiale du segment de pile

  10h  |  2   | SP initial		|

  12h  |  2   | 			| Checksum du header (souvent inutilis&eacute;)

  14h  |  2   | IP initial		| Valeur initiale du pointeur d'instruction

  16h  |  2   | CS initial		| Valeur initiale du segment de code

  18h  |  2   | Offset de la table	| offset du d&eacute;but de la table de relogement 

  1Ah  |  2   | Overlay			| au d&eacute;but, cette valeur est fix&eacute; &agrave; 0

  1Ch  |  2   | 			| Variable m&eacute;moire tampon

</pre></td></tr>
</table><br>

&nbsp;&nbsp;Toi qui lis, je suis s&ucirc;r que tu es en train dire : "M... il nous fait chier, quand est-ce qu'il va nous parler
des virii informatiques". J'y viens : d&eacute;j&agrave; avec cela, on peut avoir une petite id&eacute;e sur le mode de fonctionnement
et les probl&egrave;mes que l'on risque de rencontrer lors du fonctionnement du virus.<br><br>

<font size="+1"><b><i><u>2-Les virii infecteurs de fichiers exe</u></i></b></font><br><br>

&nbsp;&nbsp;On va pas commencer violent : je vais vous expliquer le mode de fonctionnement d'un virus se greffant &agrave; la fin du fichier exe
du DOS (les fichier com &eacute;tant de moins en moins utilis&eacute;s). <br><br>

&nbsp;&nbsp;Bon, le probl&egrave;me par rapport &agrave; un virus &agrave; recouvrement com c'est que avec les fichier ex&eacute;cutables il va falloir modifier
l'en-t&ecirc;te et la table du pointeur de relogement, il faut &eacute;galement qu'il ajoute son code au module de chargement. Le virus 
se placera &agrave; la fin du code du programme exe et prendra le contr&ocirc;le au d&eacute;marrage de celui-ci. On utilisera une routine qui copie
le code du programme de la m&eacute;moire vers le fichier sur le HD pour ensuite ajuster le fichier.<br><br>

&nbsp;&nbsp;L'inconv&eacute;nient c'est que le virus poss&eacute;dant ses propres segments de code, de donn&eacute;es et de pile risque de planter si un prog
vient contrecarrer ses suppositions quant &agrave; la fa&ccedil;on dont ces segments seront g&eacute;r&eacute;s par le programme h&ocirc;te.<br> 
&nbsp;Exemple :<br> 
&nbsp;si on utilise une pile initialis&eacute;e par le prog h&ocirc;te, elle peut se terminer en plein sur le virus greff&eacute; sur n&ocirc;tre prog h&ocirc;te, donc si
on empile ou on d&eacute;pile, le virus risque de s'autod&eacute;truire.<br><br>

&nbsp;&nbsp;Le seul moyen pour mettre en place les segments du virus est de modifier les valeurs initiales du segment CS et SS dans l'en-t&ecirc;te du
fichier exe. Mais les anciens segments initiaux doivent &ecirc;tre stock&eacute;s quelque part dans le virus pour pouvoir &ecirc;tre restaur&eacute;s et ainsi rendre
le contr&ocirc;le au programme h&ocirc;te lorsque notre virus a fini de s'ex&eacute;cuter. Solution : mettre 2 pointeurs vers ces r&eacute;f&eacute;rences de relogement 
dans le segment de code du virus. Malheureusement (et oui, tout n'est pas simple dans le dur monde de l'informatique), on est oblig&eacute; 
d'augmenter la table des pointeurs de relogement pour y ajouter des pointeurs. Vu que l'en-t&ecirc;te d'un fichier exe doit &ecirc;tre un multiple
de 16, les pointeurs de relogement sont allou&eacute;s par groupes de 4 pointeurs de 4 octet chacun. Avec 2 r&eacute;f&eacute;rences de segment, il faudra 
augmenter l'en-t&ecirc;te ult&eacute;rieurement. Il existe une autre possibilit&eacute;, il suffit seulement que le virus n'infecte pas les fichiers dont il doit
&eacute;tendre l'ent-t&ecirc;te. L'inconv&eacute;nient et qu'une bonne moiti&eacute; des fichiers exe echapperont &agrave; "l'attaque" mais vu que le module de chargement peut
faire plusieurs centaines de Ko, le d&eacute;placer risque un long temps de chargement et on risque de le remarquer. Comme je le disais plus haut, la
t&acirc;che principale d'un virus est de survivre donc de ne pas se faire rep&eacute;rer, alors je vais utiliser la 1&egrave;re solution (essayez de trouver la 2&egrave;me :
tr&egrave;s bon exercice)<br><br>

&nbsp;&nbsp;Un peu de code en asm:<br><br>
<table align=center><tr><td><pre>
VIRII segment

VIRUS:

  mov ax, cs		; on transf&egrave;re le segment de code dans ax

  mov ds, ax		; donc ds=cs

  ...			

  ...			; votre virus ici

  ...

  cli			; indicateur d'interruption est mis &agrave; 0 (d&eacute;sactivation des interruptions externes)

  mov ss, cs:[HOTEP]	; replace les valeur initiales de la pile du prog h&ocirc;te

  mov sp, cs:[HOTEP+2]	; remet la valeur initiale de SP du prog h&ocirc;te

  sti			; l'indicateur d'interruption est remis &agrave; 1

  jmp dword ptr cs:[HOTEC] ;saut vers le d&eacute;but du prog h&ocirc;te

HOTEP	dw ?,?		; valeur initiale du segment de la pile

HOTEC	dw ?,?		; valeur initiale du segment de code</pre></td></tr></table><br>

&nbsp;&nbsp;Voici &agrave; peu pr&egrave;s en d&eacute;tail les &eacute;tapes de la routine de copie pour infecter un nouveau programme <br><br>
&nbsp;&nbsp;&nbsp;&nbsp;- Lire l'en-t&ecirc;te du programme hote<br>
&nbsp;&nbsp;&nbsp;&nbsp;- Agrandir la taille du module de chargement pour qu'elle ait comme valeur un multiple pair de 16 octet, ainsi CS:0000 deviendra le 1er
&nbsp;&nbsp;&nbsp;octet du virus<br>
&nbsp;&nbsp;&nbsp;&nbsp;- &eacute;crire le code du virus sur le fichier h&ocirc;te<br>
&nbsp;&nbsp;&nbsp;&nbsp;- &eacute;crire &agrave; l'adresse HOTEP (voir ch'ti listing ) du code sur le HD la valeur initiale de SS:SP qui est dans l'en-t&ecirc;te du fichier exe<br>
&nbsp;&nbsp;&nbsp;&nbsp;- &eacute;crire &agrave; l'adresse HOTEC du code sur le HD la valeur initial de SS:SP qui est aussi dans l'en-t&ecirc;te<br>
&nbsp;&nbsp;&nbsp;&nbsp;- stocker le SS initial (segment VIRII), le SP initial (offset final + taille de la pile), le CS initial (segment VIRII) et l'IP initial 
&nbsp;&nbsp;&nbsp;(offset VIRUS) dans l'en-t&ecirc;te du fichier h&ocirc;te<br>
&nbsp;&nbsp;&nbsp;&nbsp;- ajouter 2 aux entr&eacute;es de la table de relogement toujours dans le header<br>
&nbsp;&nbsp;&nbsp;&nbsp;- ajouter deux pointeurs de relogement &agrave; la fin de la table des pointeurs de relogement du fichier exe sur le disque. Le 1er pointe vers la 
&nbsp;&nbsp;&nbsp;partie de segment correspondant &agrave; HOTEP, le 2&egrave;me vers HOTEC<br>
&nbsp;&nbsp;&nbsp;&nbsp;- recalculer la taille du fichier exe pour r&eacute;initialiser correctement compteur de page et taille de la derni&egrave;re page de l'en-t&ecirc;te<br>
&nbsp;&nbsp;&nbsp;&nbsp;- &eacute;crire le nouvel en-t&ecirc;te sur le disque<br><br>

&nbsp;&nbsp;Les fichiers &agrave; infecter doivent respecter quelques "crit&egrave;res d'infection" :<br>
&nbsp;- le fichier doit commencer par "MZ" (les initiales du cr&eacute;ateur du principe des fichier ex&eacute;cutable : un peu m&eacute;galo :)) c'est la signature d'un fichier exe<br>
&nbsp;- le n&#176; d'overlay doit &ecirc;tre &agrave; 0 sinon : plantage <br>
&nbsp;- l'h&ocirc;te doit avoir assez de place dans sa table de relogement, on peut la calculer comme ceci :<br>
si(16*taille de l'header-4*nombre d'entr&eacute;e dans la table de relogement-offset de la table de relogement)>=8
alors il y a suffisament de place dans la table des pointeurs<br>
&nbsp;- le programme ne doit pas &ecirc;tre un ex&eacute;cutable windows. on peut le d&eacute;terminer si la table de relogement se trouve &agrave; un offset de plus de 40h ou &eacute;gal &agrave; 40h
alors ce programme n'est pas un ex&eacute;cutable DOS<br>
&nbsp;- Le fichier ne doit pas avoir &eacute;t&eacute; infect&eacute;, on peut r&eacute;gler &ccedil;a en pla&ccedil;ant dans le champ initial IP une valeur de 0060h pour un programme infect&eacute;<br><br>

&nbsp;&nbsp;Encore un petit renseignement, on doit rendre le contr&ocirc;le au programme h&ocirc;te de fa&ccedil;on correcte, on doit donc r&eacute;initialiser les registres comme si il ne 
ne s'&eacute;tait rien pass&eacute;. &Eacute;galement, lors du chargement d'un ex&eacute;cutable, le registre AX prend une valeur particuli&egrave;re choisie par le DOS pour indiquer la 
validit&eacute; du lecteur dans le FCB se trouvant dans le PSP. AL prend la valeur 0 si l'indicateur se situant dans le 1er FCB &agrave; l'adresse 005Ch est bonne et AH
prend &eacute;galement 0 si l'adresse 006Ch de la FCB est valide. On doit donc sauvegarder le registre AX et le restaurer avant de rendre le contr&ocirc;le au programme h&ocirc;te
On doit &eacute;galement d&eacute;placer la DTA (les attributs du fichier) pour une meilleure efficacit&eacute; du virus<br><br>

&nbsp;&nbsp;Bon, c'est tout ce que je dirai pour l'instant : maintenant c'est &agrave; vous de vous d&eacute;brouiller, j'ai donn&eacute; les principales caract&eacute;ristiques d'un virus infecteur de 
exe, r&eacute;alisez vos virus et envoyez les moi (NON COMPIL&Eacute;S) &agrave; <a href="mailto:ddway@hotmail.com">ddway@hotmail.com</a>, le meilleur code gagnera d'avoir le prochain N&#176; du zine dans sa boite aux lettres<br><br>

&nbsp;&nbsp;La prochaine fois, je vous monterai du code comment&eacute; sur un bon virus infecteur de exe avec peut-&ecirc;tre une routine de cryptage (un ch'tit virus polymorphe)<br>
Allez bon code et surtout : NE DETRUISEZ RIEN !! (un bon virus n'est pas fait pour d&eacute;truire) ..<br><br>

<font size="-1">(Ndrl : j'esp&egrave;re qu'il est pas trop long comme article)<br>
DDway <<a href="mailto:ddway@hotmail.com">ddway@hotmail.com</a>></font><br><br>
<div align="center"><img src="ligne.gif" width=540 height=4 border=0 alt=""></div>



</body>
</html>

